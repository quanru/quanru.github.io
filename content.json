{"posts":[{"title":"16宫格拖拽","text":"实现一个如图所示的16宫格页面，其中各个数字盒子之间是能相互拖拽，并交换位置的。而横纵各自的标题栏ABC与XYZ实现的功能则是，ABC（XYZ）之间两两互换位置，从而引起两列（行）一起调换位置。 需求实现一个如图所示的16宫格页面，其中各个数字盒子之间是能相互拖拽，并交换位置的。而横纵各自的标题栏ABC与XYZ实现的功能则是，ABC（XYZ）之间两两互换位置，从而引起两列（行）一起调换位置。 外观处理 设置外层容器与内部方块宽度，并向左浮动，从而构成16宫格; 每个盒子的位置以坐标(x,y)来表示，其中0&lt;x,y&lt;4; 1234567891011121314151617#container { position: relative; width: 400px; height: 400px; background: #eee;}.box { float: left; width: 70px; height: 70px; margin: 5px; font-weight: bold; line-height: 70px; text-align: center; border: 10px solid red; border-radius: 10px;} 由于拖拽使用的是绝对定位，因此首先获取当前各个盒子的偏移量，然后将盒子的position属性设为absolute，使用对应的偏移量设置top与left。 12345678910function absoluteThem(e) { $($(&quot;.box&quot;).toArray().reverse()).each(function(index, el) { $(this).css({ &quot;left&quot;: $(this).position().left, &quot;top&quot;: $(this).position().top, &quot;float&quot;: &quot;none&quot;, &quot;position&quot;: &quot;absolute&quot; }); });} 拖拽处理注意盒子越界检查以及标题栏的字母只能横向或纵向移动，并保存被拖拽盒子的坐标 12345678910111213141516171819202122232425262728293031323334353637function clickNum(e) {//点击数字 var targetEle = e.target, targetEleJQ = $(targetEle), oriX = e.clientX - targetEle.offsetLeft, //光标按下时相对本身的坐标 oriY = e.clientY - targetEle.offsetTop; if (targetEleJQ.hasClass(&quot;undraggable&quot;)) { return; } $(document).bind(&quot;mousemove&quot;, moveIt); $(document).bind(&quot;mouseup&quot;, mouseUp); function moveIt(e2) {//移动 var newX = e2.clientX - oriX, newY = e2.clientY - oriY, maxX = 400 - targetEle.offsetWidth - 10, maxY = 400 - targetEle.offsetHeight - 10; if (newX &lt; 100) { newX = 100; } else if (newX &gt; maxX) { newX = maxX; } if (newY &lt; 100) { newY = 100; } else if (newY &gt; maxY) { newY = maxY; } if(targetEleJQ.hasClass(&quot;num&quot;)){//如果是数字 targetEle.style.left = newX + &quot;px&quot;; targetEle.style.top = newY + &quot;px&quot;; } else if(targetEleJQ.hasClass(&quot;group1&quot;)){//如果是ABC栏 targetEle.style.left = newX + &quot;px&quot;; } else if(targetEleJQ.hasClass(&quot;group2&quot;)){//如果是XYZ栏 targetEle.style.top = newY + &quot;px&quot;; } } 放下盒子释放鼠标处的盒子坐标：将鼠标当前位置clientX与clientY分别对100求余，并向下取整，即可得到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445function mouseUp(e3) { var boxLocX = Math.floor(e3.clientY/100),//放下光标时，所在的方格坐标 boxLocY = Math.floor(e3.clientX/100), oriBoxLocX = parseInt(targetEle.id.substr(4,1)),//原来的方格坐标 oriBoxLocY = parseInt(targetEle.id.substr(6,1)), boxNow = &quot;box-&quot; + boxLocX + &quot;-&quot; + boxLocY,//放下处的盒子id boxOri = &quot;box-&quot; + oriBoxLocX + &quot;-&quot; + oriBoxLocY; if(targetEleJQ.hasClass(&quot;group1&quot;)) { if(!$(&quot;#&quot; + boxNow).hasClass(&quot;letter&quot;) || $(&quot;#&quot; + boxNow).hasClass(&quot;group2&quot;)){//点击的是字母而释放的是非字母 resetLoc(boxOri); return; } changeLoc(boxNow, boxOri); for(var i = 1; i &lt; 4; i++){ boxLocX ++; oriBoxLocX ++; boxNow = &quot;box-&quot; + boxLocX + &quot;-&quot; + boxLocY;//放下处的盒子id boxOri = &quot;box-&quot; + oriBoxLocX + &quot;-&quot; + oriBoxLocY; changeLoc(boxNow, boxOri); } } else if (targetEleJQ.hasClass(&quot;group2&quot;)) { if(!$(&quot;#&quot; + boxNow).hasClass(&quot;letter&quot;) || $(&quot;#&quot; + boxNow).hasClass(&quot;group1&quot;)){//点击的是字母而释放的是非字母 resetLoc(boxOri); return; } changeLoc(boxNow, boxOri); for(var j = 1; j &lt; 4; j++){ boxLocY ++; oriBoxLocY ++; boxNow = &quot;box-&quot; + boxLocX + &quot;-&quot; + boxLocY;//放下处的盒子id boxOri = &quot;box-&quot; + oriBoxLocX + &quot;-&quot; + oriBoxLocY; changeLoc(boxNow, boxOri); } } else{ if(!$(&quot;#&quot; + boxNow).hasClass(&quot;num&quot;)){ resetLoc(boxOri); return; } changeLoc(boxNow, boxOri); } $(document).unbind(&quot;mousemove&quot;, moveIt); $(document).unbind(&quot;mouseup&quot;, mouseUp); 完整代码","link":"/2015/06/16/16%E5%AE%AB%E6%A0%BC%E6%8B%96%E6%8B%BD/"},{"title":"Chrome 谜一样卡死的排查方法","text":"遇到莫名卡死问题，如何正确地排查 最近由于 Chrome 浏览器升级，触发了一个埋点 SDK 的潜在问题，目前埋点 SDK 方面已经跟进解决，详细原因可见文章《Chrome 83 下千帆工作台卡死的问题》。 一切好像没什么问题，但是陆续有团队同学反馈，线上页面的确不卡了，测试环境某些操作仍然会出现卡死，而且卡死时正好会有 golden 或 omega 埋点处于 pending 状态。于是开始了排查之路~ 一、线索排查查看 pending 状态的请求： 发现请求卡在了一个 “Stalled” 的状态，谷歌还贴心的给出了 “Explanation” 链接，解释如下： Here’s more information about each of the phases you may see in the Timing tab: Queueing . The browser queues requests when: There are higher priority requests. There are already six TCP connections open for this origin, which is the limit. Applies to HTTP/1.0 and HTTP/1.1 only. The browser is briefly allocating space in the disk cache Stalled. The request could be stalled for any of the reasons described in Queueing. DNS Lookup. The browser is resolving the request’s IP address. Initial connection. The browser is establishing a connection, including TCP handshakes/retries and negotiating an SSL. Proxy negotiation. The browser is negotiating the request with a proxy server. Request sent. The request is being sent. ServiceWorker Preparation. The browser is starting up the service worker. Request to ServiceWorker. The request is being sent to the service worker. Waiting (TTFB). The browser is waiting for the first byte of a response. TTFB stands for Time To First Byte. This timing includes 1 round trip of latency and the time the server took to prepare the response. Content Download. The browser is receiving the response. Receiving Push. The browser is receiving data for this response via HTTP/2 Server Push. Reading Push. The browser is reading the local data previously received. 也就是 Queueing 阶段的问题导致卡在 Stalled 状态，经查得知可以通过如下方式查看 Chrome 的运行日志，当然包括详细的网络日志。 各平台查看日志方式见 https://support.google.com/chrome/a/answer/6271282?hl=zh-Hans 以监听日志方式打开浏览器 /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --enable-logging --v=1 实时查看日志：tail -f ~/Library/Application\\ Support/Google/Chrome/chrome_debug.log 二、日志查看按上述方式打开浏览器，实时查看日志文件，一步一步复现步骤，日志打印如下： 所以绕了一圈还是 “ResizeObserver” 的问题，原因在 Chrome 83 下千帆工作台卡死的问题 中也有提到，这里列两个 issue 大家有兴趣查看下： https://github.com/ElemeFE/element/issues/12866 https://github.com/ElemeFE/element/issues/17642 三、推测那么，为什么测试环境有问题，线上环境却没有呢？目前解决 Omega sdk 和 Golden sdk 问题的方法是通过如下方式重写 EventTarget.prototype.addEventListener 方法，达到过滤发送埋点请求的目的（也正是循环发送埋点请求，导致页面卡死）。 123456789101112131415EventTarget.prototype.addEventListenerBase = EventTarget.prototype.addEventListener; EventTarget.prototype.addEventListener = function(type, baseListener, status) { if(type === 'error') { function myListener(e) { // 重写 addEventListener，为了过滤ResizeObserver 错误的上报。在 Chrome 83 无限上报会造成浏览器卡死 if (e.message &amp;&amp; e.message.indexOf('ResizeObserver') !== -1) { return; } baseListener.apply(this, arguments); } this.addEventListenerBase(type, myListener, status); } else { this.addEventListenerBase(type, baseListener, status); } }; 所以，还有除了 EventTarget.prototype.addEventListener 方法之外的监听没有被重写，我掐指一算，难道是 window.onerror，于是去当前卡死页面的调试控制台打印 window.onerror: 真有这个监听，而且还有『字符串 replace 操作』，这要是无限循环调用这个回调，分分钟卡死！顺手点击这个打印结果，直接跳转到引用它的代码： 竟然是 vConsole 监听的，前端同学都知道，这个 vConsole 是为了在移动端方便调试使用的，一般在测试环境使用，所以这端代码很可能是这个导致了测试环境卡死，而线上环境正常的罪魁祸首！ 四、验证接下来我们就验证下猜想，首先把 window.onerror 覆盖为 console.log，重复复现步骤，控制台便打印出： 果不其然，不过这样还是卡住了，因为 console.log 也是同步操作。接着直接置空 window.onerror，执行 window.onerror = undefined，再来一次复现： 页面已经不再卡死了！ 五、解决目前在 Chrome 和 ele-element 未跟进解决的情况下，解决方法有： 去除 vConsole，毕竟中台项目不需要 vConsole； 置空 window.onerror； 对 window.onerror 进行节流； 六、总结此处总结下遇到莫名卡死问题，排查步骤应简化为： 监听 window.onerror 事件，这样能把一些内部的报错（即不会在控制台显示的错误）直接打印到控制台中 使用监听 Chrome 日志方式打开浏览器，从日志中查看线索 合理推测和验证","link":"/2020/06/11/Chrome%20%E8%B0%9C%E4%B8%80%E6%A0%B7%E5%8D%A1%E6%AD%BB%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/"},{"title":"HTML5 截图","text":"实现一个类似于QQ截图的小东西，点击载入按钮，则载入图片，长按图片，弹出截图框，截图框右下角能够调整大小，并在右边的截图预览区域实时显示 需求实现一个类似于QQ截图的小东西，点击载入按钮，则载入图片，长按图片，弹出截图框，截图框右下角能够调整大小，并在右边的截图预览区域实时显示，其最终效果图如下： HTML需要注意canvas的设置，主要结构如下： 123456789&lt;section class=&quot;clearfix&quot;&gt; &lt;div id=&quot;origin&quot;&gt; &lt;canvas id=&quot;originImg&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt; &lt;div id=&quot;shotRect&quot;&gt; &lt;div class=&quot;resizeBR&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;canvas id=&quot;showPre&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt;&lt;/section&gt; CSS截图框初始大小为50px50px,右下角设置了一个不可见的调节区域,此处大小设置为12px12px，并在之后为其注册调整大小的事件。 1234567891011121314151617181920#shotRect { position: absolute; display: none; width: 50px; height: 50px; opacity: .5; border: 2px solid #2d2d2d;}.resizeBR { position: absolute; right: -5px; bottom: -5px; width: 12px; height: 12px; cursor: nw-resize; opacity: 0; background: #000; background: #ff0;} 其中原始图片的canvas大小与预览区的大小一致。 JavaScript载入图片，并绘制canvas123456789function loadImg(event) { //载入图片 cOri = document.getElementById(&quot;originImg&quot;); imgOri = new Image(); ctxOri = cOri.getContext(&quot;2d&quot;); imgOri.src = &quot;vegetable.jpg&quot;; imgOri.onload=function(){ ctxOri.drawImage(imgOri,0,0,500,500);//将图片绘制到canvas上 };} 长按待截图区域,弹出截图框12345678910111213function longClick(event) { //长按弹出截图框 event = event || window.event; var shotRect = document.getElementById(&quot;shotRect&quot;); timeout = setTimeout(function() { shotRect.style.display = &quot;block&quot;; var disX = event.clientX - shotRect.offsetWidth + 10, disY = event.clientY - shotRect.offsetHeight + 10; shotRect.style.left = disX + 'px'; shotRect.style.top = disY + 'px'; initCanvas(); updateRect(disX, disY, shotRect.offsetWidth, shotRect.offsetHeight); }, 1000);} 释放鼠标时,需要清除timeout。 初始化预览canvas12345function initCanvas() {//初始化预览画布 cPre = document.getElementById(&quot;showPre&quot;); ctxPre = cPre.getContext(&quot;2d&quot;); img = document.getElementById(&quot;originImg&quot;);} 更新预览canvas根据原始图片,在预览区域上使用drawImage方法画出预览图,其中x,y为截图框左上角相对于原始图片左上角的坐标;而w,h为截图框的长与宽;这四个参数提取出了截图框内的图像数据,而之后(0,0)这个坐标代表在画布上放置该图像数据的坐标位置,(0,0)意味着将该图像数据的左上角与预览区域的左上角重合。 1234function updateRect(x, y, w, h) {//更新画布 ctxPre.clearRect(0, 0, 500, 500); //清空画布 ctxPre.drawImage(img, x, y, w, h, 0, 0, 500, 500);} 调整截图框大小计算截图框左上角的坐标，并根据调整大小后鼠标的坐标，并据此重新设置截图框的大小，然后调用更新截图预览的函数updateRect，注意限制截图框的边界不能超过原始图片的大小。 123456789101112131415161718192021222324252627282930313233343536function resizeDown(event) { event = event || window.event; var shotRect = document.getElementById(&quot;shotRect&quot;), //计算Rect左上角的坐标 x = shotRect.offsetLeft, y = shotRect.offsetTop ; //console.log(&quot;x=&quot; + x+ &quot; &quot; + &quot;y=&quot; + y); //绑定事件 document.addEventListener(&quot;mousemove&quot;, mouseMove); document.addEventListener(&quot;mouseup&quot;, mouseUp); //移动鼠标 function mouseMove(event) { event = event || window.event; var finalX = event.clientX, finalY = event.clientY; //防止超过边界 if (event.clientX &gt;= 488) { finalX = 488; } if (event.clientY &gt;= 488) { finalY = 488; } //console.log( (event.clientX) + &quot; &quot; + (event.clientY)); xy = (finalX - x + 10) &lt; (finalY - y +10) ? (finalX -x + 10) : (finalY - y + 10); //计算移动后的Rect新大小 shotRect.style.width = xy + 'px'; shotRect.style.height = xy + 'px'; updateRect(x, x, shotRect.offsetWidth, shotRect.offsetHeight); } //停止事件 function mouseUp() { //卸载事件 document.removeEventListener(&quot;mousemove&quot;, mouseMove); document.removeEventListener(&quot;mouseup&quot;, mouseUp); }} 移动截图框详看注释吧~ 12345678910111213141516171819202122232425262728293031323334353637function dragDown(event) { event = event || window.event; if (event.target !== event.currentTarget) return; //如果是从子元素冒上来的，返回 var shotRect = document.getElementById(&quot;shotRect&quot;), disX = event.clientX - shotRect.offsetLeft, // 光标按下时光标相对截图框的坐标 disY = event.clientY - shotRect.offsetTop; //绑定事件 document.addEventListener(&quot;mousemove&quot;, mouseMove); document.addEventListener(&quot;mouseup&quot;, mouseUp); function mouseMove(event) { event = event || window.event; var disL = event.clientX - disX, //截图框左边界与左侧边界的距离 disT = event.clientY - disY, //截图框上边界与上侧边界的距离 maxW = document.getElementById(&quot;originImg&quot;).clientWidth - shotRect.offsetWidth, //最大宽度 maxH = document.getElementById(&quot;originImg&quot;).clientHeight - shotRect.offsetHeight; //最大高度 //超过边界则重置 if (disL &lt; 0) { disL = 0; } else if (disL &gt; maxW) { disL = maxW + 1; } if (disT &lt; 0) { disT = 0; } else if (disT &gt; maxH) { disT = maxH + 1; } shotRect.style.left = disL + 'px'; //重新计算截图框的相对位置 shotRect.style.top = disT + 'px'; updateRect(disL, disT, shotRect.offsetWidth, shotRect.offsetHeight); } function mouseUp(event) { document.removeEventListener(&quot;mousemove&quot;, mouseMove); document.removeEventListener(&quot;mouseup&quot;, mouseUp); }} 保存图片由于跨域问题,保存在chrome无效,在firefox中有效: 12345function saveImg(event) { var image = cPre.toDataURL(&quot;image/png&quot;); var w = window.open('about:blank', 'image from canvas'); w.document.write(&quot;&lt;img src='&quot; + image + &quot;' alt='from canvas'/&gt;&quot;);} 完整代码","link":"/2015/07/19/HTML5%E6%88%AA%E5%9B%BE/"},{"title":"Javascript 语言精粹の笔记","text":"最近买了几本书，这本《JavaScript 语言精粹》果真精粹，篇幅很少，而附录较多，作者是 JSON 的发明者 Douglas Crockford ，听起来屌屌的，其中的干货也是不少的，看完受益匪浅！ JavaScript 语言精粹章四,五 函数、继承 如果在一个函数前面带上 new 来调用，则背地里会创建一个链接到该函数的 prototype 成员的新对象 a. 通过 proto 进行链接，使得新对象上的 proto 属性拥有 prototype 上的所有属性与方法 b. 同时 this 将会被绑定到这个新对象上，此时若返回值不是一个对象，则返回 this 123var that = Object.create(this.prototype);var other = this.apply(that, arguments);return (typeof outer === 'object' &amp;&amp; other) || that; new 运算符创建一个新对象（继承自其运算数原型），然后调用该运算数，把新创建的对象绑定到 this 上；使得运算符（即构造器函数）在返回给调用者前能够自定义新创建的对象。 因为 JavaScript 原型继承的动态本质，使得新的方法立刻被赋予到所有对象的实例上，哪怕在将方法增加到对应类的 prototype 属性之前就已经创建的对象实例。 function A() {}, 类 A 的构造函数位于 A 的原型 prototype 之上，因此使用如下方式继承时，最后一步需要重置子类的构造器为自身： 123456789101112131415161718192021// Shape - superclassfunction Shape() { this.x = 0; this.y = 0;}// superclass methodShape.prototype.move = function(x, y) { this.x += x; this.y += y; console.info('Shape moved.');};// Rectangle - subclassfunction Rectangle() { Shape.call(this); // call super constructor.}// subclass extends superclassRectangle.prototype = Object.create(Shape.prototype);Rectangle.prototype.constructor = Rectangle; 关于 Object.create The **Object.create()** method creates a new object with the specified prototype object and properties. 该方法根据指定的原型对象和属性生成一个新对象 1234567891011121314151617181920var o;// create an object with null as prototypeo = Object.create(null);o = {};// is equivalent to:o = Object.create(Object.prototype);// o -&gt; Object:{__proto__: Object}function Constructor() {}o = new Constructor();// is equivalent to:o = Object.create(Constructor.prototype);// Of course, if there is actual initialization code in the// Constructor function, the Object.create() cannot reflect it// o -&gt; Constructor:{__proto__: Object} 章六 数组 JavaScript 的数组是一种拥有一些类数组特性的对象 12345678var arr = [];var obj = {};typeof arr === typeof obj // true，皆为 'object'arr instanceof Array // truearr instanceof Object // true 为数组设置更大的 length 不会分配更多空间，而把 length 设小，则将所下标大于等于新 length 的属性删除 由于数组就是对象，因此可使用 delete 运算符移除元素 12345var arr = ['one', 'two', 'three'];delete arr[1]; // ['one', undefined, 'three']// 使用 splice 方法arr.splice(1,1); // ['one', 'three'] 数组是个对象，因此可以给其增添属性，当属性不为数字时，并不会增加 length 章七 正则 如果拿不准一个特殊字符是否需要转义，可统一加上转义符 ‘' \\d [0-9] \\D \\s Unicode 字符 \\S \\w [0-9A-Z_a-Z] \\W . 除结束符以外的任意字符 12345678910111213143. 正则表达式分组：()，正则表达式字符集：[]4. 量词：```js//如果只有一个量词(形如 {1,} ) 则表示进行贪婪性匹配let reg = /w{3,}/;'wwwww'.match(reg); // 'wwwww'// 通过 ？ 进行非贪婪性匹配let reg2 = /w{3,}?/;'wwwww'.match(reg2); // 'www' 章八 方法 array.pop 与 array.shift pop 的位置不同，一个在头部，一个在尾部 array.push 与 array.unshift push 的位置不同，一个在尾部，一个在头部 array.slice(start, end) 潜复制，array.splice(start, deleteCount, item…) 移除若干个元素，并使用 item 替换 regexp.exec(string)、regexp.test(string) string.lastIndexOf(searchString, position)、string.charAt(position)、string.match(regexp)、string.search(regex) 附录 1 + 0.2 // 0.30000000000000004 0.1 + 0.2 == 0.3 // false 12345672. ```js typeof NaN === 'number' // true Nan === NaN // false NaN !== NaN // true isNaN(NaN) // true ES6 将其归到 Number.isNaN 判断数组： 12arr &amp;&amp; typeof arr === 'object' &amp;&amp; arr.constructor === Array 加强版: 12Object.prototype.toString.apply(arr) === '[object Array]' 位运算符在 JavaScript 中执行效率非常慢 建议使用 var foo = function foo() {}; 而不是 function foo() {}; 避免使用类型包装器：new Boolean(false)、new Number(1)、new String(‘abc’) 避免使用 new Object 与 new Array HTML 中，字面上的 ‘&lt;’ 符号必须使用 ‘&amp;lt ;’ JSON JSON 有六种类型值： 对象、数组、字符串、数字、布尔值、null","link":"/2016/11/20/JavaScript%20%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"title":"JavaScript 权威指南の笔记","text":"当Javascript解释器启动时，它将创建一个新的全局对象，并给它一组定义的初始属性。 只要引用了字符串直接量的属性，就会将字符串值通过调用new String(). 方式转换成对象，一旦引用结束，则销毁这个临时对象。 “==”将运算符将原始值与其包装对象视为相等，而“===”不然。 原始值不可变，对象引用可变。 undefined转换为数字： NaN，而null转换为数字：0，空字符串转为0与false。 对象 当Javascript解释器启动时，它将创建一个新的全局对象，并给它一组定义的初始属性。 只要引用了字符串直接量的属性，就会将字符串值通过调用new String(). 方式转换成对象，一旦引用结束，则销毁这个临时对象。 “==”将运算符将原始值与其包装对象视为相等，而“===”不然。 原始值不可变，对象引用可变。 undefined转换为数字： NaN，而null转换为数字：0，空字符串转为0与false。 对象到布尔值的转换： 所有对象（包括数组和函数）都转为true。 全局作用域可以不写var，但局部变量的声明需要var，否则默认生成全局变量。 Javascript并无块级作用域，取而代之的是函数作用域，指在函数内声明的所有变量在函数体内始终可见，意. 着变量在声明之前已经可用，但是赋值操作还在原始位置执行，即“声明提前”。 var truevar = 1；//声明一个不可删除的全局变量 fakevar = 2; //创建全局对象的可删除的属性 x!=x来判断x是否为NaN。 in运算符： 若右侧对象拥有一个名为左操作数值的属性名，则返回true。12.typeof(null) -&gt; “object”;typeof(undefined) -&gt; “undefined”;常用语表达式中：(typeof value == “string”) ? “ ‘ “ + value + “ ‘ “ : value; 函数是对象的一种，但是typeof(func)的结果是“function”。 删除属性或数组不仅仅是设置了一个undefined的值，其属性将不存在。 不能删除通过var声明的变量，删除不存在的属性返回true，删除数组元素，不改变其长度。 void运算符： 忽略操作数的计算结果并返回undefined。 for(variable in object) statement;先计算variable的值，并将属性名赋值给它。 break不能越过函数的边界，而continue只能在循环体内使用。 &amp;&amp;短路： 当左操作数是真值时，该运算符将计算右操作数的值并将其返回作为整个表达式的计算结果。 hasOwnProperty()用来检测给定的名字是否是对象的自有属性。 存取器属性： getter与setter，可继承，get property(){},set property(){}。 数据属性：值，可写性，可枚举性，可配置性； 存取器属性：get，set，可枚举性，可配置性。 转换为不可扩展性后，不可转回，Object.preventExtensions()，给一个不可扩展的对象的原型添加属性，它照样会继承新属性。 1, Object.getOwnPropertyDescriptor()可获得某个对象特定属性的属性描述符：({x:1},”x”)。 2, Object.defineProperty(o,”x”,{value:1,writable:true,enumerable:false,configurable:true}); 3, 以上两个函数都不包括继承属性。 数组 数组是JS对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。 数组遍历：1. 排除null与defined、不存在的元素： if(!a[i]) continue; 排除undefined和不存在的元素： if(a === undefined) continue; 排除不存在仍处理undefined： if(!(i in a)) continue;或：for(var index in sparseArray){}。 数组方法： join()：将所有元素转成字符串连接在一起，默认分隔符为逗号，可指定分隔符； reverse()：将元素颠倒顺序； sort()：字母表顺序排列，数值顺序：a.sort(function(a,b) { return a - b; } ); //若第一个参数应该在前，返回小于零的数值，反之亦然； concat()：创建并返回一个新数组，包括原始数组与concat()的每个参数； slice()：返回的数组包含第一个参数指定的位置到第二个参数指定的位置之间的所有数组元素，不包括第二个参数；若指定一个参数，则该参数为起始位置，结束位置在最后；负数：-1代表最后一个元素； splice()：不同于slice与concat，它会修改调用的数组；并返回被删元素组成的数组； push与pop； unshift与shift在数组头部操作； Javascript 5： forEach()：遍历数组，为每个元素调用指定的函数； map()：需要返回值，返回的是新数组，不修改调用的数组，而forEach()修改； filter()：压缩稀疏数组：var dense = sparse.filter(functin(){return true;});//filter会跳过稀疏数组中缺少的元素，返回的数组总是稠密的; 同时删除undefined和null元素：a = a.filter(function(x){return x !== undefined &amp;&amp; x != null;}); every()：当且仅当针对数组中的所有元素调用判定函数都返回true，它才返回true； some()：至少有一个为true，则返回true； reduce()：var sum = a.reduce(function(x,y) { return x + y }, 0);//其中第二个参数0是初始值； reduceRight()：从右到左处理； indexOf()：搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引，没找到返回-1； lastIndexOf()：反向搜索，第二个参数指定开始查找的位置。 判定是否为数组：Array.isArray()。 函数 嵌套函数不会从调用它的函数中继承this，如果嵌套函数作为方法调用，其this的值指向调用它的对象，作为函数调用，其this值不是全局对象（非严格模式下）就是undefined（严格模式下）。 new o.m()调用上下文（this）并不是o，而是构造函数调用创建的一个新的空对象。 &amp;&amp;： 若左操作数为假，返回左操作数值，不计算右操作数；若左操作数为真，计算右操作数并返回右操作数的值； ||： 若左操作数为真，返回左操作数值，不计算右操作数；若左操作数为假，计算右操作数并返回右操作数的值； arguments： 指向实参对象的引用，包含一个length属性，却不是真正的数组。 arguments的属性： callee：指代当前正在执行的函数。 函数可以有自己的属性，因为它是一种特殊的对象。 函数可以作为命名空间： ( function(){ //codes } () );//结束函数定义并立即调用它。 闭包： JS函数执行用到了作用域链，此链是函数定义的时候创建的，不管在何时何地执行内部嵌套函数f()，f中的变量一定是局部变量。 每次调用JS函数的时候，都会为之创建一个新的对象用来保存局部变量，把这个对象添加至作用域链中，当函数返回时，就从作用域链中将这个绑定变量的对象删除。 嵌套函数里是无法访问this的，除非在外部函数将其转换为一个变量： var self = this; 函数属性： length：形参个数； prototype属性： 当函数用作构造函数时，新创建的对象会从原型对象上继承属性。 以对象o的方法来调用函数f： f.call(o)或者f.apply(o); bind()方法： var g = f.bind(o);//通过调用g(x)来调用o.f(x)。 Function()构造函数所创建的函数并不使用词法作用域，函数体代码的编译总是会在顶层函数（全局作用域）执行。 不完全函数与记忆函数。 类和模块 调用构造函数： 构造函数的prototype属性被用作新对象的原型，从而继承了prototype的属性。 工厂函数方法与构造函数方法。 原型对象是类的唯一标识，当且仅当两个对象继承自同一个原型对象时，它们才属于同一个类的实例。 对于任意函数F.prototype.constructor==F;一个对象的constructor属性指代这个类。 构造函数与原型对象之间的关系： 任何添加到构造函数对象（不是指添加到构造函数内部）的属性都是类字段和类方法，属于类而不属于类的某个实例； 原型对象的属性被类的所有实例所继承，若原型对象的属性值是函数的话，这个函数就作为类的实例方法来调用，实例方法由所有实例所共享； 直接给类的每个实例定义非函数属性，实际上就是实例的字段。 即使创建对象之后，原型的属性发生改变，也会影响到继承这个原型的所有实例对象。 检测对象的类：instanceof，isPrototypeOf()，这里的继承可以不是直接继承； constructor属性； 以上两个方法不适用于多窗口和多框架子页面，因此可以使用构造函数的名称； 工厂方法： 构造函数方法： toJSON()用于序列号对象，如果一个对象有toJSON()方法，则JSON.stringify()并不会对传入的对象做序列号操作，而会调用toJSON()来执行序列号操作，JSON.parse()是其逆过程。 forEach： 私有方法： 通过将变量（或参数）闭包在一个构造函数内来模拟实现私有实例字段： 创建子类的关键： B.prototype = inherit(A.prototype);//子类派生自父类 B.prototype.constructor = B;//重载继承来的constructor属性 用组合代替继承的集合的实现： Object.preventExtensions():将对象设置为不可扩展的，即不能给对象添加任何新属性； Object.seal与Object.freeze:将对象的所有属性设置为只读和不可配置的。 Object.create(null);//创建一个不包含原型的对象，使之能够直接对它使用in运算符 作为私有命名空间的函数： 创建屏外图像： new Image(80,20).src = “images/***.gif”; this： 1,指向函数执行时的当前对象；2,没有明确的当前对象时，指向全局对象window。3,在事件处理程序的代码中，关键字this引用触发该事件的文档元素。 表单元素的属性： type，form（对包含该元素的form对象的只读引用），name，value；使用this.form引用Form对象，this.form.x引用名为x的兄弟表单元素。 cookie的性质： expires，path，domain，secure。 函数直接量与Function()构造函数创建函数的方法：适用于只用一次，无需命名。 属性callee： 用来引用当前正在执行的函数。 f.call(o,1,2);等价于： o.m = f; o.m(1,2); delete o.m; 删除一个属性： delete book.chapter2。 在方法主体的内部，this的值就变成了调用该方法的对象。 JS对象都“继承”原型对象的属性。 属性的继承只发生于读属性值时，而在写属性值时不发生。 实例属性有自己的副本，而实例方法是一个类共享的。 若要生成类Complex的一个子类，只需确保新类的原型对象是Complex的一个实例；这样它就能继承Complex.prototype的所有属性： MoreComplex.prototype = new Complex(0,0)； MoreComplex.prototype.constructor = MoreComplex; Object.property 等价于 Object[“property”] -&gt;关联数组。 只有那些真正存储在数组中的元素才能够分配内存。 正则表达式直接量： var pattern = /S$/;即：var pattern = new RegExp(“S$”); 在复制和传递时使用的是引用，但在比较它们时使用的却是值。 通过设置class.prototype属性来定义所有类实例共享的方法和常量。 Function()构造函数 函数直接量 允许运行时动态地创建和编译JS代码 静态 每次调用都会解析函数体并创建一个新的函数对象 相反 不使用词法作用域作为顶级函数 null == undefined -&gt;true; null === undefined -&gt; false; web浏览器中的JS 如果两个窗口包含的脚本把Document的domain属性设置成相同的值，则这两个窗口就不再受同源策略的约束，能够相互读取对方的属性。 1, 当HTML解析器遇到script标签元素时，它默认必须先执行脚本，然后再恢复文档的解析和渲染； 2, script标签的defer属性：使得浏览器延迟脚本的执行，直到文档的载入和解析完成；按顺序执行。 3, async属性：使得浏览器尽快的执行脚本，而不用在下载脚本时阻塞文档的解析；有可能无序执行。 window对象 Window对象的location属性引用的是Location对象： window.location === document.location //true Location对象的toString方法返回的是它的href属性的值。 A窗口中调用B窗口中的函数，此函数在定义它的作用域中执行，而不是在调用它的作用域中执行。 对于内置的类，每个窗口都有构造函数的一个独立副本和构造函数对应原型对象的一个独立副本。 脚本化文档 为某些HTML元素设置name或id属性值，将自动为window与document对象创建对应的属性，其属性值指向表示该文档元素的HTMLElement对象。 通过CSS选择器选取元素： querySelectorAll()，querySelector()；接受一个包含CSS选择器的字符串参数。 Document、Element、Text对象都是Node对象，其属性： parentNode，childNodes，firstChild，lastChild，nextSibling，previoursSibling，nodeType，nodeValue，nodeName，textContent。 Element属性： attributes，innerHTML; DocumentFragment是一种特殊的Node，作为其他节点的一个临时容器。 滚动条位置： window.pageXOffset/pageYOffset; 查询视口尺寸： windows.innerWidth/innerHeight; HTML5中，input标签的placeholder属性指定了用户输入前在输入域显示的提示消息。 Document类型定义了创建Element和Text对象的方法： document.createTextNode(“text node content”); Node类型定义了在节点树中插入、删除和替换的方法： parent.appendChild(child);//插入parent元素的最后； parent.insertBefore(child,parent.childNodes[n]; n.parentNode.removeChild(n); n.parentNode.replaceChild(document.createTextNode(“[ REDACTED ]”), n); 脚本化CSS 内联样式： e.style.position=”relative”; 计算样式： window.getComputedStyle(element,null); 事件处理 通过HTML属性来注册事件处理程序是一个例外，它们被转换为能存取全局变量的顶级函数而非任何本地变量。 在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。 jQuery each()只能遍历jQuery对象，而jQuery.each()可以遍历数组元素或对象属性。 focus与blur事件不支持冒泡，而focusin与focusout支持； mouseover与mouseout支持冒泡，mouseenter与mouseleave不支持；","link":"/2015/06/15/JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"title":"Javascript 函数式编程の书摘","text":"章一1，确定抽象，并为其构建函数；2，利用已有的函数来构建更为复杂的抽象；3，通过将现有的函数传给其他的函数来构建更加复杂的抽象。 章一1，确定抽象，并为其构建函数；2，利用已有的函数来构建更为复杂的抽象；3，通过将现有的函数传给其他的函数来构建更加复杂的抽象。 章二1，函数时一等公民： 函数式编程语言应该是促进创造和使用函数的； 2，applicative 编程： 函数A作为参数提供给函数B； 3，JavaScript对象的键只能是字符串； 章三词法作用域： 指一个变量的可见性，及其文本表述的模拟值；变量查找从最内层范围向外扩展。 动态作用域： 1，维护一张”值“的全局表（维护一个命名绑定栈的全局映射）；2，并使用一个函数来查询绑定的值；3，缺点：任何给定的绑定值，在确定调用其函数前，都是不可知的。 闭包： 闭包就是一个函数，捕获作用域内的外部绑定（例如，不是自己的参数）。这些绑定是为了之后使用（即使在该作用域已经结束）而被定义的。如果一个变量的引用同时存在于闭包的内外部，则它的变化可以跨越看似私有的界限，因此JavaScript经常使用如下模式，把捕获的变量作为私有数据： 12345678910111213var pingpong = (function() { var private = 0; return { inc: function(n) { return private += n; } dec: function(n) { return private -= n; } }; })(); pingpong.inc(10); pingpong.dec(7); 章四高阶函数： 1，它是一等公民；2，以一个函数作为参数；3，以一个函数作为返回结果； 闭包： 1，闭包会捕获一个值（或引用），并多次返回相同的值；2，每一个新的闭包都会捕获不一样的值； 章五柯里化函数： 逐渐返回消耗参数的函数，直到所有参数耗尽； 部分应用函数： 是一个部分执行，等待接收剩余的参数立即执行的函数； 组合函数： _.compose: 从右往左执行，最右边的函数的结果会被送入其左侧的函数，一个接着一个。 章六尾递归： 函数（除了停止条件返回值）的最后一个动作是递归调用； 递归和组合函数： andify与orify； 相互关联函数： 两个或多个函数相互调用会被称为相互递归，通过相互递归调用来回反弹彼此之间递减某个绝对值，直到一方或另一方达到零； 蹦床原理： 通过打包调用，而不是直接调用；trampoline函数：不断调用函数的返回值，直到它不再是一个函数。 章七纯函数： 1，其结果只能从它的参数的值来计算；2，不能依赖于能被外部操作改变的数据；3，不能改变外部状态。 幂等性： 对同一的参数运行一次函数应该与连续两次运行是一个结果。 不变性： 例如字符串； 对象的不变性： 1，不可变对象应该在构造时固定它们的值之后不能再修改；2，不可变对象操作并返回新对象。 章八惰性链： 在调用value之前，_.chain是惰性的，什么都不会发生； thunk： 封装了一些行为的函数； 管道；","link":"/2015/10/06/Javascript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%81%AE%E4%B9%A6%E6%91%98/"},{"title":"Monorepo 下 Git 工作流的最佳实践","text":"没有哪一种 Git 工作流是银弹，合适的 Git 工作流往往取决于项目的代码规模、协作人数、应用场景等；本次分享先从适合小型 Monorepo 的 Feature branch 工作流开始分享，接着分享适用于中大型 Monorepo 的 Trunk-based 工作流，并给出一些选型标准供同学们参考，希望通过本次分享，大家能找到合适自己 Monorepo 工程的 Git 工作流！ 背景没有哪一种 Git 工作流是银弹，合适的 Git 工作流往往取决于项目的代码规模、协作人数、应用场景等；本次分享先从适合小型 Monorepo 的 Feature branch 工作流开始分享，接着分享适用于中大型 Monorepo 的 Trunk-based 工作流，并给出一些选型标准供同学们参考，希望通过本次分享，大家能找到合适自己 Monorepo 工程的 Git 工作流！ 前置知识我们最熟悉的 Git 工作流莫过于 Git flow, Gitlab flow, Github flow，而对于 feature branch 和 trunk-based 比较陌生，那么以上几种 flow 有什么关系呢？ Feature branch 和 Trunk-based 工作流是比较新晋的概念，二者是相对的、互斥的，它们组成一个全集； Git flow, Gitlab flow, Github flow 都属于 feature branch development，它们有一个共同点：都采用『功能驱动式开发』，即：需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）； 适用场景在 Monorepo 工程中，使用 feature branch development 开发模式时，随着代码库复杂性和团队规模的增长，并行的『长期分支』也会越来越多，这些分支在合入主干时，将会频繁遇到冲突或者不兼容的情况，而手动解决代码冲突往往会引入 Bug。 而 trunk-based development 鼓励开发者可以通过一些小的提交创建『短期分支』，从而大大缓解冲突问题，有助于保持生产版本的流畅。 总的来说，选择一个工作流不仅仅是一系列操作工具的流程，我们往往还需要对它背后的思想买单；下面的表格是两种工作流模式在各个维度的适用情况： 目前大部分业务场景使用的都是 feature branch 的开发模式，如果你的业务是多人开发一个巨型应用（如抖音主站、飞书文档等），应该尝试使用 Trunk based 开发模式，这会提高仓库整体工程质量和管理水平。 展开说说Feature branch development什么是 feature branch development？ 定义 『功能分支开发模式』的核心思想是所有特性开发都应该在专用的分支，而不是主分支中进行。这种封装使多个开发人员，可以轻松地在不干扰主代码库的情况下处理特定功能。这也意味着主分支永远不会包含损坏的代码，这对于持续集成环境来说是一个巨大的优势。– Git Feature Branch Workflow | Atlassian Git Tutorial 上线模式 从 master 分支创建一个功能分支（Feature Branch） 开发者们在功能分支中完成开发工作 构建功能分支，并通知 QA 进行验证 如果发现任何问题 开发者创建一个基于功能分支的修复 MR 经过代码审阅和合并过程将修复 MR 合入功能分支 再重新构建部署，并通知 QA 进行验证 QA 验证通过后，将功能分支发布至线上，然后将其合并入主干后删除 为什么使用 feature branch development？ 多功能并行开发 使多个开发人员可以轻松地在不干扰主代码库的情况下处理特定功能。 保持主分支稳定 主分支永远不会包含损坏的代码，这对于持续集成环境来说是一个巨大的优势。 心智负担低 仅需了解简单的操作即可实践，无需了解 cherry-pick, feature flag 等概念。 Trunk-based development什么是 trunk-based development？ 定义 『基于主干的开发模式』是一种版本控制管理实践，开发者将小而频繁的更新合并到核心『主干』（通常是 master 分支）。 这是 DevOps 团队中的一种常见做法，也是 DevOps 生命周期的一部分，因为它简化了合并和集成阶段。事实上，它也是 CI/CD 的必备实践。 与其它存在『长期分支』的功能分支策略相比，开发者可以通过一些小的提交创建『短期分支』。随着代码库复杂性和团队规模的增长，『基于主干的开发模式』有助于保持生产版本的流畅。– Trunk-based Development | Atlassian 上线模式 从部署分支上线半自动化流程，适用于低频率部署，以及自动化测试不全面的项目 (A dot represents an MR merged into master. Green dots means good commits that passed e2e tests, and red dot means a buggy commit which should be avoided when deploying/rollback) 从 master 分支创建一个部署分支（RC） 构建部署分支（RC），并通知 QA 进行验证 如果发现任何问题 开发者创建一个基于 master 分支的修复 MR 经过代码审阅和合并过程将修复 MR 合入 master 将 commits cherrypick 到部署分支（RC），再重新构建部署，并通知 QA 进行验证 QA 验证通过后，将部署分支（RC）发布至线上，然后删除该分支（RC） 从主干分支上线全自动化流程，适用于需要高频率部署，以及自动化测试较为全面的项目 (A dot represents an MR merged into master. Green dots means good commits that passed e2e tests, and red dot means a buggy commit which should be avoided when deploying/rollback) 定时部署： 每天或者每小时到了特定时间，部署机器人自动找到当前最新通过全部端到端测试的代码(特定的 commit hash)，然后将之部署上线。 持续部署： 每当有新代码合并进主干分支时，部署机器人自动验证新代码是否通过所有端到端测试，以及是否与该项目相关，如果是则自动部署上线 为什么使用 trunk-based development？ 允许持续的代码集成（CI） 在『基于主干的开发模式』中，源源不断的提交合入主干分支。为每个提交添加自动化测试套件和代码覆盖率监控可以实现持续集成。当新代码合并到主干中时，会运行自动集成和代码覆盖测试以验证代码质量。 确保持续的代码审查（CR） 『基于主干的开发模式』的快速、小型提交使代码审查成为一个更有效的过程。借助小型分支，开发人员可以快速查看和审查小的更改。与评审者阅读大面积代码变更的长期功能分支相比，这要容易得多。 支持连续的生产代码发布（CD） 团队应该每天频繁地合并到主分支。『基于主干的开发模式』努力使主干分支保持“绿色”，这意味着它可以在每次提交合并后进行部署。自动化测试、代码收敛和代码审查，保证了基于主干的项目可以随时部署到生产环境中。 更适用于大型 Monorepo 下的多人协作场景（scalable） 大型 Monorepo 下的多人协作场景更易出现代码冲突，不仅消耗的大量的人力解决冲突，还增加了『长期分支』合入『主干分支』引入 bug 的可能性。与其它存在『长期分支』的功能分支策略相比，开发者可以通过一些小提交创建『短期分支』进行快速迭代。因此，随着代码库复杂性和团队规模的增长，『基于主干的开发模式』也能保证顺畅的多人协作。 线性的提交历史（Linear history） Trunk-based development 更容易做到线性的 commit 历史，它有如下几个好处： 方便查看和跟踪历史记录 方便回溯变更，比如：Feature A 是在 Bugfix B 之前或者之后引入的？ 方便排查 bug，比如：使用 Git bisect 二分排查，而非线性历史则难以操作 撤销变更，比如：当你发现一个有问题的 commit，简单的 revert 对应的 commit 即可，而非线性的历史会有很多跨分支的合并，使 revert 变得困难 有效的两个前提 持续集成和测试 在每次代码合并前后，开发者都需要知道自己的代码对主干带来了什么影响，因此持续集成和测试的能力必不可少。 功能开关 因为在基于主干开发时，大的功能被分解为小改动，因此对于还未完成而之后部分合并进主干的功能，我们需要功能开关来不让他们过早地暴露给用户。 功能开关通常是一套独立的控制系统，线上的代码有两套逻辑，然后通过实时读取功能开关的取值来决定是否隐藏或暴露某个功能。通常，我们在部署完一个功能相关的所有代码之后打开某个功能开关。然后当此功能已经稳定并且被永久加入产品后，会把功能开关和相关的逻辑代码删除掉。 参考 A tidy, linear Git history：https://www.bitsnbites.eu/a-tidy-linear-git-history/","link":"/2022/12/31/Monorepo%20%E4%B8%8B%20Git%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"title":"Node.js 开发指南の书摘","text":"章三1，单次加载： require不会重复加载模块，无论调用多少次require，获得的模块都是同一个； 2，覆盖exports： 当将一个对象封装到模块中时，exports.Hello = Hello,则需使用require(‘./singleobject’).Hello来获取对象，可简化如下：module.exports = Hello; 此时就可以直接获取这个对象了，var Hello = require(‘./hello’); hello = new Hello(); 3，创建全局链接： npm link express；从而在当前目录使用全局安装的express； 4， 通过使用npm init交互式初始化一个符合标准的package.json；发布包：npm publish；更改json文件中的version字段后，重新发布，达到更新版本的目的；取消发布：npm unpublish； 章三1，单次加载： require不会重复加载模块，无论调用多少次require，获得的模块都是同一个； 2，覆盖exports： 当将一个对象封装到模块中时，exports.Hello = Hello,则需使用require(‘./singleobject’).Hello来获取对象，可简化如下：module.exports = Hello; 此时就可以直接获取这个对象了，var Hello = require(‘./hello’); hello = new Hello(); 3，创建全局链接： npm link express；从而在当前目录使用全局安装的express； 4， 通过使用npm init交互式初始化一个符合标准的package.json；发布包：npm publish；更改json文件中的version字段后，重新发布，达到更新版本的目的；取消发布：npm unpublish； 章四1，process： process.argv: 命令行参数数组，第一个元素是node，以此类推；process.nextTick(callback): 为事件循环设置一项任务，Node.js会在下次事件循环响应时调用callback（一般用于拆分事件，从而减少每个事件的执行时间）； 2，console： console.trace(): 向标准错误流输出当前的调用栈； 3，util： util.inherits(constructor, superConstructor): 仅仅继承superConstructor在其原型中定义的函数，而构造函数内部创造的属性和函数都没有被继承；util.inspect(object, [showHidden], [depth], [colors]): 将任意对象转换为字符串的方法，通常用于调试和错误输出； 4，events： 1234567events.EventEmitter: var events = require(&quot;events&quot;); var emitter = new events.EventEmitter(); emitter.on(&quot;someEvent&quot;, function(arg1, arg2) { console.lgo(&quot;listener1&quot;, arg1, arg2); });emitter.emit(&quot;someEvent&quot;, &quot;byvoid&quot;, 1991); result: listener1 byvoid 1991 emitter.emit(“error”);退出程序并打印调用栈。只要是支持事件响应的核心模块都是EventEmitter的子类，例如fs、net、http。 5，fs: fs.readFile(filename, [encoding], [callback(err, data)];fs.readFileSync(filename, [encoding]);与同步I/O函数不同，node.js中异步函数大多没有返回值。 6, HTTP服务器: var http = requitr(‘http’); http.Server是一个基于事件的HTTP服务器,主要有以下几个事件: 1,request: 当客户端请求到来时触发,提供两个参数req与res,分别是http.ServerRequest和http.ServerResponse的实例.2,connection: 当TCP连接建立时触发,提供一个参数socket,是net.Socket的实例。该事件粒度大于request。3,close: 当服务器关闭时触发,而不是用户连接断开时。由于最常用的是request，因此http提供了一个捷径：http.createServer([requestListener])，其功能是创建一个HTTP服务器并将requestListener作为request事件的监听函数。 而http.ServerRequest提供了以下三个事件用于控制传输： 1，data：当请求体到来时触发，并提供一个参数chunk，表示接收到的数据。2，end：当请求体数据传输完成时，该事件被触发。3，close：用户当前请求结束时触发。 http.ServerResponse是返回给客户端的信息： 1，response.WriteHead(statusCode, [headers]): 向客户端发送响应头。2，response.write(data, [encoding]): 向请求的客户端发送响应内容。3，response.end([data], [encoding]): 结束响应，告知客户端所有发送已经完成。如果不调用，客户端将永远处于等待状态。 章五1，建立网站基本结构： express -t ejs microblog 2，创建应用实例： express.createServer() 3，控制权转移： express在处理路由规则时，会优先匹配先定义的路由规则，后面的规则将会被屏蔽，可使用next()进行转移。 4，路径匹配： app.get(‘/user/:username’, function(req, res) { res.send(‘user: ‘ + req.params.username); 5，模板引擎ejs，有如下三种标签： 123&lt;% code %&gt;：JavaScript代码；&lt;%= code %&gt;：显示替换过html特殊字符的内容；&lt;%- code %&gt;：显示原始html内容。 6，关闭layout： app.set(‘view options’, { layout: false });指定layout：function(req, res) { res.render(‘userlist’, { title: ‘后台管理系统’, layout: ‘admin’ }); }; 从而指定admin.ejs作为页面布局。 7，片段视图： partials。 8，视图助手： 静态视图助手可以是任何类型的对象，包括接受任意参数的函数，并且访问到的对象必须是与用户请求无关的；动态视图助手只能是一个函数，这个函数不能接受参数，但可以访问req合res对象； 章六1，在不显式指定文件模块扩展名的时候，Node.js会分别试图加上.js、.json和.node扩展名。.js是JavaScript代码，.json是JSON格式的文本，.node是编译好的C/C++代码。 2，当require遇到一个既不是核心模块，又不是以路径形式表示的模块名称时，会试图在当前目录下的node_modules目录中来查找。如果没有找到，则会在当前目录的上一层中的node_modules目录中继续查找，反复执行这一过程，直到遇到根目录为止。 3，加载缓存： Node.js模块不会被重复加载，这是因为Node.js通过文件名缓存所有加载过的文件模块，所以以后再访问到时就不会重新加载了。注意，Node.js是根据实际文件名缓存的，加载两次，也不会重复加载，解析到的文件是同一个。 4，控制流问题： 循环陷阱，可用forEach、闭包、let解决。","link":"/2016/03/18/Node.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%B9%A6%E6%91%98/"},{"title":"Node.js 微信公众号开发小试","text":"申请服务器: 微信公众号的开发需要使用一台用于接收并处理消息的服务器, 此处推荐申请腾讯的免费云主机, 点我去申请吧, 每天九点半开抢, 我选择的服务器镜像是Ubuntu, 关于如何在服务器上配置Node环境, 可参考我另一篇博客使用 Linux 系统开发Web前端. 公众号开发的原理就是通过设置一个接收接口, 一旦开启开发者模式, 微信服务器将转发消息至该接口. 申请服务器微信公众号的开发需要使用一台用于接收并处理消息的服务器, 此处推荐申请腾讯的免费云主机, 点我去申请吧, 每天九点半开抢, 我选择的服务器镜像是Ubuntu, 关于如何在服务器上配置Node环境, 可参考我另一篇博客使用 Linux 系统开发Web前端. 公众号开发的原理就是通过设置一个接收接口, 一旦开启开发者模式, 微信服务器将转发消息至该接口. 接入开发步骤填写服务器配置 验证服务器地址的有效性完成配置后, 服务器将收到来自微信的GET验证请求, 该请求包括如下参数: signature 微信加密签名, 使用开发者填写的token参数和请求中的timestamp参数、nonce参数进行加密 timestamp 时间戳 nonce 随机数 echostr 随机字符串, 当验证通过时, 返回该字符串给微信服务器, 从而完成验证 验证流程 将token、timestamp、nonce三个参数进行字典序排序 将三个参数字符串拼接成一个字符串进行sha1加密 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 验证有效性的代码 123456789101112131415161718192021app.get('/wechat', (req, res) =&gt; { var token = &quot;quanru&quot;; var signature = req.query.signature; var timestamp = req.query.timestamp; var echostr = req.query.echostr; var nonce = req.query.nonce; var oriArray = [nonce, timestamp, token]; oriArray.sort(); var original = oriArray.join(''); var shaObj = new jsSHA(original, 'TEXT'); var scyptoString = shaObj.getHash('SHA-1', 'HEX'); if (signature == scyptoString) { //验证成功 res.send(echostr); } else { //验证失败 res.send(false); }}); 依据接口文档实现业务逻辑以文本消息为例, 如下为微信转发至服务器的文本消息: 12345678&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt; 消息处理: 123456789101112 app.post('/wechat', (req, res) =&gt; { res.writeHead(200, {'Content-Type': 'application/xml'}); var content = req.body.xml.content; turingRobot(encodeURI(content)).then((data) =&gt; { var response = JSON.parse(data); var resMsg = autoReply(req.body.xml, response.text);console.log(resMsg); res.end(resMsg); });}); 其中turingRobot用于向图灵机器人发送用户消息: 1234567891011121314151617181920const request = require('request');function getTuringResponse(info) { if(typeof info !== 'string') { info = info.toString(); } let options = { method:'GET', url: 'http://www.tuling123.com/openapi/api?key=13a74dbd0f6b45d69ac49334e7027742&amp;info='+info }; return new Promise((resolve, reject) =&gt; { request(options, (err, res, body) =&gt; { if (res) { resolve(body); } else { reject(err); } }); })}module.exports = getTuringResponse; 自动回复模块autoReply: 12345678910111213function autoReply(requestData, info) { if(requestData.msgtype == 'text') { var resMsg = '&lt;xml&gt;' + '&lt;ToUserName&gt;&lt;![CDATA[' + requestData.fromusername + ']]&gt;&lt;/ToUserName&gt;' + '&lt;FromUserName&gt;&lt;![CDATA[' + requestData.tousername + ']]&gt;&lt;/FromUserName&gt;' + '&lt;CreateTime&gt;' + parseInt(new Date().valueOf() / 1000) + '&lt;/CreateTime&gt;' + '&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;' + '&lt;Content&gt;&lt;![CDATA['+info+']]&gt;&lt;/Content&gt;' + '&lt;/xml&gt;'; } return resMsg;}module.exports = autoReply; One More Thing使用微信的官方的Node中间件, 可更方便高效地开发公众号传送门 123456789101112131415161718192021222324const turingRobot = require('./turingRobot');const autoReply = require('./autoReply');const wechat = require('wechat');module.exports = function(app) { //使用中间件 //传入这三个配置, 自动帮你验证 var config = { token: 'quanru', appid: 'wxdc6410f1001d787b', encodingAESKey: 'IJwymet3h2KzGSTPxMnITc25pGiSzSlWCXHUhcvQRzc' }; app.use('/wechat', wechat(config, (req, res, next) =&gt; { //用户的消息以对象的形式返回到该变量 var message = req.weixin; var content = message.Content; turingRobot(encodeURI(content)) .then((data) =&gt; { var response = JSON.parse(data); //默认回复文本消息, 支持多种格式回复, 如图像, 音乐 res.reply(response.text); }); }));} 附上精美PPT地址附上精美代码地址 参考nodejs微信开发—自动回复的实现微信公众平台开发概述—接入指南(需要登录)使用 Linux 系统开发Web前端","link":"/2016/08/14/Node.js%20%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AF%95/"},{"title":"Node.js 的 Morgan 模块与 Cluster 模块","text":"这段时间鼓捣Node.js，跟着《Node.js 开发指南》把 Microblog 给实现了一下，由于该书撰写于 2012 年，Node 版本目前最新已更新至 v5.9.0，且 Express 也发生了相当大的变化，导致很多书中代码已经不符合当前的版本了。关于实现部分，可参考这篇文章：《nodejs开发指南》微博实例express4.x版 。BTW，目前 express 启动命令改为 npm start，该命令执行 bin 目录下的 www 文件，相当于直接执行 node ./bin/www。此处简要记录下该书第六章提到的关于日志与多核CPU的优化问题，并介绍一款 debug tool。整个 microblog 的代码已放至 github 上：摸我 一、前言这段时间鼓捣Node.js，跟着《Node.js 开发指南》把 Microblog 给实现了一下，由于该书撰写于 2012 年，Node 版本目前最新已更新至 v5.9.0，且 Express 也发生了相当大的变化，导致很多书中代码已经不符合当前的版本了。关于实现部分，可参考这篇文章：《nodejs开发指南》微博实例express4.x版 。BTW，目前 express 启动命令改为 npm start，该命令执行 bin 目录下的 www 文件，相当于直接执行 node ./bin/www。 此处简要记录下该书第六章提到的关于日志与多核CPU的优化问题，并介绍一款 debug tool。 整个 microblog 的代码已放至 github 上：摸我 二、Morgan 模块の日志生成 安装 morgan 与 file-stream-rotator，后者用于生成 daily log： npm i morgan file-stream-rotato –save-dev 编辑 app.js 文件，将其引入，此外还有 node 自带模块 fs： 123var FileStreamRotator = require('file-stream-rotator');var logger = require('morgan');var fs = require('fs'); daily log 生成： 123456789var logDirectory = __dirname + '/log';//日志文件存放目录fs.existsSync(logDirectory) || fs.mkdirSync(logDirectory);//检查目录是否存在，若不存在则新建var accessLogStream = FileStreamRotator.getStream({ date_format: 'YYYYMMDD',//日期格式 filename: logDirectory + '/access-%DATE%.log',//日志文件命名方式 frequency: 'daily',//生成频率，可以是每两小时:2h，每分钟：1m verbose: false//详细与否});app.use(logger('combined', {stream: accessLogStream}));//其中 combined 为生成格式 该插件的具体使用方法参见： morgan ，包括生成格式与配置选项等，也可自行组合配置生成格式。 三、Cluster 模块の生成子进程该模块为 Node.js 自带的核心模块，用于生成与当前进程相同的子进程，允许父子进程共享端口，可充分利用当代服务器的多核CPU。 www 文件中存放服务器创建代码，因此编辑该文件，添加如下代码：12345678910111213141516&quot;use strict“;//后面用到了箭头函数，属于es6，因此设定严格模式，否则不支持var cluster = require('cluster');//模块引入var numCPUs = require('os').cpus().length;//获得当前系统的 cpu 数量if(cluster.isMaster) {//若当前进程为主进程，则 fork 新进程，数目为cpu数量 for(let i = 0; i &lt; numCPUs; i++) { cluster.fork(); } cluster.on('exit', (worker, code, signal) =&gt; { console.log(`worker ${worker.process.pid} died`); }); } else {//否则，创建服务器主进程 //share TCP connection server.listen(port); server.on('error', onError); server.on('listening', onListening); } 此时查看进程管理器，发现有多个 node 进程，而原来的代码则只有两个： 四、Node.js 除虫工具我就不搬运了，它基于 electron，模仿 chrome 的 devtool，会用 chrome 的 devtool 就会这个，反正很吊：devtool ，github 地址为：devtool 安装： npm install -g devtool 此处启动命令为： devtool bin/www –watch 断点之后，按 ctrl + r，重启服务器即可。 进入断点后，点击 esc 可打开一个执行在当前作用域内的控制台，可以修改一些变量然后继续执行。 当使用 cluster 时，无法进入 get 与 post 请求函数内部，我提了个 issue。 高级使用方法见上述网址咯。","link":"/2016/03/18/Node.js%20%E7%9A%84%20Morgan%20%E6%A8%A1%E5%9D%97%E4%B8%8E%20Cluster%20%E6%A8%A1%E5%9D%97/"},{"title":"Node.js 调试方式集锦","text":"本文讨论了几个流行的 Node.js 调试方式，包括 Chrome，VSCODE，ATOM，WebStorm Chrome：优势 不依赖编辑器； 不依赖配置； Node.js 默认已经集成，官方推荐； 与前端代码调试工具一致； dev-tools 工具强大 劣势 无法在源文件上进行断点 VSCODE：优势 可在源文件上进行断点 劣势 需要一定的配置 WebStorm：优势 可在源文件上进行断点 劣势 需要一定的配置 ATOM：优势 可在源文件上进行断点 劣势 功能比较弱，不如 VSCODE 个人建议：如果本身就使用 VSCODE，WebStorm 的话，建议继续使用对应的 Node.js 调试方式；如果使用 ATOM，Sublime 调试不便的编辑器，推荐使用 Chrome 进行调试。 CHROME 调试配置步骤一：安装 nodemon，监听文件变化以重启 node 服务 $&gt; npm install nodemon -g 步骤二：以 —inspect 参数启动调试 $&gt; NODE_ENV=development nodemon --inspect -w config -w server -x node server/server.js 注： NODE_ENV=development // 传入环境变量 —inspect // 配合 Chrome 进行调试，当同时调试多个 node 服务时，可设置端口以避免冲突：—inspect=9291 -w config -w server // 监听 config 与 server 目录，当上述两个目录内文件发生变化时，自动重启服务 -x node // 默认为 node，可不配置，必要时可配置为 babel-node：-x babel-node server/server.js // node 项目入口文件 步骤三：启动前端调试服务(如果有的话) 步骤四：建议将上述命令配置为 scripts 脚本（此时可在项目内单独安装 nodemon）： 1234567&quot;scripts&quot;: { &quot;start&quot;: &quot;npm run server &amp; npm run dev&quot;, &quot;server&quot;: &quot;NODE_ENV=development nodemon -w config -w server server/server.js&quot;, &quot;start-debug&quot;: &quot;npm run server-debug &amp; npm run dev&quot;, &quot;server-debug&quot;: &quot;NODE_ENV=development nodemon --inspect -w config -w server server/server.js&quot;, &quot;dev&quot;: &quot;nodemon -w config -w scripts scripts/server.js&quot; } 步骤五：打开 Chrome，并打开 dev tool，当你的 Chrome 足够新（60 以上），可点击如下 node.js 图标，进入调试 步骤六：如果当前 Chrome 不支持，请更新，或者使用插件 NIM VSCODE 调试配置步骤一：打开项目目录步骤二：切换到 debug tab： 步骤三：打开 launch.json 文件 步骤四：配置 launch.json12345678910111213141516171819{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;type&quot;: &quot;node2&quot;, // 新增类型，方便调试 await/async 语法 &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;启动程序&quot;, &quot;verboseDiagnosticLogging&quot;: false, &quot;program&quot;: &quot;${workspaceRoot}/server/server.js&quot;, // 此为 node 工程的入口文件 &quot;cwd&quot;: &quot;${workspaceRoot}&quot;, &quot;runtimeExecutable&quot;: &quot;${workspaceRoot}/node_modules/.bin/babel-node&quot;, // 若未使用 babel-node，例如使用 node8 以上版本，请移除本行 &quot;env&quot;: { &quot;NODE_ENV&quot;: &quot;development&quot; }, &quot;sourceMaps&quot;: true } ]} 步骤五：启动前端调试服务(如果有的话) 步骤六：使用 VSCode 打开源码文件，点击行号左侧以添加断点 步骤七：切回 debug tab，启动 node.js 服务，即可调试 WebStorm步骤一：打开项目目录，展开 Run 菜单，选择 Edit Configurations 步骤二：新建 Node.js 调试配置 步骤三：配置参考 注： Node interpreter：node 可执行文件路径，若使用 babel-node 则需要添加 babel-node 路径； Working directory：工作目录； JavaScript file：项目入口文件； Environment variables：环境变量； 步骤四：启动前端调试服务(如果有的话) 步骤五：使用 WebStorm 打开源码文件，点击行号左侧以添加断点 步骤六：点击启动调试服务 ATOM 调试配置步骤一：安装插件：a. xatom-debug b. xatom-debug-nodejs 步骤二：打开 node 项目入口文件，并在箭头处切换需要调试的项目目录，之后点击箭头右侧的 Node.js 按钮进入配置 步骤三：配置调试 步骤四：启动前端调试服务(如果有的话) 步骤五：使用 ATOM 打开源码文件，点击行号左侧以添加断点 步骤六：点击启动调试服务","link":"/2017/08/15/Node.js%20%E8%B0%83%E8%AF%95%E6%96%B9%E5%BC%8F%E9%9B%86%E9%94%A6/"},{"title":"React 状态的逻辑复用","text":"关于 React 状态的逻辑复用史！","link":"/2020/05/30/React%20%E7%8A%B6%E6%80%81%E7%9A%84%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"title":"Schema 与下载条","text":"由于我司有个网站还没有对应的移动端版本，因此需要在移动端访问该网站时，在底部显示一条下载条，而且点击该下载条时需要满足以下两个需求： 点击下载时，如果本机已经安装该软件，则尝试打开对应软件； 点击下载时，如果本机未安装该软件，则跳转到对应系统的下载地址。 需求由于我司有个网站还没有对应的移动端版本，因此需要在移动端访问该网站时，在底部显示一条下载条，而且点击该下载条时需要满足以下两个需求： 点击下载时，如果本机已经安装该软件，则尝试打开对应软件； 点击下载时，如果本机未安装该软件，则跳转到对应系统的下载地址。 schema协议 schema类似自定义url协议，我们可以通过自定义的协议来打开自己的应用，形如： 代码如下 复制代码myapplink:// 例如 facebook的fb:// itunes的itms-apps:// 还有短信也是类似的sms://如果要打开一个app，最简单的方式是通过一个链接，如我们在html中这样写： 代码如下 复制代码打开我的app 下载条配置由于该下载条在PC页面中使用，因此无法使用rem单位，我将下载条统一做成了png，并通过引入js文件来配置不同的下载条： 12&lt;script src=&quot;dlBar.js&quot; data-imgurl=&quot;下载条图片地址&quot; data-itunesurl=&quot;苹果下载地址&quot; data-androidurl=&quot;安卓下载地址&quot; data-schemaurl=&quot;schema url&quot;&gt;&lt;/script&gt; 生成考虑到兼容性，其中下载条使用原生原生的方法生成对应的css与html部分，其代码如下： 123456789101112function creatHtml () { var st = document.createElement(&quot;style&quot;); var cssText = document.createTextNode(&quot;.bottom-bar { display: none; position: fixed; left: 0; bottom: 0; width: 100%; } .dl-btn { position: absolute; right: 17.5%; width: 18.75%; } .cl-btn { position: absolute; right: 3.4375%; width: 4.6875%; } .dl-img { width: 100%; display: block; }&quot;); st.setAttribute(&quot;type&quot;, &quot;text/css&quot;); st.appendChild(cssText); var heads = document.getElementsByTagName(&quot;head&quot;); if(heads.length) { heads[0].appendChild(st); } document.body.insertAdjacentHTML(&quot;beforeEnd&quot;, '&lt;div id=&quot;barab&quot; style=&quot;display: none; position: fixed; left: 0; bottom: 0; width: 100%;&quot;&gt;&lt;img style=&quot;width: 100%; display: block;&quot; src=&quot;'+ imgSrc +'&quot; alt=&quot;下载条&quot;&gt;&lt;span style=&quot;position: absolute; right: 14.8%; bottom: 20%; width: 18.55%; height: 63%&quot;&gt;&lt;/span&gt;&lt;span style=&quot;position: absolute; right: 3.4375%; bottom: 35%;width: 4.6875%; height: 30%;&quot;&gt;&lt;/span&gt;&lt;/div&gt;');} 配置使用的下载条图片、APP store跳转地址、Android的下载地址以及schema地址。 主要代码1234567891011121314151617181920212223242526272829303132333435function downloadApp () { var dlNow = document.querySelector(&quot;#barab span&quot;); var closeBtn = dlNow.nextElementSibling; closeBtn.addEventListener(&quot;touchend&quot;, function (event) { downBar.style.display = &quot;none&quot;; }); dlNow.addEventListener(&quot;touchend&quot;, function (event) { var t; var clickTime = new Date(); var ifr = document.createElement('iframe'); ifr.src = schemaSrc; ifr.style.display = 'none'; document.body.appendChild(ifr); if(ios) { t = window.setTimeout(function () { var timeOutTime = new Date(); if (!clickTime || timeOutTime - clickTime &lt; 600 + 200) { window.location = itunesSrc; } }, 600); } if(android) { t = window.setTimeout(function() { var endTime = Date.now(); if (!clickTime || endTime - clickTime &lt; 600 + 200) { window.location = androidSrc; } }, 600); } window.onblur = function() { clearTimeout(t); }; });}})(); 代码思路 首先创建一个iframe，将schema赋值给它的src属性； 当点击下载按钮时，记录点击时的时间戳，并将iframe添加到body中，紧接着设置一个setTimeout； 如果该程序已经安装，便会尝试使用schema协议打开app； 如果该程序没有被安装，则所设置的定时器会在600ms后执行，并记录定时器触发的时间，与点击的时间如果相差200ms，则跳转到对应系统的下载地址。 原理 如果schema地址跳转成功，说明程序已经安装，则后续代码如何执行已不重要； 否则，没跳转成功的话，说明程序尚未安装，因此程序跳转到对应下载地址； 其中时间差就是为了等待schema地址打开软件的，如果不设置等待时间的话，程序会马上执行跳转部分，也就没有schema什么事了。 完整代码","link":"/2015/08/16/Schema%E4%B8%8E%E4%B8%8B%E8%BD%BD%E6%9D%A1/"},{"title":"git checkout 与 git reset 备忘录","text":"一直没搞清 git checkout 与 git reset, 昨晚特地建了一个仓库进行实验, 特此备忘. git 的三块区域与仓库 工作区 (working directory) 即当前编辑的文件所处的区域 暂存区 (stage index) 即当你执行 git add 命令之后, 对应的文件便加入暂存区 历史记录区 (history) 即当你执行 git commit 之后, 暂存区的修改便会作为一个 commit 记录, 存入历史记录区 以上都发生在本地仓库, 直到执行 git push 之后, 便将本地仓库的修改 (历史记录区) 推送到远程仓库. 此外还有个 HEAD 的概念, 它默认指向当前分支的最新的一个 commit. git checkout git checkout 平时主要用于切换分支 git checkout – 用于丢弃工作区的改动. 其中 ‘–’ 用于区分切换分支的 git checkout, 假设如下一种情况: 当前有个分支叫做 ‘ master’, 此时当前目录下也有一个叫做 ‘master’ 的文件, 此时你想撤销对工作区中对 ‘master’ 文件的修改, 便执行 git checkout master, 但是该命令只是让你切换到 ‘master’ 分支. 如图, 当我们修改一个文件后, 查看 git status, 给出了如下提示, 要么使用 git add 将修改过的文件提交到暂存区, 要么使用 git checkout – 丢弃当前工作区对该文件的修改. 可以发现执行 git checkout – 之后, README.md 恢复到修改之前. git reset git reset HEAD 丢弃暂存区的修改, 使改动退回到工作区 如下图, 当在添加 ‘second modify’ 到 README.md 文件后, 将此次修改通过 git add 命令将其添加到暂存区, 终端提示使用 git reset HEAD 用于取消暂存区的修改, 其中 git reset HEAD 代表将当前 HEAD 指向当前 commit. 其中 HEAD 可省略, 即默认指向当前 commit. 如下图, 继续修改 README.md, 在文件中追加 ‘ third modify’, 此时查看 git status, 发现除了原有的暂存区修改 (绿色文字) 之外, 还有第二次修改的当前工作区修改 (红色文字), 接着执行 git reset HEAD, 终端提示 ‘重置后取消暂存的变更’, 此时查看 git status, 发现暂存区不见了, 只剩当前工作区, 查看工作区中的 README.md 文件, 发现原有的暂存区修改被撤销了, 且不影响工作区文件. ‘重置后取消暂存的变更’如果 git reset ‘commitID’ 呢, 此时所谓 ‘重置’ 指的是将当前指针指向对应的 ‘commitID’, 而 ‘取消暂存的变更’ 指的是撤销最近一次 ‘git add’; 这样分开看, 就很好理解了. git reset –soft/–mixed/–hard如图, 带参数的 git reset 不能 (或不建议) 作用于某个路径, 因此只要用于操作 commitID. –soft重置 HEAD 的指针到指定的 commitID, 同时保持暂存区与工作区不变; 如图, 将 HEAD 指针重置到两个 commit 之前, 发现当前分支落后远程分支两个 commit, 此时查看暂存区 (git diff –cached) 和 工作区 (cat README.md), 可以发现这两个区域的文件相比 git reset –soft 之前都没有变化. –mixed重置 HEAD 的指针到指定的 commitID, 同时撤销暂存区, 而工作区则不变; 如图, 此处与 git reset soft,hard,mixed之区别深解 中所述的 –mixed 有出入, 并没有 ‘并且重置index以便和HEAD相匹配’; –hard重置 HEAD 的指针到指定的 commitID, 同时重置暂存区与工作区与其对应的 commitID 相匹配; 如图, 执行 –hard 重置之后, 暂存区与工作区全都消失了, 此时可以选择 git pull, 重新与远程分支一致, 也可使用 git push –force, 强行将远程分支的 commit 记录与本地仓库保持一致. 不过一般建议使用 git revert, 回退的同时保存 commit 的历史记录. 到底哪个才是默认参数有些文章说 –mixed 是默认参数, 也有些说 –soft 是默认参数 如图, 可知默认参数是 –mixed","link":"/2016/10/04/git%20checkout%20%E4%B8%8E%20git%20reset%20%E5%A4%87%E5%BF%98%E5%BD%95/"},{"title":"一种实用新型 Obsidian 实践之构建我的第二大脑 🧠","text":"本文将以 Obsidian 为例，分享我使用 Obsidian 构建第二大脑的实践！ 前言什么是 Obsidian？ 官网上它是这么自我介绍的： Obsidian is the private and flexible note‑taking app that adapts to the way you think. Obsidian 是一款私密且灵活的笔记应用程序，可以适应您的思维方式。 我主要看中它丰富的插件生态，你如果喜欢 Vscode，那你大概率也会喜欢 Obsidian，只不过 Vscode 用于写代码，而 Obsidian 用于记笔记。 第一大脑 VS 第二大脑第一大脑即我们的真实大脑，只要我们还活着，那这个大脑就不停地在运转，执行的任务比如知识管理、任务管理、目标管理等，大多数时候我们并不能一脑多用，因此第一大脑更像是一个 CPU，各式各样的任务在抢占 CPU 分片。当需要处理的任务多起来的时候，大脑将不堪重负，因为大脑既要处理当前的任务，又要保持其它任务的上下文，用以切换任务，使得我们无法专注于当前任务的执行，此时需要一个外置的系统来辅助第一大脑，它就是第二大脑。 第二大脑即一个外置的系统，如果把第一大脑比作 CPU 的话，第二大脑更像是存储系统，它就像第一大脑与真实世界之间的一道缓存，减轻了第一大脑的负担，使其能够专注于当前事项。它可以类比为内存和硬盘，只不过内存相对于硬盘，它与 CPU（第一大脑）沟通更加频繁，读取速度也更快。这个存储系统存放当前第一大脑无需时刻关注的事物，当然，这些事物得由第一大脑思考决-定是否有存放的必要，内容可以是记录、待办、流程，载体可以是文本、图片、视频。 举一个例子，当我们使用第二大脑进行任务管理的时候，重要紧急的事项存放在内存，不重要不紧急的事项存放在硬盘；本周任务存放在内存，本月任务可能就存放在硬盘；因此通过借助第二大脑，我们就能够无压力专注在当下，在有必要的时候再切换上下文。 本文将以 Obsidian 为例，分享我构建第二大脑的实践！你说它是第二大脑，但是从不同角度审视这个大脑，我也可以称它为『LifeOS』，因为无论从生活还是工作，我都记录在上面；我也可以称它为『可编程个人生产力系统』，我在上面写了不少代码，用来做一些查询和自动化的事情，也是我用来管理任务和目标的生产力系统；甚至它还有点像『Monorepo 工程』，每个文件夹就是一个项目，项目中的 README.md 就像是 Package.json 一样描述了当前项目的元信息。 📢 注意：这套系统不是那种自上而下、先有这套流程而去实现的，是我在使用 Obsidian 过程中逐渐形成的，而且也一直在迭代中，姑且把当前的版本定为 1.0，现在分享出来是想给大家一点点灵感，去完善自己的系统！此外，可能需要有编程基础，因为我写了不少自定义的 JavaScript 脚本（不排除抽成插件的可能），但是你如果完全遵循我这套系统，那也不需要懂代码，下载使用即可！ 我的实践我采用两套系统，一个是知识管理系统，另一个是周期笔记，前者以项目/领域/资源为维度，进行知识管理，后者以时间为维度，进行任务/目标/时间管理。 两套系统 知识管理：采用 PARA 系统 Projects -&gt; 项目是与目标相关的一系列任务，有截止日期 Areas -&gt; 领域是一种活动领域，需要在一定时间内保持一定的标准 Resources -&gt; 资源是持续感兴趣的话题或主题 Archives -&gt; 存档是来自上述三个类别的非活动条目 周期笔记 长期：自顶向下，专注于长期的目标 三年记 年记 季记 短期：自底向上，专注于短期的任务 月记 周记 日常：捕捉想法洞见，实现自我觉察；耗时统计，确保聚焦于项目 日记 其中 PARA 越靠近 Projects，它的可操作性就越高；周期笔记越长期，它的可预测性就越低； 这两套系统相当于制造了两个上下文，让我保持聚焦 一个是基于时间的（周期笔记），即我到达某个时间节点，我就基于对应周期笔记作业，且笔记中有足够的上下文； 另一个是基于主题的（PARA），即我想对某个主题进行调查研究的时候，我就基于对应主题的索引（README.md）作业，且笔记中已经收集了不少上下文； 切面子系统在上述两套系统之下，隐藏着任务/目标/时间管理子系统，我主要通过『周期笔记』来管理： 任务管理 通过日记/周记来收集 通过周记/月记来整理 目标管理 通过年记规划年度目标 通过季记分拆年度目标 通过月记拆解待办事项 自上而下整理（通过目标拆解） 自下而上整理（通过收集拆解 -&gt; 日记/周记） 时间管理 通过日记手动统计各个项目的耗时和占比，反馈和调整时间开销 通过日记、周记、月记、季记、年记使用脚本自动统计各个项目的耗时和占比，用于复盘时间开销 你也许会好奇，上述子系统似乎只使用了『周期笔记』，实际上两个父系统之间通过两种方式将各个子系统连接起来。 连接 系统之间如何关联 标签连接 将 PARA 下的一级文件夹作为一种特殊的标签（不一定要与文件名完全一致），在『周期笔记』中使用，那么便可在各个一级文件夹中，以相同的方式进行统一的索引。这样能保证每个 PARA 文件夹下的 README.md 索引有当前主题的所有上下文： 项目连接通过在『知识管理』中立项来生成项目，为了增加对项目的关注，在每类『周期笔记』中均设置有『要事列表』或『项目列表』，比如 日记中的『项目列表』，它是一份当前项目列表的快照，用于统计当天花费在各个项目中的耗时及其占比，确保把足够的时间花在项目上 周记和月记中的『要事维度』，是从本周和本月的日记中自动合并去重得到的一个列表，用于安排项目维度的任务和后续的复盘 季记的『要事维度』，它是一份当前领域列表的快照，用于安排要事维度的目标和后续的复盘 年记中的『要事维度』，是从本年的季记中自动合并去重得到的一个列表，用于设置领域维度的目标和后续的复盘 检索 标签 比如，日记的节日、休假标签 索引文件 比如，每个项目的 README.md 索引本项目的任务、日志、上下文 文件夹 比如，每个 PARA 目录使用一致的目录结构 复盘 复盘主要针对本周期内的项目，复盘的同时规划下个周期的任务 周记复盘本周日记，月记复盘每周复盘，季记复盘每月复盘 演示说明『日记』与『项目 README』 用于日常管理，包括项目列表、日常记录、习惯打卡、精力分配、今日完成等模块 日记中的『项目列表』是一份当前项目（即 Projects 目录下）的快照 『周记』与『月记』 用于安排周度和月度任务，包括任务和复盘模块 在周记和月记中，『要事维度』是一份本周期日记『项目列表』的快照合集（自动生成） 在周记和月记中，『复盘』主要针对本周期内的项目进行 『季记』与『年记』 用于制定季度和年度目标，包括目标和复盘模块 在季记中，『要事维度』是一份当前领域（即 Areas 目录下）的快照 在年记中，『要事维度』是一份本周期季记『要事维度』的快照合集（自动生成） 在季记和年记中，『复盘』主要针对本周期内的领域进行 『PARA 索引』与『任务索引』 如何打造？ 拉取 Demo 工程，即可体验 插件安装 周期笔记 https://github.com/liamcain/obsidian-calendar-plugin https://github.com/liamcain/obsidian-periodic-notes 任务管理：https://github.com/obsidian-tasks-group/obsidian-tasks 查询工具：https://github.com/blacksmithgu/obsidian-dataview 自定义逻辑：https://github.com/saml-dev/obsidian-custom-js 笔记模版：https://github.com/SilentVoid13/Templater 脚本编写 - https://github.com/saml-dev/obsidian-custom-js date 根据周期笔记的文件名，解析出日期 根据解析出的日期，获取日期范围 根据解析出的日期，获取文件列表 task 根据日期范围，获取任务列表 project 获取当前项目列表的快照 根据日期范围内，获取项目列表 计算日期范围内，项目的耗时及其占比 area 获取当前领域列表的快照 根据日期范围内，获取领域列表 Dataview 视图 - https://github.com/blacksmithgu/obsidian-dataview taskDoneList 放到周期笔记中，可获取当前日期范围内完成的任务列表 taskRecordList 放到周期笔记中，可获取当前日期范围内收集的任务列表 projectList 放到周期笔记中，可获取当前日期范围内项目耗时的占比 areaList 放到周期笔记中，可获取当前日期范围内领域列表 周期笔记模版 - https://github.com/SilentVoid13/Templater Daily Weekly Monthly Quarterly Yearly 实践中的小 Tips缓存区机制把不重要不紧急的事情，通过创建任务，快速放到缓存区，把大部分注意力保持在『项目』中 任务列表任务的记录不要有太大的心里压力，记下的不代表一定要做；记下了能够减轻你的心里负担，不用老想着这个事，也不怕忘记这个事；我有非常多的任务记下来了，后续经过评估也确实没实现。 我们只要保证一定的机制能回顾到这些被记下的任务即可，比如 使用 tasks 插件来做一些任务列表的查询视图 每份周期笔记中都有当前周期收集的任务列表 项目索引文件中的任务列表 任务提醒我认为任务有三种提醒方式 强提醒，比如抢茅台、抢演唱会门票这种，到点就要进行，就需要强提醒，，比如抢茅台、抢演唱会门 弱提醒，某天需要完成，比如信用卡还款、贷款还款之类的，通过 GTD 软件设置提醒即可 列表类，用于记录任务，让你后续统筹安排的，根据需要可以转成强提醒或者弱提醒事件，有点类似 GTD 里的收件箱 微习惯 我会在日记中列一些微习惯，切记不是任务，完不完成都行，主要用来提醒『这些微习惯，你今天考虑做一下吗？』，即在我有『能力』和『动机』的时候，起到『提示』的作用，比如： 微习惯 一听到闹钟响就起床喝水 一下车就戴耳机听小宇宙 一上地铁就打开微信读书 一到工位就写下三件待办 一到十点半就开始干正事 易于重构在每份周期笔记中，相同功能的模块都使用同一个语句，比如『本周期收集的任务』，都是通过插入如下查询语句，而『本周期』的变量是当前的文件名提供，这就使得批量重构所有周期文件变得十分方便，只需要批量替换即可： 1await dv.view(&quot;Templates/PeriodicNotes/views/taskRecordList&quot;) 善用快捷键设置全局一致的快捷键，使得无论在哪个软件都能使用同一个快捷键唤起同一个功能，如下是我的部分设置： 光标移动 规律：Control + 方向首字母/VIM方向 示例： A: Head of line E: End of line F/L: Forward B/H: Backward N/J: Next line P/K: Previous line W: Delete a word(Backward) D: Delete a character(Forward) 窗口管理 规律：Command + Option + 首字母 示例： L: 左侧半屏 R: 右侧半屏 C: 居中 M: 最大化 [: 显示/隐藏左侧栏 ]: 显示隐藏右侧栏 ‘: 显示/隐藏底栏 T: 新建 Tab(更具体的窗口下，顶层 Tab 使用 Command + T) W: 关闭 Tab(更具体的窗口下，顶层 Tab 使用 Command + W) J: 下一个 Tab K: 上一个 Tab 文档编辑 规律1：Command + Option + 数字/符号 示例： 1: Markdown 一级标题 2: Markdown 二级标题 3: Markdown 三级标题 4: Markdown 四级标题 5: Markdown 五级标题 6: Markdown 六级标题 无序列表: ~ 删除线: - 功能类 规律：Control + 首字母 示例： C: Copy link(Obsidian block link, Arc browser link, Vscode git link) D: Download I: Add to inbox K: Quick Search","link":"/2023/06/18/%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%94%A8%E6%96%B0%E5%9E%8B%20Obsidian%20%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%9E%84%E5%BB%BA%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%84%91%20%F0%9F%A7%A0/"},{"title":"不要叫我程序猿,我是前端开发工程狮","text":"上学期期末开始了解到前端开发，当时忙于做实验、写论文、投文章，也就没深入了解，当时觉得挺好玩的，所以屁颠屁颠的去借了一本《HTML与CSS入门经典》，当时那个迷茫啊。一开始是借了《Java编程思想》和《Android 4.X从入门到精通》，想着复习下Java，然后动手写写安卓，然后毕业搞安卓开发，后来也没看下去。那本入门经典是很基础的那种，看起来轻轻松松地，兴趣也慢慢培养起来。 引言上学期期末开始了解到前端开发，当时忙于做实验、写论文、投文章，也就没深入了解，当时觉得挺好玩的，所以屁颠屁颠的去借了一本《HTML与CSS入门经典》，当时那个迷茫啊。一开始是借了《Java编程思想》和《Android 4.X从入门到精通》，想着复习下Java，然后动手写写安卓，然后毕业搞安卓开发，后来也没看下去。那本入门经典是很基础的那种，看起来轻轻松松地，兴趣也慢慢培养起来。之后隔了一个寒假回来，论文却被拒了。差不多也是那时开始决心好好学习前端，所以借了一些特别经典的前端书籍，例如：《CSS权威指南》、《精通CSS:高级Web标准解决方案》、《JavaScript编程精解》、《JavaScript权威指南》。 学习当时满腔热情的学着，一开始先看的《JavaScript编程精解》，看起来真是费劲，后来看犀牛书就通顺多了，本来有编程基础的程序猿，上手JavaScript是挺快的。然后配合网上的视频，动手做一些小例程，进步非常快，好在导师也没烦我，完全放羊状态，更能全心全意地学习。期间还写了一篇论文，跟之前被拒绝的一起再投出去了，好在这两篇都中了，毕业要求达到了，就更有底气学自己喜欢的东西。 2048网页版 面试&amp;笔试 一直想出去实习，俗话说：“纸上得来终觉浅”，之前从来没有找过工作，没什么经验。注册了智联招聘，隔三差五就有人打电话，不是了解情况就是让我去面试，可见前端需求还是相当大的。其中我去了两家，一家是GXG男装，想想也好玩，我竟然去了，我同学问我是不是去应聘模特？哈哈。面试官问我有做过什么项目没，我说没有，都是自己在看书；还各种给我灌输，打杂是应该的，而且几乎不问前端的知识点，真心觉得好坑。另一个公司我忘了叫什么，从事体检方面的公司，也是找人打杂，也不问我学到的知识点。 跟同学一起去杭州参加了蘑菇街的宣讲会，笔试被虐得很惨，都是基础的算法题，太久没接触，考完研都忘光了。在杭州呆了一晚，跟爹娘会合去乌镇玩了。回来报名参加了一个网上的在线面试，50RMB。一共有两个面试官跟我视频，简直一问三不知，打击真的太大了，之后针对他问的一些缺漏，有针对的研究了一阵子，进步跟打击一样大哈。 实验室的同学介绍了一个打算出来创业做旅游网站的程序员给我，说是需要前端工程师，联系之后才知道，项目还没启动呢。不过他给我布置了个小任务，实现一个网页版的微信，写了一周。又说要适配移动端，用响应式媒体查询语句，真是麻烦到死，适配移动端这种需求应该一开始就要考虑到，反正改得很难受。之后也没联系了，不过通过这次也学到了很多。 网页版微信 本人作为知乎脑残粉，在一个关于前端入门的回答里，偶然发现了百度推出的一个公益性质的前端学院。该项目托管在github上，第一次看到github，挺惊奇的，之前备份都是直接备份整个目录，然后才敢改代码。在百度的这个项目上，做了三个任务，学了很多细致入微的知识点，虽然最后一个“待办事项”的任务由于一开始没发现要本地存储的这个需求，就屁颠屁颠的写起来，后来这个需求也就不了了之了。 百度前端学院任务 短信收到挖财的在线笔试通知，这在线笔试还要求摄像头常开，这逼格也是够了。笔试做起来很顺利，开放题也是惊奇。笔试自我感觉挺好的，可就是一直等不到面试通知，某一天又在各大招聘网站闲逛，突然挖财就来电话通知面试了，真是“没有一点点防备，也没有一丝丝…”。订了隔天的票就奔向省城了，面试也挺顺利的，都是基础问题，期间换了一个面试官。这位面试官问了稍微深入的一些问题，末了，给了两个任务让我回去做，一个是实现截图实时显示，另一个任务则是给你一个psd，让你照着做，要求适配移动端的网页。 任务一、任务二也遇到了一些问题，不过后来都解决了，面试官挺满意的，说是确定要我。又问我有没有兴趣再做一题，“又是没有一点点防备”。我能说没兴趣么？当然，任务三也完成了。 任务一 任务二 任务三 实习打算端午过后去杭州实习，好喜欢杭州啊，也算是正式入了前端这个坑了，对这几个月认真学习有了个交代。","link":"/2015/06/14/%E4%B8%8D%E8%A6%81%E5%8F%AB%E6%88%91%E7%A8%8B%E5%BA%8F%E7%8C%BF-%E6%88%91%E6%98%AF%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E7%8B%AE/"},{"title":"为前端应用开发一个本地接口 mock 服务","text":"无法忍受没有 mock 服务的日子 背景本地开发时，目前通过直连测试环境和修改代码两种方式调试接口，前者十分依赖后端的数据状态和服务稳定，使得本地开发调试容易受外部影响；后者修改代码容易造成问题，如果涉及多处代码改动，还需要对这些分散的代码进行撤销改动，从而造成不必要的心智负担。因此，以上两种方式都不能良好地做到前后端分离开发。理想情况下，前端应在开发阶段使用 api mock 服务，当流程走通之后，再切到测试环境与后端联调。 有现成的工具吗？有的，目前公司现有 mock 平台 能支持这个需求，但是由于我们的应用使用的是 gateway 的方式调用后端方法，即所有接口都是访问同一个 api 地址，并通过区分 query 参数标识不同 dubbo 方法，因此该 mock 平台不能很好地支持这种场景，需要通过对同一 api 地址添加多种 http method 的接口，接着通过设置不同『期望』以达到根据不同 query 参数返回不同数据的效果。此外，目前项目没有编写 mock 接口配置的习惯，不可能对百来个接口进行一一配置调试，因此接入 mock 不能做到一蹴而就。 怎么办？针对以上情况，我觉得可以通过开发一个本地接口 Mock 服务如下方式解决： 在本地启动一个 mock 服务，当本地存在对应接口的 mock json 文件时，优先使用 mock 数据，否则调用测试环境。这样既保证了项目在开发调试阶段不受外部影响，做到完全地前后端分离开发（通过切换环境决定连接 mock 接口还是测试环境接口），又能够逐步实现上百个接口的 mock。 为什么使用本地 mock 服务，而不是在线 mock 服务？无论是前公司，还是现公司，都存在多个在线 mock 服务，有的是前端团队主导的，有的是测试团队主导的，这些服务要么仅有少数项目使用，要么几乎没人用。这些服务大多没有解决如下两个问题： 老项目如何快速接入？每个老项目涉及几十上百个接口，几乎不可能主动去接入这些平台。 接口直接如何避免相互影响？同一个工程，A 同学修改了 M 接口返回 N 以测试流程 X，而 B 同学需要修改 M 接口返回 P 用以测试流程 Y，这就造成了冲突（开发阶段应尽量避免外界的影响，开发一个功能实在不应该因为 mock 接口返回的修改或者测试环境的出错而阻塞） 而本地 mock 服务可以较好地通过缓存测试环境或线上环境的接口数据解决问题1；通过将接口数据缓存在本地解决问题2，也就是说 A 同学在本地的操作是不会影响到 B 同学的调试的。 不过，我认为本地 mock 和在线 mock 二者并不冲突，二者可以相互同步接口数据，这样既保证了在线维护接口的便利，又能隔离开发时，在线编辑接口返回值导致的相互影响。 还能怎么玩？对于这种缓存测试数据到本地的模式，我想到一个有趣的使用方式，当与后端联调时，通过特定参数启动本地开发服务，使得当前每个接口都强制同步测试环境数据；接着将联调的页面跳转路径点击一遍，便可将此次流程涉及的接口悉数缓存；重启本地开发服务，这样同一个操作流程皆使用了刚刚缓存的接口，做到『流程回放』，从而不需要依赖后端重复造数据，非常方便 B 端这种流程多，步骤长（这往往十分依赖状态，而状态在每个步骤之后往往会改变）的联调。","link":"/2019/07/21/%E4%B8%BA%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3%20mock%20%E6%9C%8D%E5%8A%A1/"},{"title":"从 line-height 到 0.5 px","text":"前几天发现写的一段代码，其中line-height（1.7rem）与height（1.7rem）相等，font-size（1.1rem）；在ios设备上文字垂直居中，而在android设备上竟上下缝隙相差1px（其实我看不出来是不是一像素，我猜的）。 问题前几天发现写的一段代码，其中line-height（1.7rem）与height（1.7rem）相等，font-size（1.1rem）；在ios设备上文字垂直居中，而在android设备上竟上下缝隙相差1px（其实我看不出来是不是一像素，我猜的）。 为什么我试了好久，我以为是字体的原因，毕竟ios用了自己设计的字体，虽然我的大魅族也是自己设计（白永祥：这并没有什么卵用）。后来我发现当我把字体设为1rem时，android上的字体看起来就居中了，而ios无论如何都是居中的，百思不得其解啊； 机智如我，获取了魅族MX5的设备宽度（360），所以根据我的页面计算出来的rem对应为18px，也就是说line-height实际高度为1.7rem=1.718px=30.6px，font-size实际大小为1.1rem=1.118px=19.8px； 而由于1px是最小单位，那么这个带小数点的单位到底是向上取整还是向下取整，亦或是四舍五入，我在我的MX5上设置了“林”这个字的如下字号：70、70.4、70.5、70.6、71px；接着屏幕截图，放到ps里量了下，高度分别是71、71、71、71、72；事实证明是向下取整的，不要问我为什么是71而不是70，因为我不告诉你。 那么，就有了一个很好的解释了：line-height - font-size = (30 - 19)px = 11px，11px上下没法均摊，结果上面5px，而下面的空隙就是6px，导致了整体向上偏移，然而这没法解释ios设备为什么就可以上下均摊。 再试试，字号改为1rem的情况：line-height - font-size = (30 - 18)px = 12px，上下各自为6px，因此能居中。 0.5px今天在搜寻如何在retina设备上实现1px，无意中发现ios8以上的版本，是支持0.5px的，也就是说ios8设备上的精度是0.5px，所以11px除以2，各自都是5.5px，难怪可以垂直居中。 ios8中的近似那么，70.4、70.5、70.6这些字号，在ios8这种精度为0.5px的设备上是如何近似的呢？答案就是：只要不是整数，通通设为70.5px，这能叫居中近似吗？哈哈~ 那么问题来了1px边框到底如何在非ios8的retina屏幕下实现呢？今天看到一篇博客里的一句话，我激动了： 要是没有最后一句话该多好啊~ 网上搜了好久，找到一个不错的方法： 伪类 + transform 原理是把原先元素的 border 去掉，然后利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border 绝对定位 单条 border: 12345678910111213141516.hairlines li{ position: relative; border:none;}.hairlines li:after{ content: ''; position: absolute; left: 0; background: #000; width: 100%; height: 1px; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0;} 四条 border: 1234567891011121314151617181920.hairlines li{ position: relative; margin-bottom: 20px; border:none;}.hairlines li:after{ content: ''; position: absolute; top: 0; left: 0; border: 1px solid #000; -webkit-box-sizing: border-box; box-sizing: border-box; width: 200%; height: 200%; -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: left top; transform-origin: left top;} 样式使用的时候，需要结合 JS 代码，判断是否 Retina 屏 123if(window.devicePixelRatio &amp;&amp; devicePixelRatio &gt;= 2){ document.querySelector('ul').className = 'hairlines';} 那么问题又来了有没有更好的方法啊？","link":"/2015/09/14/%E4%BB%8Eline-height%E5%88%B00-5px/"},{"title":"使用 Jest 测试 Node.js","text":"使用 Jest 测试你的 Node.js 应用 目的 增强代码的健壮性 及时发现未被覆盖的代码逻辑 项目交接或重构更加放心 工具1. 安装1npm install --save-dev jest supertest 2. 配置 package.json123456789101112131415161718192021222324&quot;scripts&quot;: { &quot;test&quot;: &quot;NODE_ENV=development jest&quot;, &quot;test-watch&quot;: &quot;npm test -- --watch&quot;,},&quot;jest&quot;: { &quot;verbose&quot;: true, &quot;notify&quot;: true, &quot;collectCoverage&quot;: true, &quot;testEnvironment&quot;: &quot;node&quot;, &quot;modulePaths&quot;: [ &quot;&lt;rootDir&gt;/server&quot; ], &quot;roots&quot;: [ &quot;&lt;rootDir&gt;/__tests__&quot; ], &quot;testPathIgnorePatterns&quot;: [ &quot;__tests__/(fixtures|__mocks__)/&quot; ], &quot;coverageReporters&quot;: [ &quot;html&quot;, &quot;text&quot;, &quot;text-summary&quot; ] } 3. 添加 gitignore 在 .gitignore 配置文件中增加忽略 coverage 目录 4. 运行12npm test # 全部测试npm run test-watch # 开启 watch 模式, 只运行修改的测试文件 5. jest 命令的实用参数 npm test -- fileName 文件名支持正则，比如 npm test -- server/*；支持部分匹配，比如 npm run test -- controllers/login npm test --bail [-- fileName] 当遇到失败的用例时，立马退出，方便查看报错信息 npm test --watch [-- fileName] 监听测试文件修改，仅重新执行所修改的测试用例 npm test --watchAll [-- fileName] 监听测试修改，重新执行所有测试用例 6. 目录结构约定 测试文件：__tests__ mock 模块：__mocks__ 辅助工具：__test__/fixtures 123456789__tests__├── fixtures├── __mocks__│ └── request.js└── server ├── controllers │ └── thread │ └── index.test.js └── server.test.js 测试维度 正向测试：这个函数是否按照其声明的那样实现了非常基本的功能？ 负向测试：代码是否可以处理非期待值？ 测试覆盖率源代码被测试的比例, 有四个测量维度 行覆盖率（line coverage）：是否每一行都执行了？ 函数覆盖率（function coverage）：是否每个函数都调用了？ 分支覆盖率（branch coverage）：是否每个if代码块都执行了？ 语句覆盖率（statement coverage）：是否每个语句都执行了？ 1234567891011-----------|----------|----------|----------|----------|----------------|File | % Stmts | % Branch | % Funcs | % Lines |Uncovered Lines |-----------|----------|----------|----------|----------|----------------|All files | 100 | 85.71 | 100 | 100 | | logger.js | 100 | 85.71 | 100 | 100 | |-----------|----------|----------|----------|----------|----------------|Test Suites: 1 passed, 1 totalTests: 9 passed, 9 totalSnapshots: 0 totalTime: 0.836s, estimated 1sRan all test suites. 附：单元测试准则 文档较长，建议饭后查看 测哪些东西 server - 启动是否正常 middlewares - 加载正常，请求时正常工作 controllers - 请求特定路由，看响应是否是符合预期 services - 调用特定方法，返回结果符合预期，边界情况 routes、lib - 普通测试 测试用例撰写一个普通且完备的单测文件 1234567891011121314151617181920212223242526272829303132333435363738394041describe('api 映射模块', () =&gt; { // 在所有单测运行前执行，用于准备当前 describe 模块所需要的环境准备，比如全局的数据库； beforeAll(() =&gt; { }) // 在每个单测运行前执行，用于准备每个用例（it）所需要的操作，比如重置 server app 操作 beforeEach(() =&gt; { }) // 在每个单测运行后执行，用于清理每个用例（it）的相关变量，比如重置所有模块的缓存 afterEach(() =&gt; { jest.resetModules() }) // 在所有单测运行后执行，用于清理环境，比如清理一些为了单测而生成的“环境准备” afterAll(() =&gt; { }) // 注：以上四个方法均支持返回一个 Promise，此时 Jest 将等待该 Promise resolve 后继续 it('当 env 为默认的 development 环境时，返回 localhost 地址', async() =&gt; { process.env.NODE_ENV = '' const API = require('lib/api') expect(API).toThrow() // 期望 API 抛错 expect(API('')).toMatch(/localhost/) // 期望返回包含 'localhost' 字段 }) it.only('当 env 为测试环境时，返回测试环境地址', async() =&gt; { // 仅执行本测试用例，常用于调试当前用例 process.env.NODE_ENV = 'test' const API = require('lib/api') expect(API('get_items')).toMatch(/test.baidu.info/) })}) ​ 附：expect 常用语句，更多请查看官方 expect 文档 12345678910111213.toBe(value) // 期望值为 value.toEqual(value) // 期望两个对象内容完全相等.toBeDefined() // 期望被定义.toBeFalsy() // 期望为 Falsy.toBeTruthy() // 期望 Truthy.toMatch() // 期望符合，支持字符串和正则对象.toThrow() // 期望抛错.toHaveBeenCalled() // 方法被调用.toHaveBeenCalledWith(arg1, arg2, ...) // 方法被以参数 arg1, arg2, ... 调用.toHaveBeenCalledTimes(number) // 方法被调用次数为 number 次// 以上 expect 语句均可取非，形式如下：not.toBe() mock 示例jest 中 mock 主要有两种作用：屏蔽外部影响：123456789101112131415161718192021222324// number-add.js...const debug = require('debug')module.exports = (a, b) =&gt; { debug('value a: ', a) debug('value b: ', b) return a + b}...// number-add.test.js// mock debug 模块，使得每次 require 该模块时，返回自动生成的 mock 实例jest.mock('debug')...it('返回 a 和 b 的和', () =&gt; { const add = require('utils/number-add') const total = add(1, 2) expect(total).toBe(3)})... 模拟外部调用：123456789101112131415161718192021222324252627// string-add-async.jsconst fetch = require('node-fetch')module.exports = async (apiA, apiB) =&gt; { const stringA = await fetch(apiA) const stringB = await fetch(apiB) return stringA + stringB}// string-add-async.test.jsdescribe('测试 string-add-async 模块', () =&gt; { it('返回接口 a 和 接口 b 所返回的字符串拼接', async () =&gt; { // mock node-fetch 模块 jest.mock('node-fetch', () =&gt; { return jest .fn() .mockImplementationOnce(async () =&gt; 'Hello ') // 首次调用时返回 'Hello ' .mockImplementationOnce(async () =&gt; 'world!') // 第二次调用时返回 ' world!' }) const addAsync = require('utils/string-add-async') const string = await addAsync('apiA', 'apiB') expect(string).toBe('Hello world!') })}) 如何正确的 mock 一个模块 此处以 string-add-async 模块为例 12345678910111213141516171819202122232425262728293031323334353637383940414243// 方式一describe('测试 string-add-async 模块', () =&gt; { it('返回接口 a 和 接口 b 所返回的字符串拼接', async () =&gt; { // mock node-fetch 模块 jest.mock('node-fetch', () =&gt; { return jest .fn() .mockImplementationOnce(async () =&gt; 'Hello ') // 首次调用时返回 'Hello ' .mockImplementationOnce(async () =&gt; 'world!') // 第二次调用时返回 ' world!' }) const addAsync = require('utils/string-add-async') const string = await addAsync('apiA', 'apiB') expect(string).toBe('Hello world!') })})// 方式二describe('测试 string-add-async 模块 2', () =&gt; { it('返回接口 a 和 接口 b 所返回的字符串拼接', async () =&gt; { // mock node-fetch 模块，使得每次 require 该模块时，返回 mock 实例 jest.mock('node-fetch') const fetch = require('node-fetch') fetch .mockImplementationOnce(async () =&gt; 'Hello ') // 首次调用时返回 'Hello ' .mockImplementationOnce(async () =&gt; 'world!') // 第二次调用时返回 ' world!' const addAsync = require('utils/string-add-async') const string = await addAsync('apiA', 'apiB') expect(string).toBe('Hello world!') })})// 方式三// __tests__/__mocks__/node-fetch.jsmodule.exports = async apiUrl =&gt; { return apiUrl} 注：强烈不建议使用方式三，因为该方式影响范围比较大，不过适合 屏蔽外部影响 的情况 mock 实例 当一个模块被 mock 之后，便返回了一个 mock 实例，该实例上有丰富的方法可以用来进一步 mock；且还给出了丰富的属性用以断言 mockImplementation(fn) 其中 fn 就是所 mock 模块的实现 mockImplementationOnce(fn) 与 1 类似，但是仅生效一次，可链式调用，使得每次 mock 的返回都不一样 mockReturnValue(value) 直接定义一个 mock 模块的返回值 mockReturnValueOnce(value) 直接定义一个 mock 模块的返回值（一次性） mock.calls 调用属性，比如一个 mock 函数 fun 被调用两次：fun(arg1, arg2); fun(arg3, arg4);，则 mock.calls 值为 [['arg1', 'arg2'], ['arg3', 'arg4']] 附：更多 mock 实例属性与方法详见官方文档 测试示例完整代码暂不提供工具模块的测试方法参看本文档 mock 示例 部分服务启动的测试方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const supertest = require('supertest')describe('server 服务', () =&gt; { let app, server beforeEach(async () =&gt; { app = await require('server') // 禁用 koa-logger 日志输出 app.log.level('fatal') }) afterEach(() =&gt; { if (server) { server.close() } app = null server = null }) const request = () =&gt; { if (!server) { server = app.listen(0) } return supertest(server) } it('启动正常', async () =&gt; { expect(request).not.toThrow() }) it('app 抛出异常处理', async () =&gt; { app.use(async ctx =&gt; { app.emit('error', new Error('app error'), ctx) ctx.body = 'ok' }) await request() .get('/throw-error') .expect(200) .then(res =&gt; { expect(res.text).toBe('ok') }) })}) 中间件测试的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const supertest = require('supertest')describe('错误中间件', () =&gt; { let app, server beforeEach(async () =&gt; { app = await require('server') // 可以试试取消注释这一句，可以发现由于没有重置模块缓存，导致测试用例 3 使用了用例 2 中的 server 实例 jest.resetModules() }) afterEach(() =&gt; { if (server) { server.close() } app = null server = null }) const request = () =&gt; { if (!server) { server = app.listen(0) } return supertest(server) } it('抛出异常-中间件出错（自定义错误）', async () =&gt; { app.use(async (ctx, next) =&gt; { await Promise.reject(new Error('中间件出错')) await next() }) await request() .get('/throw-error') .expect(200) .then(res =&gt; { expect(res.body.error).toBe('中间件出错') }) }) it('app 抛出异常-系统异常，请稍后再试（默认错误）', async () =&gt; { app.use(async (ctx, next) =&gt; { await Promise.reject(new Error('')) await next() }) await request() .get('/throw-error') .expect(200) .then(res =&gt; { expect(res.body.error).toBe('系统异常，请稍后再试') }) })}) 接口测试的方法// add-api.js 1234567891011121314151617181920const AddService = require('./add-service')module.exports = async router =&gt; { router.get('/add', async ctx =&gt; { const { a, b } = ctx.query const numberA = Number(a) const numberB = Number(b) if (Number.isNaN(numberA) || Number.isNaN(numberB)) { throw new Error('参数必须为数字！') } const projectService = new AddService(ctx) const ret = await projectService.add(numberA, numberB) // 处理请求成功后的数据 ctx.body = `接口计算结果：${ret}` })} // add.test.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566jest.mock('./add-service')const Service = require('./add-service')const addApi = require('add-api')const Router = class { constructor (ctx) { return new Proxy({}, { get (target, name) { return async (path, callback) =&gt; { callback(ctx) } } }) }}describe('测试 add 接口', () =&gt; { it(`当 a=1 且 b=2，返回 '接口计算结果：1 + 2 = 3'`, async () =&gt; { const mockedAdd = jest.fn(async () =&gt; '1 + 2 = 3') const ctx = { query: { a: '1', b: '2' } } Service.mockImplementation(() =&gt; { return { add: mockedAdd } }) const router = new Router(ctx) await addApi(router) expect(mockedAdd).toBeCalledWith(1, 2) // or expect(mockedAdd.mock.calls).toEqual([[1, 2]]) expect(ctx.body).toBe('接口计算结果：1 + 2 = 3') }) it(`当 a=1 且 b=xxx，接口报错`, async () =&gt; { const mockedAdd = jest.fn(async () =&gt; '1 + 2 = 3') const ctx = { query: { a: '1', b: 'xxx' } } Service.mockImplementation(() =&gt; { return { add: mockedAdd } }) const router = new Router(ctx) try { await addApi(router) } catch (error) { expect(error).toBeEqual(new Error('参数必须为数字！')) } expect(mockedAdd).not.toBeCalled() })}) 服务层的测试方法// project-service.js 12345678910const add = require('utils/number-add')module.exports = class { add (a, b) { const ret = add(a, b) return `${a} + ${b} = ${ret}` }} // project-service.test.js 12345678910111213141516describe('测试 project service', function() { it('测试 service 的 add 方法', async () =&gt; { jest.mock('utils/number-add') const add = require('utils/number-add') const Service = require('project-service') const service = new Service() add.mockImplementation(() =&gt; 100) const ret = await service.add(1, 2) expect(ret).toBe('1 + 2 = 100') })}) FAQconsole.log 有时无效 试试 console.warn mock 没起作用 mock 模块是否在多个测试用例中相互影响了； mock 操作是否在 require 之后； 是否需要在 beforeEach 中执行 jest.resetModules() 或 jest.resetAllMocks()； 是否需要单独执行 mock 的实例方法mockReset； 参考 Jest - Getting Started","link":"/2018/02/22/%E4%BD%BF%E7%94%A8%20Jest%20%E6%B5%8B%E8%AF%95%20Node.js/"},{"title":"使用 Linux 系统开发Web前端","text":"为什么使用 Linux? Mac纵有千千万万的好，作为学生党来说，毕竟其较高的价格让的确让许多我”党“人士望而却步，去年刚进公司实习的时候，使用的是Win7，对于Windows下的命令行体验真是无力吐槽，特别是对于Web前端来说，非常多的工具都运行在终端内，比如不计其数的Node.js工具，后来改用Linux就舒畅多了。 为什么使用 LinuxMac纵有千千万万的好，作为学生党来说，毕竟其较高的价格让的确让许多我”党“人士望而却步，去年刚进公司实习的时候，使用的是Win7，对于Windows下的命令行体验真是无力吐槽，特别是对于Web前端来说，非常多的工具都运行在终端内，比如不计其数的Node.js工具，后来改用Linux就舒畅多了。 发行版本选择发行版本个人还是推荐主流之一的Ubuntu，建议使用Gnome Flavor版本，简洁优雅的Gnome3桌面，使用起来相当顺手，Ubuntu自带的Unity界面丑到我想哭。也可使用Fedora，它默认就是Gnome3，二者主要是包管理器不一样，前者使用apt-get，后者使用yum。 系统安装建议使用U盘刻录安装，推荐刻录软件UNetbootin，将下载好的ISO文件通过UNetbootin烧进U盘，安装前记得空出一块磁盘，系统本身占用很小，10G虽然够，还是建议20G吧。安装过程不细说了，网上教程一大堆，建议第一次安装还是对着教程来吧，记得备份重要文件。这是我安装后的桌面： 开发软件前端开发所需的软件大都有对应的Linux版本，比如Sublime、Atom、Charles、WebStorm、Chrome，大家可自行Google下载。 安装Git：sudo apt-get install git 配置github(如果你使用的话，否则可略过)： 配置git用户名和邮箱 git config user.name &quot;用户名&quot; git config user.email &quot;邮箱&quot; 在config后加参数 –global 可设置全局用户名和邮箱。 生成ssh key ssh-keygen -t rsa -C &quot;邮箱&quot; 然后根据提示连续回车即可在~/.ssh目录下得到id_rsa和id_rsa.pub两个文件，id_rsa.pub文件里存放的就是公钥。 上传公钥到github 复制公钥内容，接着登录github，进入Settings，选择 SSH and GPG keys，点击 New SSH key。 测试是否配置成功 ssh -T git@github.com 如果配置成功，则会显示： Hi username! You’ve successfully authenticated, but GitHub does not provide shell access. 安装Node.js：方法零：使用apt安装 sudo apt-get install nodejs npm ln -s nodejs /usr/bin sudo apt-get install openjdk-9-jdk sudo npm i -g wnpm sudo wnpm i -g wac-cli 方法一：使用包管理器安装（推荐新手使用）安装 5.x 版本： sudo apt-get install curl curl -sL https://deb.nodesource.com/setup_5.x | sudo -E bash - sudo apt-get install nodejs 方法二：使用 NVM 安装并管理 node，建议有一定 Linux 命令行和 Node.js 经验的人使用： https://github.com/creationix/nvm 方法三：也可采用编译源码的方式安装，打开终端，其步骤如下。 安装 build-essential，即软件编译工具集，用于从源代码编译和安装软件。 sudo apt-get update sudo apt-get install build-essential 克隆分支并进入node目录： git clone https://github.com/nodejs/node.git &amp;&amp; cd node 切换到一个你需要的稳定分支： git checkout v4.0.0-rc 编译并安装： ./configure make sudo make install 查看node安装位置并添加软连接： whereis node sudo ln -s /usr/local/bin/node /usr/bin/node sudo ln -s /usr/local/bin/npm /usr/bin/npm 查看node版本 node -v PlayOnLinux &amp;&amp; PhotoShop令人头疼的PhotoShop，Adobe没有对应的Linux版本，此处使用Wine方案，推荐安装PlayOnLinux，你只要有exe文件就好了，Wine的环境配置不需要你操心，PlayOnLinux帮你搞定。安装PlayOnLinux只需输入一条命令搞定： sudo apt-get install playonlinux 装好后，打开PlayOnLinux，如何安装请看下图： 再往后就是下一步、下一步、下一步、完成。 wine软件可能出现中文乱码，可参看彻底消除wine中文乱码 Zsh终端： 首先安装zsh： sudo apt-get install zsh 切换shell： chsh -s which zsh 重启系统即可生效 安装主题，本人推荐主题bullet-train-oh-my-zsh-theme 其它软件越过长城 搜狗输入法 WPS QQ easystroke鼠标手势： sudo apt-get install easystroke audacious听歌： sudo apt-get install audacious","link":"/2016/04/17/%E4%BD%BF%E7%94%A8%20Linux%20%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91Web%E5%89%8D%E7%AB%AF/"},{"title":"使用 Node.js 将珍藏的 bash 脚本封装成命令行工具","text":"阐述如何将一个常用的 bash 脚本融入 npm 生态之中，此处以最近遇到的一个 CR 提交脚本为例。 背景作为程序猿，大家或多或少地都用过 GitHub 上的 merge request 功能。当然，除了这类 Code Review 方式，不少公司都有自己的 Code Review 平台，我司也不例外，我们使用了类似 Gerrit 的工具，此处我们暂且以 Gerrit 指代。由于最近在治理工程时，需要全面切（要）到（求）使用 Gerrit 进行 CR 提交。发现 Gerrit 提交命令不是那么好记，经常需要先 git push，接着被拦截报错之后，再根据提示复制命令行，再次执行方可成功提交 Gerrit 。作为攻城狮，这有点难以忍受了！！！ 诉求一、有没有单独的命令让我直接提交 Gerrit？二、有没有命令行工具，我直接安装就能使用？三、在 git push 后，经由 git hook 拦截后按需提交 Gerrit？解决一、有没有单独的命令让我直接提交 Gerrit？ 答：有的，有次同事见我提交 Gerrit 不顺畅，转发了一个 bash 脚本给我：你把它复制到 /usr/local/bin 目录下，就能直接使用 gerrit 执行了，珍藏脚本如下（gerrit）： 12branch=$(git symbolic-ref --short -q HEAD)git push origin HEAD:refs/for/${branch} 二、有没有命令行工具，我直接安装就能使用？ 答：有的，既然都有脚本了，作为前端开发，必须用心爱的 Node.js 封装一个命令行工具，只需两步即可使用：首先执行 npm i @dd/gerrit-cli -g ；接着在工程目录下执行 gerrit 即可使用。 三、在 git push 后，经由 git hook 拦截后按需提交 Gerrit？ 答：有的，如果你还觉得全局安装命令行太麻烦，或者害怕新人来了一脸懵逼。那么，还可以借助 git hook 进行拦截，用户只需要『无脑地』执行 git push 即可。当然前端这块有现成的 git hook 神器，它就是人见人爱的哈士奇，至于其它语言生态，大家找找应该有的。 我们来看看如何封装上述脚本吧！ 实现方式1.配置命令如何能让别人安装你的 npm 包时，就能在终端中执行命令行呢？只需对你的 npm 包的 package.json 添加 bin 字段： 123456789{ &quot;name&quot;: &quot;your-first-cli-package&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;你的第一个命令行工具&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;bin&quot;: { &quot;yourCommand&quot;: &quot;index.js&quot; },} 之后别人使用 npm i -g your-first-cli-package 时，即可在终端中执行 yourCommand 调用你的 index.js 的逻辑啦。如果使用局部安装的方式，即 npm i your-first-cli-package，命令行将被安装到 node_modules/.bin/yourCommand 下，其内容正是 index.js 的内容。此时可编辑 npm scripts 调用。 2.调用声明由于我们使用 Node.js 实现，因此命令行对应的入口 js 文件（此处即 index.js）需要声明当前文件使用 node 执行： 12#!/usr/bin/env node// 此处编写 yourCommand 命令的逻辑 3.编写逻辑此处实现得比较粗糙，目前就一个命令，因此未引入 args 这类包。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/usr/bin/env nodeconst execa = require('execa')const chalk = require('chalk')const run = async () =&gt; { let branch = '' let result = '' try { console.log(chalk.gray(`获取当前分支...`)) const { stdout } = await execa.command('git symbolic-ref --short -q HEAD') branch = stdout console.log(chalk.gray(`当前分支为: ${branch}`)) } catch (error) { console.log(chalk.red(`获取分支失败：${error.message}`)) process.exit(1) // 以失败码退出，用于 git hooks 拦截识别 } try { console.log(chalk.gray(`检查当前分支是否推送过远程仓库...`)) await execa.command(`git rev-parse --abbrev-ref ${branch}@{upstream}`) console.log(chalk.gray(`当前分支存在于 ${branch} 远程仓库...`)) } catch (error) { console.log( chalk.yellow(`当前分支 ${branch} 未推送远程仓库 ${error.message}`), ) try { console.log(chalk.green(`尝试推送分支 ${branch} 至远程仓库`)) const { stderr } = await execa.command( `git push --set-upstream origin ${branch} --no-verify`, ) result = stderr } catch (error) { console.log(chalk.red(`提交 gerrit 失败：${error.message}`)) process.exit(1) } } try { console.log(chalk.gray(`对分支 ${branch} 提交 gerrit ...`)) const { stderr } = await execa.command( `git push origin HEAD:refs/for/${branch} --no-verify`, ) result = stderr } catch (error) { console.log(chalk.red(`提交 gerrit 失败：${error.message}`)) process.exit(1) } console.log(chalk.green(`${branch} 提交 gerrit 成功，信息如下：\\n${result}`)) process.exit(0) // 以成功码退出，用于 git hooks 通过识别}run() 使用方式全局使用（非前端工程推荐使用）安装npm i @dd/gerrit-cli -g 执行 确保在 git 工程目录下 gerrit 示例 JavaScript 工程局部使用（前端工程推荐使用）安装npm i @dd/gerrit-cli --save-dev 在 package.json 中新增 gerrit scripts12345&quot;scripts&quot;: { ... &quot;cr&quot;: &quot;gerrit&quot; ... }, 执行 确保在 git 工程目录下 npm run cr 示例 和 husky 配合使用在 package.json 中新增 gerrit scripts12345678910&quot;scripts&quot;: { ... &quot;cr&quot;: &quot;gerrit&quot; ...},&quot;husky&quot;: { &quot;hooks&quot;: { &quot;pre-push&quot;: &quot;npm run cr&quot; }}, 执行 确保在 git 工程目录下 git push 示例 TODO 新增子命令支持生成 gerrit 的配置文件 打印对应的 CR 规范的文档链接，否则新人会懵逼 封装成 SDK 供其它工具调用 总结我们多多少少会遇到类似的场景，以工程化的视角去封装它，让原本 npm 生态之外的 bash 脚本也能融于无形！","link":"/2020/10/02/%E4%BD%BF%E7%94%A8%20Node.js%20%E5%B0%86%E7%8F%8D%E8%97%8F%E7%9A%84%20bash%20%E8%84%9A%E6%9C%AC%E5%B0%81%E8%A3%85%E6%88%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"title":"函数式编程中的柯里化到底有什么用？","text":"函数式编程最近越来越活跃，去年实习的时候买了一本 《JavaScript 函数式编程》，囫囵吞枣的看了一遍，似懂非懂的， 今年重新看了一遍，现写下这篇博客，谈谈我对柯里化的理解吧。 柯里化柯里化函数为每一个逻辑参数返回一个新函数。(《JavaScript 函数式编程》) 简单说，函数柯里化就是对高阶函数的降阶处理。举个例子，就是把原本：function(arg1,arg2)变成function(arg1)(arg2)function(arg1,arg2,arg3)变成function(arg1)(arg2)(arg3)function(arg1,arg2,arg3,arg4)变成function(arg1)(arg2)(arg3)(arg4)……function(arg1,arg2,…,argn)变成function(arg1)(arg2)…(argn) 作者：小蝶惊鸿链接：https://www.zhihu.com/question/40374792/answer/86268208来源：知乎著作权归作者所有，转载请联系作者获得授权。 举个例子一个参数 强制只接收一个参数 123456789101112131415161718// 接收一个参数自动柯里化function curry (fun) { return function (arg) { return fun(arg); }}// es6 装逼版function curry (fun) { return arg =&gt; fun(arg);}[1, 2, 3, 4, 5].map(parseInt)//[1, NaN, NaN, NaN, NaN][1, 2, 3, 4, 5].map(curry(parseInt))//[1, 2, 3, 4, 5] 两个参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 普通二参数的加法function normalAdd(x, y) { return x + y;}// 柯里化版本function add(y) { return function(x) { return x + y; }}let add2 = add(2);add2(3);// 5// 普通二参数乘法function normalMultiply(x, y) { return x * y;}// 柯里化版本function multiply(y) { return function(x) { return x * y; }}let multiply2 = multiply(2);multiply2(3);// 6// 自动柯里化function curry2 (fun) { return function (arg2) { return function (arg1) { return fun(arg1, arg2); } }}// es6 装逼版function curry2 (fun) { return arg2 =&gt; arg1 =&gt; fun(arg1, arg2);}let curryAdd = curry2(normalAdd);let curryAdd2 = curryAdd(2);let curryMultiply = curry2(normalMultiply);let curryMultiply2 = curryMultiply(2);curryAdd2(3);// 5curryMultiply2(3);// 6 三个参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 普通版本function normalAddThenMultiply(arr, factor, increase) { let tempArr = arr.map(function(ele, index) { return normalAdd(ele, increase); }); return tempArr.map(function(ele, index) { return normalMultiply(ele, factor); });}normalAddThenMultiply([1, 2, 3], 3, 2);// [9, 12, 15]// 柯里化版本function addThenMultiply(increase){ return function(factor) { return function(arr) { let addStep = curry2(normalAdd); let multiplyFactor = curry2(normalMultiply); let tempArr = arr.map(addStep(increase)); return tempArr.map(multiplyFactor(factor)); } } }let add2Multiply = addThenMultiply(2);let add2Multiply3 = add2Multiply(3);add2Multiply3([1, 2, 3]);// [9, 12, 15]// 自动柯里化function curry3 (fun) { return function (last) { return function (middle) { return function (first) { return fun(first, middle, last); } } }}// es6 装逼版function curry3(fun) { return last =&gt; middle =&gt; first =&gt; fun(first, middle, last);}let curryAddMultiply = curry3(normalAddThenMultiply);let curryAdd2Multiply = curryAddMultiply(2);let curryAdd2Multiply3 = curryAdd2Multiply(3);curryAdd2Multiply3([1, 2, 3]);// [9, 12, 15] 柯里化到底有什么用 每个步骤都是显性调用（消耗一个参数），同时将该步骤的结果缓存（返回匿名闭包，该闭包等待下一个参数），从而暂缓调用，待时机成熟时便可传入下一个参数以便继续调用； 两个参数情况下的应用12345678910111213141516171819202122232425262728293031323334353637383940414243444546 // 用于定义一系列 action actionList = [{ &quot;action&quot;: &quot;isLogin&quot;, &quot;hasCallback&quot;: true }, { &quot;action&quot;: &quot;doLogin&quot;, &quot;hasCallback&quot;: false }, { &quot;action&quot;: &quot;setTitle&quot;, &quot;hasCallback&quot;: true }]; // 批量生成 API 的工厂函数 factory(actionList) { for (let value of actionList) { this[`${value.action}`] = this.generator(value); } } // 简化版本的 API 生成函数 generator(action) { return function(params) { let MyPromise = es6Promise.Promise; action['params'] = params; return new MyPromise((resolve, reject) =&gt; { let callbackId = this.generateId(); this.responseCallbackList[callbackId] = (data) =&gt; { resolve(data); } this.sendAction(action, callbackId); }); } }// 最终的调用方式， 其中 params 是用户调用时才传入的 bridge.setTitle({skin: 'red', color: '#666'}) .then((data) =&gt; { alert(data); }) .catch((err) =&gt; { alert(err); }); 三个参数情况下的应用12345// redux-thunk 中间件export default function thunkMiddleware({ dispatch, getState }) { return next =&gt; action =&gt; typeof action === 'function' ? action(dispatch, getState) : next(action);} 该中间件期待一个第一个参数 { dispatch, getState }, 并返回一个期待一个 next 参数的匿名函数， 由于 next 的值由上一个中间件决定， 因此暂缓调用， 直至传入 next 参数， 最终返回一个新的函数（即加入中间件的 dispatch 函数）， 该函数期待一个 action 参数。 具体调用过程及原理详见：理解 redux 中间件 参考：专属前端坑的函数式编程深入到源码：解读 redux 的设计思路与用法理解 redux 中间件","link":"/2016/10/06/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F/"},{"title":"函数式编程之 Functor","text":"万万没想到，Promise 也属于函数式编程？","link":"/2018/02/05/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%20Functor/"},{"title":"前端 Monorepo 在字节跳动的实践","text":"受邀参加第十一届 Top100 峰会，更多详情见文章年底了，看看这100位技术创新带头人如何做复盘？ 分享会背景受邀参加第十一届 Top100 峰会，更多详情见文章年底了，看看这100位技术创新带头人如何做复盘？ 本主题简介 PPT 正文 大家早上好，我是林宜丙，今天我带来的分享主题是《前端 Monorepo 在字节跳动的实践》 简单介绍下我自己，我来自字节跳动的 Web Infra 部门，拥有多年前端工程化的经验，主要帮助前端工程师更好地管理和治理工程 目前负责前端 Monorepo 解决方案的设计及其落地工作，有丰富的 Monorepo 实践和治理经验 今天的分享分为以下五个部分 首先分析『现代前端工程开发』的趋势，并引出字节跳动，前端工程开发面临的痛点 其次简单介绍下 Monorepo，以及它为什么能解决我们面临的痛点 接着针对我们在落地过程中遇到的问题及其实践 再接着分享下自研的方案在字节跳动的落地情况 最后总结当前方案的问题和针对这些问题的展望 OK，我们先来看看现代前端工程开发的几个趋势 首先是前端工种的趋势 第一个趋势是涉及的平台越来越多，Web，Node，客户端和跨平台等 第二个趋势是所能支撑的业务越来越多，复杂度越来越大，特别是近年来前端侧涌现出不少重前端交互的应用，比如搭建类的 figma，文档类的飞书等 第三个趋势是随着上述两个趋势而来地、不可避免地使得前端团队的规模不断增大 上述三个趋势又客观上造成了前端工程的四个趋势，即： 代码规模增大，内部已经出现代码量超过 10G 的大型工程 维护人数增多，一个工程少则十来人，多则四五十人 研发工具增加，不断出现的新工具在一个工程上堆叠，构建方面比如 webpack，rollup，vite 等，测试方面比如 jest，vitest 等 依赖关系复杂，各类项目安装依赖后的 lock 文件大小，足以说明一个工程的复杂依赖关系 那么，在上述这些个趋势下，我们的前端工程开发面临了哪些痛点呢？主要有三个： 其一，项目基建重复，每次新增项目都需要重复配置 Git，构建平台，CI/CD 配置等 其二，代码复用困难，跨项目的代码复用和调试极其繁琐，往往通过发布 npm 包来复用，而这种复用方式又不可避免地遇到更新触达率的问题 其三，工作流程割裂，一个功能往往涉及到多个模块，这时需要分别在各个模块的工程上开发、合码、上线和验证，这是繁琐和割裂的 面对上述痛点，我们该如何更好地组织工程，以提高工程的『可维护性』和『开发效率』？我们给出的答案是 Monorepo！ 接下来我们来简单介绍下 Monorepo 首先我们来看看，什么是 Monorepo 呢？Monorepo 是一种源代码管理的模式，其形式就是将多个项目集中到一个仓库中管理； 与 Monorepo 相对的是 Polyrepo 模式，这种模式各个项目都有独立的仓库。 这里需要注意，Monorepo 的子项目不仅仅是简单地放到一个仓库中维护而已，处理子项目间的关系也十分重要。 子项目也可以是任意的类型，可以是 web 项目，也可以是 node 项目和 Lib 库。 总而言之，Monorepo 就是将多个不同的项目以良好的组织关系放到单个仓库中维护。 在前端领域，大家可能对 Lib 型的 Monorepo 更加熟悉，知名的开源项目比如 React、Vue、Babel 等都采用 Monorepo 方式管理源码，大家看左边这个图，通过将整个系统拆分成多个 package，便于抽象和复用，并且这些 package 往往不需要走线上部署流程，只需要发布到 npm registry 即可。我相信大家在公司中接触和使用到的大部分 Monorepo 项目就是这个类型，但是这类项目往往在商业公司中并不是主流。 除了 Lib 型以外，我们看右边这张图，多个 App 也是可以放到一个仓库中维护的，这就是 App 型的 Monorepo，它包含多个 App 项目，以及项目共享的组件、工具函数等等，App 类型的项目需要走完整的部署流程，App 及其依赖的 Lib 一般不需要发布到 npm registry，这类项目呢，才是商业公司的主流。 在字节跳动，大部分的项目都是 App 应用，我们侧重在这个类型上建设自研的 Monorepo 方案，它的覆盖的人群和覆盖的应用是最多的，因此它的收益也是巨大的；当然支持了 App 型的 Monorepo，自然也就支持了 Lib 型的 Monorepo。 那为什么要采用 Monorepo 呢？接下来我们看看使用 Monorepo 的收益都有哪些？它是如何解决我们遇到的痛点的？ 首先，Monorepo 可以降低多项目的维护成本，从而解决项目基建重复的痛点。 Polyrepo 下，每个项目都需要有同学创建和维护，当创建更多项目的时候，需要更多同学，或者更多精力去创建和维护。 而在 Monorepo 中，只需要少数几个同学负责设立起 Monorepo，所有的项目以及将来的项目都能够在一个仓库中统一维护，从而降低多项目维护成本； 此外，Polyrepo 下，多个项目的基建有很多重复，当团队有多个项目的时候，需要频繁创建 git 仓库，配置 CI、Lint 规则、构建等等，而且为每个项目创建的基建后续都需要有人来维护。 同时将一个项目的调整，同步到其他项目的成本也很高，比如想在 CI 流程中为所有项目加入类型检查，来提高下 ts 项目的质量，那么需要修改每个项目，提交代码，跑 CI，这样成本其实是很高的。而在 Monorepo，只需要创建一套基建，所有子项目，以及未来的子项目都能够接入现有的基建。这些基建的调整和维护，也能够很容易地应用到多个项目。 在 Polyrepo 中，如果要开发多个项目的话，还可能需要来回切换开发环境、切换仓库，link 代码，而在 Monorepo 中可以一键启动多个子项目的调试、构建，从而提高研发效率。 其次，在 Monorepo 下可以很方便的共享代码，从而解决代码复用困难的痛点。 Polyrepo 中，复用公用代码比较困难，需要为公用代码单独维护一个仓库，此外升级、调试流程也十分繁琐低效。 首先是调试很繁琐，公用模块的调试需要手动执行 link，与当前调试的项目关联起来，如果公用模块较多的话，link 步骤将非常繁琐低效。 其次公用模块的升级很繁琐，需要手动管理这种依赖关系，先升级底层的模块，然后发布，最后再升级顶层模块，如果升级完之后发现有问题，这些步骤还得重来一次。此外，推动上层模块更新也不能及时触达。 而在 Monorepo 中，可以直接一键创建公用模块，顶层的模块一键引入公用模块进行开发、调试，底层模块的更改能够直接被上层感知，甚至不需要经过 link 和 npm 发布，即可在本地调试或者部署平台发布，降低了很多重复的工作。 因此，在 Polyrepo 中复用代码比较困难，导致代码复用率比较低，而 Monorepo 中能够很方便的复用代码，抽离新的工具库的成本非常低，这使得大家更愿意做这类抽离工作，提高了代码复用率。 再次，在 Monorepo 里能够实现自动化的多项目工作流，从而解决工作流程割裂的痛点。 如果我的业务需求要涉及到多个项目，在 Polyrepo 模式中，我需要修改多个项目，对多个项目各自提交 commit，每个项目单独跑 CI 流程，如果项目间有依赖关系的话，还需要手动升级项目的依赖版本。例如需要修改图中的三个项目，需要先修改提交底层模块，跑每个模块的 CI 流程，在处理顶层模块时，还得更新底层依赖，接着再跑一次 CI 流程，这一套流程非常繁琐且不连续。 而在 Monorpeo 中，我们可以直接修改多个子项目，只需一次 commit 提交，多个子项目的 CI 和发布流程也是一次性的。从而将整个多项目的工作流自动化，连续化。 我们简单的做一个总结：在 Polyrepo 的模式下，每一个项目都有自己的地址、仓库，这会导致共享代码很困难，基建比较重复，同时工作流也比较割裂。 但是在 Monorepo 里面，我们可以将多个项目的工作流进行规范统一。比如说统一的 CI 流程、 code review 等等。同时，它的代码共享也比较方便，我们可以直接将多个项目共享的组件或者工具函数，抽离出来，便可以在多个项目间复用，当然，多个项目的基建也可以复用。 很多时候一个团队、或者一块业务，他们的项目之间并不是完全割裂的，而是相互联系的，Monorepo 可以很方便的将这些项目组织到一起，进行维护。当团队有多项目需求的时候，推荐使用 Monorepo。 当然，Monorepo 并不是银弹，Polyrepo 也能符合大部分的场景，我们选择 Monorepo 是基于我们遇到的痛点考虑和权衡的，使用 Monorepo 虽然很好地解决我们遇到的痛点，但是也给我们来了不少额外成本，接下来的部分我会着重分享，在采用 Monorepo 方案后，所带来的问题及其实践。 接下来，我们来看看引入 Monorepo 方案后遇到的问题，以及我们在解决这些问题方面的实践 我们的自研方案在实践过程中，主要遇到如下四个方面的问题： 第一个，因为大部分用户习惯于 Polyrepo 的开发，有些甚至是第一次使用 Monorepo，因此存在用户教育，上手门槛的问题 第二个是随着业务的迭代，Monorepo 工程的规模，即子应用数量迅速增多，而一次调试和构建往往涉及多个子应用，从而导致调试、构建性能下降 第三个是 Monorepo 工程的生命周期往往比 Ployrepo 长很多，且参与开发的同学也非常多，如何确保合入工程的代码保持良好的可维护性，也是一个挑战 第四个，字节的业务线众多，号称 App 工厂，那么面对这些不同业务的需求，如何提供丰富的扩展能力呢？ 此处简述我们自研方案的整体架构，主要分为三层，底层是开源工具层，即我们依赖的开源方案，有 npm 包管理器，changesets 版本管理工具，子应用集成工具，比如 jest 和 webpack 等； 顶层是各类业务场景的支撑，有微前端、跨端、BFF、H5、Library 等场景； 中间层是自研的解决方案，方案也包含三个层次，底层是各类基础能力的封装，比如缓存管理、任务管理、依赖管理、子项目管理等；中间是面向用户的功能模块封装，比如 Checker、Builder、Pipeline 等；顶层则是命令行工具，提供各种命令用于调用 Monorepo 的能力； 右侧则是自研方案提供的，基于插件的扩展能力。 架构设计不是本次分享的重点，接下来才是我们的重点，重点分享这套自研方案，在面对上述四个问题时，它是如何实践的。 因为相当多的用户对 Monorepo 项目的开发方式了解不足，习惯于 Polyrepo 的开发，甚至此前都没有接触过 Monorepo 项目的开发。 因此在加强用户教育，降低上手门槛方面，我们紧密贴合字节基础设施，实践有 提供『内置脚手架』工具，使得用户能够一键创建字节常见的应用类型 提供『CI/CD 能力』，适配字节基建的发包和构建流水线 提供『可视化扩展』，通过界面教育和引导用户使用 接下来我们展开说说 内置脚手架方面，我们提供了一种生成器的模版机制来应对子项目的初始化，我们集成字节常见应用类型的模版（Lynx、Gulu、Garfish、组件库/工具库等），此外也能实现自己的模版，模版既可以是项目级别的，也可以是组件级别的。 如图就是生成器的架构图，它由 5 个 stage 组成，比如 prompt 阶段用于收集用户的命令行输入，render 阶段是渲染模版文件阶段，emit 阶段是生成模版文件，然后通过插件机制，使得每个插件能够在上述 5 个 stage 中处理插件的逻辑，我们提供的插件有 Git 仓库创建插件、SCM 创建插件、Npm 依赖安装插件等。 基于生成器的设计，用户能够定制合适自己业务线的、开箱即用的模版，一键创建项目及其 Git 仓库、配置 SCM 构建等，降低了创建项目的成本。 接下来看看 CI/CD 能力方面的实践，如下是架构图，它也是通过插件的机制来实现的，比如 EntryPackagePlugin 用于入口应用探测，BuildDependenciesPlugin 用于构建依赖，RunSubPackageBuildShPlugin 用于执行子应用的 shell 脚本； 为了实现多环境支持，它会对每一种场景都有对应的 Pipeline，比如 GitlabPipeline 和 SCMPipeline，可以简单的理解为，为每个场景维护了一份插件集合，然后在对应的场景执行时会调用对应场景的 Pipeline，每个 Pipeline 都会执行相同的 stage； stage 列表如右边所示，其中 analyzeEntries stage 会分析依赖，得出哪些代码变更了，collect tasks stage 会去调度子项目的任务流水线。 基于插件集的定制，使得当前的 Pipeline 机制在 SCM 和 Gitlab CI 场景下开箱即用，也方便为未来新的场景进行扩展。 这套机制支持了 Gitlab CI 自动发版流水线与 SCM 构建流水线等场景，大大降低了应用接入发版平台和构建平台的成本。 可视化扩展方面，我们通过界面教育和引导用户，提供快捷操作创建子应用、调用各类命令、搜索子应用、配置 Monorepo 等； 从而降低新手用户的上手成本、降低记住命令的心智负担。 因为 Monorepo 势必会让子应用迅速增多，而一次调试和构建往往涉及多个子应用，从而导致调试、构建性能下降，所以我们需要有特别的方案来保障调试和构建的性能。 因此在规模增大导致性能下降方面，我们通过多种方式提高构建效率，实践有 支持『任务并行能力』，采用最大限度的批量任务并行加速 支持『多级缓存能力』，对依赖安装、构建产物、测试结果等实现了多级缓存 支持『按需构建能力』，根据依赖图和代码更改的影响面来构建和测试 接下来看看我们是如何实践任务并行能力的！ 如图所示，根据子项目的依赖关系转成一个任务依赖图，就可以根据这个依赖图进行任务的调度。 看左下角的任务依赖图，它的构建顺序必须符合这样一种要求，即上层的项目构建依赖于底层项目构建的完成。 OK，我们看方式一，一种最朴素的方式，即通过串行排成 DEBCA，这是能够符合构建要求的；但是它的性能是比较低的，比如 D 和 E 是可以并行的，所以第二种方式就是通过把 DE 以及 BC 进行并行处理，这样便能把前面的 5 个步骤加速到 3 个步骤。但这种优化还不够极致，我们发现任务 C 呢，不依赖任务 E 的完成，但是方式二下，任务 C 却得等待 D 和 E 都完成才开始执行。 因此便引出第三种方式，在任务 E 完成后，D 和 C 便可以并行执行；考虑到并行执行涉及的子项目任务过多时，会导致 cpu 过载，因此还配套了并发控制能力，比如右侧的时序图，4 个需要执行的任务，最大的并发数为 2。 接下来看看多级缓存能力的实践，当 monorepo 体积增大以后，每一次开发或者上线都可能涉及到数个子项目，每次都需要对这些子应用进行重新构建，这将会极大地拖慢构建和部署时间。 我们提供了对构建产物进行缓存的能力，能够同时将产物缓存到本地和远程，当相关的子项目没有修改过代码时，将会复用之前的构建产物以减少构建时间。此外，除了构建任务，其它的操作，比如单测任务的执行，也会缓存结果，从而跳过单测任务。 按需构建能力方面的实践，我们支持按影响面执行 CI 流程，通过 diff 更改的代码并进行依赖分析，得到整个 Monorepo 中受影响的项目，并执行其 CI 流水线；否则每次 CI 都会完整的构建整个所有的子项目 此处以一个简单的 Monorepo 为例，依赖关系如图所示，三个 App，一个 Component，一个 Sdk 和工具库 如果一次性全量构建所有应用，耗时约为 17.72秒 如果仅仅改动了 component 模块，那么按需构建的话，我只需要构建 component, app1, app2，此时耗时 8.94秒，节约 50% 的时间 再来看看无缓存的情况下，我仅仅构建 App1, App2, App3 它们的耗时在 10.77秒到16.94秒之间 如果有缓存的话，比如 component, sdk, util 已经构建过，那么再单独构建 App1, App2, App3 时，构建耗时在 7.55秒到9.74秒 之间，大约节约 45% 的时间 因为 Monorepo 会让众多水平不一工程师在同一个仓库里开发，而且仓库每周新增的代码量都是巨大的，所以我们更需要去保障代码质量。 因此在代码防劣化方面，我们通过 Checker 机制进行各类规范的检查，实践有 支持『内置多种 Checker』，确保项目基本的可维护性 支持『自定义 Checker』，使用户能够编写基于各自团队的规范检查 支持『支持自动修复』，自动修复不符合规范的代码或配置 我们内置了多种 Checker，用于保证基本的可维护性，比如统一依赖版本，它会检查各项目的 package.json 下相同依赖版本是否一致等等 此处以统一依赖版本一致为例，我们都知道，如果多个项目使用相同依赖的不同版本容易导致问题，比如 components 和 app 的 react 版本不一致，就会有 react hooks 报错等问题，此时应用这里的第一个 Checker，就能检测这个问题，并自动修复为统一的版本。 如果内置的 Checker 不满足用户对于规范的需求呢？我们也提供了自定义 Checker 的能力，在每个 Checker 内部，我们注入当前 Monorepo 工程的配置和依赖图等上下文信息，Checker 开发者便能通过这些信息去 check 当前的工程是否符合规范。 当我们探测出问题后，其实有些不规范是能通过自动修复解决的，就像 eslint 一样，我们也支持自动修复代码 因为字节的业务线众多，号称 App 工厂，所以各个业务对 Monorepo 有这样或那样的扩展需求。 因此在面对这些不同业务的扩展需求方面，我们通过插件机制支持用户自定义命令，Checker，生成器，并暴露整个生命周期的钩子，以提供更灵活的扩展能力 以上就是自研方案在实践过程中遇到的一些问题，接下来简要说说整体的落地情况 在字节前端领域，我们的自研方案在所有的 Monorepo 工程中 仓库占比达 25%，采用自研方案的仓库绝对数量已经有上千个 月活占比 47%，拍平后的子应用总数接近多仓项目数量 每周的 npm 包下载量达 14万+ 在字节跳动的前端领域，无论从仓库占比，月活占比，以及下载量来看，我们的自研方案都是排名第一的 Monorepo 工具 过去通过自研方案的建设，拥有高效率、可扩展、开箱即用的 Monorepo 解决方案，良好地服务了字节跳动上千个 Monorepo 工程，颇受业务好评。当前的 Monorepo 方案，面临几个核心问题： 第一个，本地任务调度性能瓶颈，巨型 Monorepo 仓库开始出现依赖安装和构建速度问题，需要更极致的性能和体验优化 第二个，缺乏缓存管理能力，如何跟踪和解决缓存命中率偏低问题 第三个，依赖可读性问题，目前文本形式的依赖结构难以理解，这也导致难以对依赖进行有效的管理 我们对上述问题的解决方法如下： 针对性能，我们将会自研依赖安装逻辑，加速安装；任务调度性能加强（比如子项目任务调度能力，远程任务执行能力），加速构建 针对缓存，我们将会开发缓存 sdk，提供缓存的管理和复用能力，跟踪和提高缓存命中率 针对依赖管理，我们将提供开发辅助工具，用可视化的方式管理复杂的依赖关系 PPT 附件","link":"/2022/12/31/%E5%89%8D%E7%AB%AF%20Monorepo%20%E5%9C%A8%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E7%9A%84%E5%AE%9E%E8%B7%B5/"},{"title":"前端八股知识点-速记脑图","text":"为面试而整理的前端八股文脑图！ RepositoryGithub repository Preview 阅读方式：在线点开每个子目录可以预览脑图下载本仓库，使用软件可打开 mindnode 文件","link":"/2021/04/06/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E7%9F%A5%E8%AF%86%E7%82%B9-%E9%80%9F%E8%AE%B0%E8%84%91%E5%9B%BE/"},{"title":"命令行工具的监控告警建设","text":"本人五年的工作经验，历经三份工作，竟然每份都开发维护过前端命令行工具，大家对前端页面和服务端应用有监控告警这件事习以为常，其实这类工具也需要监控告警，本文将从错误处理到上报排查进行分享。 背景作为前端大家其实都习惯了前端页面有 sentry 类的应用进行错误监控；Node.js 应用打印日志，并在需要的时候使用类 kibana 的应用进行日志查询，且往往配套监控告警。而前端开发几乎每天都会打交道的命令行工具，却在每次报错时，要么联系开发者，要么去用户群咨询。 目的我们先来看看命令行工具的几个特点： 在用户的终端中执行，像一个客户端 运行在 Node.js 环境中，像服务端应用 用户是开发者，往往不能像一个真实产品一样被运营 基于如上几个特点，命令行工具的监控告警需要有上报处理；错误处理需要借鉴 Node.js 应用；开发者对 bug 的容忍度比较高，善于自行排查，命令行工具的维护者需要主动解决某一类问题，以减少开发者在排查中浪费时间；需要一个反馈机制，使得工具能够越来越 bug less。 作为命令行的维护者，借助监控告警的目的主要有： 主动发现异常，提前介入处理，而不是积累到一定程度，用户主动上门时才介入 大部分用户往往不会主动上门，如果有替代品或者不是必须使用的话，用户就流失了 即使用户没有流失，一个经常出错的命令行工具，会使得用户变得不信任 接入监控告警重点是发现『重复类』的错误，解决一批错误而不是偶现错误，从而迅速收敛错误 错误处理在阐述监控告警之前，有必要重点说明下如何科学地处理程序出现的错误。如果程序侧无法很好地处理和上报错误，那么监控告警将起不到有效的作用。 错误分类正确地区分错误分类，有助于我们分别采取不同的方式处理错误，错误主要分为： 操作性的错误(预期内) 程序员的错误(预期外) 这两类错误的区别： 『操作性的错误』是程序正常操作的一部分 『程序员的错误』是 Bug，往往由于程序员没有正确处理导致 举几个例子： 操作性的错误 连接不到服务器 无法解析主机名 无效的用户输入 请求超时 服务器返回500 套接字被挂起 程序员的错误 读取 undefined 的一个属性 调用异步函数没有指定回调 该传对象的时候传了一个字符串 该传IP地址的时候传了一个对象 不同类别的错误如何处理？操作性的错误 直接处理（处理完成后，继续执行） 向上层传错（及时向上层抛错，由上层处理） 重试操作（尝试重试，比如重发请求） 直接崩溃（崩溃退出进程，比如内存不足） 记录错误（仅记录或上报错误） 程序员的错误 无法处理（log &amp; crash） 错误上报我们往往能妥善地处理大部分『操作性的错误』，但是一旦出现无能为力的『操作性的错误』或者『程序员的错误』，此时我们能做的一般只有打印错误告知用户后退出应用，同时将错误上报。接着在服务端根据错误信息区分监控和告警，那么什么样的错误属于告警，什么样的错误属于监控呢？ 告警 当程序出现『程序员的错误』，需要紧急介入时，比如用户初始化模版时，进程异常退出 当程序出现『操作性的错误』，且最终无法被处理时，比如用户创建 gitlab 时，重试次数达到上限，且仍未成功时 监控 当程序出现『操作性的错误』，需要引起足够重视，比如用户输入了不合法的路径、用户创建 gitlab 时经常需要重试 2 次才能成功 当程序进入需要引起足够重视的逻辑（可以不是错误），比如出现了新用户、新部门、新工程 哪些地方需要上报预期外的错误12345678910process.on('unhandledRejection', error =&gt; { reportAlarm({ error }); console.error('Unhandled Rejection Error: ', error); setTimeout(() =&gt; process.exit(1), 1000);});process.on('uncaughtException', error =&gt; { reportAlarm({ error }); console.error('Unhandled Exception Error: ', error); setTimeout(() =&gt; process.exit(1), 1000);}); 预期内的错误1234567try { // 命令行处理逻辑} catch (error) { console.error('Handled Error: ', error); await reportAlarm({ error }); process.exit(1);} 错误排查有效的错误上报，对错误的监控告警处理起到了决定性的作用，我们来看看两则上报消息： Bad case1234567891011121314错误模块：模版初始化错误信息：输入路径非法错误栈：/Users/linleyang/code/temp/case.js:2 throw new Error('输入路径非法'); ^Error: 输入路径非法 at init (/Users/linleyang/code/temp/case.js:2:9) at Object.&lt;anonymous&gt; (/Users/linleyang/code/temp/case.js:5:1) at Module._compile (internal/modules/cjs/loader.js:999:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:1027:10) at Module.load (internal/modules/cjs/loader.js:863:32) at Function.Module._load (internal/modules/cjs/loader.js:708:14) at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:60:12) at internal/main/run_main_module.js:17:47 Good case12345678910111213141516错误模块：模版初始化错误信息：输入路径非法错误栈：/Users/linleyang/code/temp/case.js:2 throw new Error('输入路径非法'); ^Error: 输入路径非法 at init (/Users/linleyang/code/temp/case.js:2:9) at Object.&lt;anonymous&gt; (/Users/linleyang/code/temp/case.js:5:1) at Module._compile (internal/modules/cjs/loader.js:999:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:1027:10) at Module.load (internal/modules/cjs/loader.js:863:32) at Function.Module._load (internal/modules/cjs/loader.js:708:14) at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:60:12) at internal/main/run_main_module.js:17:47输入值：$/home/linleyang触发用户：林宜丙 这两个示例，下面那个除了上报错误消息和错误栈之外，还上报了足够多的错误上下文，我们称之为错误现场，有了错误现场，我们便可能自行复现，或者阅读源码就能解决问题，错误现场既然如此重要，我们来看看一般可以上报哪些现场信息： 错误发生时的入参 错误发生时的状态（关键变量） 触发人 错误信息/错误栈 环境信息（SCM，CI，本地）…… 我们正确处理了错误，正确上报了现场，这样服务端便可根据这些信息将错误分发到各个模块负责人，示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647模版初始化 | 载入模版失败 | 错误报警模块负责人@林宜丙基本信息Version: 1.0.1 Node: v12.22.5 Env: localProject: https://github.com/quanru/bagu用户信息姓名: @林某某首次使用的时间: 2021-08-31 05:00:29最近使用的时间: 2021-11-23 06:00:00历史执行次数: 111部门信息名称: XX部门首次使用的时间: 2021-05-24 04:03:43使用的总人数: 21信息链接: https://quanru.github.io/错误信息级别: 未设置信息:Cannot read property 'replace' of undefined近 24 小时内该用户出现该错误信息的次数: 4近 24 小时内该用户出现所有错误信息的次数: 4近三个月该用户出现该错误信息的次数: 4近三个月所有用户出现该错误信息的次数: 26错误栈:Error: 输入路径非法 at init (/Users/linleyang/code/temp/case.js:2:9) at Object.&lt;anonymous&gt; (/Users/linleyang/code/temp/case.js:5:1) at Module._compile (internal/modules/cjs/loader.js:999:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:1027:10) at Module.load (internal/modules/cjs/loader.js:863:32) at Function.Module._load (internal/modules/cjs/loader.js:708:14) at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:60:12) at internal/main/run_main_module.js:17:47上下文信息输入值：$/home/linleyang附加信息command: cra init hello-world 上报策略为了让命令行维护者更聚焦的处理错误，请切记『监控告警』： 只提供一个通道，用户需要酌情上报 都上报和都不上报区别不大 服务侧需提供默认的上报策略： 这些策略提供参数供上报侧设置 同一个人，半小时内仅上报一次 同一个人，首次无需上报 不存在上下文信息和附加信息的降级为监控 上报侧需要考虑： 调试流量/测试版本不上报 上报侧应主动区分监控和告警（比如：npm start） 用户目录下的代码改动，可以是监控 我们的模块代码出错，应该是告警 尽量主动处理预期内错误，减少抛到兜底处理（比如：某个 npm 包未安装） 按需配置『上报策略』 发生主动异常退出 (process.exit(1)) 时，使用 console.error 而不是 console.log，这样父进程能获取到 stderr 标准错误输出 spawnSync 子进程时，将标准错误 pipe 到父进程进行处理 参考 https://www.joyent.com/node-js/production/design/errors","link":"/2021/12/05/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6%E5%BB%BA%E8%AE%BE/"},{"title":"基于 Gitlab Web Hook 的自动 Eslint 语法检查","text":"Eslint, 一个插件化的 Javascript 语法检查工具, 如何将其结合 Gitlab 并应用于开发呢? Gitlab Web HookGitlab Web Hook 提供如下事件的 Hook: Push events Tag push events Comments Issues events Merge Request events… 当对应事件发生时, 将触发预设的 URL (即 Web Hook), 并向其发送一个包含该事件详细信息的 POST 请求, 正是通过该 POST 请求从而对各个事件进行处理的. 例如 Merge Requests events: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//Request body:{ &quot;object_kind&quot;: &quot;merge_request&quot;, &quot;user&quot;: { &quot;name&quot;: &quot;Administrator&quot;, &quot;username&quot;: &quot;root&quot;, &quot;avatar_url&quot;: &quot;http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=40\\u0026d=identicon&quot; }, &quot;object_attributes&quot;: { &quot;id&quot;: 99, &quot;target_branch&quot;: &quot;master&quot;, &quot;source_branch&quot;: &quot;ms-viewport&quot;, &quot;source_project_id&quot;: 14, &quot;author_id&quot;: 51, &quot;assignee_id&quot;: 6, &quot;title&quot;: &quot;MS-Viewport&quot;, &quot;created_at&quot;: &quot;2013-12-03T17:23:34Z&quot;, &quot;updated_at&quot;: &quot;2013-12-03T17:23:34Z&quot;, &quot;st_commits&quot;: null, &quot;st_diffs&quot;: null, &quot;milestone_id&quot;: null, &quot;state&quot;: &quot;opened&quot;, &quot;merge_status&quot;: &quot;unchecked&quot;, &quot;target_project_id&quot;: 14, &quot;iid&quot;: 1, &quot;description&quot;: &quot;&quot;, &quot;source&quot;:{ &quot;name&quot;:&quot;Awesome Project&quot;, &quot;description&quot;:&quot;Aut reprehenderit ut est.&quot;, &quot;web_url&quot;:&quot;http://example.com/awesome_space/awesome_project&quot;, &quot;avatar_url&quot;:null, &quot;git_ssh_url&quot;:&quot;git@example.com:awesome_space/awesome_project.git&quot;, &quot;git_http_url&quot;:&quot;http://example.com/awesome_space/awesome_project.git&quot;, &quot;namespace&quot;:&quot;Awesome Space&quot;, &quot;visibility_level&quot;:20, &quot;path_with_namespace&quot;:&quot;awesome_space/awesome_project&quot;, &quot;default_branch&quot;:&quot;master&quot;, &quot;homepage&quot;:&quot;http://example.com/awesome_space/awesome_project&quot;, &quot;url&quot;:&quot;http://example.com/awesome_space/awesome_project.git&quot;, &quot;ssh_url&quot;:&quot;git@example.com:awesome_space/awesome_project.git&quot;, &quot;http_url&quot;:&quot;http://example.com/awesome_space/awesome_project.git&quot; }, &quot;target&quot;: { &quot;name&quot;:&quot;Awesome Project&quot;, &quot;description&quot;:&quot;Aut reprehenderit ut est.&quot;, &quot;web_url&quot;:&quot;http://example.com/awesome_space/awesome_project&quot;, &quot;avatar_url&quot;:null, &quot;git_ssh_url&quot;:&quot;git@example.com:awesome_space/awesome_project.git&quot;, &quot;git_http_url&quot;:&quot;http://example.com/awesome_space/awesome_project.git&quot;, &quot;namespace&quot;:&quot;Awesome Space&quot;, &quot;visibility_level&quot;:20, &quot;path_with_namespace&quot;:&quot;awesome_space/awesome_project&quot;, &quot;default_branch&quot;:&quot;master&quot;, &quot;homepage&quot;:&quot;http://example.com/awesome_space/awesome_project&quot;, &quot;url&quot;:&quot;http://example.com/awesome_space/awesome_project.git&quot;, &quot;ssh_url&quot;:&quot;git@example.com:awesome_space/awesome_project.git&quot;, &quot;http_url&quot;:&quot;http://example.com/awesome_space/awesome_project.git&quot; }, &quot;last_commit&quot;: { &quot;id&quot;: &quot;da1560886d4f094c3e6c9ef40349f7d38b5d27d7&quot;, &quot;message&quot;: &quot;fixed readme&quot;, &quot;timestamp&quot;: &quot;2012-01-03T23:36:29+02:00&quot;, &quot;url&quot;: &quot;http://example.com/awesome_space/awesome_project/commits/da1560886d4f094c3e6c9ef40349f7d38b5d27d7&quot;, &quot;author&quot;: { &quot;name&quot;: &quot;GitLab dev user&quot;, &quot;email&quot;: &quot;gitlabdev@dv6700.(none)&quot; } }, &quot;work_in_progress&quot;: false, &quot;url&quot;: &quot;http://example.com/diaspora/merge_requests/1&quot;, &quot;action&quot;: &quot;open&quot;, &quot;assignee&quot;: { &quot;name&quot;: &quot;User1&quot;, &quot;username&quot;: &quot;user1&quot;, &quot;avatar_url&quot;: &quot;http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=40\\u0026d=identicon&quot; } }} 从这个请求体中可知该 Merge Request 的创建者, 分支, 源分支信息, 目标分支信息, 最近一次 Commit, 分配给哪个用户, 对应的状态等信息. Eslint作为插件化的 lint 方案, 逐渐打败了原有的 JSLint 和 JSHint, 并’吞并’了 JSCS, 其最大的优势就是标榜的可插件化, 并且有各种插件可以扩展, 使得开发人员能够灵活的配置规则, 如果这还不满足你的需求, 你还能方便的开发针对自己需求的插件, 此外它还支持 Es6, Jsx 语法, 前端程序员真是一群追求’时尚’的猿, 你不能阻止一个前端使用新工具 …… 编写自己的 config/plugin npm package两种方式: 第一种是类似于 eslint-google-config 的方式, 通过编写配置文件 npm package, 具体详见官方教程; 第二种以插件形式, 类似于eslint-plugin-react-native, 通过编写独立的 Eslint 插件; 本文采用第二种方式, 不仅方便配置现有的 rules, 也方便未来添加自己的 rules: 12345678910111213141516171819202122232425262728293031import ReactEslint from 'eslint-plugin-react';import ReactNativeEslint from 'eslint-plugin-react-native';const reactRules = ReactEslint.rules;const reactNativeRules = ReactNativeEslint.rules;const ReactNativeDemo = { rules: { 'split-platform-components': reactNativeRules['split-platform-components'], 'no-inline-styles': reactNativeRules['no-inline-styles'], 'no-did-mount-set-state': reactRules['no-did-mount-set-state'], 'no-did-update-set-state': reactRules['no-did-update-set-state'] }, configs: { recommended: { parserOptions: { ecmaFeatures: { jsx: true } }, rules: { 'react-native-demo/split-platform-components': 2, 'react-native-demo/no-inline-styles': 2, 'react-native-demo/no-did-mount-set-state': 2, 'react-native-demo/no-did-update-set-state': 2 } } }};export default MyEslinPlugin; 假设你的插件叫做: eslint-react-demo, 那么通过安装该插件(前提是你 npm publish了这个插件): 1npm install eslint-react-demo babel-eslint eslint --save-dev 并在项目根目录配置如下 .eslintrc 文件即可: 1234567{ &quot;parser&quot;: &quot;babel-eslint&quot;, &quot;plugins&quot;: [ &quot;react-demo&quot;, ], &quot;extends&quot;: [&quot;plugin:react-demo/recommended&quot;]} 使用 Node 编写 Gitlab Web Hook 接口现在插件有了, 还是聊聊怎么实现自动化 Eslint 检查吧, 由于目前采用 Issue 方式开发, 当猿们最终写完功能, 需要合并到 master 分支时, 必须提一个 Merge Request, 此时通过监听拦截 Merge Request 事件, 对应的 Web Hook 需要完成以下任务: 判断 Merge Request 事件的触发动作, 若为 open 或者 reopen, 则执行 Eslint 检查 通过 POST 请求体获取对应事件的 git 地址, 分支等信息, 将对应仓库拉到本地 执行 Eslint 检查 如果通过 Eslint 检查, 则什么都不做, 否则将 Eslint 检查结果作为评论回复在该 Merge Request 页面, 并关闭该 Merge Request(当然, 你也可以发邮件给对应的开发人员); 关键代码如下: 12345678910111213141516171819check(mr) { return new Promise((resolve, reject) =&gt; { // TODO fs.chmodSync(shellFilePath, 755); return execFile(shellFilePath, [mr.author, mr.project_path, mr.source_branch, mr.repo], { cwd: rootPath }, (err, stdout, stderr) =&gt; { // 此处不处理 err, 因为 eslint 不通过也算一种 err...... resolve(stdout); }); }) .then(async(ret) =&gt; { const projectService = new ProjectService(); if(ret) { await projectService.createMrNotes(mr, `\\`\\`\\`\\n ${ret} \\`\\`\\`\\n`); await projectService.updateMr(mr, 'close'); return Promise.resolve(false); } else { return Promise.resolve(true); } })} 其中用到的 shell 脚本内容如下: 1234567891011121314151617181920212223#!/bin/bashif [ ! -d eslint ]; thenmkdir eslintficd eslintif [ ! -d $1 ]; thenmkdir $1ficd $1if [ ! -d $2 ]; thengit clone -b $3 $4 &gt; /dev/nullcd $2elsecd $2git checkout $3 &gt; /dev/nullgit pull &gt; /dev/nullfi../../.././node_modules/eslint/bin/eslint.js . 剧终","link":"/2016/10/02/%E5%9F%BA%E4%BA%8E%20Gitlab%20Web%20Hook%20%E7%9A%84%E8%87%AA%E5%8A%A8%20Eslint%20%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5/"},{"title":"如何打造一个满足快速定制能力的私有化部署系统？","text":"打造私有化部署系统过程中的一些和总结 场景我们来看一个场景，一个『规模不大』或者『精力有限』的中小型公司，接入三方公司的效率工具，比如 IM 工具（企业微信）、文档协作系统（语雀）、问卷系统（问卷星）、绩效系统等等。三方公司提供接入的主流方式为 SASS，通过用户分级的方式（普通用户、会员用户、企业用户）售卖自身的产品，这对三方公司来说，易于统一维护。 然而我这边举的几个例子往往关系到公司内部的敏感信息，比如高层员工间的对话、核心战略文档、eNps 调研数据、绩效信息等。这些数据如果保存在三方公司维护的服务器里，多少会有一些安全问题；此外『用户分级』的方式就像套餐，难以满足各类用户的定制需求。因此目前越来越多的三方公司支持私有化部署的方式，将自身的服务部署在客户指定的服务器上，比如企业内部机房、公有云和专有云（阿里云、华为云）。目前，我们对外提供的一款服务也遇到此类问题，当客户不满足于我们提供的『用户分级』套餐，且对『数据存储』十分敏感时，我们如何快速定制并私有化部署服务呢？ 现有问题直接将现有的系统，打包部署到客户指定的服务器上不就完事了？事情没有这么简单，它存在如下3个关键的问题： 一、依赖内部环境在公司内部维护了多年的系统，不少能力都强依赖了内部提供的基础设施，比如 CDN、数据库、缓存服务、动态配置、用户体系等。这些基础设施可能在用户指定的服务器上不一致，甚至不存在。 二、缺乏定制能力当开放用户对系统的定制能力后，现有的系统仅仅支持『用户分级』的方式，是难以支持用户『变幻莫测』的定制需求的，如何快速响应用户的定制需求，是需要全新的一套『模块组织方式』。 三、 并行维护成本如果支持用户私有化部署，那么不得不面临一个这样的问题，当 N 个公司接入时，我们会同时维护 N 套系统，那涉及到一系列在多套系统之间同步 bug 和 feature 的规范、多个版本并行『开发调试构建部署』的研发流程。 解决方法那么，如何打造一个满足快速定制能力的私有化部署系统呢？依旧从上述三点问题出发： 一、摆脱依赖内部环境配置化为了摆脱对内部环境的依赖，我们需要对现有系统进行配置化改造，支持对涉及到的基础设施进行配置，这些配置可以手动写在配置文件里、可构建时生成、运行时动态修改。最终做到根据 N 份配置，即可产出针对 N 个公司的部署包。 二、满足需求定制能力模块化抽离功能模块，通过『开关』、『配置』进行设置。那模块如何拆分和维护呢？拆分可考虑从『垂直』角度，比如『投放功能』、『个人中心』等；或者从『水平』角度，比如『登录』、『权限』等。 三、降低并行维护成本系统融合对现存的系统进行融合，维护一个基线版本的『基础版』，这个所谓的『基础版』有两个目的： 当有新的企业需要接入时，可使用本『基础版』快速定制开发 作为所有并行系统的上游代码分支（master），下游代码分支（各企业分支）定期从该分支 pick bugfix &amp; feature 流程改造我们的服务比较特殊（参考页面搭建类服务），有负责配置的 B 端，以及由 B 端生成的 C 端页面。这样我们就有 4 个工程，每次功能开发都可能涉及到 4 个工程的开发、调试、联调、构建、发布，同时 C 端的静态资源版本和服务地址又是自身决定的。这两点无疑增加了开发人员的心智负担。 首先，将 BC 两端的前后端各放入一个工程中维护，每次发布最大仅需要发布两次。同时 B 端既然作为配置侧，那么不仅 C 端页面本身的功能需要由 B 端决定，我们完全可以将诸如静态资源版本和服务地址这类配置也交由 B 端获取和设置。 接着，对应用初始化、开发、调试、联调、构建、发布进行规范，规范是一种约定，为了更好地将规范落地，有必要实现一套命令行工具或页面流程作为规范的载体。更进一步，可抽象应用概念，这样所有的流程都围绕着这类应用开展； BC 两端可以是这类应用，同时拆分的模块也可以是这类应用，此时我们的所有流程都是围绕着这个应用概念，也就是说，BC 两端以及拆分出的几十甚至上百的模块都共用一套初始化、开发、调试、联调、构建、发布流程。 配置化此外，配置化也有助于降低并行维护成本，我们通过维护配置而不是维护各类代码逻辑。避免诸如『如果是A公司，就执行B逻辑』这类逻辑，配置更关注功能，比如 A 公司的配置开启了『B逻辑』。 除了降低成本之外，配置化还用于应对未来的规划，由于目前所有的企业『定制需求』都是通过人工方式去组装 BC 端应用。在未来当我们接入的企业越来越多，沉淀出大量的『模块』应用之时，便可去探索如何摆脱手工组装，也即通过在线页面通过搭积木的方式组装，借助于配置化，我们的设计可以很好地满足这个需求。 结语此处仅简单讨论了下一个私有化部署系统所需要的改造，步骤三中的流程改造涉及到大量前端工程化相关的能力，还需进一步展开~","link":"/2021/04/05/%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E6%BB%A1%E8%B6%B3%E5%BF%AB%E9%80%9F%E5%AE%9A%E5%88%B6%E8%83%BD%E5%8A%9B%E7%9A%84%E7%A7%81%E6%9C%89%E5%8C%96%E9%83%A8%E7%BD%B2%E7%B3%BB%E7%BB%9F/"},{"title":"字节跳动的前端工程化实践","text":"受邀参加 2023 51CTO 举办的『WOT全球技术创新大会』 分享会背景受邀参加 2023 51CTO 举办的『WOT全球技术创新大会』 本主题简介 PPT 正文 大家早上好，我叫林宜丙，今天带来的分享主题是『字节跳动的前端工程化实践』。 简单介绍下我自己，我是一名来 Web Infra 部门的前端架构工程师，拥有多年前端工程化的经验，致力于帮助前端工程师更好地管理和治理工程；目前负责工程治理方向的方案设计和落地工作。 今天的分享包括以下四个部分 首先分析『当下前端开发领域的趋势』，并引出字节跳动前端开发所面临的新挑战； 其次分享我们目前通过哪些实践来应对这些新挑战； 接着分享自研的方案在字节跳动的整体落地情况； 最后总结和展望前端工程化的发展规律； OK，在分享之前，我们先来看看『什么是前端工程化？』 所谓前端工程化，就是在前端开发过程中，采用一系列的技术手段和工具，来提高开发效率、保证代码质量、提高代码复用性、实现自动化流程和促进团队协作等方面的目标，是现代前端开发不可或缺的一部分； 在这里呢我要特别说明一下，本次主题所要分享的并不是大而全的前端工程化，而是分享为了应对当前『新趋势』下的『新挑战』，我们所做的『新实践』，接下来一起看看，前端开发出现了哪些新趋势呢？ 首先是前端工种的趋势 第一个趋势是涉及的平台越来越多，Web，Node，客户端和跨平台等 第二个趋势是所能支撑的业务也越来越多，复杂度越来越大，特别是近年来前端侧涌现出不少重前端交互的应用 第三个的话，是随着上述两个趋势而来地、不可避免地使得前端团队的规模增大 上述三个趋势又客观上造成了前端工程的四个趋势，也就是： 第一个是，代码规模增大，内部已经出现代码量超过 10G 的大型工程，同时一个应用的上下游依赖所涉及的项目数量也是非常的多 第二个，维护人数增多，一个工程少则十来人，多则四五十人 第三个，应用体积增加，随着应用功能的迭代，体积越来越庞大 第四个，治理难度增高，复杂的依赖关系难以治理，复杂的构建产物难以诊断 那么，在上述这些趋势下，我们的前端开发面临了哪些新的挑战呢？主要有四个： 第一个是多项目维护成本比较高，项目基建重复、代码复用困难、工作流程割裂等 第二个是多人开发协作成本比较高，相互依赖的流程、级联的依赖升级，都增加了协作成本 第三个是巨型应用构建速度比较慢，构建耗时随着应用增大而变慢 第四个是大型应用劣化速度比较快，我们缺乏有效的防劣化手段 为了解决上述新挑战，我们投资如下工具来应对 第一个是自研 Monorepo 工具，用于降低多项目的维护成本 第二个是对原有的微前端框架进行升级，进一步降低多人开发的协作成本 第三个是开发 Bundler 和 Build System，来加快巨型应用的构建速度 第四个是提供诊断工具，来有效地防止应用劣化 接下来将从这四个主题展开聊聊，为了达到上述目标，我们是如何实践的 什么是 Monorepo？ 它是一种源代码管理的模式，其形式就是将多个项目集中到一个仓库中管理； 与之相对的是 Polyrepo 模式，这种模式下各个项目都有独立的仓库； 简而言之，Monorepo 就是将多个不同的项目以良好地组织关系，放到单个仓库中维护； 那么 Monorepo 是如何降低多项目的维护成本的？他通过 复用基建，让开发人员重新专注于应用本身 代码共享，能够低成本的做到代码复用 原子提交，使用自动化的多项目工作流 首先是通过复用基建，让开发人员重新专注于应用本身： 在传统的 Polyrepo 模式下，每个项目都需要有开发人员创建和维护；而在 Monorepo 中，只需要一两个开发人员负责建立 Monorepo 工程，所有的项目都能够在一个仓库中统一维护，通过复用一套基建（比如 CI 配置、Lint 规则、构建脚本等），从而降低多项目维护成本 此外，复用基建也使得统一改造和升级基建变得方便，比如想在 CI 流程中为所有项目加入类型检查，来提高下项目的质量，在 Polyrepo 下需要修改每一个项目，这样成本其实是很高的。而在 Monorepo 下，基建的调整和维护，能够很容易地应用到多个项目中。 其次是通过代码共享，让开发人员能够低成本地复用代码： Polyrepo 中，维护公用模块的成本比较高，首先是调试很繁琐，公用模块的调试需要手动执行 npm link，与当前调试的项目关联起来，如果公用模块较多的话，npm link 步骤将非常繁琐低效。 其次公用模块的升级很繁琐，需要手动管理这种依赖关系，先升级底层的模块，然后发布，最后再升级顶层模块，如果中途出错了，我还得再来一遍这个过程。 而在 Monorepo 中，可以直接一键创建公用模块，顶层的模块一键引入公用模块进行开发、调试，底层模块的更改能够直接被上层感知，甚至不需要经过 link 和 npm 发布，减少了很多重复的工作，大大降低了抽离新的『复用代码』的成本，这使得大家更愿意做这类抽离工作，这反过来又提高了代码复用率。 再次，是通过原子提交，让开发人员享受自动化的多项目工作流 如果我的业务需求要涉及到多个项目，在 Polyrepo 模式中，例如需要修改图中的三个项目，需要先修改提交底层模块，跑每个模块的 CI 流程，在处理顶层模块时，还得更新底层依赖，接着再跑一次 CI 流程，这一套流程非常繁琐且不连续。 而在 Monorpeo 中，我们可以直接一次性调整并提交多个项目，CI 和发布流程也都是一次搞定的，从而将多项目的工作流自动化。 我们简单的做一个总结： 在 Polyrepo 的模式下，每一个项目都有各自的一套基建，且代码复用困难、工作流程割裂，但是在 Monorepo 里面，我们可以让多个项目复用一套基建；方便地共享代码，使用一致的工作流。 很多时候一个团队的项目往往不是割裂的，而是相互联系的，Monorepo 可以很方便地将这些项目组织到一个大仓库中维护，从而极大地降低了多项目的维护成本。 接下来分享下 bunlder 和 build stystem 的工程化实践，因为无论是单仓项目还是多仓项目，随着代码规模和子应用数量的增加，都会导致构建性能下降，为了应对这种情况，我们分别建设了 Bundler 和 Build System 工具。 其中 Bundler 是为了解决单个巨石应用构建速度慢的问题； 而 Build System 则是为了解决 Monorepo 下构建速度慢的问题。 在前端领域，Bundler 是一种工具，用于将多个前端资源（例如 JS、CSS、图像等文件）打包到一个或多个文件中，从而让浏览器能够直接运行； 常见的 Bundler 工具有 Webpack、Rollup、Vite、Parcel、Esbuild。 接下来介绍一下我们自研的 Rspack Bundler，它是一个基于 Rust 语言的高性能构建引擎， 具备与 Webpack 生态系统的互操作性。 从这句介绍中，我们可以知道，Rspack 有两个特性，一个是高性能，另一个是与 Webpack 生态的兼容性。 首先第一个特性，即采用 Rust 语言实现，由于 JS 是单线程的，虽然在 JS 中也有些方式做到并发，但这些方法都有种带着镣铐跳舞的感觉，而在 Rust 中我们能很好地支持并发特性，所以我们将构建过程中的任务，利用并发的特性去执行，这极大提升了构建性能； 这两张图片是 Webpack 与 RSpack 在构建过程中的线程情况对比，我们可以明显地看出，Webpack 其实只是一个单线程，而 Rspack 则能充分发挥多核 CPU 的优势，极致地压榨出性能。 这是我们官网上的一个对比图，在相同的项目下，RSpack 只需要 4.2秒，而 Webpack 需要 34.8秒 Rspack 第二个特性就是与 webpack 部分兼容，目前的实现可以理解为是一个 webpack 的子集，这套子集里包含了大部分的常用配置，满足了日常的业务开发，那么，为什么要与 webpack 生态兼容？ 首先，webpack 的插件机制满足了项目对定制化的要求 其次，复用 webpack 丰富的生态，相当于用最小的成本优化巨型项目的开发体验 最后，存量的 webpack 项目非常多，兼容 webpack 能大大降低迁移成本 这是两个典型业务上的收益，两个项目原本 dev 启动耗时5分钟左右，使用 Rspack 后只需 20 秒左右，原本 hmr 需要 20 秒左右，使用 Rspack 后只需要 1 秒左右，性能收益基本都在 10 倍左右 简单介绍下 Build System，它通过处理 Monorepo 下的项目依赖关系图，并根据这个关系图调度构建任务； 为什么 Monorepo 下需要一个 Build System 呢？ 因为 Monorepo 不是简单的将多个项目直接维护到单个仓库而已，它还需要借助 Build System 来管理整个代码仓库中的多个项目，并根据项目之间的依赖关系进行构建； 常见的 Build System 工具有 Bazel、NX、Turborepo、Lage 等 接下来介绍下在我们自研的 Monorepo 工具中，如何实践 Build System，我们通过 支持『任务并行能力』，采用最大限度的并行任务加速 支持『多级缓存能力』，对构建任务实现了多级缓存 支持『按需构建能力』，根据代码更改的影响面来构建 如图所示，根据子项目的依赖关系转成一个任务依赖图，它的构建顺序必须符合这样一种要求，即上层的项目构建，需要等待底层项目构建的完成。 OK，我们看方式一，即通过串行排成 DEBCA，这是能够符合构建要求的；但是它的性能是比较低的，比如 D 和 E 是可以并行的，所以第二种方式就是通过把 DE 以及 BC 进行并行处理，这样便能把前面的 5 个步骤加速到 3 个步骤。 此时我们发现任务 C 呢，它不依赖任务 D 的完成，但是方式二下，任务 C 却得等待 D 和 E 都完成才开始执行。 因此便引出第三种方式，在任务 E 完成后，D 和 C 以并行方式执行； 当 monorepo 子项目规模增大后，每一次开发或者上线都会涉及多个子项目，如果每次都需要对这些子项目进行重新构建，这将会极大地拖慢构建和部署速度。 我们提供了对构建产物进行缓存的能力，能够同时将产物缓存到本地和远程，当相关的子项目没有修改过代码时，将会复用之前的构建产物以减少构建时间。 按需构建能力方面的实践，我们支持按影响面执行 CI 流程，通过 git diff 当前有改动的代码进行依赖分析，从而只构建受影响的项目，否则每次 CI 都会完整的构建所有的子项目。 此处以一个简单的 Monorepo 为例，依赖关系如图所示 如果一次性全量构建所有项目，耗时约为 17.72秒 如果仅仅改动了 component 模块，那么按需构建的话，我只需要构建 component, app1, app2，此时耗时 8.94秒，节约 50% 的时间 再来看看无缓存的情况下，我仅仅构建 App1, App2, App3 它们的耗时在 10.77秒到16.94秒之间 如果有缓存的话，比如 component, sdk, util 已经构建过，那么再单独构建 App1, App2, App3 时，构建耗时在 7.55秒到9.74秒之间，大约节约 45% 的时间 通过 Builder 和 Build System 的建设，我们分别借助 Rust 语言的高性能和远程构建缓存能力，极大地加速了巨型应用的构建速度，但这又不仅仅是开发速度上的提升，它同时给我们的业务带来两个巨大的收益 拉高了一个巨石应用上限：使得我们能够开发一个更巨型更强大的应用 加快迭代速度：使得我们可以更快更多地做 AB 测试和功能发布 所谓微前端，就是前端领域的应用分治解决方案，字节跳动的微前端实践也经过 iframe, spa, 框架阶段；在实践中遇到不少问题，为了进一步降低多人协作的成本，目前进入一个新方案的探索阶段。 接下来看下微前端的工程化实践，新方案是如何降低多人开发的协作成本的 首先，通过减轻基座负担，将基座应用与业务逻辑解耦 其次，采用细粒度的组合，在更细粒度的模块上独立开发、部署 最后，通过约定模块协议标准，我们搭建了模块中心，甚至可以结合低代码平台，从而带来更高的模块复用率；并支持模块级别的灰度和AB能力； 它是如何减轻基座负担的呢？传统的微前端，通过建立一个公共的基座来承载公共逻辑，这种复用方式，除了工具库以外，往往导致不少业务逻辑耦合到基座中，这导致基座更频繁的改动和发布，更容易出现更大的故障影响面和更容易失效的缓存； 这又让子应用从独立开发、部署重新回到某种程度上地相互依赖，因此，新方案通过两种方式消除了这类基座的存在，一个是消费机制，另一个是共享机制，前者一般用于复用业务逻辑，后者用于复用业务无关的工具库 那么，新方案的机制是如何起作用的？ 传统的微前端架构中，多个子应用之间是相对隔离的，往往都会通过一套沙箱机制来保证这种隔离性； 但随着前端子应用的规模增大，人员增多，如此粗粒度的隔离又会反过来制约每个子应用内外的人员协作； 因此，我们新的应对方式就是通过提供更细粒度的模块消费和共享方案，从而让开发人员能够以更小的单位进行独立开发、测试、部署 模块协议标准约定了模块的元信息，通过该协议在各个平台之间流转，来达到特定的功能 比如构建平台会根据配置文件构建出这份协议文件 比如部署平台会将元信息转成包含具体 cdn 地址的数据，直接回填到 html 里下发，这步操作也是能做到模块灰度和AB的前提 再比如应用运行时也会根据这份协议动态加载模块 有了细粒度组合和模块协议标准的特性，我们又能够十分方便地建立一个在线模块中心，无论是业务相关的组件，还是业务无关的工具库，都能以极低的成本在团队内部，甚至跨团队复用； 此外，基于这套机制，我们还尝试了与低代码平台的配合，通过低代码平台搭建出符合模块协议标准的组件，并注册为在线模块后，能够极大的提高业务开发的效率。 这是一个典型的接入业务，接入之后我们发现从构建耗时、部署耗时，甚至迭代速度和需求吞吐量都有了显著的提升效果。 接下来分享下诊断工具，市面上的工具大多面向构建产物进行诊断和分析，无法对构建过程进行更深入诊断和分析，作用十分有限 那么我们自研的诊断工具，是如何有效地防止应用劣化的呢？ 首先，提供面向构建过程的分析能力，由于记录了构建过程的数据，我们会有更细粒度和更丰富的分析； 其次，提供一套可扩展的规则机制，让不同的垂直场景和业务场景能够扩展自身的规则； 最后，通过与核心研发流程结合，让规则真正发生作用； 这是一份 statoscope 的分析结果页面，它是典型面向构建产物分析的，即通过消费 stats.json 来分析产物； 它没有 loader、resolver、plugin 等和构建过程相关的分析和诊断； 而我们的工具能做到如下一些能力： webpack loader 时序分析 webpack loader 分析 webpack resolver 分析 webpack plugin 分析 bundle 深度分析 那我们是如何做到的呢？我们通过监听插件钩子和劫持 Loader 等方式介入构建过程，并收集和生成专门用于诊断和分析场景的数据结构，比如依赖图、模块图、三方包图、源码、loader、plugin、resolver 等数据，从而获得更完善的构建上下文信息，以便我们后续进行深度的诊断和分析 我们提供了一些默认的诊断规则，比如 重复包检查 - Duplicate Packages 包规范语句匹配 - Default Import Check Loader 性能优化 - Loader Performance Optimization 此外，我们还提供一套可扩展的诊断规则机制，我们将重新生成的数据结构作为上下文传递给自定义的规则，便能轻松的做到如下能力： 依赖的引用方式检查 特定依赖的版本检查 禁止使用特定的语句 光有上述两个能力还不够，我们还谋求与核心研发流程结合，在 CI 中支持基于分支的 diff 拦截，从而让规则真正发生作用 总结一下，这是一些典型的业务收益情况 这是目前上述几个工具的整体落地情况，其中 Monorepo 工具接入工程x个，微前端活跃用户y个，Bundler 开源工具 Rspack z stars，诊断工具的周下载量达到n次 接下来做一个简单的总结和展望： 当上述一系列工具链支撑了更大的工程规模，更多的人员规模，更加快速的构建速度，更可维护的前端工程之后； 我相信未来一定会催生出更『强大』的前端应用，当这个更强大的前端应用继续增大工程规模，增加团队人员，渐渐地拉低了构建速度和可维护性 那未来必将会对这些工具提出更高的要求，从而带动整个前端工具链再一次革新 谢谢，这就是我今天带来的分享 PPT 附件","link":"/2023/06/17/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/"},{"title":"实习总结","text":"上接《不要叫我程序猿,我是前端开发工程狮》，话说我去了挖财实习，此处省略一万字，然后我就顺利转正，接着回学校撰写毕业论文了。 上接《不要叫我程序猿,我是前端开发工程狮》，话说我去了挖财实习，此处省略一万字，然后我就顺利转正，接着回学校撰写毕业论文了。 省略一万字（部分内容） 找呀找呀找工作当初做的选择是多么正确，一路顺风顺水就拿到offer，基友们都还没着落的时候，我已经决定留在挖财了（挖财决定留我了）。待遇挺满意，团队超nice，我就没有再出去找其他公司了。 当然，转正之前，我还是试了几家的；做过那么多家笔试，唯一进入面试的就是阿里了，然后你懂的，阿里实习宝宝们都拥抱“变化”了，接着宝宝们就出来拥抱我们了，并成功让我司一个前端实习生拥抱了“变化”。阿里的面试，尽问些前端工程化的问题，事实上，那时我还没接触到，一问三不知哈，反正就是去打酱油的。 内推进入面试的有两家，一家是蘑菇街，一家是51信用卡管家。蘑菇街顺利进入了二面，然后也没怎么问，期间问我职业规划什么的，我就blabla说了一大堆我想学的，然后我又没时间什么的，所以面试官问我你加班吗？我说不怎么加班，“那你回到家，为什么不自学”，就没然后了，其实我回家是有学习的，我当时想表达的是我想学那些，可是我在忙着学其他的，怪我咯。下楼问我何时能来实习，二逼如我：“明年六月份吧”，嗯，这下真的没有然后了。 51信用卡真是掉渣天，10点通知我到他那面试，然后10.30才匆匆忙忙跟我碰上头；跟我聊感想….然后我就发现这姐们是hr，所以没有技术面？然后也问了我什么时候能来实习，再续二逼：“明年六月份吧”，其实我主要在等挖财，可惜挖财转正面试太晚啦！ 挖财的转正面试，应该是走个过场，CTO面的，看我简历上写的关键字中有“Linux”，然后就去拿了台mac，问了一些常用命令，比如ps，比如vi，再比如grep；他问我平时是用Linux吗？我说是的，“前端屌丝不都用mac吗？”，内心os：人家才不是屌丝呢（我只是没钱），对了，我现在是我司唯一一个没有mac的前端工程师，随意感受下。 实习经历刚来挖财的时候，一切都是那么新鲜，我还是很屌的，什么git啊，svn啊，idea啊，vm啊，avalon啊，mvvm啊，gulp啊，webpack啊我都没听过，哈哈~还有一个有求必应的资深前端小哥在我旁边，随时都可以请教，进步是非常明显的。 期间做了很多有趣的项目，都不大，但是挺有成就感的，有个大咖秀项目的活动页面生成管理系统，现在又增加了有些小需求，打算做成发布各种类似活动的管理系统。还有一个让我累死累活的双十一活动主会场，倒不是有多难，主要是开发人员都在上海那边，而负责前端的我一个人在杭州，沟通极为不便，很多东西都是我第一次接触，又要兼容我司各个app，但是做成了，还是蛮好玩的。 第一笔实习工资入账的时候还是很激动的，心想：我也是能够养活自己了，还跟我妈说了，以后不用给我寄生活费啦。还有以后我就要扎根杭州啦~大爱杭城。 回校瞒着导师出来实习，已有整整四个月半了，四个月的时候，导师估计发现什么了，在电话里第一句就问我：“xx，实习得怎么样？”，看来到了不得不回校的时候了，于是请了一个长长长的假就回到我校，着手准备撰写“优秀毕业论文”哈，开玩笑~","link":"/2015/11/18/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"title":"排查 Node.js 服务内存泄漏，没想到竟是它？","text":"团队最近将两个项目迁移至 degg 2.0 中，两个项目均出现比较严重的内存泄漏问题，此处以本人维护的埋点服务为例进行排查。服务上线后内存增长如下图，其中红框为 degg 2.0 线上运行的时间窗口，在短短 36 小时内，内存已经增长到 50%，而平时内存稳定在 20%-30%，可知十之八九出现了内存泄漏。 背景团队最近将两个项目迁移至 degg 2.0 中，两个项目均出现比较严重的内存泄漏问题，此处以本人维护的埋点服务为例进行排查。服务上线后内存增长如下图，其中红框为 degg 2.0 线上运行的时间窗口，在短短 36 小时内，内存已经增长到 50%，而平时内存稳定在 20%-30%，可知十之八九出现了内存泄漏。 排查思路由于两个接入 degg 2.0 的服务均出现内存泄漏问题，因此初步将排查范围锁定在 degg 2.0 引入或重写的基础组件上，重点怀疑对象为 nodex-logger 组件；同时为了排查内存泄漏，我们需要获取服务运行进程的堆快照（heapsnapshot），获取方式可参看文章：Node 案发现场揭秘 —— 快速定位线上内存泄漏。 排查过程一、获取堆快照使用 alinode 获取堆快照，服务启动后，使用小流量预热一两分钟便记录第1份堆快照（2020-4-16-16:52），接着设置 qps 为 125 对服务进行施压，经过大约一个小时（2020-4-16-15:46）获取第2份堆快照。使用 Chrome dev 工具载入两份堆快照，如下图所示，发现服务仅短短运行一小时，其堆快照文件就增大了 45MB，而初始大小也不过 39.7MB；我们按 Retained Size 列进行排序，很快就发现了一个『嫌疑犯』，即 generator；该项占用了 55% 的大小，同时 Shallow Size 却为 0%，一项一项地展开，锁定到了图中高亮的这行，但是继续展开却提示 0%，线索突然断了。 盯着 generator 进入思考，我的服务代码并没有 generator 语法，为什么会出现 generator 对象的内存泄漏呢？此时我把注意力转到 node_modules 目录中，由于最近一直在优化 nodex-kafka 组件，有时直接在 node_modules 目录中修改该组件的代码进行调试，因此几乎每个文件头部都有的一段代码引起了我的注意： 12345678910&quot;use strict&quot;;var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); } return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); });}; 这个代码是 typescript 源码编译后的产出，由于代码使用了 async/await 语法，因此都编译成 __awaiter 的形式，在源码中使用 async 函数的地方，在编译后都使用 __awaiter 进行包裹： 12345678910111213// 编译前(async function() { await Promise.resolve(1); await Promise.resolve(2);})()// 编译后(function () { return __awaiter(this, void 0, void 0, function* () { yield Promise.resolve(1); yield Promise.resolve(2); });})(); 同时一个关于 generator 内存泄漏的 #30753 generator functions - memory leak 也引起了我的注意，该 issue 遇到的问题无论从 Node.js 的版本和内存泄漏的表现都和我遇到的问题十分相似。所以我在工程的 node_modules 中搜索所有 __awaiter 字符串，发现了 3 个模块编译出了上述代码，分别是： nodex-logger nodex-kafka nodex-apollo 由于模块的 tsconfig.json 的 target 字段将目标产出为 es6，因此才会使用 generator 去模拟 async/await 语法，但是从 Node.js v8.10.0 开始已经 100% 支持了 ES2017 的所有特性，所以本不该编译 async/await 语法，此处遂将这 3 个模块的目标产出配置改为 es2017，这样 tsc 就不会编译 async/await 语法。 二、验证重复之前获取堆快照的步骤，惊奇地发现即使过了一天，内存也没有增长，而且 generator 也没有持有未释放的内存： 至此，内存泄漏问题已经解决！那么如何避免遇到这个问题呢？ 如何避免一、解决步骤步骤一该问题仅在特定的 Node.js 版本中存在，请使用版本区间 [v11.0.0 - v12.16.0) 之外的 Node.js，从而防止二方 npm 组件、三方 npm 组件的 generator 语法使你的服务出问题 步骤二将自己的 typescript 的目标环境（target）编译为 es2017 及以上，同时应尽量使用 async/await 语法而不是 generator 语法，从而防止别人使用 [v11.0.0 - v12.16.0) 版本时，引入你的 npm 组件而导致内存泄漏 二、详细说明前文说了从 Node.js v8.10.0 开始就已经支持了 async/await 语法，经查该版本于 2018-03-06 发布，由于所有服务也不可能一下全切换到新版本，因此为了兼容 Node.js v6 版本的环境，需要将代码编译到 es6。但是站在现在这个 LTS 版本已经是 v12 的时间节点，完全可以排查现有使用 typescript 的 npm 组件是否都编译到 es2017，甚至探讨编译到 es2019 的可能。 此外这个内存泄漏问题是从哪个版本开始有的，现在是否解决了呢？编写可验证的内存泄漏的代码如下： 1234567891011121314151617181920// node-leak.jsconst heapdump = require('heapdump')class Async { async run() { return null; }}const run = async () =&gt; { for (let index = 0; index &lt; 10000000; index++) { if (index % 1000000 === 0) console.log(Math.floor(process.memoryUsage().heapUsed / 10000), index); const doer = new Async(); await doer.run(); } heapdump.writeSnapshot((err, filename) =&gt; { console.log(&quot;Heap dump written to&quot;, filename); });};run(); 123456789101112131415161718192021222324252627282930// leak.js 由 node-leak.js 编译得来var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); } return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); });};class Async { run() { return __awaiter(this, void 0, void 0, function* () { return null; }); }}const run = () =&gt; __awaiter(this, void 0, void 0, function* () { const now = Date.now(); console.log('循环总次数: ', 10000000); for (let index = 0; index &lt; 10000000; index++) { if (index % 1000000 === 0) { console.log('第 %d 次循环，此时内存为 %d', index, Math.floor(process.memoryUsage().heapUsed / 1000000)); } const instance = new Async(); yield instance.run(); } console.log('总耗时: %d 秒', (Date.now() - now) / 1000);});run(); 经过二分排查，发现该泄漏问题从 v11.0.0 引入，在 v12.16.0 解决；内存泄漏版本执行脚本时，内存占用逐步递增直到 crash，而未泄漏版本则会及时回收内存。 根本原因根本原因是 v8 的一个 bug，相关链接： v8 issue: https://bugs.chromium.org/p/v8/issues/detail?id=10031 v8 commit: https://chromium.googlesource.com/v8/v8.git/+/d3a1a5b6c4916f22e076e3349ed3619bfb014f29 node issue: https://github.com/nodejs/node/issues/30753 node commit: https://github.com/nodejs/node/pull/31005/files 改进后的代码，在分配新增 WeakArrayList 数组时，即使返回没有空闲数组的标记（ kNoEmptySlotsMarker ），仍需要调用 ScanForEmptySlots 方法重新扫描一次数组，因为该数组元素有可能有被 GC 回收，这些被回收的元素是可以重复使用的；仅当返回 kNoEmptySlotsMarker 且数组中没有被 GC 回收的元素，才真正执行新增逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// https://github.com/targos/node/blob/cceb2a87295724b7aa843363460ffcd10cda05b5/deps/v8/src/objects/objects.cc#L4042// staticHandle&lt;WeakArrayList&gt; PrototypeUsers::Add(Isolate* isolate, Handle&lt;WeakArrayList&gt; array, Handle&lt;Map&gt; value, int* assigned_index) { int length = array-&gt;length(); if (length == 0) { // Uninitialized WeakArrayList; need to initialize empty_slot_index. array = WeakArrayList::EnsureSpace(isolate, array, kFirstIndex + 1); set_empty_slot_index(*array, kNoEmptySlotsMarker); array-&gt;Set(kFirstIndex, HeapObjectReference::Weak(*value)); array-&gt;set_length(kFirstIndex + 1); if (assigned_index != nullptr) *assigned_index = kFirstIndex; return array; } // If the array has unfilled space at the end, use it. if (!array-&gt;IsFull()) { array-&gt;Set(length, HeapObjectReference::Weak(*value)); array-&gt;set_length(length + 1); if (assigned_index != nullptr) *assigned_index = length; return array; } // If there are empty slots, use one of them. int empty_slot = Smi::ToInt(empty_slot_index(*array)); if (empty_slot == kNoEmptySlotsMarker) { // GCs might have cleared some references, rescan the array for empty slots. PrototypeUsers::ScanForEmptySlots(*array); empty_slot = Smi::ToInt(empty_slot_index(*array)); } if (empty_slot != kNoEmptySlotsMarker) { DCHECK_GE(empty_slot, kFirstIndex); CHECK_LT(empty_slot, array-&gt;length()); int next_empty_slot = array-&gt;Get(empty_slot).ToSmi().value(); array-&gt;Set(empty_slot, HeapObjectReference::Weak(*value)); if (assigned_index != nullptr) *assigned_index = empty_slot; set_empty_slot_index(*array, next_empty_slot); return array; } else { DCHECK_EQ(empty_slot, kNoEmptySlotsMarker); } // Array full and no empty slots. Grow the array. array = WeakArrayList::EnsureSpace(isolate, array, length + 1); array-&gt;Set(length, HeapObjectReference::Weak(*value)); array-&gt;set_length(length + 1); if (assigned_index != nullptr) *assigned_index = length; return array;}// staticvoid PrototypeUsers::ScanForEmptySlots(WeakArrayList array) { for (int i = kFirstIndex; i &lt; array.length(); i++) { if (array.Get(i)-&gt;IsCleared()) { PrototypeUsers::MarkSlotEmpty(array, i); } }} 不止内存泄漏在我测试内存泄漏时，有一个发现，执行发生内存泄漏时的代码（前文的 leak.js）和未发生内存泄漏时的代码（前文的 node-leak.js）时，即使在已经修复该问题的 Node.js v12.16.2 版本下，generator 语法仍然有两个问题： 内存回收效率低，导致执行完后，仍有相当大的内存占用； 执行效率非常慢，async/await 版本仅需要 0.953 秒，而 generator 却需要 17.754 秒； 这说明，相比 generator 语法，async/await 语法无论从执行效率还是内存占用方面都有压倒性优势。那么执行效率对比如何呢？上 benchmark 工具比划比划： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// benchmark.jsconst __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) { function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); } return new (P || (P = Promise))(function (resolve, reject) { function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } } function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } } function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); } step((generator = generator.apply(thisArg, _arguments || [])).next()); });};const Benchmark = require('benchmark');const suite = new Benchmark.Suite;suite .add('generator', { defer: true, fn: function (deferred) { (function () { return __awaiter(this, void 0, void 0, function* () { yield Promise.resolve(1); yield Promise.resolve(2); // 测试完成 deferred.resolve(); }); })(); } }) .add('async/await', { defer: true, fn: function(deferred) { (async function() { await Promise.resolve(1); await Promise.resolve(2); // 测试完成 deferred.resolve(); })() } }) .on('cycle', function(event) { console.log(String(event.target)); }) .run({ 'async': false }); Node.js v12.16.2 的结果： 12generator x 443,891 ops/sec ±4.12% (75 runs sampled)async/await x 4,567,163 ops/sec ±1.96% (79 runs sampled) generator 每秒执行了 516,178 次操作，而 async/await 每秒执行了 4,531,357 次操作，后者是前者的 10 倍多！我们看看其它 Node.js 版本表现如何： 电脑配置：MacBook Pro (13-inch, 2017, Two Thunderbolt 3 ports) Node.js 版本 generator async/await 倍数 12.16.2 443,891 4,567,163 10.29 11.15.0 424,073 680,795 1.60 10.20.1 427,799 669,910 1.57 9.11.2 275,526 500,487 1.82 8.17.0 281,571 535,317 1.90 二者执行效率和 Node.js 版本成正比，而 Node.js v12 来了一次大跃进，直接高了一个数量级，这个得益于 v8 7.2 的一个新特性，官网用了整整一篇文章说明，有兴趣的可以看看。 Chrome 也中招了吗？ 目前最新版：版本 81.0.4044.113（正式版本） （64 位） 已经修复这个问题 既然是 v8 的问题，那么 chrome 浏览器也是有这个问题的，打开空白标签页，执行前文给出的 leak.js 代码： 可发现，chrome 下也会有内存泄漏问题，只不过 chrome 页面上的代码运行一般不会有密集地、重复地执行某段『导致内存泄漏』的代码，因此该问题在 chrome 端不容易被察觉。 总结没想到一个小小的语法转译也会造成如此严重的内存泄漏问题，且一个 V8 底层小小的 bug 在上层使用时会被放大得如此严重。但是只要我们不放过每一个可疑点，深入排查总会有意想不到的收获！","link":"/2020/04/20/%E6%8E%92%E6%9F%A5%20Node.js%20%E6%9C%8D%E5%8A%A1%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E6%B2%A1%E6%83%B3%E5%88%B0%E7%AB%9F%E6%98%AF%E5%AE%83%EF%BC%9F/"},{"title":"排查守候在零点两分的 bug","text":"最近接手泛前端团队的服务稳定性治理，遇到一些很有特点的线上问题，这边记录一次『有趣的 bug』排查 背景故事的开始是由老板的一个艾特开始的： 当时排查了下没啥思路，就放弃了（以为偶现，过几天它能自己好起来！）。直到某一天我又收到了同样的告警，我回想了下最近好几天都有这个告警。 抬头一看： 心里一惊：别搞出事故啊！就开始了我的排查之路。 排查思路根据告警错误栈显示，这是一个 “unhandledRejection”： 1234567891011[ERROR][2020-09-16T23:59:59.582+0800][default:process.&lt;anonymous&gt; at /home/xxx/xxx/xxx/lib/app.js:49:10] _undef||traceid=64594b155f6231298ae0e2b114a1a02||spanid=38197e8a96a6d96a||pid=1431||msg=on unhandledRejection, error: { Error: ERR invalid expire time in set at JavascriptReplyParser.parseResult (/home/xxx/xxx/xxx/node_modules/redis-parser/lib/javascript.js:90:16) at JavascriptReplyParser.tryParsing (/home/xxx/xxx/xxx/node_modules/redis-parser/lib/javascript.js:117:21) at JavascriptReplyParser.run (/home/xxx/xxx/xxx/node_modules/redis-parser/lib/javascript.js:131:22) at JavascriptReplyParser.execute (/home/xxx/xxx/xxx/node_modules/redis-parser/lib/javascript.js:112:10) at Socket.&lt;anonymous&gt; (/home/xxx/xxx/xxx/node_modules/redis/index.js:223:27) at emitOne (events.js:116:13) at Socket.emit (events.js:211:7) at addChunk (_stream_readable.js:263:12) at readableAddChunk (_stream_readable.js:250:11) at Socket.Readable.push (_stream_readable.js:208:10) command: 'SET', code: 'ERR' } 所以一层一层往上找，是找不到抛错的源头的！猜测了一通无果，于是我去翻告警群的记录，我发现了一个惊人的规律，该告警只要出现，必定是每天凌晨 00:02： 因此排查思路锁定在以下几个： 存在每天定时任务设置某个 redis 值的超时时间？ 服务器时间存在误差？ 排查过程剧透下，并不是上述两个原因。 经过多番搜索代码，发现了几处设置 redis 值的代码，同时结合 Google，有人指出 Redis 设置的超时时间不能为小于 0。经过本地验证，的确发现超时时间不能为 0： 于是排查方向转为代码中哪里出现了设置超时时间小于 0 的逻辑。可疑代码如下： 12345setRedisKey( redisTeamKey, data, 24 * 3600 - getPastTimeOfToday() / 1000,) 那么这个值 24*3600 - getPastTimeOfToday() / 1000 可能为 0 或者负数吗？我们来看看完整逻辑： 12345678const getPastTimeOfToday = () =&gt; { const date = new Date() const year = date.getFullYear() const month = strPadding(date.getMonth() + 1, '0', 2) const day = strPadding(date.getDate(), '0', 2) const todayStartTs = +new Date(`${year}/${month}/${day} 00:00:00`) return +new Date() - +new Date(todayStartTs)} 这个值代表当前这个时间点，离今天结束还有多少秒的时间。可是这个值不可能小于 0，我甚至猜测是否执行上述代码第二行时是昨天，而第七行的时候是今天，这样能验证我们的猜测，即这个函数返回的值大于 24*3600，那 24*3600 - getPastTimeOfToday() / 1000 就小于 0 了。不过这个可能性比较低，于是我转而去服务器复现这个 bug，编写如下代码并执行： 12345const { setRedisKey } = require('./lib/xxx/xxx/redis')process.on('unhandledRejection', console.log)setRedisKey('abc', 'value', 0) 执行结果如下，与告警的错误栈一致： 既然复现了错误，回头继续找 bug，深入到 setRedisKey 代码： 123const setRedisKey = (key, value, expireTime = DEFAULT_EXPIRETIME) =&gt; { return redis.set(key, value, 'EX', Math.floor(expireTime))} 过期时间 expireTime 被 Math.floor 包裹，也就是说当 0 &lt; expireTime &lt; 1 时，Math.floor(expireTime) 的值为 0。那么当服务器时间到无限接近 00:00:00 时，getPastTimeOfToday 将返回 (24*3600-x)*1000 ，因为无限接近 00:00:00，因此 x 的值介于 0 - 1 之间（毕竟时间戳的最小单位是毫秒，想象下『当天剩余毫秒数』还有不到 1000 的情况）。 为什么 unhandledRejection对了，为什么该错误没有被捕获？如果一开始被捕获，也就有完整的错误栈，那么排查过程肯定会顺利很多。业务代码如下（已脱敏）： 123Promise.resolve().then(() =&gt; { Promise.reject(new Error('出错了！'))}).catch(console.error) 大家发现了吧，then 中的 Promise 没有返回，那么我返回了就一定会被捕获吗？在这种写法下是会的，大家可以尝试下，但是你写成下面这样，还是会 unhandledRejection： 123456789101112new Promise((resolve, reject) =&gt; { if (false) { resolve('对了！') } if (true) { return Promise.reject(new Error('出错了！')) } reject(new Error('兜底逻辑！'))}).catch(console.warn) 为什么呢？因为需要手动调用 reject 才可抛错，这就需要层层将 resolve 和 reject 传入可能报错的 Promise 才行，珍爱生命远离 Promise，大家还是尽量用 async/await 语法（相同功能下）。 解决方式原因既然依旧找到，解决方式也就出来了： 向下取整 Math.floor 改为向上取整 Math.ceil（不过极端情况下还是存在当天剩余毫秒数恰好为 0 的情况） 判断 expireTime 值小于等于 0 时，赋值为 1（续一秒，蛤蛤蛤），同时记录 warn 警告日志 排查未 return 的 Promise，统一返回 尝试找了下 typescript 限制 number 为正整数的方式，没有找到，有的话求大神告知？","link":"/2020/09/18/%E6%8E%92%E6%9F%A5%E5%AE%88%E5%80%99%E5%9C%A8%E9%9B%B6%E7%82%B9%E4%B8%A4%E5%88%86%E7%9A%84%20bug/"},{"title":"消失的 1px","text":"之前本人写过一篇文章，是关于1px边框的：从line-height到0-5px。文中提到用缩放的方法固然可行，但是在使用rem或者百分比单位时，时常会造成1px边框在某些机型下消失；而使用border-image方案则不会出现消失的情况；本文将探索该1px边框消失的原因以及后者为何能正常显示。 前因之前本人写过一篇文章，是关于1px边框的：从line-height到0-5px。文中提到用缩放的方法固然可行，但是在使用rem或者百分比单位时，时常会造成1px边框在某些机型下消失；而使用border-image方案则不会出现消失的情况；本文将探索该1px边框消失的原因以及后者为何能正常显示。 LayoutUnit在LayoutUnit中提到了两种将亚像素(即小数点像素)转换为真实物理像素的两种方法，示意图如下： enclosingIntRect x: floor(x) y: floor(y) maxX: ceil(x + width) maxY: ceil(y + height) width: ceil(x + width) - floor(x) height: ceil(y + height) - floor(y) pixelSnappedIntRect 采用该方式，最终形成的物理大小将会超过原来的小，使得盒模型出现溢出的风险。 pixelSnappedIntRect x: round(x) y: round(y) maxX: round(x + width) maxY: round(y + height) width: round(x + width) - round(x) height: round(y + height) - round(y) 采用这种方式的好处是能够保证最终渲染的物理大小不超过原来的大小，使得在屏幕等分出现小数的情况也不会溢出到下一行。本人将七个div等分整个屏幕宽度，在不同的分辨率下并没有发生溢出的情况，因此猜测浏览器采用了这套方案。 转换时的相互影响如果每个DOM节点都各自独立地采用上述方案之一，那么就不会出现1px消失的情况，然而事实上在文档流中，前一个节点所占用的大小经过亚像素转换之后，还会影响后一个节点的大小，从而影响后者进行亚像素转换。 此处以iPhone4屏幕大小为例，将其七等分： .box { font-size: 10px; width: 14.2857%; height: 14.2857%; background: pink; float: left; } .box:nth-child(2n) { background: gray; } 并打印计算宽度与实际渲染宽度： 1234$.each($(&quot;.box&quot;), function(index, val) {var computedWid = getComputedStyle(val).width;var wid = val.offsetWidth;$(val).html(computedWid + '&lt;br&gt;' + wid + 'px'); 显示效果如下： 其计算规则如下： 第一个box的大小为45.7031px，进位46px大小，导致其覆盖了后一个box，覆盖宽度为1-0.7031=0.2969px； 第二个box的大小此时缩减为45.7031-0.2969=45.4062px，因此舍入为45px，此时舍弃的0.4062px则合并到下一个box的上； 第三个box的大小此时扩大为45.7031+0.4062=46.1093px，因此舍入为46px，合并到下一个box的宽度为0.1093px； 第四个box的大小扩大为45.7031+0.1093px=45.8124px，因此进位为46px，覆盖下一个节点宽度0.1876px； 第五个box的大小缩减为45.7031-0.1876=45.5155px，因此进位为46px，覆盖后一个节点宽度0.4845px； 第六个box的大小缩减为45.7031-0.4845=45.2186px，因此舍入45px，合并到下一个节点宽度为0.2186px； 第七个box的大小扩大为45.7031+0.2186=45.9217px，因此舍入为46px； 可发现计算结果与显示效果吻合，读者可以通过调整不同的分辨率来测试，根据这个规则都能预测正确结果。 结论 采用scale、zoom、viewport等缩放方案实现的1px，由于实际上为0.5px的CSS像素，导致其有可能被上一个DOM节点所覆盖，从而导致其大小小于0.5px，进而导致其被舍入为0px，所以才会消失不见。 而采用border-image方式则不会消失，由于border-image方案的大小为1px的CSS像素，上一个DOM节点无论如何覆盖，最大不过0.499999px，即不超过0.5px，因此即使被覆盖0.499999px，其大小仍为0.511111px，最终效果也是进位到1px，因此该方案实现的1px边框会始终显示。","link":"/2016/04/17/%E6%B6%88%E5%A4%B1%E7%9A%841px/"},{"title":"深入浅出 Node.js の笔记","text":"前端开发人员上手 Node.js 还是需要课补一些服务端知识的。 章一，章二 单线程，使得 Node 不需要像多线程编程那样处处在意状态的同步问题（没有死锁，没有线程上下文交换） exports 对象用于导出当前模块的方法或变量，此外，在模块中还存在一个 module 对象，它代表模块自身，而 exports 是 module 的属性 exports 和 module.exports 的区别: module.exports 初始值为一个空对象 {} exports 是指向的 module.exports 的引用 require() 返回的是 module.exports 而不是 exports require 模块时优先从缓存中加载，而 Node 缓存的是编译和执行之后的对象 require 模块时，可省略扩展名，Node 会依次补足 .js, .json, .node 进行尝试，建议后缀为 .json 和 .node 时带上扩展名 在模块编译过程中，Node 对获取的 JavaScript 文件进行了头尾包装，使其执行在一个包含特定变量（exports，require，module，__filename，__dirname）的闭包中，该闭包返回模块的 exports 属性 章三 阻塞 IO: 等到系统内核层面完成所有操作之后，调用随之结束 非阻塞 IO: 调用之后立即返回（不携带处理完成的数据，因为尚未生成），之后还得通过文件描述符再次读取数据 非阻塞 IO 返回之后，CPU 时间片可以用于处理其它事务，但为了获取完整数据需要轮询，以判断操作是否完成 轮询满足了非阻塞 IO 确保获取完整数据的需求，但是对于应用程序而言，它仍然是一种同步，因为应用程序仍然需要等待 IO 完全返回 Node 的单线程仅仅是指 JavaScript 执行在单线程中，内部另有线程池完成 IO 任务 Node 经典的调用方式: 从 JavaScript 调用 Node 的核心模块；核心模块调用 C++ 内建模块；内建模块通过 libuv 进行系统调用（其中 libuv 作为封装层，有两个平台的实现） Node 的异步: 第一部分：JavaScript 调用立即返回；接着在进行系统调用过程中，创建了一个请求对象，该对象包含了从JavaScript 层传入的参数和当前方法，以及回调函数；接着将该对象推入系统的线程池中等待执行，而不用在乎该操作是否阻塞 IO 第二部分：线程池中的 IO 操作调用完毕之后，将 IO 结果通知并归还线程；此时在每次 Tick 的执行中，会调用特定方法检查线程池中是否有执行完的请求；若存在则将请求对象加入到 IO 观察者的队列中，然后将其当做事件处理 setTimeout 与 setInterval 的定时并不精确，相比 process.nextTick 更为浪费性能 process.nextTick 在每轮循环中将数组中的回调函数全部执行完毕，而 setImmediate 则在每轮循环中执行链表中的一个回调函数 章四 雪崩: 在高访问量，大并发量的情况下缓存失效的情景，此时大量的请求同时涌入数据库中数据库无法同时承受如此大的查询请求，进而往前影响到网站整体的响应速度 使用 once 解决雪崩问题: 1234567891011const proxy = new events.EventEmitter();let status = 'ready';const select = function(callback) { proxy.once('selected', callback); if(status === 'ready') { status = 'pending'; db.select('SQL', (ret) =&gt; { proxy.emit('selected', ret); status = 'ready'; }); }}; 将所有请求回调都压入事件队列中，使用 once 保证每个回调只会被执行一次，对于相同的 SQL 语句，保证只查询一次；SQL 在进行查询时，新到来的相同调用只需在队列中等待就绪即可，一旦查询结束，得到的结果可以被这些调用共同使用（因为都监听了 ‘selected’ 事件） 尾触发: next() 机制 章五 解除引用：delete 操作和重新赋值具有相同的效果，在 V8 中通过 delete 删除对象的属性有可能干扰V8的优化，所以建议使用赋值方式。 无法立即回收的内存有闭包和全局变量引用这两种情况。由于V8的内存限制，要十分小心此类变量是否无限制地增加，因为它会导致老生代中的对象增多。 堆中的内存总是小于进程的内存，这意味着 Node 中的内存使用并非都是通过 V8 进行分配的。那些不是通过 V8 分配的内存称为堆外内存。例如 Buffe r对象，它不经过V8的内存分配机制，所以也不会有堆内存的大小限制。 由于模块的缓存机制，模块是常驻老生代的。在设计模块时，要十分小心内存泄漏的出现。在下面的代码，每次调用 leak() 方法时，都导致局部变量 leakArray 不停增加内存的占用，且不被释放： 1234var leakArray = [];exports.leak = function () { leakArray.push(&quot;leak&quot; + Math.random());}; 如果模块不可避免地需要这么设计，那么请添加清空队列的相应接口，以供调用者释放内存。 ​ 深度的解决方案应该是监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。 另一个解决方案是任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值。 由于V8的内存限制，我们无法通过fs.readFile()和fs.writeFile()直接进行大文件的操作，而改用fs.createReadStream()和fs.createWriteStream()方法通过流的方式实现对大文件的操作。 章六 如果需要超过 8 KB 的 Buffer 对象，将会直接分配一个 SlowBuffer 对象作为 slab 单元，这个 slab 单元将会被这个大 Buffer 对象独占。 上面提到的 Buffer 对象都是 JavaScript 层面的，能够被 V8 的垃圾回收标记回收。但是其内部的 parent 属性指向的 SlowBuffer 对象却来自于 Node 中 C++ 层面上的 Buffe r对象，所用内存不在 V8 的堆中。 当进行小而频繁的 Buffer 操作时，采用 slab 的机制进行预先申请和事后分配，使得 JavaScript 到操作系统之间不必有过多的内存申请方面的系统调用。对于大块的 Buffer 而言，则直接使用 C++ 层面提供的内存，而无需细腻的分配操作。 buffer += chunk; 这句代码里隐藏了 toString() 操作，它等价于如下的代码： 1buffer = buffer.toString() + chunk.toString(); 通过预先转换静态内容为 Buffer 对象，可以有效地减少 CPU 的重复使用，节省服务器资源。在 Node 构建的 Web 应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通过预先转换为 Buffer 的方式，使性能得到提升。由于文件自身是二进制数据，所以在不需要改变内容的场景下，尽量只读取 Buffer，然后直接传输，不做额外的转换，避免损耗。 章七 TCP 针对网络中的小数据包有一定的优化策略：Nagle算法。Nagle算法要求缓冲区的数据达到一定数量或者一定时间后才将其发出，所以小数据包将会被Nagle算法合并，以此来优化网络。这种优化虽然使网络带宽被有效地使用，但是数据有可能被延迟发送。 在 Node 中，TCP 默认启用了 Nagle 算法，调用 socket.setNoDelay(true) 关闭 Nagle 算法，使得write() 可以立即发送数据到网络中。另一个需要注意的是，尽管在网络的一端调用 write() 会触发另一端的 data 事件，但是并不意味着每次 write() 都会触发一次 data 事件，在关闭掉 Nagle 算法后，另一端可能会将接收到的多个小数据包合并，然后只触发一次 data 事件。 UDP 与 TCP 同属于网络传输层。TCP 中连接一旦建立，所有的会话都基于连接完成，客户端如果要与另一个 TCP 服务通信，需要另创建一个套接字来完成连接。但在 UDP 中，一个套接字可以与多个 UDP 服务通信，常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，比如音频、视频等。UDP 目前应用很广泛，DNS 服务即是基于它实现的。 报文体部分则抽象为一个只读流对象，如果业务逻辑需要读取报文体中的数据，则要在这个数据流结束后才能进行操作，如下所示： 123456789101112function (req, res) { // console.log(req.headers); var buffers = []; req.on('data', function (trunk) { buffers.push(trunk); }).on('end', function () { var buffer = Buffer.concat(buffers); // TODO res.end('Hello world'); });} HTTP响应对象：它封装了对底层连接的写操作，可以将其看成一个可写的流对象。它影响响应报文头部信息的 API 为 res.setHeader() 和 res.writeHead()。在上述示例中： res.writeHead(200, {‘Content-Type’: ‘text/plain’}); 其分为 setHeader() 和 writeHead() 两个步骤。它在 http 模块的封装下，实际生成如下报文： &lt; HTTP/1.1 200 OK&lt; Content-Type: text/plain 我们可以调用 setHeader 进行多次设置，但只有调用 writeHead 后，报头才会写入到连接中。除此之外，http模块会自动帮你设置一些头信息，如下所示： &lt; Date: Sat, 06 Apr 2013 08:01:44 GMT&lt; Connection: keep-alive&lt; Transfer-Encoding: chunked​ 报文体部分则是调用 res.write() 和 res.end() 方法实现，差别在于 res.end() 会先调用 write() 发送数据，然后发送信号告知服务器这次响应结束。 响应结束后，HTTP 服务器可能会将当前的连接用于下一个请求，或者关闭连接。值得注意的是，报头是在报文体发送前发送的，一旦开始了数据的发送，writeHead() 和 setHeader() 将不再生效。另外，无论服务器端在处理业务逻辑时是否发生异常，务必在结束时调用res.end()结束请求，否则客户端将一直处于等待的状态。 同时 http 模块提供了一个底层 API：http.request(options, connect)，用于构造 HTTP 客户端。 为了重用 TCP 连接，http 模块包含一个默认的客户端代理对象 http.globalAgent。它对每个服务器端（host + port）创建的连接进行了管理，默认情况下，通过 ClientRequest 对象对同一个服务器端发起的 HTTP 请求最多可以创建 5 个连接。 除此之外，WebSocket 与传统 HTTP 有如下好处： 客户端与服务器端只建立一个TCP连接，可以使用更少的连接。 WebSocket服务器端可以推送数据到客户端，这远比HTTP请求响应模式更灵活、更高效。 有更轻量级的协议头，减少数据传送量。 章八基础功能与数据上传 RESTful 类 Web 服务中请求方法： PUT 代表新建一个资源 POST 表示要更新一个资源 GET 表示查看一个资源 而 DELETE 表示删除一个资源 我们可以通过请求方法来决定响应行为，如下所示： 12345678910111213141516function (req, res) { switch (req.method) { case 'POST': update(req, res); break; case 'DELETE': remove(req, res); break; case 'PUT': create(req, res); break; case 'GET': default: get(req, res); }} ​ var url = require('url'); var querystring = require('querystring'); var query = querystring.parse(url.parse(req.url).query); //更简洁的方法是给url.parse()传递第二个参数，如下所示： var query = url.parse(req.url, true).query; // 它会将foo=bar&amp;baz=val解析为一个JSON对象，如下所示： { foo: 'bar', baz: 'val' } 12345678910113. 要注意的点是，如果查询字符串中的键出现多次，那么它的值会是一个数组，如下所示： ```js // foo=bar&amp;foo=baz var query = url.parse(req.url, true).query; // { // foo: ['bar', 'baz'] // } 业务的判断一定要检查值是数组还是字符串，否则可能出现TypeError异常的情况。 Cookie 的处理分为如下几步： 服务器向客户端发送 Cookie。 浏览器将 Cookie 保存。 之后每次浏览器都会将 Cookie 发向服务器端。 HTTP_Parser 会将所有的报文字段解析到 req.headers 上，那么 Cookie 就是 req.headers.cookie。 响应的 Cookie 值在 Set-Cookie 字段中，规范中对它的定义如下所示：Set-Cookie: name=value; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com;其中 name=value 是必须包含的部分，其余部分皆是可选参数。 path 表示这个 Cookie 影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个 Cookie。 HttpOnly 告知浏览器不允许通过脚本 document.cookie 去更改这个 Cookie 值，事实上，设置HttpOnly 之后，这个值在 document.cookie 中不可见。但是在 HTTP 请求的过程中，依然会发送这个Cookie到服务器端。 Secure，当Secure值为true时，在HTTP中是无效的，在HTTPS中才有效，表示创建的Cookie只能在HTTPS连接中被浏览器传递到服务器端进行会话验证，如果是HTTP连接则不会传递该信息，所以很难被窃听到。 如果在域名的根节点设置 Cookie，将使得几乎所有子路径下的请求都会带上这些Cookie。 解决方法：为静态组件使用不同的域名 为不需要 Cookie 的组件换个域名减少无效 Cookie 的传输。 同时还可以突破浏览器下载线程数量的限制，因为域名不同，可以将下载线程数翻倍。 缺点是域名转换为 IP 需要进行 DNS 查询，多一个域名就多一次 DNS 查询。 为了解决 Cookie 敏感数据的问题，Session 的数据只保留在服务器端，使数据的安全性得到一定的保障。 两种方式： 第一种：基于Cookie来实现用户和数据的映射 第二种：通过查询字符串来实现浏览器端和服务器端数据的对应 注: 用户访问 http://localhost/pathname 时，如果服务器端发现查询字符串中不带 session_id 参数，就会将用户跳转到 http://localhost/pathname?session_id=12344567 这样一个类似的地址。如果浏览器收到302状态码和Location报头，就会重新发起新的请求。 有的服务器在客户端禁用Cookie时，会采用这种方案实现退化。通过这种方案，无须在响应时设置Cookie。但是这种方案带来的风险远大于基于Cookie实现的风险，因为只要将地址栏中的地址发给另外一个人，那么他就拥有跟你相同的身份。Cookie的方案在换了浏览器或者换了电脑之后无法生效，相对较为安全。 为了解决性能问题和 Session 数据无法跨进程共享的问题，常用的方案是将 Session 集中化，将原本可能分散在多个进程里的数据，统一转移到集中的数据存储中。工具有 Redis、Memcached 等，通过这些高效的缓存，Node 进程无须在内部维护数据对象，垃圾回收问题和内存限制问题都可以迎刃而解，并且这些高速缓存设计的缓存过期策略更合理更高效，比在Node中自行设计缓存策略更好。 采用第三方缓存来存储 Session 引起的一个问题是会引起网络访问。理论上来说访问网络中的数据要比访问本地磁盘中的数据速度要慢，因为涉及到握手、传输以及网络终端自身的磁盘I/O等，尽管如此但依然会采用这些高速缓存的理由有以下几条： Node 与缓存服务保持长连接，而非频繁的短连接，握手导致的延迟只影响初始化。 高速缓存直接在内存中进行数据存储和访问。 缓存服务通常与Node进程运行在相同的机器上或者相同的机房里，网络速度受到的影响较小。 ETag: 由服务端生成，服务端还可以决定它的生成规则，例如根据文件内容生成 Hash 值 数据上传与安全： 内存限制：1. 限制上传内容的大小，一旦超过限制，停止并响应 400 状态码；2. 通过流式解析，将数据流导向磁盘中，Node 只保留文件路径等小数据 CSRF：跨站请求伪造，可为每个请求的用户在 Session 中赋予一个随机值 路由解析与中间件 MVC Controller，一组行为的集合 Model，数据相关的操作和封装 View，视图的渲染 require 的缓存机制使得只有在首次 require 时是阻塞的 RESTful：将服务器端提供的内容看做一个资源，对该资源的操作只要体现在 HTTP 请求方法上： POST /user/tihu DELETE /user/tihu PUT /user/tihu GET /user/tihu Connect 中间件使用 next() 进行尾触发 中间件与性能： 编写高效的中间件：提高单个处理单元的处理速度，以尽早调用 next()；缓存需要重复计算的结果；避免不必要的计算 合理使用路由：例如只处理静态资源的中间件，可限定路由（app.use(‘/public’, statcFile))，从而避免对整站都处理 章九 创建子进程：child_process 模块的四种方法 spawn() 启动一个子进程来执行命令 exec() 与 spawn 不同，它多了一个用于获知子进程状况的回调 execFile() 启动一个子进程来执行可执行文件 fork() 与 spawn 类似，不同点在于创建的子进程只需指定 JavaScript 文件模块 注：其中 2，3 可设置超时 子进程对象的 send() 方法支持发送以下五种类型的句柄 net.Socket，TCP 套接字 net.Server， TCP 服务器 net.Native， C++ 层面的 TCP 套接字或 IPC 管道 dgram.Socket，UDP 套接字 dgram.Native， C++ 层面的 UDP 套接字 多个应用监听相同端口时，文件描述符同一时间只能被某个进程所用，即抢占式的，因此只有一个进程能够抢到连接 除了 send() 外，还能通过 kill() 方法给子进程发送消息，kill() 方法只是给子进程发送了一个系统信号，进程在收到这些系统信号时，做出约定的行为 自杀信号：当所有进程都处于等待退出状态，并停止接收新连接，如果等到进程退出才重启，则此时新来的请求可能存在没有工作进程为新用户服务的情景，从而丢失请求；解决方法是在子进程决定退出前主动向父进程发送一个 “自杀信号” 通知父进程，使得父进程能够及时创建新进程。 限量重启：当重启过于频繁时，主动通知进程放弃重启 状态共享，使用第三方进行数据存储，比如数据库，磁盘文件，缓存服务（如 Redis），因此需要一种机制通知各个子进程：各个子进程向第三方进行定时轮询 状态共享，主动通知，可设计一个进程只进行轮询和通知，如果想跨越多台服务器，可采用 UDP 或 TCP 方案 章十 单测原则 单一职责 接口抽象 层次分离 TDD：测试驱动开发；BDD：行为驱动开发；二者差别： 关注点不同，TDD 关注所有功能是否被正确实现，每个功能对应一个测试用例；BDD 关注整体行为是否符合预期，适合自顶向下的设计方式 表达方式不同，TDD 偏向于功能说明书风格，而 BDD 更接近与自然语言的习惯 BDD：before 与 after 分别在进入和退出 describe 时触发，beforeEach 与 afterEach 分别在 describe 中的每个测试用例执行前和执行后触发 性能测试 基准测试，统计在多少时间内执行了多少次某个方法 压力测试，对网络接口进行压测的指标主要有吞吐率，响应时间和并发数","link":"/2016/12/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Node.js%20%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"title":"第十一届 D2 会议的观后感与总结","text":"生平第一次参加这种技术会议，围观各种前端界网红，感觉知乎和微博里的网红都触手可及，记下这篇观后感与总结。 Weex 在双十一会场的大规模应用 鬼道 淘宝 相比去年双十一，weex 在今年双十一的主会场中几乎都使用了 weex DOM 嵌套不要太深，否则将导致性能问题 长列表滚动-性能问题，H5 lazy load 体验不好，原生好于 weex 帧率方面，weex 在 Android 与 iOS 上表现一致，而 H5 在低端机上（特别是 Android）表现较差 iOS 中打开多个 weex 页面，使得内存占用过大而导致 crash 解决方案： 主会场单实例 push 页面设置上限（双十一中上限为 5） H5 降级方案，不过几乎没开启 iOS JSCore 内存，通过分析 JS Heap，发现是 JS 引用持有导致的内存不释放（好奇 Android 为什么没有问题，是安卓内存够大不在乎吗？） 通过预加载提高页面秒开率： a. App 启动预先下载 JS； b. 通过长连通道 push； c. 本地 IO； d. 平台自动化对接； framework &amp; bundle 分离，共有逻辑前置 + 异步执行 Node &amp; Tree 渲染结合 Node: 最小颗粒度渲染 解析 DOM 后立即显示 不会长时间阻塞主线程 可能造成多次冗余的 Layout Tree: 块级渲染 只需 Layout 一次 可能阻塞主线程 weex 存在的缺点 发布无灰度 缺失兼容性与性能验收 线上监控未到人 组件生态相比 RN，差距大 富交互能力 常用 API 未来会丰富组件市场，同时添加研发支撑（上述1-3） XCore —蘑菇街移动端动态跨平台开发框架 蘑菇街 王兴楠 移动端业务场景定制的一套动态跨平台开发框架，但是目前并不开源 XCore 封装了底层，自称新造了轮子，而不需要改变现有框架的编码方式(Vue.js，React，DOM)，即车不需要变 与 weex / react-native 差异，三棵树，DOM tree，Shadow tree ，Native tree 以 Web 的方式快速开发与部署可运行于三端（H5，Android，iOS）的代码 实现了一套标准的 Web 子集 对比 RN，Weex： a. 定位不同，解决特定业务场景的问题，并不是一个业界通用的开源方案 b. 目标不同，采用了一个浏览器的架构，不绑定固定的前端框架 只要使用的 DOM 层面或者是模板的层面，在 XCore 模板范围内就可以. 基于云端真机的无线调试解决方案 淘宝 肖焉 真机放置在机房中，远程申请进行调试，只对阿里集团内部开放，对外开放已在计划中。 这种核心竞争力大概不会对外开放吧。 蚂蚁财富的 BFF 实践 蚂蚁金服 汤 尧 BFF: Backends for Frontends，复杂环境的必然产物 核心思想 在前端页面与后端 Java 间加入一层 Node，使 Node 直接调用 Java jar 包(hessian)，Node 层完成多端 API 接入、裁剪、格式化、聚合编排，从而控制接口数量，规范数据格式，只把用户关心的数据输出给界面，同时也方便了数据的 mock 业务现状 服务层 API 相对稳定 体验者 API 经常变化 场景 多APP适配： Error code 统一管理 数据一致性 免登 业务日志… 聚合 简化客户端逻辑，减少网络开销（毕竟有些后端接口的数据，前端可能只需要获取其中的一部分） 敏感信息过滤（我朝你懂的） Node.js 在 YunOS 中的最佳实践 YunOS 逸臻 把 Node.js 引入到 YunOS 的基础架构中 对 IO 优先的 Looper 机制的改造和优化 Node.js 的消息循环机制完全由 IO 事件来驱动 终端设备的场景在 UI 渲染及非 IO 任务的及时响应的需求 解决：将系统任务与 Node.js 的 IO 任务融合，二者地位基本相当，系统任务优先级略高；系统任务通过异步事件接入 Node.js 的队列中 性能优化 将系统级 JS 模块合并加载，减少 IO 次数 Code cache，预先将 JavaScript 代码编译成 cache 文件，运行时直接加载 cache 文件，调过编译过程 require 的懒加载，require 时不真正加载模块，而是在第一次访问对象的时候进行加载，从而减轻启动时的压力，优化启动时间 提出模块可卸载概念，不过这样的话，是否顶部 require 的模块并不是都用的了？因为无法获知该模块是否在某个地方被卸载了 NW.js: 集成DOM和Node.js的编程方式 Intel 王文睿 NW.js (原名 node-webkit )通过集成 Chromium 和 Node.js感觉枯燥，讲的不好，回答问题也不诚心 在 DOM 中直接调用 Node.js 介绍 NW 的主要功能和最新进展 个人比较看好 electron，成熟应用比较多（Atom, VSCode)，社区支持比较好 从 React 到 ClojureScript 饿了么 题叶 主要介绍了一些函数式编程的概念 JavaScript 有种通过自我阉割来实现函数式编程 介绍性较多，走马观花 大数据下的前端优化实战 UC 庞锦贵 借助 UC 浏览器的海量用户产生的大数据，针对特定场景的一些优化（场景性特别强，有点 hack） 通过在浏览器内核打点的方式进行数据分析（希望我司未来的客户端 webview 实现类似的打点分析）","link":"/2016/12/24/%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%20D2%20%E4%BC%9A%E8%AE%AE%E6%80%BB%E7%BB%93/"},{"title":"给你心爱的 npm 包上个『北京户口』","text":"记录解决如何批量将 npm 包从一个 npm 源迁移到另一个源 背景一切从我司有两个 npm 源说起，一个叫杭州源，另一个叫北京源。本来各用各的相安无事，直到有一天我们想依赖另一个源的 npm 包时，就相互拉取不到对方的源了。杭州源这边也有做过兼容，当拉取的源不存在时，就尝试去北京源拉取，看似解决了这个问题。但是这只解决了我们依赖北京源的 npm 包的问题，而我们有大量的包需要推广到其它部门，因此我们决定切换到使用人数更多的北京源，目前团队正处于集体转向使用北京源的阶段，不过经常会遇到如下问题： 项目拉取下来，执行 npm install，提示某些包不存在，然后查看当前源，切换到另一种源，继续 npm install； 老项目使用杭州源，但是依赖了北京源的 npm 包，虽然杭州源会在拉取不到包时主动向北京源拉取，但是这个机制经常出问题，有时会阻塞服务的构建，得解决这个依赖问题才能重新构建项目； 新项目使用北京源，但是依赖了杭州源的 npm 包，这个场景比较棘手，北京源没有向杭州源拉取包的机制，因此需要将杭州源的包重新在北京源上发布，如果采用手动发布，版本多的包会很繁琐还容易出错；如果只发布部分包，会导致两边不一致，导致无法拉取到未发布的包； 发布一个包，只向杭州源发布，那使用北京源的项目很可能更新不到你的新版本，反之亦然； 咋整？ 解决思路为了加快结束这个过渡期，需要我们全面切换到北京源，有两个问题需要解决： 团队内的杭州源 npm 包的各个版本需要在北京源重新发布一次，除了版本外，dist-tag 也要同步到北京源； 通知团队成员将项目切换到北京源，并不再使用杭州源，如有遗漏未同步到北京源的 npm 包告知我将其同步； 那么，我们团队有多少个包呢？已知的 @kd scope 下的包有 49 个，而更多的包都在 @dd scope 下，目前收集到的有 50 个。假设平均一个包有 10 个版本，那么粗略估计有上千个版本需要重新发布，所以手动是不可能手动的，得想法子通过自动化的方式批量同步。 来看看到底咋整吧！ 实现方式作为一个前端开发，当然选择 Node.js 来编写脚本或命令行工具解决这种重复劳动了！先来回顾下如何发布一个 npm 包：只要进入 npm 包的根目录，执行 npm publish 即可。所以我们只要找到一个方式能获取到每个包的每个版本的所有代码即可！那有这种方式吗？ 有的，有的！回忆下你使用 npm view 查询一个 npm 包时的情形： 聪明的你肯定发现 .tarball: https://registry.npmjs.org/koa/-/koa-2.13.0.tgz，这个包正是当前最新版本 2.13.0 的 koa 包。下载解压后发现这正是我们要的，只要进入该目录执行 npm publish 即可： 那我们能获取指定版本的 tgz 包吗？当然，使用 npm view koa@1.0.0 即可查看指定版本。等等，我没法知道当前 koa 包有哪些版本诶？别慌，试试这个命令 npm view koa --json，答案就藏在 versions 字段里： 此外 dist-tags 字段也需要同步（ 默认不同步 tag，这有可能导致杭州源的 tag 覆盖了北京源的 tag，而杭州源的 tag 可能不是最新的）。 目前万事俱备，离搞定只差一个程序猿了！核心逻辑即是根据包名拉取所有版本的 tgz 压缩包，同时解压所有 tgz 压缩包，进入对应目录执行 npm publish： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 获取该包的所有版本let resulttry { result = await execa.command(`npm view ${npmPacakgeName} --json --registry=${from}`)} catch (error) { // 查询失败的日志写入文件，方便追踪 console.log(chalk.red(`获取列表失败：${npmPacakgeName}`)) const content = await fs.readFile(errorLogFile) await fs.writeFile(errorLogFile, `${content}\\n获取列表失败：${npmPacakgeName}: ${error.stack}`) return}const json = result.stdout ? eval(`temp = ${result.stdout}`) : {}const tagTaskList = Object.keys(json['dist-tags']).map(npmPackageTag =&gt; { return async () =&gt; { try { await execa.command(`npm dist-tag add ${npmPacakgeName}@${json['dist-tags'][npmPackageTag]} ${npmPackageTag} --registry=${to}`) console.log(chalk.green(`成功同步 tag：${npmPacakgeName}@${npmPackageTag}`)) } catch (error) { // 发布失败的日志写入文件，方便追踪 console.log(chalk.red(`tag 添加失败：${npmPacakgeName}@${json['dist-tags']}`)) const content = await fs.readFile(errorLogFile) await fs.writeFile(errorLogFile, `${content}\\ntag 添加失败：${npmPacakgeName}@${json['dist-tags']}: ${error.stack}`) } }})const publishTaskList = json.versions &amp;&amp; json.versions.map(npmPacakgeVersion =&gt; { // 该包每个版本的处理逻辑 return async () =&gt; { try { // 如果 ${to}已经存在该版本，则不处理 // FIXME: 处理 ${to}不存在该包的情况 let result try { result = await execa.command(`npm view ${npmPacakgeName}@${npmPacakgeVersion} --registry=${to}`) if (result.stdout) { console.log(chalk.green(`已存在于 ${to}，无需同步：${npmPacakgeName}@${npmPacakgeVersion}`)) return } } catch (error) { if (!error.message.includes('npm ERR! code E404')) { throw error } } // 去除形如 @scope 的字符串 const packagePath = path.join(__dirname, npmPacakgeName, `${npmPacakgeName.replace(/@.*\\//, '')}-${npmPacakgeVersion}`) const tgzPath = `${packagePath}.tgz` // 下载包 await download( `${from}/${npmPacakgeName}/download/${npmPacakgeName}-${npmPacakgeVersion}.tgz`, npmPacakgeName ) // 解压包 await compressing.tgz.uncompress( tgzPath, packagePath ) // 删除压缩包 await execa.command(`rm ${tgzPath}`) // 发布 await execa.command(`npm publish --tag=sync --registry=${to}`, { cwd: path.join(packagePath, 'package') }) console.log(chalk.green(`${npmPacakgeName}@${npmPacakgeVersion} 成功同步 ${to}！`)) } catch (error) { // 发布失败的日志写入文件，方便追踪 console.log(chalk.red(`version 发布失败：${npmPacakgeName}@${npmPacakgeVersion}`)) const content = await fs.readFile(errorLogFile) await fs.writeFile(errorLogFile, `${content}\\nversion 发布失败：${npmPacakgeName}@${npmPacakgeVersion}: ${error.stack}`) } }})// 限制并行数为 5，防止 npm 网站报错await Promise.all(publishTaskList.map(pLimit(5)))// 修复所有 tag，并行会导致不成功，此处改为串行// 默认不同步 tag，有可能导致${from}的 tag 覆盖了 ${to}的 tag，而${from}的 tag 可能不是最新的if (options.syncTag) { await Promise.all(tagTaskList.map(pLimit(1)))} 请留意并行问题，并发量太大 npm 网站会报错（估计被拦截了）。 如何使用本来仅提供脚本执行方式，为了让大家也能方便使用（不要再叫我同步了）。贴心的我已把这个脚本实现为一个命令行工具，使用方式如下： 内部工具，此处不提供，大伙可自行实现 安装命令行npm i @dd/npm-sync -g 执行版本同步npm-sync packageName 执行版本和tag同步npm-sync packageName --syncTag=true 更多使用方式npm-sync --help TODOS 欢迎提交代码 支持『发布前有编译钩子』的包 登录前置校验","link":"/2020/09/27/%E7%BB%99%E4%BD%A0%E5%BF%83%E7%88%B1%E7%9A%84%20npm%20%E5%8C%85%E4%B8%8A%E4%B8%AA%E5%8C%97%E4%BA%AC%E6%88%B7%E5%8F%A3/"},{"title":"redux 中间件入门到编写，到改进，到出门","text":"春江花月夜调 bug，孤独寂寞日著 blog。吾母昨夜托梦，吾儿只身在外，读书撩妹两手要抓，前端知识切莫荒废。如无对象可面向，可以学学函数式。多写代码少睡觉，还有周五的周报。redux 要会，middleware 能写，有空记得写博客，写好发给我看看。 惊醒之余，其敦敦教诲不敢忘，乃正襟危坐，挑灯写下这篇博客，感动~ redux 中间件redux 提供了类似 Web 开发的中间件机制，Web 中经过中间件的是一个个请求，而 redux 中经过中间件的是一个个 action，使得开发人员能够在中间件中针对特定 action 进行各种统一的处理，比如日志打印，数据请求，错误处理等。 如何使用redux 提供 applyMiddleware 方法，通过如下方式即可应用中间件： 1234567891011121314151617import { createStore, applyMiddleware, compose,} from 'redux'import nextAndRequest from './middleware/redux-next-and-request'import errorCatcher from './middleware/redux-error-catcher'import reducer from '../reducer'const createStoreWithMiddleware = compose( applyMiddleware( nextAndRequest, errorCatcher, ), DevTools.instrument(), window.devToolsExtension(),)(createStore) 实现原理compose 函数此处有个神奇的函数，即 compose，该函数在 applyMiddleware 中也是核心代码，正是它实现了 redux 中间件的机制，我们来看看 compose 的源码： 12345678910111213141516171819202122/** * Composes single-argument functions from right to left. The rightmost * function can take multiple arguments as it provides the signature for * the resulting composite function. * * @param {...Function} funcs The functions to compose. * @returns {Function} A function obtained by composing the argument functions * from right to left. For example, compose(f, g, h) is identical to doing * (...args) =&gt; f(g(h(...args))). */export default function compose(...funcs) { if (funcs.length === 0) { return arg =&gt; arg } if (funcs.length === 1) { return funcs[0] } return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))} 从注释中可知，它的作用是从右到左将多个函数组合成一个新函数，其中最右边的函数消耗了该新函数的参数，并逐级向左作为参数依次执行； 执行 compose(f1, f2, f3) 可得 (…args) =&gt; f1(f2(f3(…args)))；核心操作为 reduce，详细使用方式可参看文档 12345678910111213141516第一次 reduce previousValue: f1; currentValue: f2; returnValue: (...args1) =&gt; f1(f2(...args1)) // 记为 R1第二次 reduce previousValue: R1 currentValue: f3; returnValue: (...args2) =&gt; R1(f3(...args2)) // 记为 R2其中 R2:(...args2) =&gt; ((...args1) =&gt; f1(f2(...args1)))(f3(...args2))此时传入 args 执行 R2：第一步： 得到 ((...args1) =&gt; f1(f2(...args1)))(f3(args)) // 记为 R3第二步：f3(args) 即是 R3 的参数 (...args1)，继续执行可得 f1(f2(f3(args))) 其实之前这个 compose 方法不是使用 reduce 实现的，而是使用 reduceRight 实现 composeRight，因此对比新版实现，比较好理解，原来的版本为： 新版 Merge Request新版的方式使用惰性求值，性能有提升 1234567891011121314151617181920212223242526/** * Composes single-argument functions from right to left. The rightmost * function can take multiple arguments as it provides the signature for * the resulting composite function. * * @param {...Function} funcs The functions to compose. * @returns {Function} A function obtained by composing the argument functions * from right to left. For example, compose(f, g, h) is identical to doing * (...args) =&gt; f(g(h(...args))). */export default function compose(...funcs) { if (funcs.length === 0) { return arg =&gt; arg } funcs = funcs.filter(func =&gt; typeof func === 'function') if (funcs.length === 1) { return funcs[0] } const last = funcs[funcs.length - 1] const rest = funcs.slice(0, -1) return (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))} 让我们回到： 12345678const createStoreWithMiddleware = compose( applyMiddleware( nextAndRequest, errorCatcher, ), DevTools.instrument(), window.devToolsExtension(),)(createStore) createStoreWithMiddleware 的最终值为： 1applyMiddleware(nextAndRequest,errorCatcher)(DevTools.instrument()(window.devToolsExtension()(createStore))) applyMiddleware 函数其源码如下： 12345678910111213141516171819202122232425262728293031323334353637import compose from './compose'/** * Creates a store enhancer that applies middleware to the dispatch method * of the Redux store. This is handy for a variety of tasks, such as expressing * asynchronous actions in a concise manner, or logging every action payload. * * See `redux-thunk` package as an example of the Redux middleware. * * Because middleware is potentially asynchronous, this should be the first * store enhancer in the composition chain. * * Note that each middleware will be given the `dispatch` and `getState` functions * as named arguments. * * @param {...Function} middlewares The middleware chain to be applied. * @returns {Function} A store enhancer applying the middleware. */export default function applyMiddleware(...middlewares) { return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; { const store = createStore(reducer, preloadedState, enhancer) let dispatch = store.dispatch let chain = [] const middlewareAPI = { getState: store.getState, dispatch: (action) =&gt; dispatch(action) } chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return { ...store, dispatch } }} 一个 redux 中间件的结构： 123store =&gt; next =&gt; action =&gt; { // 中间件逻辑代码} 假设有三个中间件 M1, M2, M3，应用 applyMiddleware(M1, M2, M3) 将返回一个闭包函数，该函数接受 createStore 函数作为参数，使得创建状态树 store 的步骤在这个闭包函数内执行;接着将 store 重新组装成 middlewareAPI 作为新的 store，也就是我们编写的中间件最外层函数的参数 store，这样中间件就可以根据状态树进行各种操作了。 可以发现重新组装之后的 store 只有两个方法，一个是用户获取 state 的 getState 方法，另一个是用于分发 action 的 dispatch，而 setState、subscribe、replaceReducer 等方法则不提供，setState 在设置状态时重新 render 可能会触发新的 action 而导致死循环；setState 本身就是用于订阅每个 dispatch 操作，此时 dispatch 就在你手上（next)，根本不需要订阅；replaceReducer 用于动态加载新的 reducer，我猜你用不到。 将中间件数组中的函数逐一传入参数 middlewareAPI 并执行，从而得到 chain 数组，此时 chain 数组中的每个函数长这样： 123next =&gt; action =&gt; { // 中间件逻辑代码} 核心代码解读 dispatch = compose(…chain)(store.dispatch) 假设 chain 是包含 C1, C2, C3 三个函数的数组，那么 compose(…chain)(store.dispatch) 即是 C1(C2(C3(store.dispatch))), 因此易知： applyMiddleware 的最后一个中间件 M3 中的 next 就是原始的 store.dispatch; M2 中的 next 为 C3(store.dispatch); M1 中的 next 为 C2(C3(store.dispatch)); 最终将 C1(C2(C3(store.dispatch))) 作为新的 dispatch 挂在 store 上返回给用户，因此这就是用户切实调到的 dispatch 方法，既然层层执行了 C3，C2, C1，那么一个中间件已经被拆解为： 123action =&gt; {} 触发 action 的完整流程有了这个 dispatch 方法和被扒光的中间件，我们来梳理一遍当用户触发一个 action 的完整流程： 手动触发一个 action：store.dispatch(action)； 即调用 C1(C2(C3(store.dispatch)))(action)； 执行 C1 中的代码，直到遇到 next(action)，此时 next 为 M1 中的 next，即：C2(c3(store.dispatch))； 执行 C2(c3(store.dispatch))(action)，直到遇到 next(action)，此时 next 为 M2 中的 next，即：C3(store.dispatch)； 执行 C3(store.dispatch)(action)，直到遇到 next(action)，此时 next 为 M3 中的 next，即：store.dispatch； 执行 store.dispatch(action)，store.dispatch 内部调用 root reducer 更新当前 state； 执行 C3 中 next(action) 之后的代码 执行 C2 中 next(action) 之后的代码 执行 C1 中 next(action) 之后的代码 即：C1 -&gt; C2 -&gt; C3 -&gt; store.dispatch -&gt; C3 -&gt; C2 -&gt; C1 洋葱模型有没有!!! 如何编写讲了这么多，终于切入正题，开始写中间件了，目标是实现中间件，使得异步请求，错误处理都能经由中间件处理；而不需要每次手动繁琐的发起异步请求，同时每个异步请求语句之后都手动处理错误代码。 先从简单的错误处理中间件开始~ 错误处理中间件通过检测 action 上是否存在 error 字段，来决定是否抛出错误 1234567891011121314151617import { notification } from 'antd'export default store =&gt; next =&gt; async action =&gt; { try { if(action.error) { throw new Error(action.error) } else { next(action) } } catch (err) { notification.error({ message: '错误信息', description: err.message }); throw err }} 当发现 action 中有 error 字段，则抛出错误，这个字段可由上游中间件出错后，将对应的错误信息挂在 action.error 上，使得本中间件能够处理这个错误，由于项目基于 antd，此处将所有错误都通过 notification 组件在右上角弹窗显示； 如果做成通用的错误处理的话，可以再包一层函数，传入错误处理函数，便能够自定义错误处理函数了： 123456789101112export default handler =&gt; store =&gt; next =&gt; action =&gt; { try { if(action.error) { throw new Error(action.error) } else { next(action) } } catch (err) { handler &amp;&amp; handler(err) throw err }} 则使用方式变为： 123456789101112const createStoreWithMiddleware = compose( applyMiddleware( nextAndRequest, errorHandler(err =&gt; { notification.error({ message: '错误信息', description: err.message }) }), ), window.devToolsExtension)(createStore) 异步请求处理中间件版本一通过判断 action 字段上是否用 url 字段来判断是否需要发起异步请求，同时将请求结果挂在 action 的 result 字段上，供下一个中间件或 reducer 使用。 123456789101112131415161718192021222324252627282930313233343536373839404142import request from './request'export default store =&gt; next =&gt; async action =&gt; { if (action.url) { try { const execAction = async act =&gt; { if(act.url) { const { code, data, error, } = await request({ url: act.url, method: act.method || 'get', data: act.data || {}, }) if (code !== 0) { throw new Error(error || '未知错误！') } else { return data } } } const result = await execAction(action) next({ result, ...action }) } catch (error) { next({ error: error.message, }) } } else { next(action) }} 版本二由于本项目大部分情况需要在执行一个异步 action 之后，再重新执行一个异步 action，达到更新当前列表的目的。 例如删除或添加一条记录后，希望更新当前列表信息 因此做如下更改，在 action 上增加一个 nextAction 字段，使得能够在执行当前 action 之后，接着执行一个 action： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import request from './request'export default store =&gt; next =&gt; async action =&gt; { if (action.url || action.nextAction) { try { const execAction = async act =&gt; { if(act.url) { const { code, data, error, } = await request({ url: act.url, method: act.method || 'get', data: act.data || {}, }) if (code !== 0) { throw new Error(error || '未知错误！') } else { return data } } } const result = await execAction(action) next({ result, ...action }) if (action.nextAction) { const act = action.nextAction const nextAction = typeof act === 'function' ? await act(result, action) : act const nextResult = await execAction(nextAction) next({ result: nextResult, lastResult: result, ...nextAction }) } } catch (error) { next({ error: error.message, }) } } else { next(action) }} 为了方便执行一些额外的操作，此处 nextAction 也可以是一个函数，该函数必须返回一个 action，同时将当前 action 的返回值作为回调传入这个函数，nextAction 执行之后，除了将请求结果作为 result 字段挂在 action 之外，还加入了一个 lastResult 字段保存首次 action 的值。 版本三目前只能支持一级 nextAction，如果要支持多级的话，可以传入数组，数组中可以是一个普通的 action，也可以是返回一个 action 的函数，完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// index.jsimport execAction from './exec-action'import execNextAction from './exec-next-action'import isFunction from './is-function'import isArray from './is-array'export default () =&gt; next =&gt; async action =&gt; { if (action.url || action.nextAction) { try { const result = await execAction(action) next({ result, ...action }) if (action.nextAction) { let nextAction = action.nextAction let lastResult = result let lastAction = action if(isFunction(nextAction)) { nextAction = await nextAction(lastResult, lastAction) await execNextAction(nextAction, lastResult, next) } else if(isArray(nextAction)) { let currentAction for( let i = 0; i &lt; nextAction.length; i++ ) { lastAction = nextAction[i - 1] ? nextAction[i - 1] : lastAction currentAction = isFunction(nextAction[i]) ? await nextAction[i](lastResult, lastAction) : nextAction[i] await execNextAction(currentAction, lastResult, next) } } else { await execNextAction(nextAction, lastResult, next) } } } catch (error) { next({ error: error.message, }) } } else { next(action) }} 123// is-array.jsexport default param =&gt; Array.isArray(param) 123// is-function.jsexport default param =&gt; typeof param === 'function' 1234567891011121314151617181920212223242526272829// request.jsimport reqwest from 'reqwest'export default async opts =&gt; { const defaultOpts = { type: 'json', url: `/routers${opts.url}`, } const finalOpts = { ...opts, ...defaultOpts, } let ret try { ret = await reqwest(finalOpts) return ret } catch (e) { try { ret = JSON.parse(e.response) } catch (e) { ret = e.message } return ret }} 123456789101112131415161718192021222324// exec-action.jsimport request from './request'export default async act =&gt; { if(act.url) { const { code, data, error, } = await request({ url: act.url, method: act.method || 'get', data: act.data || {}, }) if (code !== 0) { throw new Error(error || '未知错误！') } else { return data } }} 12345678910111213// exec-next-action.jsimport execAction from './exec-action'export default async (nextAct, lastResult, next) =&gt; { const result = await execAction(nextAct) next({ result, lastResult, ...nextAct })} 如此这般，便能开心的写页面了~好了，我要发给我妈看看。","link":"/2017/03/18/%E7%BC%96%E5%86%99%20redux%20%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"title":"编写可维护的 JavaScriptの笔记","text":"第一部分主要涉及编程风格，为了让团队的代码看起来如出一人之手；第二部分为编程实践，学到了很多关于 JavaScript 的编程经验；第三部分是关于自动化的，介绍的工具链，在 2016 年底看来已经相当过时。 编写可维护的 JavaScriptの笔记第一部分 基本格式化 建议在每个流程控制语句（比如 if 和 for 语句）之前添加空行 变量命名应当以名词为前缀，而函数命名则以动词为前缀，常用动词约定： 动词 含义 can 返回布尔值 has 返回布尔值 is 返回布尔值 get 返回非布尔值 set 用于保存一个值 常量约定使用大写字母书写，单词之间使用下划线分隔 使用 null 的场景（理解为对象的占位符） a. 初始化一个变量，该变量可能赋值为一个对象 b. 用来和一个已经初始化的变量（可以是也可以不是一个对象）比较 c. 当函数的期望是对象时，用作参数传入 d. 当函数的返回值期望是对象时，用作返回值传出 null == undefined // true typeof null === object // true 注释前留出空行，文件头部除外 不符常理，有意为之的代码最好注释 声明语句之后留出空行 原始包装类型：String、Boolean、Number，原始值本身并不具有对象特性 第二部分 使用单全局变量，将变量统一挂载到一个具体的全局变量上 可在全局对象的第一层级创建对象以作为命名空间 使用函数包装器创建零全局变量场景： 1234(function(win) { let doc = window.document; // your code}(window)); 隔离应用逻辑，例如将事件处理程序封装到一个全局对象中 123456789const MyApp = { handleClick: e =&gt; { this.showPopup(e); }, showPopup: e =&gt; { // 事件逻辑代码 }，}； 不要分发事件对象，仅分发需要的参数 123456789const MyApp = { handleClick: e =&gt; { this.showPopup(e.clientX, e.clientY); }, showPopup: (x, y) =&gt; { // 事件逻辑代码 }，}； 尽量让事件处理程序成为接触到 event 对象的唯一函数，经过4、5、6，使得代码更易于测试 123456789101112const MyApp = { handleClick: e =&gt; { e.preventDefault(); e.stopPropagation(); this.showPopup(e.clientX, e.clientY); }, showPopup: (x, y) =&gt; { // 事件逻辑代码 }，}； frame A 中的对象传入 frame B，则相当于每个 frame 都有一份拷贝，使得： 123456// trueframeAObjInstance instanceof frameAObj//falseframeAObjInstance instanceof frameBObj// 同样适用于 Function 与 Array，因为每个 frame 中都个各自的构造函数 Array.isArray 判断数组 判断某个对象是否存在某个属性值（避免属性假值，不建议 if(obj[‘count’])，使用 in 操作符，或者 hasOwnProperty() 方法 抽离配置数据（硬编码值） 抛出错误就像给自己留下为什么出错的便签 包装器模式和适配器模式唯一的不同是前者创建新接口，后者实现已存在的接口 避免使用特性推断和浏览器推断，酌情使用特性检测和用户代理检测","link":"/2016/11/27/%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%20JavaScript%20%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"title":"编译&amp;构建现代JS应用","text":"给合作部门的客户端同学科普如何《编译&amp;构建现代JS应用》！","link":"/2020/05/30/%E7%BC%96%E8%AF%91&%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3JS%E5%BA%94%E7%94%A8/"},{"title":"记一次 Webview Jsbridge 接口封装","text":"由于我司原有的 Jsbridge 方案调用繁琐, 参数多层嵌套, 并在多个 APP 上存在兼容性问题, 引来我司前端开发人员的一致吐槽… 前因客户端开发人员站在自己的角度上, 根据前端需要使用的功能设计出了一套 Jsbridge 交互方案, 该方案虽然能很好地完成 native 与 h5 页面的相互调用对方的函数(方法), 但是由于没有充分考虑到前端开发的使用习惯, 导致该方案难以推广, 作为我司前端的一员, 恰好又被分在了公共组, 觉得十分有必要封装一层对前端开发人员友好的 API. 新旧对比旧的方式 同步接口 1234const data = { &quot;action&quot;: &quot;doLogin&quot;}bridge.send(JSON.stringify(data)); 异步接口 123456const data = { &quot;action&quot;: &quot;isLogin&quot;}bridge.send(JSON.stringify(data), (response) =&gt; { alert(response === 'true');}); 优缺点 优点: 1.接口统一使用bridge.send方式执行 缺点: 1.参数为多层JSON格式, 比较繁琐, 2.参数众多, 容易写错, 3.语义化不足, 调用起来不直观 例如:closeWebView 关闭当前 webview ，并向下一个打开的 webview 传递 message 信息 123456789101112131415161718192021222324//发送参数const data = { &quot;action&quot;: &quot;closeWebView&quot;, &quot;params&quot;: { &quot;message&quot;: { &quot;action&quot;: &quot;prePageClose&quot;, &quot;params&quot;: { &quot;message&quot;: &quot;data form previous page&quot; } } }}bridge.send(JSON.stringify(data));//在上一个 webview 中需要初始化 bridge.init 来监听消息bridge.init((data) =&gt; { data === JSON.stringify({ &quot;action&quot;: &quot;prePageClose&quot;, &quot;params&quot;: { &quot;message&quot;: &quot;data form previous page&quot; } });}); 新的方式 同步 123bridge.doLogin(); 异步 1234567891011jsbridge.isLogin().then((res) =&gt; { if(res) { alert(&quot;已登录!&quot;); } else { alert(&quot;未登录!&quot;); }}).catch((err) =&gt; { alert(err);}); 优缺点 优点: 1. 使用 Promise 实现, 符合前端习惯; 2. 同步的接口也返回 Promise, 方便后续异步化; 3. API 方法名直接体现action, 比较直观; 3. catch函数能处理异常 新的实现方式 native 与 h5交互h5通过如下函数向native发送消息 123web.handleMessageFromJs 无回调api: 直接使用上述函数向native发送消息 有回调api: 除了发送消息外, 还需发送一个 unique id 标记回调函数, 当客户端执行完毕, 便可根据 unique id 执行该回调函数, 并提供超时销毁机制 动态生成 API 通过一个 action 列表, 生成对应的 API 函数, 方便动态地扫描新增的 API, 并添加到 Jsbridge 库中 1234567891011121314151617181920212223242526272829303132333435363738394041424344 // action 列表 const actionList = [ {&quot;action&quot;: &quot;isLogin&quot;, &quot;hasCallback&quot;: true}, {&quot;action&quot;: &quot;doLogin&quot;, &quot;hasCallback&quot;: false}, {&quot;action&quot;: &quot;test&quot;, &quot;hasCallback&quot;: true} ]; // 根据列表生成 API 函数 factory(actionList) { for (let value of actionList) { this[`${value.action}`] = this.generator(value); }} // API 生成器, 根据是否有回调函数, 分别生成同步 API 和 异步 API generator(action) { return function(params) { action['params'] = params; if (!action.hasCallback) { return new Promise((resolve, reject) =&gt; { this.sendAction(action); resolve(); }); } else { return new Promise((resolve, reject) =&gt; { let callbackId = this.generateId(); this.responseCallbackList[callbackId] = (data) =&gt; { clearTimeout(destoryCallback); resolve(data); } this.sendAction(action, callbackId); // 超时销毁回调 let destoryCallback = setTimeout(() =&gt; { delete this.responseCallbackList[callbackId]; reject(new Error('TIME EXCEED')); }, 5000); }); } }} 关于 generator 函数最近函数式编程越来越火, 从某种意义上来说该函数就是传说中的 curry 函数: 它接受一个函数 返回一个只接收一个参数的函数 好屌, 高阶函数有木有!","link":"/2016/10/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%20Webview%20Jsbridge%20%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85/"},{"title":"记一次难忘的前后端分离","text":"重构公司多年的 JSP 项目，加入 Node.js 层 可维护代码规范接入并使用 eslint 之前改过一个项目，满屏报错啊 属于接了 eslint，但是没按配置文件进行开发，如果这样不接会更好点 es6 module 配合 webpack2 可支持 tree shake 注释与变量命名 仅注释必要的场景：比如不合常理的写法、有很强 background 信息的、步骤性的 1234567// 1const getNextPageUrlAfterCheckPhone = () =&gt; ()const nextPageUrl = getNextPageUrlAfterCheckPhone()// 2const getUrl = () =&gt; () // 验证手机后，返回下一步的页面地址const url = getUrl() // 获取接下来需要跳转的页面地址 代码可能几经人手，大家都改过，逻辑变了，很可能注释却保持不动，最终注释反而影响了阅读代码的人 关于缺憾文档1. 项目对外文档 使用在线的 API 文档中心维护，便于查看 毕竟文档是给别人看的 2. 与后端对接的文档 同样使用在线的 API 文档中心维护，便于查看 接口文档修改会有通知，便于同步 mock 数据可同步到本地 utils 边界 一旦使用了名为 utils 的 componets，不管前期如何明了，到后来都不可避免的越写越臃肿 使用更具体的命名，比如用于表单验证的工具：formValidationUtils，用于 url 操作的工具：URLUtils 样式改动 已将样式的命名统一为小写，连接符为 - 而不是驼峰 原项目的移动端样式可维护性比较高，大部分都按页面级别拆分了 PC 端虽然重构后把独立的样式抽离，不过公共部分的样式实在太大了，且类名短，很难运用批量替换的方式重构 过时的 jQuery 开了历史的倒车，将一些使用 vue 的页面改回 jQuery 了 大量组件都直接依赖了 jQuery，改写困难重重 比如项目中的 vue 版本支持混用 jQuery，而最新版的 vue 直接篡改了 dom 节点，导致 jQuery 的一些 DOM 操作方法失效","link":"/2017/12/15/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9A%BE%E5%BF%98%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"title":"论如何科学地治理老项目的 eslint","text":"行之有效，可行性高的治理方式 背景总有那么些老项目，当老板叫你上去开发需求时，你会有一种不祥的预感，生怕改完一发布，线上就崩了。但是你还是慌兮兮的介入开发，想着开发完马上抽身。这些除了一些贴药膏式的业务逻辑外，让你十分缺乏安全感的就是项目没有接入 eslint，一不小心就是一个低级语法造成 crash；更可怕的是接入了大家都不遵守，想象下编辑器满屏红色错误，黄色警告的画面，此时的你，已经对报错不敏感，以致同流合污。有一个犯罪心理学上的理论可以套用在软件工程中，即『破窗效应』： 此理论认为环境中的不良现象如果被放任存在，会诱使人们仿效，甚至变本加厉。以一幢有少许破窗的建筑为例，如果那些窗不被修理好，可能将会有破坏者破坏更多的窗户。最终他们甚至会闯入建筑内，如果发现无人居住，也许就在那里定居或者纵火。一面墙，如果出现一些涂鸦没有被清洗掉，很快的，墙上就布满了乱七八糟、不堪入目的东西；一条人行道有些许纸屑，不久后就会有更多垃圾，最终人们会视若理所当然地将垃圾顺手丢弃在地上。 因此，随着时间的推移，此类项目会变得愈发难以维护。当然，这种难以维护不仅仅是 eslint 的问题，会有一系列约定和规范的问题，约定和规范制定很简单，但是如何保证这些约定和规范执行才是关键。本文聚焦 eslint 治理，将以一个仍然在持续维护的项目为例，阐述如何治理这种老项目。 现状描述当前存在的 eslint 错误数和告警数： 其中 5697 个错误和 65 个警告可被自动修复，修复后仍剩余 6468 个。经发现，原有项目使用 Airbnb 等规则集，由于该规则十分严格，且本身没有可靠手段阻止不符合规范的代码入库，使得开发更不愿意遵守，错误数有越来越多的趋势，即使自动修复，也仍有 6000+ 的错误。因此选择和制定一个大家都能良好遵守的规则集就很重要，切忌进入『越严格越牛逼』的误区，时刻记住我们的目的是保证代码符合一定的规范，从而避免低级错误。 解决方式最后经过调研和讨论，我们采用如下的规则集： 12345678extends: [ 'standard', 'plugin:@typescript-eslint/recommended', 'plugin:react/recommended', 'plugin:react-native/all', 'prettier', 'prettier/@typescript-eslint', ] 此处我们接入了 prettier 和 lint-staged，前者用于保证同一份代码仅输出一个确定的格式；后者用于保证不会有新的 eslint 错误引入，并对修改过的文件强制校验，从而逐步减少错误数。 结果eslint 默认的结果仅支持文件维度的统计，这在错误数非常多的项目是不适合的，几乎所有文件都有相当数量的错误。此处使用工具 eslint-formatter-stats，使得我们可以从错误类型的维度进行分析。运行结果如下： 接入后未修复的 eslint 结果 10959 个错误和警告 接入并修复的 eslint 结果 837 个错误和警告 分析错误数接入并修复之后，错误数仅有 800+，老板说对，放低点要求，我们 eslint 做得还挺好。 排查错误数量排名靠前的大部分是一些不影响程序功能的，而且为了保证线上代码的稳定性，除了自动修复以外，本次治理尽量不去更改其它错误。因此决定重点看看几个造成影响或可能造成影响的高危错误： no-undef，即使用了未定义的变量，这种错误极有可能造成 crash，目前有 13 处 import-no-unresolved，即导入了不存在的模块，目前有 6 处 react-no-key，即数组元素未使用 key，可能造成卡顿，目前有 4 处 react-native-no-unused-styles，即存在未使用的样式，造成应用体积变大，目前有 45 处 no-dupe-keys 和 no-duplicate-case，即重复定义的对象 key 或者 switch case，增加了不确定性，目前有 7 处 react/no-direct-muttion-state，即直接修改 this.state，有可能导致状态更新不生效，目前有 21 处 此外，诸如变量驼峰，双等号这种错误如果数量巨大，建议改成 warn 级别或者直接关闭，毕竟无关痛痒。经过上述修复之后，剩余的就交给 lint-staged 即可。","link":"/2020/09/28/%E8%AE%BA%E5%A6%82%E4%BD%95%E7%A7%91%E5%AD%A6%E5%9C%B0%E6%B2%BB%E7%90%86%E8%80%81%E9%A1%B9%E7%9B%AE%E7%9A%84%20eslint/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Monorepo","slug":"Monorepo","link":"/tags/Monorepo/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"公众号","slug":"公众号","link":"/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"LifeOS","slug":"LifeOS","link":"/tags/LifeOS/"},{"name":"知识管理","slug":"知识管理","link":"/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"},{"name":"周期笔记","slug":"周期笔记","link":"/tags/%E5%91%A8%E6%9C%9F%E7%AC%94%E8%AE%B0/"},{"name":"任务管理","slug":"任务管理","link":"/tags/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/"},{"name":"目标管理","slug":"目标管理","link":"/tags/%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86/"},{"name":"时间管理","slug":"时间管理","link":"/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"},{"name":"自学历程","slug":"自学历程","link":"/tags/%E8%87%AA%E5%AD%A6%E5%8E%86%E7%A8%8B/"},{"name":"Api Mock","slug":"Api-Mock","link":"/tags/Api-Mock/"},{"name":"单元测试","slug":"单元测试","link":"/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"Jest","slug":"Jest","link":"/tags/Jest/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"命令行工具","slug":"命令行工具","link":"/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"柯里化","slug":"柯里化","link":"/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"},{"name":"函数式编程","slug":"函数式编程","link":"/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"Functor","slug":"Functor","link":"/tags/Functor/"},{"name":"前端八股","slug":"前端八股","link":"/tags/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/"},{"name":"监控告警","slug":"监控告警","link":"/tags/%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6/"},{"name":"Hook","slug":"Hook","link":"/tags/Hook/"},{"name":"私有化部署","slug":"私有化部署","link":"/tags/%E7%A7%81%E6%9C%89%E5%8C%96%E9%83%A8%E7%BD%B2/"},{"name":"Micro Frontend","slug":"Micro-Frontend","link":"/tags/Micro-Frontend/"},{"name":"Bundler","slug":"Bundler","link":"/tags/Bundler/"},{"name":"Diagnostics Tool","slug":"Diagnostics-Tool","link":"/tags/Diagnostics-Tool/"},{"name":"实习历程","slug":"实习历程","link":"/tags/%E5%AE%9E%E4%B9%A0%E5%8E%86%E7%A8%8B/"},{"name":"内存泄漏","slug":"内存泄漏","link":"/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"name":"线上 Bug 排查","slug":"线上-Bug-排查","link":"/tags/%E7%BA%BF%E4%B8%8A-Bug-%E6%8E%92%E6%9F%A5/"},{"name":"D2 会议","slug":"D2-会议","link":"/tags/D2-%E4%BC%9A%E8%AE%AE/"},{"name":"Redux","slug":"Redux","link":"/tags/Redux/"},{"name":"中间件","slug":"中间件","link":"/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"可维护性","slug":"可维护性","link":"/tags/%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7/"},{"name":"Compile","slug":"Compile","link":"/tags/Compile/"},{"name":"Build","slug":"Build","link":"/tags/Build/"},{"name":"Webview","slug":"Webview","link":"/tags/Webview/"},{"name":"JsBridge","slug":"JsBridge","link":"/tags/JsBridge/"},{"name":"重构","slug":"重构","link":"/tags/%E9%87%8D%E6%9E%84/"},{"name":"前后端分离","slug":"前后端分离","link":"/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"name":"项目治理","slug":"项目治理","link":"/tags/%E9%A1%B9%E7%9B%AE%E6%B2%BB%E7%90%86/"}],"categories":[{"name":"小任务","slug":"小任务","link":"/categories/%E5%B0%8F%E4%BB%BB%E5%8A%A1/"},{"name":"疑难杂症","slug":"疑难杂症","link":"/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"工程治理","slug":"工程治理","link":"/categories/%E5%B7%A5%E7%A8%8B%E6%B2%BB%E7%90%86/"},{"name":"Node.js 服务端","slug":"Node-js-服务端","link":"/categories/Node-js-%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"前端学习","slug":"前端学习","link":"/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"},{"name":"前端框架","slug":"前端框架","link":"/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"开发工具","slug":"开发工具","link":"/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"第二大脑","slug":"第二大脑","link":"/categories/%E7%AC%AC%E4%BA%8C%E5%A4%A7%E8%84%91/"},{"name":"职业道路","slug":"职业道路","link":"/categories/%E8%81%8C%E4%B8%9A%E9%81%93%E8%B7%AF/"},{"name":"工程化","slug":"工程化","link":"/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"工作记录","slug":"工作记录","link":"/categories/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"},{"name":"参会感","slug":"参会感","link":"/categories/%E5%8F%82%E4%BC%9A%E6%84%9F/"},{"name":"源码解析","slug":"源码解析","link":"/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}],"pages":[{"title":"404 Not Found：该页无法显示","text":"","link":"/404.html"},{"title":"About","text":"一个热爱工具和规则的 JavaScript 攻城狮！","link":"/about/index.html"},{"title":"","text":"/** * @licstart The following is the entire license notice for the * JavaScript code in this page * * Copyright 2022 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * * @licend The above is the entire license notice for the * JavaScript code in this page */ (function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' && define.amd) define(\"pdfjs-dist/build/pdf\", [], factory); else if(typeof exports === 'object') exports[\"pdfjs-dist/build/pdf\"] = factory(); else root[\"pdfjs-dist/build/pdf\"] = root.pdfjsLib = factory(); })(globalThis, () => { return /******/ (() => { // webpackBootstrap /******/ \"use strict\"; /******/ var __webpack_modules__ = ([ /* 0 */, /* 1 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.UNSUPPORTED_FEATURES = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.LINE_FACTOR = exports.LINE_DESCENT_FACTOR = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.BASELINE_FACTOR = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationEditorType = exports.AnnotationEditorPrefix = exports.AnnotationEditorParamsType = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0; exports.arrayByteLength = arrayByteLength; exports.arraysToBytes = arraysToBytes; exports.assert = assert; exports.bytesToString = bytesToString; exports.createPromiseCapability = createPromiseCapability; exports.createValidAbsoluteUrl = createValidAbsoluteUrl; exports.getModificationDate = getModificationDate; exports.getVerbosityLevel = getVerbosityLevel; exports.info = info; exports.isArrayBuffer = isArrayBuffer; exports.isArrayEqual = isArrayEqual; exports.objectFromMap = objectFromMap; exports.objectSize = objectSize; exports.setVerbosityLevel = setVerbosityLevel; exports.shadow = shadow; exports.string32 = string32; exports.stringToBytes = stringToBytes; exports.stringToPDFString = stringToPDFString; exports.stringToUTF8String = stringToUTF8String; exports.unreachable = unreachable; exports.utf8StringToString = utf8StringToString; exports.warn = warn; ; const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0]; exports.IDENTITY_MATRIX = IDENTITY_MATRIX; const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0]; exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX; const LINE_FACTOR = 1.35; exports.LINE_FACTOR = LINE_FACTOR; const LINE_DESCENT_FACTOR = 0.35; exports.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR; const BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR; exports.BASELINE_FACTOR = BASELINE_FACTOR; const RenderingIntentFlag = { ANY: 0x01, DISPLAY: 0x02, PRINT: 0x04, SAVE: 0x08, ANNOTATIONS_FORMS: 0x10, ANNOTATIONS_STORAGE: 0x20, ANNOTATIONS_DISABLE: 0x40, OPLIST: 0x100 }; exports.RenderingIntentFlag = RenderingIntentFlag; const AnnotationMode = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 }; exports.AnnotationMode = AnnotationMode; const AnnotationEditorPrefix = \"pdfjs_internal_editor_\"; exports.AnnotationEditorPrefix = AnnotationEditorPrefix; const AnnotationEditorType = { DISABLE: -1, NONE: 0, FREETEXT: 3, INK: 15 }; exports.AnnotationEditorType = AnnotationEditorType; const AnnotationEditorParamsType = { FREETEXT_SIZE: 1, FREETEXT_COLOR: 2, FREETEXT_OPACITY: 3, INK_COLOR: 11, INK_THICKNESS: 12, INK_OPACITY: 13 }; exports.AnnotationEditorParamsType = AnnotationEditorParamsType; const PermissionFlag = { PRINT: 0x04, MODIFY_CONTENTS: 0x08, COPY: 0x10, MODIFY_ANNOTATIONS: 0x20, FILL_INTERACTIVE_FORMS: 0x100, COPY_FOR_ACCESSIBILITY: 0x200, ASSEMBLE: 0x400, PRINT_HIGH_QUALITY: 0x800 }; exports.PermissionFlag = PermissionFlag; const TextRenderingMode = { FILL: 0, STROKE: 1, FILL_STROKE: 2, INVISIBLE: 3, FILL_ADD_TO_PATH: 4, STROKE_ADD_TO_PATH: 5, FILL_STROKE_ADD_TO_PATH: 6, ADD_TO_PATH: 7, FILL_STROKE_MASK: 3, ADD_TO_PATH_FLAG: 4 }; exports.TextRenderingMode = TextRenderingMode; const ImageKind = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }; exports.ImageKind = ImageKind; const AnnotationType = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 }; exports.AnnotationType = AnnotationType; const AnnotationStateModelType = { MARKED: \"Marked\", REVIEW: \"Review\" }; exports.AnnotationStateModelType = AnnotationStateModelType; const AnnotationMarkedState = { MARKED: \"Marked\", UNMARKED: \"Unmarked\" }; exports.AnnotationMarkedState = AnnotationMarkedState; const AnnotationReviewState = { ACCEPTED: \"Accepted\", REJECTED: \"Rejected\", CANCELLED: \"Cancelled\", COMPLETED: \"Completed\", NONE: \"None\" }; exports.AnnotationReviewState = AnnotationReviewState; const AnnotationReplyType = { GROUP: \"Group\", REPLY: \"R\" }; exports.AnnotationReplyType = AnnotationReplyType; const AnnotationFlag = { INVISIBLE: 0x01, HIDDEN: 0x02, PRINT: 0x04, NOZOOM: 0x08, NOROTATE: 0x10, NOVIEW: 0x20, READONLY: 0x40, LOCKED: 0x80, TOGGLENOVIEW: 0x100, LOCKEDCONTENTS: 0x200 }; exports.AnnotationFlag = AnnotationFlag; const AnnotationFieldFlag = { READONLY: 0x0000001, REQUIRED: 0x0000002, NOEXPORT: 0x0000004, MULTILINE: 0x0001000, PASSWORD: 0x0002000, NOTOGGLETOOFF: 0x0004000, RADIO: 0x0008000, PUSHBUTTON: 0x0010000, COMBO: 0x0020000, EDIT: 0x0040000, SORT: 0x0080000, FILESELECT: 0x0100000, MULTISELECT: 0x0200000, DONOTSPELLCHECK: 0x0400000, DONOTSCROLL: 0x0800000, COMB: 0x1000000, RICHTEXT: 0x2000000, RADIOSINUNISON: 0x2000000, COMMITONSELCHANGE: 0x4000000 }; exports.AnnotationFieldFlag = AnnotationFieldFlag; const AnnotationBorderStyleType = { SOLID: 1, DASHED: 2, BEVELED: 3, INSET: 4, UNDERLINE: 5 }; exports.AnnotationBorderStyleType = AnnotationBorderStyleType; const AnnotationActionEventType = { E: \"Mouse Enter\", X: \"Mouse Exit\", D: \"Mouse Down\", U: \"Mouse Up\", Fo: \"Focus\", Bl: \"Blur\", PO: \"PageOpen\", PC: \"PageClose\", PV: \"PageVisible\", PI: \"PageInvisible\", K: \"Keystroke\", F: \"Format\", V: \"Validate\", C: \"Calculate\" }; exports.AnnotationActionEventType = AnnotationActionEventType; const DocumentActionEventType = { WC: \"WillClose\", WS: \"WillSave\", DS: \"DidSave\", WP: \"WillPrint\", DP: \"DidPrint\" }; exports.DocumentActionEventType = DocumentActionEventType; const PageActionEventType = { O: \"PageOpen\", C: \"PageClose\" }; exports.PageActionEventType = PageActionEventType; const StreamType = { UNKNOWN: \"UNKNOWN\", FLATE: \"FLATE\", LZW: \"LZW\", DCT: \"DCT\", JPX: \"JPX\", JBIG: \"JBIG\", A85: \"A85\", AHX: \"AHX\", CCF: \"CCF\", RLX: \"RLX\" }; exports.StreamType = StreamType; const FontType = { UNKNOWN: \"UNKNOWN\", TYPE1: \"TYPE1\", TYPE1STANDARD: \"TYPE1STANDARD\", TYPE1C: \"TYPE1C\", CIDFONTTYPE0: \"CIDFONTTYPE0\", CIDFONTTYPE0C: \"CIDFONTTYPE0C\", TRUETYPE: \"TRUETYPE\", CIDFONTTYPE2: \"CIDFONTTYPE2\", TYPE3: \"TYPE3\", OPENTYPE: \"OPENTYPE\", TYPE0: \"TYPE0\", MMTYPE1: \"MMTYPE1\" }; exports.FontType = FontType; const VerbosityLevel = { ERRORS: 0, WARNINGS: 1, INFOS: 5 }; exports.VerbosityLevel = VerbosityLevel; const CMapCompressionType = { NONE: 0, BINARY: 1 }; exports.CMapCompressionType = CMapCompressionType; const OPS = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotation: 80, endAnnotation: 81, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91 }; exports.OPS = OPS; const UNSUPPORTED_FEATURES = { forms: \"forms\", javaScript: \"javaScript\", signatures: \"signatures\", smask: \"smask\", shadingPattern: \"shadingPattern\", errorTilingPattern: \"errorTilingPattern\", errorExtGState: \"errorExtGState\", errorXObject: \"errorXObject\", errorFontLoadType3: \"errorFontLoadType3\", errorFontState: \"errorFontState\", errorFontMissing: \"errorFontMissing\", errorFontTranslate: \"errorFontTranslate\", errorColorSpace: \"errorColorSpace\", errorOperatorList: \"errorOperatorList\", errorFontToUnicode: \"errorFontToUnicode\", errorFontLoadNative: \"errorFontLoadNative\", errorFontBuildPath: \"errorFontBuildPath\", errorFontGetPath: \"errorFontGetPath\", errorMarkedContent: \"errorMarkedContent\", errorContentSubStream: \"errorContentSubStream\" }; exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES; const PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 }; exports.PasswordResponses = PasswordResponses; let verbosity = VerbosityLevel.WARNINGS; function setVerbosityLevel(level) { if (Number.isInteger(level)) { verbosity = level; } } function getVerbosityLevel() { return verbosity; } function info(msg) { if (verbosity >= VerbosityLevel.INFOS) { console.log(`Info: ${msg}`); } } function warn(msg) { if (verbosity >= VerbosityLevel.WARNINGS) { console.log(`Warning: ${msg}`); } } function unreachable(msg) { throw new Error(msg); } function assert(cond, msg) { if (!cond) { unreachable(msg); } } function _isValidProtocol(url) { if (!url) { return false; } switch (url.protocol) { case \"http:\": case \"https:\": case \"ftp:\": case \"mailto:\": case \"tel:\": return true; default: return false; } } function createValidAbsoluteUrl(url, baseUrl = null, options = null) { if (!url) { return null; } try { if (options && typeof url === \"string\") { if (options.addDefaultProtocol && url.startsWith(\"www.\")) { const dots = url.match(/\\./g); if (dots && dots.length >= 2) { url = `http://${url}`; } } if (options.tryConvertEncoding) { try { url = stringToUTF8String(url); } catch (ex) {} } } const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url); if (_isValidProtocol(absoluteUrl)) { return absoluteUrl; } } catch (ex) {} return null; } function shadow(obj, prop, value, nonSerializable = false) { Object.defineProperty(obj, prop, { value, enumerable: !nonSerializable, configurable: true, writable: false }); return value; } const BaseException = function BaseExceptionClosure() { function BaseException(message, name) { if (this.constructor === BaseException) { unreachable(\"Cannot initialize BaseException.\"); } this.message = message; this.name = name; } BaseException.prototype = new Error(); BaseException.constructor = BaseException; return BaseException; }(); exports.BaseException = BaseException; class PasswordException extends BaseException { constructor(msg, code) { super(msg, \"PasswordException\"); this.code = code; } } exports.PasswordException = PasswordException; class UnknownErrorException extends BaseException { constructor(msg, details) { super(msg, \"UnknownErrorException\"); this.details = details; } } exports.UnknownErrorException = UnknownErrorException; class InvalidPDFException extends BaseException { constructor(msg) { super(msg, \"InvalidPDFException\"); } } exports.InvalidPDFException = InvalidPDFException; class MissingPDFException extends BaseException { constructor(msg) { super(msg, \"MissingPDFException\"); } } exports.MissingPDFException = MissingPDFException; class UnexpectedResponseException extends BaseException { constructor(msg, status) { super(msg, \"UnexpectedResponseException\"); this.status = status; } } exports.UnexpectedResponseException = UnexpectedResponseException; class FormatError extends BaseException { constructor(msg) { super(msg, \"FormatError\"); } } exports.FormatError = FormatError; class AbortException extends BaseException { constructor(msg) { super(msg, \"AbortException\"); } } exports.AbortException = AbortException; function bytesToString(bytes) { if (typeof bytes !== \"object\" || bytes === null || bytes.length === undefined) { unreachable(\"Invalid argument for bytesToString\"); } const length = bytes.length; const MAX_ARGUMENT_COUNT = 8192; if (length < MAX_ARGUMENT_COUNT) { return String.fromCharCode.apply(null, bytes); } const strBuf = []; for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) { const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length); const chunk = bytes.subarray(i, chunkEnd); strBuf.push(String.fromCharCode.apply(null, chunk)); } return strBuf.join(\"\"); } function stringToBytes(str) { if (typeof str !== \"string\") { unreachable(\"Invalid argument for stringToBytes\"); } const length = str.length; const bytes = new Uint8Array(length); for (let i = 0; i < length; ++i) { bytes[i] = str.charCodeAt(i) & 0xff; } return bytes; } function arrayByteLength(arr) { if (arr.length !== undefined) { return arr.length; } if (arr.byteLength !== undefined) { return arr.byteLength; } unreachable(\"Invalid argument for arrayByteLength\"); } function arraysToBytes(arr) { const length = arr.length; if (length === 1 && arr[0] instanceof Uint8Array) { return arr[0]; } let resultLength = 0; for (let i = 0; i < length; i++) { resultLength += arrayByteLength(arr[i]); } let pos = 0; const data = new Uint8Array(resultLength); for (let i = 0; i < length; i++) { let item = arr[i]; if (!(item instanceof Uint8Array)) { if (typeof item === \"string\") { item = stringToBytes(item); } else { item = new Uint8Array(item); } } const itemLength = item.byteLength; data.set(item, pos); pos += itemLength; } return data; } function string32(value) { return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff); } function objectSize(obj) { return Object.keys(obj).length; } function objectFromMap(map) { const obj = Object.create(null); for (const [key, value] of map) { obj[key] = value; } return obj; } function isLittleEndian() { const buffer8 = new Uint8Array(4); buffer8[0] = 1; const view32 = new Uint32Array(buffer8.buffer, 0, 1); return view32[0] === 1; } function isEvalSupported() { try { new Function(\"\"); return true; } catch (e) { return false; } } class FeatureTest { static get isLittleEndian() { return shadow(this, \"isLittleEndian\", isLittleEndian()); } static get isEvalSupported() { return shadow(this, \"isEvalSupported\", isEvalSupported()); } static get isOffscreenCanvasSupported() { return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\"); } static get platform() { if (typeof navigator === \"undefined\") { return shadow(this, \"platform\", { isWin: false, isMac: false }); } return shadow(this, \"platform\", { isWin: navigator.platform.includes(\"Win\"), isMac: navigator.platform.includes(\"Mac\") }); } } exports.FeatureTest = FeatureTest; const hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, \"0\")); class Util { static makeHexColor(r, g, b) { return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`; } static scaleMinMax(transform, minMax) { let temp; if (transform[0]) { if (transform[0] < 0) { temp = minMax[0]; minMax[0] = minMax[1]; minMax[1] = temp; } minMax[0] *= transform[0]; minMax[1] *= transform[0]; if (transform[3] < 0) { temp = minMax[2]; minMax[2] = minMax[3]; minMax[3] = temp; } minMax[2] *= transform[3]; minMax[3] *= transform[3]; } else { temp = minMax[0]; minMax[0] = minMax[2]; minMax[2] = temp; temp = minMax[1]; minMax[1] = minMax[3]; minMax[3] = temp; if (transform[1] < 0) { temp = minMax[2]; minMax[2] = minMax[3]; minMax[3] = temp; } minMax[2] *= transform[1]; minMax[3] *= transform[1]; if (transform[2] < 0) { temp = minMax[0]; minMax[0] = minMax[1]; minMax[1] = temp; } minMax[0] *= transform[2]; minMax[1] *= transform[2]; } minMax[0] += transform[4]; minMax[1] += transform[4]; minMax[2] += transform[5]; minMax[3] += transform[5]; } static transform(m1, m2) { return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]]; } static applyTransform(p, m) { const xt = p[0] * m[0] + p[1] * m[2] + m[4]; const yt = p[0] * m[1] + p[1] * m[3] + m[5]; return [xt, yt]; } static applyInverseTransform(p, m) { const d = m[0] * m[3] - m[1] * m[2]; const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d; const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d; return [xt, yt]; } static getAxialAlignedBoundingBox(r, m) { const p1 = Util.applyTransform(r, m); const p2 = Util.applyTransform(r.slice(2, 4), m); const p3 = Util.applyTransform([r[0], r[3]], m); const p4 = Util.applyTransform([r[2], r[1]], m); return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])]; } static inverseTransform(m) { const d = m[0] * m[3] - m[1] * m[2]; return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d]; } static singularValueDecompose2dScale(m) { const transpose = [m[0], m[2], m[1], m[3]]; const a = m[0] * transpose[0] + m[1] * transpose[2]; const b = m[0] * transpose[1] + m[1] * transpose[3]; const c = m[2] * transpose[0] + m[3] * transpose[2]; const d = m[2] * transpose[1] + m[3] * transpose[3]; const first = (a + d) / 2; const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2; const sx = first + second || 1; const sy = first - second || 1; return [Math.sqrt(sx), Math.sqrt(sy)]; } static normalizeRect(rect) { const r = rect.slice(0); if (rect[0] > rect[2]) { r[0] = rect[2]; r[2] = rect[0]; } if (rect[1] > rect[3]) { r[1] = rect[3]; r[3] = rect[1]; } return r; } static intersect(rect1, rect2) { const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2])); const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2])); if (xLow > xHigh) { return null; } const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3])); const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3])); if (yLow > yHigh) { return null; } return [xLow, yLow, xHigh, yHigh]; } static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) { const tvalues = [], bounds = [[], []]; let a, b, c, t, t1, t2, b2ac, sqrtb2ac; for (let i = 0; i < 2; ++i) { if (i === 0) { b = 6 * x0 - 12 * x1 + 6 * x2; a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3; c = 3 * x1 - 3 * x0; } else { b = 6 * y0 - 12 * y1 + 6 * y2; a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3; c = 3 * y1 - 3 * y0; } if (Math.abs(a) < 1e-12) { if (Math.abs(b) < 1e-12) { continue; } t = -c / b; if (0 < t && t < 1) { tvalues.push(t); } continue; } b2ac = b * b - 4 * c * a; sqrtb2ac = Math.sqrt(b2ac); if (b2ac < 0) { continue; } t1 = (-b + sqrtb2ac) / (2 * a); if (0 < t1 && t1 < 1) { tvalues.push(t1); } t2 = (-b - sqrtb2ac) / (2 * a); if (0 < t2 && t2 < 1) { tvalues.push(t2); } } let j = tvalues.length, mt; const jlen = j; while (j--) { t = tvalues[j]; mt = 1 - t; bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3; bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3; } bounds[0][jlen] = x0; bounds[1][jlen] = y0; bounds[0][jlen + 1] = x3; bounds[1][jlen + 1] = y3; bounds[0].length = bounds[1].length = jlen + 2; return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])]; } } exports.Util = Util; const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac]; function stringToPDFString(str) { if (str[0] >= \"\\xEF\") { let encoding; if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") { encoding = \"utf-16be\"; } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") { encoding = \"utf-16le\"; } else if (str[0] === \"\\xEF\" && str[1] === \"\\xBB\" && str[2] === \"\\xBF\") { encoding = \"utf-8\"; } if (encoding) { try { const decoder = new TextDecoder(encoding, { fatal: true }); const buffer = stringToBytes(str); return decoder.decode(buffer); } catch (ex) { warn(`stringToPDFString: \"${ex}\".`); } } } const strBuf = []; for (let i = 0, ii = str.length; i < ii; i++) { const code = PDFStringTranslateTable[str.charCodeAt(i)]; strBuf.push(code ? String.fromCharCode(code) : str.charAt(i)); } return strBuf.join(\"\"); } function stringToUTF8String(str) { return decodeURIComponent(escape(str)); } function utf8StringToString(str) { return unescape(encodeURIComponent(str)); } function isArrayBuffer(v) { return typeof v === \"object\" && v !== null && v.byteLength !== undefined; } function isArrayEqual(arr1, arr2) { if (arr1.length !== arr2.length) { return false; } for (let i = 0, ii = arr1.length; i < ii; i++) { if (arr1[i] !== arr2[i]) { return false; } } return true; } function getModificationDate(date = new Date()) { const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")]; return buffer.join(\"\"); } function createPromiseCapability() { const capability = Object.create(null); let isSettled = false; Object.defineProperty(capability, \"settled\", { get() { return isSettled; } }); capability.promise = new Promise(function (resolve, reject) { capability.resolve = function (data) { isSettled = true; resolve(data); }; capability.reject = function (reason) { isSettled = true; reject(reason); }; }); return capability; } /***/ }), /* 2 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0; exports.getDocument = getDocument; exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory; exports.version = void 0; var _util = __w_pdfjs_require__(1); var _annotation_storage = __w_pdfjs_require__(3); var _display_utils = __w_pdfjs_require__(6); var _font_loader = __w_pdfjs_require__(9); var _canvas = __w_pdfjs_require__(11); var _worker_options = __w_pdfjs_require__(14); var _is_node = __w_pdfjs_require__(10); var _message_handler = __w_pdfjs_require__(15); var _metadata = __w_pdfjs_require__(16); var _optional_content_config = __w_pdfjs_require__(17); var _transport_stream = __w_pdfjs_require__(18); var _xfa_text = __w_pdfjs_require__(19); const DEFAULT_RANGE_CHUNK_SIZE = 65536; const RENDERING_CANCELLED_TIMEOUT = 100; let DefaultCanvasFactory = _display_utils.DOMCanvasFactory; exports.DefaultCanvasFactory = DefaultCanvasFactory; let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory; exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory; let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory; exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory; if (_is_node.isNodeJS) { const { NodeCanvasFactory, NodeCMapReaderFactory, NodeStandardFontDataFactory } = __w_pdfjs_require__(20); exports.DefaultCanvasFactory = DefaultCanvasFactory = NodeCanvasFactory; exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = NodeCMapReaderFactory; exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = NodeStandardFontDataFactory; } let createPDFNetworkStream; function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) { createPDFNetworkStream = pdfNetworkStreamFactory; } function getDocument(src) { const task = new PDFDocumentLoadingTask(); let source; if (typeof src === \"string\" || src instanceof URL) { source = { url: src }; } else if ((0, _util.isArrayBuffer)(src)) { source = { data: src }; } else if (src instanceof PDFDataRangeTransport) { source = { range: src }; } else { if (typeof src !== \"object\") { throw new Error(\"Invalid parameter in getDocument, \" + \"need either string, URL, TypedArray, or parameter object.\"); } if (!src.url && !src.data && !src.range) { throw new Error(\"Invalid parameter object: need either .data, .range or .url\"); } source = src; } const params = Object.create(null); let rangeTransport = null, worker = null; for (const key in source) { const value = source[key]; switch (key) { case \"url\": if (typeof window !== \"undefined\") { try { params[key] = new URL(value, window.location).href; continue; } catch (ex) { (0, _util.warn)(`Cannot create valid URL: \"${ex}\".`); } } else if (typeof value === \"string\" || value instanceof URL) { params[key] = value.toString(); continue; } throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\"); case \"range\": rangeTransport = value; continue; case \"worker\": worker = value; continue; case \"data\": if (_is_node.isNodeJS && typeof Buffer !== \"undefined\" && value instanceof Buffer) { params[key] = new Uint8Array(value); } else if (value instanceof Uint8Array) { break; } else if (typeof value === \"string\") { params[key] = (0, _util.stringToBytes)(value); } else if (typeof value === \"object\" && value !== null && !isNaN(value.length)) { params[key] = new Uint8Array(value); } else if ((0, _util.isArrayBuffer)(value)) { params[key] = new Uint8Array(value); } else { throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\"); } continue; } params[key] = value; } params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory; params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory; params.ignoreErrors = params.stopAtErrors !== true; params.fontExtraProperties = params.fontExtraProperties === true; params.pdfBug = params.pdfBug === true; params.enableXfa = params.enableXfa === true; if (!Number.isInteger(params.rangeChunkSize) || params.rangeChunkSize < 1) { params.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE; } if (typeof params.docBaseUrl !== \"string\" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) { params.docBaseUrl = null; } if (!Number.isInteger(params.maxImageSize) || params.maxImageSize < -1) { params.maxImageSize = -1; } if (typeof params.cMapUrl !== \"string\") { params.cMapUrl = null; } if (typeof params.standardFontDataUrl !== \"string\") { params.standardFontDataUrl = null; } if (typeof params.useWorkerFetch !== \"boolean\") { params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory; } if (typeof params.isEvalSupported !== \"boolean\") { params.isEvalSupported = true; } if (typeof params.isOffscreenCanvasSupported !== \"boolean\") { params.isOffscreenCanvasSupported = !_is_node.isNodeJS; } if (typeof params.disableFontFace !== \"boolean\") { params.disableFontFace = _is_node.isNodeJS; } if (typeof params.useSystemFonts !== \"boolean\") { params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace; } if (typeof params.ownerDocument !== \"object\" || params.ownerDocument === null) { params.ownerDocument = globalThis.document; } if (typeof params.disableRange !== \"boolean\") { params.disableRange = false; } if (typeof params.disableStream !== \"boolean\") { params.disableStream = false; } if (typeof params.disableAutoFetch !== \"boolean\") { params.disableAutoFetch = false; } (0, _util.setVerbosityLevel)(params.verbosity); if (!worker) { const workerParams = { verbosity: params.verbosity, port: _worker_options.GlobalWorkerOptions.workerPort }; worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams); task._worker = worker; } const docId = task.docId; worker.promise.then(function () { if (task.destroyed) { throw new Error(\"Loading aborted\"); } const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId); const networkStreamPromise = new Promise(function (resolve) { let networkStream; if (rangeTransport) { networkStream = new _transport_stream.PDFDataTransportStream({ length: params.length, initialData: params.initialData, progressiveDone: params.progressiveDone, contentDispositionFilename: params.contentDispositionFilename, disableRange: params.disableRange, disableStream: params.disableStream }, rangeTransport); } else if (!params.data) { networkStream = createPDFNetworkStream({ url: params.url, length: params.length, httpHeaders: params.httpHeaders, withCredentials: params.withCredentials, rangeChunkSize: params.rangeChunkSize, disableRange: params.disableRange, disableStream: params.disableStream }); } resolve(networkStream); }); return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) { if (task.destroyed) { throw new Error(\"Loading aborted\"); } const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port); const transport = new WorkerTransport(messageHandler, task, networkStream, params); task._transport = transport; messageHandler.send(\"Ready\", null); }); }).catch(task._capability.reject); return task; } async function _fetchDocument(worker, source, pdfDataRangeTransport, docId) { if (worker.destroyed) { throw new Error(\"Worker was destroyed\"); } if (pdfDataRangeTransport) { source.length = pdfDataRangeTransport.length; source.initialData = pdfDataRangeTransport.initialData; source.progressiveDone = pdfDataRangeTransport.progressiveDone; source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename; } const workerId = await worker.messageHandler.sendWithPromise(\"GetDocRequest\", { docId, apiVersion: '3.2.146', data: source.data, password: source.password, disableAutoFetch: source.disableAutoFetch, rangeChunkSize: source.rangeChunkSize, length: source.length, docBaseUrl: source.docBaseUrl, enableXfa: source.enableXfa, evaluatorOptions: { maxImageSize: source.maxImageSize, disableFontFace: source.disableFontFace, ignoreErrors: source.ignoreErrors, isEvalSupported: source.isEvalSupported, isOffscreenCanvasSupported: source.isOffscreenCanvasSupported, fontExtraProperties: source.fontExtraProperties, useSystemFonts: source.useSystemFonts, cMapUrl: source.useWorkerFetch ? source.cMapUrl : null, standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null } }); if (source.data) { source.data = null; } if (worker.destroyed) { throw new Error(\"Worker was destroyed\"); } return workerId; } class PDFDocumentLoadingTask { static #docId = 0; #onUnsupportedFeature = null; constructor() { this._capability = (0, _util.createPromiseCapability)(); this._transport = null; this._worker = null; this.docId = `d${PDFDocumentLoadingTask.#docId++}`; this.destroyed = false; this.onPassword = null; this.onProgress = null; } get onUnsupportedFeature() { return this.#onUnsupportedFeature; } set onUnsupportedFeature(callback) { (0, _display_utils.deprecated)(\"The PDFDocumentLoadingTask onUnsupportedFeature property will be removed in the future.\"); this.#onUnsupportedFeature = callback; } get promise() { return this._capability.promise; } async destroy() { this.destroyed = true; await this._transport?.destroy(); this._transport = null; if (this._worker) { this._worker.destroy(); this._worker = null; } } } exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask; class PDFDataRangeTransport { constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) { this.length = length; this.initialData = initialData; this.progressiveDone = progressiveDone; this.contentDispositionFilename = contentDispositionFilename; this._rangeListeners = []; this._progressListeners = []; this._progressiveReadListeners = []; this._progressiveDoneListeners = []; this._readyCapability = (0, _util.createPromiseCapability)(); } addRangeListener(listener) { this._rangeListeners.push(listener); } addProgressListener(listener) { this._progressListeners.push(listener); } addProgressiveReadListener(listener) { this._progressiveReadListeners.push(listener); } addProgressiveDoneListener(listener) { this._progressiveDoneListeners.push(listener); } onDataRange(begin, chunk) { for (const listener of this._rangeListeners) { listener(begin, chunk); } } onDataProgress(loaded, total) { this._readyCapability.promise.then(() => { for (const listener of this._progressListeners) { listener(loaded, total); } }); } onDataProgressiveRead(chunk) { this._readyCapability.promise.then(() => { for (const listener of this._progressiveReadListeners) { listener(chunk); } }); } onDataProgressiveDone() { this._readyCapability.promise.then(() => { for (const listener of this._progressiveDoneListeners) { listener(); } }); } transportReady() { this._readyCapability.resolve(); } requestDataRange(begin, end) { (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\"); } abort() {} } exports.PDFDataRangeTransport = PDFDataRangeTransport; class PDFDocumentProxy { constructor(pdfInfo, transport) { this._pdfInfo = pdfInfo; this._transport = transport; } get annotationStorage() { return this._transport.annotationStorage; } get numPages() { return this._pdfInfo.numPages; } get fingerprints() { return this._pdfInfo.fingerprints; } get stats() { (0, _display_utils.deprecated)(\"The PDFDocumentProxy stats property will be removed in the future.\"); return this._transport.stats; } get isPureXfa() { return (0, _util.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa); } get allXfaHtml() { return this._transport._htmlForXfa; } getPage(pageNumber) { return this._transport.getPage(pageNumber); } getPageIndex(ref) { return this._transport.getPageIndex(ref); } getDestinations() { return this._transport.getDestinations(); } getDestination(id) { return this._transport.getDestination(id); } getPageLabels() { return this._transport.getPageLabels(); } getPageLayout() { return this._transport.getPageLayout(); } getPageMode() { return this._transport.getPageMode(); } getViewerPreferences() { return this._transport.getViewerPreferences(); } getOpenAction() { return this._transport.getOpenAction(); } getAttachments() { return this._transport.getAttachments(); } getJavaScript() { return this._transport.getJavaScript(); } getJSActions() { return this._transport.getDocJSActions(); } getOutline() { return this._transport.getOutline(); } getOptionalContentConfig() { return this._transport.getOptionalContentConfig(); } getPermissions() { return this._transport.getPermissions(); } getMetadata() { return this._transport.getMetadata(); } getMarkInfo() { return this._transport.getMarkInfo(); } getData() { return this._transport.getData(); } saveDocument() { return this._transport.saveDocument(); } getDownloadInfo() { return this._transport.downloadInfoCapability.promise; } cleanup(keepLoadedFonts = false) { return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa); } destroy() { return this.loadingTask.destroy(); } get loadingParams() { return this._transport.loadingParams; } get loadingTask() { return this._transport.loadingTask; } getFieldObjects() { return this._transport.getFieldObjects(); } hasJSActions() { return this._transport.hasJSActions(); } getCalculationOrderIds() { return this._transport.getCalculationOrderIds(); } } exports.PDFDocumentProxy = PDFDocumentProxy; class PDFPageProxy { constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) { this._pageIndex = pageIndex; this._pageInfo = pageInfo; this._ownerDocument = ownerDocument; this._transport = transport; this._stats = pdfBug ? new _display_utils.StatTimer() : null; this._pdfBug = pdfBug; this.commonObjs = transport.commonObjs; this.objs = new PDFObjects(); this._bitmaps = new Set(); this.cleanupAfterRender = false; this.pendingCleanup = false; this._intentStates = new Map(); this.destroyed = false; } get pageNumber() { return this._pageIndex + 1; } get rotate() { return this._pageInfo.rotate; } get ref() { return this._pageInfo.ref; } get userUnit() { return this._pageInfo.userUnit; } get view() { return this._pageInfo.view; } getViewport({ scale, rotation = this.rotate, offsetX = 0, offsetY = 0, dontFlip = false } = {}) { return new _display_utils.PageViewport({ viewBox: this.view, scale, rotation, offsetX, offsetY, dontFlip }); } getAnnotations({ intent = \"display\" } = {}) { const intentArgs = this._transport.getRenderingIntent(intent); return this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent); } getJSActions() { return this._transport.getPageJSActions(this._pageIndex); } get isPureXfa() { return (0, _util.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa); } async getXfa() { return this._transport._htmlForXfa?.children[this._pageIndex] || null; } render({ canvasContext, viewport, intent = \"display\", annotationMode = _util.AnnotationMode.ENABLE, transform = null, canvasFactory = null, background = null, optionalContentConfigPromise = null, annotationCanvasMap = null, pageColors = null, printAnnotationStorage = null }) { this._stats?.time(\"Overall\"); const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage); this.pendingCleanup = false; if (!optionalContentConfigPromise) { optionalContentConfigPromise = this._transport.getOptionalContentConfig(); } let intentState = this._intentStates.get(intentArgs.cacheKey); if (!intentState) { intentState = Object.create(null); this._intentStates.set(intentArgs.cacheKey, intentState); } if (intentState.streamReaderCancelTimeout) { clearTimeout(intentState.streamReaderCancelTimeout); intentState.streamReaderCancelTimeout = null; } const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({ ownerDocument: this._ownerDocument }); const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT); if (!intentState.displayReadyCapability) { intentState.displayReadyCapability = (0, _util.createPromiseCapability)(); intentState.operatorList = { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null }; this._stats?.time(\"Page Request\"); this._pumpOperatorList(intentArgs); } const complete = error => { intentState.renderTasks.delete(internalRenderTask); if (this.cleanupAfterRender || intentPrint) { this.pendingCleanup = true; } this._tryCleanup(); if (error) { internalRenderTask.capability.reject(error); this._abortOperatorList({ intentState, reason: error instanceof Error ? error : new Error(error) }); } else { internalRenderTask.capability.resolve(); } this._stats?.timeEnd(\"Rendering\"); this._stats?.timeEnd(\"Overall\"); }; const internalRenderTask = new InternalRenderTask({ callback: complete, params: { canvasContext, viewport, transform, background }, objs: this.objs, commonObjs: this.commonObjs, annotationCanvasMap, operatorList: intentState.operatorList, pageIndex: this._pageIndex, canvasFactory: canvasFactoryInstance, useRequestAnimationFrame: !intentPrint, pdfBug: this._pdfBug, pageColors }); (intentState.renderTasks ||= new Set()).add(internalRenderTask); const renderTask = internalRenderTask.task; Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => { if (this.pendingCleanup) { complete(); return; } this._stats?.time(\"Rendering\"); internalRenderTask.initializeGraphics({ transparency, optionalContentConfig }); internalRenderTask.operatorListChanged(); }).catch(complete); return renderTask; } getOperatorList({ intent = \"display\", annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null } = {}) { function operatorListChanged() { if (intentState.operatorList.lastChunk) { intentState.opListReadCapability.resolve(intentState.operatorList); intentState.renderTasks.delete(opListTask); } } const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true); let intentState = this._intentStates.get(intentArgs.cacheKey); if (!intentState) { intentState = Object.create(null); this._intentStates.set(intentArgs.cacheKey, intentState); } let opListTask; if (!intentState.opListReadCapability) { opListTask = Object.create(null); opListTask.operatorListChanged = operatorListChanged; intentState.opListReadCapability = (0, _util.createPromiseCapability)(); (intentState.renderTasks ||= new Set()).add(opListTask); intentState.operatorList = { fnArray: [], argsArray: [], lastChunk: false, separateAnnots: null }; this._stats?.time(\"Page Request\"); this._pumpOperatorList(intentArgs); } return intentState.opListReadCapability.promise; } streamTextContent({ disableCombineTextItems = false, includeMarkedContent = false } = {}) { const TEXT_CONTENT_CHUNK_SIZE = 100; return this._transport.messageHandler.sendWithStream(\"GetTextContent\", { pageIndex: this._pageIndex, combineTextItems: disableCombineTextItems !== true, includeMarkedContent: includeMarkedContent === true }, { highWaterMark: TEXT_CONTENT_CHUNK_SIZE, size(textContent) { return textContent.items.length; } }); } getTextContent(params = {}) { if (this._transport._htmlForXfa) { return this.getXfa().then(xfa => { return _xfa_text.XfaText.textContent(xfa); }); } const readableStream = this.streamTextContent(params); return new Promise(function (resolve, reject) { function pump() { reader.read().then(function ({ value, done }) { if (done) { resolve(textContent); return; } Object.assign(textContent.styles, value.styles); textContent.items.push(...value.items); pump(); }, reject); } const reader = readableStream.getReader(); const textContent = { items: [], styles: Object.create(null) }; pump(); }); } getStructTree() { return this._transport.getStructTree(this._pageIndex); } _destroy() { this.destroyed = true; const waitOn = []; for (const intentState of this._intentStates.values()) { this._abortOperatorList({ intentState, reason: new Error(\"Page was destroyed.\"), force: true }); if (intentState.opListReadCapability) { continue; } for (const internalRenderTask of intentState.renderTasks) { waitOn.push(internalRenderTask.completed); internalRenderTask.cancel(); } } this.objs.clear(); for (const bitmap of this._bitmaps) { bitmap.close(); } this._bitmaps.clear(); this.pendingCleanup = false; return Promise.all(waitOn); } cleanup(resetStats = false) { this.pendingCleanup = true; return this._tryCleanup(resetStats); } _tryCleanup(resetStats = false) { if (!this.pendingCleanup) { return false; } for (const { renderTasks, operatorList } of this._intentStates.values()) { if (renderTasks.size > 0 || !operatorList.lastChunk) { return false; } } this._intentStates.clear(); this.objs.clear(); if (resetStats && this._stats) { this._stats = new _display_utils.StatTimer(); } for (const bitmap of this._bitmaps) { bitmap.close(); } this._bitmaps.clear(); this.pendingCleanup = false; return true; } _startRenderPage(transparency, cacheKey) { const intentState = this._intentStates.get(cacheKey); if (!intentState) { return; } this._stats?.timeEnd(\"Page Request\"); intentState.displayReadyCapability?.resolve(transparency); } _renderPageChunk(operatorListChunk, intentState) { for (let i = 0, ii = operatorListChunk.length; i < ii; i++) { intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]); intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]); } intentState.operatorList.lastChunk = operatorListChunk.lastChunk; intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots; for (const internalRenderTask of intentState.renderTasks) { internalRenderTask.operatorListChanged(); } if (operatorListChunk.lastChunk) { this._tryCleanup(); } } _pumpOperatorList({ renderingIntent, cacheKey, annotationStorageMap }) { const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", { pageIndex: this._pageIndex, intent: renderingIntent, cacheKey, annotationStorage: annotationStorageMap }); const reader = readableStream.getReader(); const intentState = this._intentStates.get(cacheKey); intentState.streamReader = reader; const pump = () => { reader.read().then(({ value, done }) => { if (done) { intentState.streamReader = null; return; } if (this._transport.destroyed) { return; } this._renderPageChunk(value, intentState); pump(); }, reason => { intentState.streamReader = null; if (this._transport.destroyed) { return; } if (intentState.operatorList) { intentState.operatorList.lastChunk = true; for (const internalRenderTask of intentState.renderTasks) { internalRenderTask.operatorListChanged(); } this._tryCleanup(); } if (intentState.displayReadyCapability) { intentState.displayReadyCapability.reject(reason); } else if (intentState.opListReadCapability) { intentState.opListReadCapability.reject(reason); } else { throw reason; } }); }; pump(); } _abortOperatorList({ intentState, reason, force = false }) { if (!intentState.streamReader) { return; } if (intentState.streamReaderCancelTimeout) { clearTimeout(intentState.streamReaderCancelTimeout); intentState.streamReaderCancelTimeout = null; } if (!force) { if (intentState.renderTasks.size > 0) { return; } if (reason instanceof _display_utils.RenderingCancelledException) { let delay = RENDERING_CANCELLED_TIMEOUT; if (reason.extraDelay > 0 && reason.extraDelay < 1000) { delay += reason.extraDelay; } intentState.streamReaderCancelTimeout = setTimeout(() => { intentState.streamReaderCancelTimeout = null; this._abortOperatorList({ intentState, reason, force: true }); }, delay); return; } } intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {}); intentState.streamReader = null; if (this._transport.destroyed) { return; } for (const [curCacheKey, curIntentState] of this._intentStates) { if (curIntentState === intentState) { this._intentStates.delete(curCacheKey); break; } } this.cleanup(); } get stats() { return this._stats; } } exports.PDFPageProxy = PDFPageProxy; class LoopbackPort { #listeners = []; #deferred = Promise.resolve(); postMessage(obj, transfers) { const event = { data: structuredClone(obj, transfers) }; this.#deferred.then(() => { for (const listener of this.#listeners) { listener.call(this, event); } }); } addEventListener(name, listener) { this.#listeners.push(listener); } removeEventListener(name, listener) { const i = this.#listeners.indexOf(listener); this.#listeners.splice(i, 1); } terminate() { this.#listeners.length = 0; } } exports.LoopbackPort = LoopbackPort; const PDFWorkerUtil = { isWorkerDisabled: false, fallbackWorkerSrc: null, fakeWorkerId: 0 }; exports.PDFWorkerUtil = PDFWorkerUtil; { if (_is_node.isNodeJS && typeof require === \"function\") { PDFWorkerUtil.isWorkerDisabled = true; PDFWorkerUtil.fallbackWorkerSrc = \"./pdf.worker.js\"; } else if (typeof document === \"object\") { const pdfjsFilePath = document?.currentScript?.src; if (pdfjsFilePath) { PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\"); } } PDFWorkerUtil.isSameOrigin = function (baseUrl, otherUrl) { let base; try { base = new URL(baseUrl); if (!base.origin || base.origin === \"null\") { return false; } } catch (e) { return false; } const other = new URL(otherUrl, base); return base.origin === other.origin; }; PDFWorkerUtil.createCDNWrapper = function (url) { const wrapper = `importScripts(\"${url}\");`; return URL.createObjectURL(new Blob([wrapper])); }; } class PDFWorker { static #workerPorts = new WeakMap(); constructor({ name = null, port = null, verbosity = (0, _util.getVerbosityLevel)() } = {}) { if (port && PDFWorker.#workerPorts.has(port)) { throw new Error(\"Cannot use more than one PDFWorker per port.\"); } this.name = name; this.destroyed = false; this.verbosity = verbosity; this._readyCapability = (0, _util.createPromiseCapability)(); this._port = null; this._webWorker = null; this._messageHandler = null; if (port) { PDFWorker.#workerPorts.set(port, this); this._initializeFromPort(port); return; } this._initialize(); } get promise() { return this._readyCapability.promise; } get port() { return this._port; } get messageHandler() { return this._messageHandler; } _initializeFromPort(port) { this._port = port; this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port); this._messageHandler.on(\"ready\", function () {}); this._readyCapability.resolve(); this._messageHandler.send(\"configure\", { verbosity: this.verbosity }); } _initialize() { if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) { let { workerSrc } = PDFWorker; try { if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) { workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href); } const worker = new Worker(workerSrc); const messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", worker); const terminateEarly = () => { worker.removeEventListener(\"error\", onWorkerError); messageHandler.destroy(); worker.terminate(); if (this.destroyed) { this._readyCapability.reject(new Error(\"Worker was destroyed\")); } else { this._setupFakeWorker(); } }; const onWorkerError = () => { if (!this._webWorker) { terminateEarly(); } }; worker.addEventListener(\"error\", onWorkerError); messageHandler.on(\"test\", data => { worker.removeEventListener(\"error\", onWorkerError); if (this.destroyed) { terminateEarly(); return; } if (data) { this._messageHandler = messageHandler; this._port = worker; this._webWorker = worker; this._readyCapability.resolve(); messageHandler.send(\"configure\", { verbosity: this.verbosity }); } else { this._setupFakeWorker(); messageHandler.destroy(); worker.terminate(); } }); messageHandler.on(\"ready\", data => { worker.removeEventListener(\"error\", onWorkerError); if (this.destroyed) { terminateEarly(); return; } try { sendTest(); } catch (e) { this._setupFakeWorker(); } }); const sendTest = () => { const testObj = new Uint8Array(); messageHandler.send(\"test\", testObj, [testObj.buffer]); }; sendTest(); return; } catch (e) { (0, _util.info)(\"The worker has been disabled.\"); } } this._setupFakeWorker(); } _setupFakeWorker() { if (!PDFWorkerUtil.isWorkerDisabled) { (0, _util.warn)(\"Setting up fake worker.\"); PDFWorkerUtil.isWorkerDisabled = true; } PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => { if (this.destroyed) { this._readyCapability.reject(new Error(\"Worker was destroyed\")); return; } const port = new LoopbackPort(); this._port = port; const id = `fake${PDFWorkerUtil.fakeWorkerId++}`; const workerHandler = new _message_handler.MessageHandler(id + \"_worker\", id, port); WorkerMessageHandler.setup(workerHandler, port); const messageHandler = new _message_handler.MessageHandler(id, id + \"_worker\", port); this._messageHandler = messageHandler; this._readyCapability.resolve(); messageHandler.send(\"configure\", { verbosity: this.verbosity }); }).catch(reason => { this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`)); }); } destroy() { this.destroyed = true; if (this._webWorker) { this._webWorker.terminate(); this._webWorker = null; } PDFWorker.#workerPorts.delete(this._port); this._port = null; if (this._messageHandler) { this._messageHandler.destroy(); this._messageHandler = null; } } static fromPort(params) { if (!params?.port) { throw new Error(\"PDFWorker.fromPort - invalid method signature.\"); } if (this.#workerPorts.has(params.port)) { return this.#workerPorts.get(params.port); } return new PDFWorker(params); } static get workerSrc() { if (_worker_options.GlobalWorkerOptions.workerSrc) { return _worker_options.GlobalWorkerOptions.workerSrc; } if (PDFWorkerUtil.fallbackWorkerSrc !== null) { if (!_is_node.isNodeJS) { (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.'); } return PDFWorkerUtil.fallbackWorkerSrc; } throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.'); } static get _mainThreadWorkerMessageHandler() { try { return globalThis.pdfjsWorker?.WorkerMessageHandler || null; } catch (ex) { return null; } } static get _setupFakeWorkerGlobal() { const loader = async () => { const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler; if (mainWorkerMessageHandler) { return mainWorkerMessageHandler; } if (_is_node.isNodeJS && typeof require === \"function\") { const worker = eval(\"require\")(this.workerSrc); return worker.WorkerMessageHandler; } await (0, _display_utils.loadScript)(this.workerSrc); return window.pdfjsWorker.WorkerMessageHandler; }; return (0, _util.shadow)(this, \"_setupFakeWorkerGlobal\", loader()); } } exports.PDFWorker = PDFWorker; class WorkerTransport { #docStats = null; #pageCache = new Map(); #pagePromises = new Map(); #metadataPromise = null; constructor(messageHandler, loadingTask, networkStream, params) { this.messageHandler = messageHandler; this.loadingTask = loadingTask; this.commonObjs = new PDFObjects(); this.fontLoader = new _font_loader.FontLoader({ onUnsupportedFeature: this._onUnsupportedFeature.bind(this), ownerDocument: params.ownerDocument, styleElement: params.styleElement }); this._params = params; if (!params.useWorkerFetch) { this.CMapReaderFactory = new params.CMapReaderFactory({ baseUrl: params.cMapUrl, isCompressed: params.cMapPacked }); this.StandardFontDataFactory = new params.StandardFontDataFactory({ baseUrl: params.standardFontDataUrl }); } this.destroyed = false; this.destroyCapability = null; this._passwordCapability = null; this._networkStream = networkStream; this._fullReader = null; this._lastProgress = null; this.downloadInfoCapability = (0, _util.createPromiseCapability)(); this.setupMessageHandler(); } get annotationStorage() { return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage()); } get stats() { return this.#docStats; } getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) { let renderingIntent = _util.RenderingIntentFlag.DISPLAY; let annotationMap = null; switch (intent) { case \"any\": renderingIntent = _util.RenderingIntentFlag.ANY; break; case \"display\": break; case \"print\": renderingIntent = _util.RenderingIntentFlag.PRINT; break; default: (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`); } switch (annotationMode) { case _util.AnnotationMode.DISABLE: renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE; break; case _util.AnnotationMode.ENABLE: break; case _util.AnnotationMode.ENABLE_FORMS: renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS; break; case _util.AnnotationMode.ENABLE_STORAGE: renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE; const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage; annotationMap = annotationStorage.serializable; break; default: (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`); } if (isOpList) { renderingIntent += _util.RenderingIntentFlag.OPLIST; } return { renderingIntent, cacheKey: `${renderingIntent}_${_annotation_storage.AnnotationStorage.getHash(annotationMap)}`, annotationStorageMap: annotationMap }; } destroy() { if (this.destroyCapability) { return this.destroyCapability.promise; } this.destroyed = true; this.destroyCapability = (0, _util.createPromiseCapability)(); if (this._passwordCapability) { this._passwordCapability.reject(new Error(\"Worker was destroyed during onPassword callback\")); } const waitOn = []; for (const page of this.#pageCache.values()) { waitOn.push(page._destroy()); } this.#pageCache.clear(); this.#pagePromises.clear(); if (this.hasOwnProperty(\"annotationStorage\")) { this.annotationStorage.resetModified(); } const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null); waitOn.push(terminated); Promise.all(waitOn).then(() => { this.commonObjs.clear(); this.fontLoader.clear(); this.#metadataPromise = null; this._getFieldObjectsPromise = null; this._hasJSActionsPromise = null; if (this._networkStream) { this._networkStream.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\")); } if (this.messageHandler) { this.messageHandler.destroy(); this.messageHandler = null; } this.destroyCapability.resolve(); }, this.destroyCapability.reject); return this.destroyCapability.promise; } setupMessageHandler() { const { messageHandler, loadingTask } = this; messageHandler.on(\"GetReader\", (data, sink) => { (0, _util.assert)(this._networkStream, \"GetReader - no `IPDFStream` instance available.\"); this._fullReader = this._networkStream.getFullReader(); this._fullReader.onProgress = evt => { this._lastProgress = { loaded: evt.loaded, total: evt.total }; }; sink.onPull = () => { this._fullReader.read().then(function ({ value, done }) { if (done) { sink.close(); return; } (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetReader - expected an ArrayBuffer.\"); sink.enqueue(new Uint8Array(value), 1, [value]); }).catch(reason => { sink.error(reason); }); }; sink.onCancel = reason => { this._fullReader.cancel(reason); sink.ready.catch(readyReason => { if (this.destroyed) { return; } throw readyReason; }); }; }); messageHandler.on(\"ReaderHeadersReady\", data => { const headersCapability = (0, _util.createPromiseCapability)(); const fullReader = this._fullReader; fullReader.headersReady.then(() => { if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) { if (this._lastProgress) { loadingTask.onProgress?.(this._lastProgress); } fullReader.onProgress = evt => { loadingTask.onProgress?.({ loaded: evt.loaded, total: evt.total }); }; } headersCapability.resolve({ isStreamingSupported: fullReader.isStreamingSupported, isRangeSupported: fullReader.isRangeSupported, contentLength: fullReader.contentLength }); }, headersCapability.reject); return headersCapability.promise; }); messageHandler.on(\"GetRangeReader\", (data, sink) => { (0, _util.assert)(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\"); const rangeReader = this._networkStream.getRangeReader(data.begin, data.end); if (!rangeReader) { sink.close(); return; } sink.onPull = () => { rangeReader.read().then(function ({ value, done }) { if (done) { sink.close(); return; } (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetRangeReader - expected an ArrayBuffer.\"); sink.enqueue(new Uint8Array(value), 1, [value]); }).catch(reason => { sink.error(reason); }); }; sink.onCancel = reason => { rangeReader.cancel(reason); sink.ready.catch(readyReason => { if (this.destroyed) { return; } throw readyReason; }); }; }); messageHandler.on(\"GetDoc\", ({ pdfInfo }) => { this._numPages = pdfInfo.numPages; this._htmlForXfa = pdfInfo.htmlForXfa; delete pdfInfo.htmlForXfa; loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this)); }); messageHandler.on(\"DocException\", function (ex) { let reason; switch (ex.name) { case \"PasswordException\": reason = new _util.PasswordException(ex.message, ex.code); break; case \"InvalidPDFException\": reason = new _util.InvalidPDFException(ex.message); break; case \"MissingPDFException\": reason = new _util.MissingPDFException(ex.message); break; case \"UnexpectedResponseException\": reason = new _util.UnexpectedResponseException(ex.message, ex.status); break; case \"UnknownErrorException\": reason = new _util.UnknownErrorException(ex.message, ex.details); break; default: (0, _util.unreachable)(\"DocException - expected a valid Error.\"); } loadingTask._capability.reject(reason); }); messageHandler.on(\"PasswordRequest\", exception => { this._passwordCapability = (0, _util.createPromiseCapability)(); if (loadingTask.onPassword) { const updatePassword = password => { if (password instanceof Error) { this._passwordCapability.reject(password); } else { this._passwordCapability.resolve({ password }); } }; try { loadingTask.onPassword(updatePassword, exception.code); } catch (ex) { this._passwordCapability.reject(ex); } } else { this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code)); } return this._passwordCapability.promise; }); messageHandler.on(\"DataLoaded\", data => { loadingTask.onProgress?.({ loaded: data.length, total: data.length }); this.downloadInfoCapability.resolve(data); }); messageHandler.on(\"StartRenderPage\", data => { if (this.destroyed) { return; } const page = this.#pageCache.get(data.pageIndex); page._startRenderPage(data.transparency, data.cacheKey); }); messageHandler.on(\"commonobj\", ([id, type, exportedData]) => { if (this.destroyed) { return; } if (this.commonObjs.has(id)) { return; } switch (type) { case \"Font\": const params = this._params; if (\"error\" in exportedData) { const exportedError = exportedData.error; (0, _util.warn)(`Error during font loading: ${exportedError}`); this.commonObjs.resolve(id, exportedError); break; } let fontRegistry = null; if (params.pdfBug && globalThis.FontInspector?.enabled) { fontRegistry = { registerFont(font, url) { globalThis.FontInspector.fontAdded(font, url); } }; } const font = new _font_loader.FontFaceObject(exportedData, { isEvalSupported: params.isEvalSupported, disableFontFace: params.disableFontFace, ignoreErrors: params.ignoreErrors, onUnsupportedFeature: this._onUnsupportedFeature.bind(this), fontRegistry }); this.fontLoader.bind(font).catch(reason => { return messageHandler.sendWithPromise(\"FontFallback\", { id }); }).finally(() => { if (!params.fontExtraProperties && font.data) { font.data = null; } this.commonObjs.resolve(id, font); }); break; case \"FontPath\": case \"Image\": this.commonObjs.resolve(id, exportedData); break; default: throw new Error(`Got unknown common object type ${type}`); } }); messageHandler.on(\"obj\", ([id, pageIndex, type, imageData]) => { if (this.destroyed) { return; } const pageProxy = this.#pageCache.get(pageIndex); if (pageProxy.objs.has(id)) { return; } switch (type) { case \"Image\": pageProxy.objs.resolve(id, imageData); const MAX_IMAGE_SIZE_TO_STORE = 8000000; if (imageData) { let length; if (imageData.bitmap) { const { bitmap, width, height } = imageData; length = width * height * 4; pageProxy._bitmaps.add(bitmap); } else { length = imageData.data?.length || 0; } if (length > MAX_IMAGE_SIZE_TO_STORE) { pageProxy.cleanupAfterRender = true; } } break; case \"Pattern\": pageProxy.objs.resolve(id, imageData); break; default: throw new Error(`Got unknown object type ${type}`); } }); messageHandler.on(\"DocProgress\", data => { if (this.destroyed) { return; } loadingTask.onProgress?.({ loaded: data.loaded, total: data.total }); }); messageHandler.on(\"DocStats\", data => { if (this.destroyed) { return; } this.#docStats = Object.freeze({ streamTypes: Object.freeze(data.streamTypes), fontTypes: Object.freeze(data.fontTypes) }); }); messageHandler.on(\"UnsupportedFeature\", this._onUnsupportedFeature.bind(this)); messageHandler.on(\"FetchBuiltInCMap\", data => { if (this.destroyed) { return Promise.reject(new Error(\"Worker was destroyed.\")); } if (!this.CMapReaderFactory) { return Promise.reject(new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\")); } return this.CMapReaderFactory.fetch(data); }); messageHandler.on(\"FetchStandardFontData\", data => { if (this.destroyed) { return Promise.reject(new Error(\"Worker was destroyed.\")); } if (!this.StandardFontDataFactory) { return Promise.reject(new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\")); } return this.StandardFontDataFactory.fetch(data); }); } _onUnsupportedFeature({ featureId }) { if (this.destroyed) { return; } this.loadingTask.onUnsupportedFeature?.(featureId); } getData() { return this.messageHandler.sendWithPromise(\"GetData\", null); } saveDocument() { if (this.annotationStorage.size { this.annotationStorage.resetModified(); }); } getPage(pageNumber) { if (!Number.isInteger(pageNumber) || pageNumber this._numPages) { return Promise.reject(new Error(\"Invalid page request.\")); } const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex); if (cachedPromise) { return cachedPromise; } const promise = this.messageHandler.sendWithPromise(\"GetPage\", { pageIndex }).then(pageInfo => { if (this.destroyed) { throw new Error(\"Transport destroyed\"); } const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug); this.#pageCache.set(pageIndex, page); return page; }); this.#pagePromises.set(pageIndex, promise); return promise; } getPageIndex(ref) { if (typeof ref !== \"object\" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) { return Promise.reject(new Error(\"Invalid pageIndex request.\")); } return this.messageHandler.sendWithPromise(\"GetPageIndex\", { num: ref.num, gen: ref.gen }); } getAnnotations(pageIndex, intent) { return this.messageHandler.sendWithPromise(\"GetAnnotations\", { pageIndex, intent }); } getFieldObjects() { return this._getFieldObjectsPromise ||= this.messageHandler.sendWithPromise(\"GetFieldObjects\", null); } hasJSActions() { return this._hasJSActionsPromise ||= this.messageHandler.sendWithPromise(\"HasJSActions\", null); } getCalculationOrderIds() { return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null); } getDestinations() { return this.messageHandler.sendWithPromise(\"GetDestinations\", null); } getDestination(id) { if (typeof id !== \"string\") { return Promise.reject(new Error(\"Invalid destination request.\")); } return this.messageHandler.sendWithPromise(\"GetDestination\", { id }); } getPageLabels() { return this.messageHandler.sendWithPromise(\"GetPageLabels\", null); } getPageLayout() { return this.messageHandler.sendWithPromise(\"GetPageLayout\", null); } getPageMode() { return this.messageHandler.sendWithPromise(\"GetPageMode\", null); } getViewerPreferences() { return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null); } getOpenAction() { return this.messageHandler.sendWithPromise(\"GetOpenAction\", null); } getAttachments() { return this.messageHandler.sendWithPromise(\"GetAttachments\", null); } getJavaScript() { return this.messageHandler.sendWithPromise(\"GetJavaScript\", null); } getDocJSActions() { return this.messageHandler.sendWithPromise(\"GetDocJSActions\", null); } getPageJSActions(pageIndex) { return this.messageHandler.sendWithPromise(\"GetPageJSActions\", { pageIndex }); } getStructTree(pageIndex) { return this.messageHandler.sendWithPromise(\"GetStructTree\", { pageIndex }); } getOutline() { return this.messageHandler.sendWithPromise(\"GetOutline\", null); } getOptionalContentConfig() { return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then(results => { return new _optional_content_config.OptionalContentConfig(results); }); } getPermissions() { return this.messageHandler.sendWithPromise(\"GetPermissions\", null); } getMetadata() { return this.#metadataPromise ||= this.messageHandler.sendWithPromise(\"GetMetadata\", null).then(results => { return { info: results[0], metadata: results[1] ? new _metadata.Metadata(results[1]) : null, contentDispositionFilename: this._fullReader?.filename ?? null, contentLength: this._fullReader?.contentLength ?? null }; }); } getMarkInfo() { return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null); } async startCleanup(keepLoadedFonts = false) { if (this.destroyed) { return; } await this.messageHandler.sendWithPromise(\"Cleanup\", null); for (const page of this.#pageCache.values()) { const cleanupSuccessful = page.cleanup(); if (!cleanupSuccessful) { throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`); } } this.commonObjs.clear(); if (!keepLoadedFonts) { this.fontLoader.clear(); } this.#metadataPromise = null; this._getFieldObjectsPromise = null; this._hasJSActionsPromise = null; } get loadingParams() { const params = this._params; return (0, _util.shadow)(this, \"loadingParams\", { disableAutoFetch: params.disableAutoFetch, enableXfa: params.enableXfa }); } } class PDFObjects { #objs = Object.create(null); #ensureObj(objId) { const obj = this.#objs[objId]; if (obj) { return obj; } return this.#objs[objId] = { capability: (0, _util.createPromiseCapability)(), data: null }; } get(objId, callback = null) { if (callback) { const obj = this.#ensureObj(objId); obj.capability.promise.then(() => callback(obj.data)); return null; } const obj = this.#objs[objId]; if (!obj?.capability.settled) { throw new Error(`Requesting object that isn't resolved yet ${objId}.`); } return obj.data; } has(objId) { const obj = this.#objs[objId]; return obj?.capability.settled || false; } resolve(objId, data = null) { const obj = this.#ensureObj(objId); obj.data = data; obj.capability.resolve(); } clear() { this.#objs = Object.create(null); } } class RenderTask { #internalRenderTask = null; constructor(internalRenderTask) { this.#internalRenderTask = internalRenderTask; this.onContinue = null; } get promise() { return this.#internalRenderTask.capability.promise; } cancel(extraDelay = 0) { this.#internalRenderTask.cancel(null, extraDelay); } get separateAnnots() { const { separateAnnots } = this.#internalRenderTask.operatorList; if (!separateAnnots) { return false; } const { annotationCanvasMap } = this.#internalRenderTask; return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0; } } exports.RenderTask = RenderTask; class InternalRenderTask { static #canvasInUse = new WeakSet(); constructor({ callback, params, objs, commonObjs, annotationCanvasMap, operatorList, pageIndex, canvasFactory, useRequestAnimationFrame = false, pdfBug = false, pageColors = null }) { this.callback = callback; this.params = params; this.objs = objs; this.commonObjs = commonObjs; this.annotationCanvasMap = annotationCanvasMap; this.operatorListIdx = null; this.operatorList = operatorList; this._pageIndex = pageIndex; this.canvasFactory = canvasFactory; this._pdfBug = pdfBug; this.pageColors = pageColors; this.running = false; this.graphicsReadyCallback = null; this.graphicsReady = false; this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\"; this.cancelled = false; this.capability = (0, _util.createPromiseCapability)(); this.task = new RenderTask(this); this._cancelBound = this.cancel.bind(this); this._continueBound = this._continue.bind(this); this._scheduleNextBound = this._scheduleNext.bind(this); this._nextBound = this._next.bind(this); this._canvas = params.canvasContext.canvas; } get completed() { return this.capability.promise.catch(function () {}); } initializeGraphics({ transparency = false, optionalContentConfig }) { if (this.cancelled) { return; } if (this._canvas) { if (InternalRenderTask.#canvasInUse.has(this._canvas)) { throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\"); } InternalRenderTask.#canvasInUse.add(this._canvas); } if (this._pdfBug && globalThis.StepperManager?.enabled) { this.stepper = globalThis.StepperManager.create(this._pageIndex); this.stepper.init(this.operatorList); this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint(); } const { canvasContext, viewport, transform, background } = this.params; this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, { optionalContentConfig }, this.annotationCanvasMap, this.pageColors); this.gfx.beginDrawing({ transform, viewport, transparency, background }); this.operatorListIdx = 0; this.graphicsReady = true; this.graphicsReadyCallback?.(); } cancel(error = null, extraDelay = 0) { this.running = false; this.cancelled = true; this.gfx?.endDrawing(); if (this._canvas) { InternalRenderTask.#canvasInUse.delete(this._canvas); } this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, \"canvas\", extraDelay)); } operatorListChanged() { if (!this.graphicsReady) { if (!this.graphicsReadyCallback) { this.graphicsReadyCallback = this._continueBound; } return; } this.stepper?.updateOperatorList(this.operatorList); if (this.running) { return; } this._continue(); } _continue() { this.running = true; if (this.cancelled) { return; } if (this.task.onContinue) { this.task.onContinue(this._scheduleNextBound); } else { this._scheduleNext(); } } _scheduleNext() { if (this._useRequestAnimationFrame) { window.requestAnimationFrame(() => { this._nextBound().catch(this._cancelBound); }); } else { Promise.resolve().then(this._nextBound).catch(this._cancelBound); } } async _next() { if (this.cancelled) { return; } this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper); if (this.operatorListIdx === this.operatorList.argsArray.length) { this.running = false; if (this.operatorList.lastChunk) { this.gfx.endDrawing(); if (this._canvas) { InternalRenderTask.#canvasInUse.delete(this._canvas); } this.callback(); } } } } const version = '3.2.146'; exports.version = version; const build = '3fd2a3548'; exports.build = build; /***/ }), /* 3 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PrintAnnotationStorage = exports.AnnotationStorage = void 0; var _util = __w_pdfjs_require__(1); var _editor = __w_pdfjs_require__(4); var _murmurhash = __w_pdfjs_require__(8); class AnnotationStorage { #modified = false; #storage = new Map(); constructor() { this.onSetModified = null; this.onResetModified = null; this.onAnnotationEditor = null; } getValue(key, defaultValue) { const value = this.#storage.get(key); if (value === undefined) { return defaultValue; } return Object.assign(defaultValue, value); } getRawValue(key) { return this.#storage.get(key); } remove(key) { this.#storage.delete(key); if (this.#storage.size === 0) { this.resetModified(); } if (typeof this.onAnnotationEditor === \"function\") { for (const value of this.#storage.values()) { if (value instanceof _editor.AnnotationEditor) { return; } } this.onAnnotationEditor(null); } } setValue(key, value) { const obj = this.#storage.get(key); let modified = false; if (obj !== undefined) { for (const [entry, val] of Object.entries(value)) { if (obj[entry] !== val) { modified = true; obj[entry] = val; } } } else { modified = true; this.#storage.set(key, value); } if (modified) { this.#setModified(); } if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === \"function\") { this.onAnnotationEditor(value.constructor._type); } } has(key) { return this.#storage.has(key); } getAll() { return this.#storage.size > 0 ? (0, _util.objectFromMap)(this.#storage) : null; } get size() { return this.#storage.size; } #setModified() { if (!this.#modified) { this.#modified = true; if (typeof this.onSetModified === \"function\") { this.onSetModified(); } } } resetModified() { if (this.#modified) { this.#modified = false; if (typeof this.onResetModified === \"function\") { this.onResetModified(); } } } get print() { return new PrintAnnotationStorage(this); } get serializable() { if (this.#storage.size === 0) { return null; } const clone = new Map(); for (const [key, val] of this.#storage) { const serialized = val instanceof _editor.AnnotationEditor ? val.serialize() : val; if (serialized) { clone.set(key, serialized); } } return clone; } static getHash(map) { if (!map) { return \"\"; } const hash = new _murmurhash.MurmurHash3_64(); for (const [key, val] of map) { hash.update(`${key}:${JSON.stringify(val)}`); } return hash.hexdigest(); } } exports.AnnotationStorage = AnnotationStorage; class PrintAnnotationStorage extends AnnotationStorage { #serializable = null; constructor(parent) { super(); this.#serializable = structuredClone(parent.serializable); } get print() { (0, _util.unreachable)(\"Should not call PrintAnnotationStorage.print\"); } get serializable() { return this.#serializable; } } exports.PrintAnnotationStorage = PrintAnnotationStorage; /***/ }), /* 4 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.AnnotationEditor = void 0; var _tools = __w_pdfjs_require__(5); var _util = __w_pdfjs_require__(1); class AnnotationEditor { #boundFocusin = this.focusin.bind(this); #boundFocusout = this.focusout.bind(this); #hasBeenSelected = false; #isEditing = false; #isInEditMode = false; _uiManager = null; #zIndex = AnnotationEditor._zIndex++; static _colorManager = new _tools.ColorManager(); static _zIndex = 1; constructor(parameters) { if (this.constructor === AnnotationEditor) { (0, _util.unreachable)(\"Cannot initialize AnnotationEditor.\"); } this.parent = parameters.parent; this.id = parameters.id; this.width = this.height = null; this.pageIndex = parameters.parent.pageIndex; this.name = parameters.name; this.div = null; this._uiManager = parameters.uiManager; const { rotation, rawDims: { pageWidth, pageHeight, pageX, pageY } } = this.parent.viewport; this.rotation = rotation; this.pageDimensions = [pageWidth, pageHeight]; this.pageTranslation = [pageX, pageY]; const [width, height] = this.parentDimensions; this.x = parameters.x / width; this.y = parameters.y / height; this.isAttachedToDOM = false; } static get _defaultLineColor() { return (0, _util.shadow)(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\")); } addCommands(params) { this._uiManager.addCommands(params); } get currentLayer() { return this._uiManager.currentLayer; } setInBackground() { this.div.style.zIndex = 0; } setInForeground() { this.div.style.zIndex = this.#zIndex; } setParent(parent) { if (parent !== null) { this.pageIndex = parent.pageIndex; this.pageDimensions = parent.pageDimensions; } this.parent = parent; } focusin(event) { if (!this.#hasBeenSelected) { this.parent.setSelected(this); } else { this.#hasBeenSelected = false; } } focusout(event) { if (!this.isAttachedToDOM) { return; } const target = event.relatedTarget; if (target?.closest(`#${this.id}`)) { return; } event.preventDefault(); if (!this.parent?.isMultipleSelection) { this.commitOrRemove(); } } commitOrRemove() { if (this.isEmpty()) { this.remove(); } else { this.commit(); } } commit() { this.addToAnnotationStorage(); } addToAnnotationStorage() { this._uiManager.addToAnnotationStorage(this); } dragstart(event) { const rect = this.parent.div.getBoundingClientRect(); this.startX = event.clientX - rect.x; this.startY = event.clientY - rect.y; event.dataTransfer.setData(\"text/plain\", this.id); event.dataTransfer.effectAllowed = \"move\"; } setAt(x, y, tx, ty) { const [width, height] = this.parentDimensions; [tx, ty] = this.screenToPageTranslation(tx, ty); this.x = (x + tx) / width; this.y = (y + ty) / height; this.div.style.left = `${100 * this.x}%`; this.div.style.top = `${100 * this.y}%`; } translate(x, y) { const [width, height] = this.parentDimensions; [x, y] = this.screenToPageTranslation(x, y); this.x += x / width; this.y += y / height; this.div.style.left = `${100 * this.x}%`; this.div.style.top = `${100 * this.y}%`; } screenToPageTranslation(x, y) { switch (this.parentRotation) { case 90: return [y, -x]; case 180: return [-x, -y]; case 270: return [-y, x]; default: return [x, y]; } } get parentScale() { return this._uiManager.viewParameters.realScale; } get parentRotation() { return this._uiManager.viewParameters.rotation; } get parentDimensions() { const { realScale } = this._uiManager.viewParameters; const [pageWidth, pageHeight] = this.pageDimensions; return [pageWidth * realScale, pageHeight * realScale]; } setDims(width, height) { const [parentWidth, parentHeight] = this.parentDimensions; this.div.style.width = `${100 * width / parentWidth}%`; this.div.style.height = `${100 * height / parentHeight}%`; } fixDims() { const { style } = this.div; const { height, width } = style; const widthPercent = width.endsWith(\"%\"); const heightPercent = height.endsWith(\"%\"); if (widthPercent && heightPercent) { return; } const [parentWidth, parentHeight] = this.parentDimensions; if (!widthPercent) { style.width = `${100 * parseFloat(width) / parentWidth}%`; } if (!heightPercent) { style.height = `${100 * parseFloat(height) / parentHeight}%`; } } getInitialTranslation() { return [0, 0]; } render() { this.div = document.createElement(\"div\"); this.div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360); this.div.className = this.name; this.div.setAttribute(\"id\", this.id); this.div.setAttribute(\"tabIndex\", 0); this.setInForeground(); this.div.addEventListener(\"focusin\", this.#boundFocusin); this.div.addEventListener(\"focusout\", this.#boundFocusout); const [tx, ty] = this.getInitialTranslation(); this.translate(tx, ty); (0, _tools.bindEvents)(this, this.div, [\"dragstart\", \"pointerdown\"]); return this.div; } pointerdown(event) { const { isMac } = _util.FeatureTest.platform; if (event.button !== 0 || event.ctrlKey && isMac) { event.preventDefault(); return; } if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) { this.parent.toggleSelected(this); } else { this.parent.setSelected(this); } this.#hasBeenSelected = true; } getRect(tx, ty) { const scale = this.parentScale; const [pageWidth, pageHeight] = this.pageDimensions; const [pageX, pageY] = this.pageTranslation; const shiftX = tx / scale; const shiftY = ty / scale; const x = this.x * pageWidth; const y = this.y * pageHeight; const width = this.width * pageWidth; const height = this.height * pageHeight; switch (this.rotation) { case 0: return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY]; case 90: return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY]; case 180: return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY]; case 270: return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY]; default: throw new Error(\"Invalid rotation\"); } } getRectInCurrentCoords(rect, pageHeight) { const [x1, y1, x2, y2] = rect; const width = x2 - x1; const height = y2 - y1; switch (this.rotation) { case 0: return [x1, pageHeight - y2, width, height]; case 90: return [x1, pageHeight - y1, height, width]; case 180: return [x2, pageHeight - y1, width, height]; case 270: return [x2, pageHeight - y2, height, width]; default: throw new Error(\"Invalid rotation\"); } } onceAdded() {} isEmpty() { return false; } enableEditMode() { this.#isInEditMode = true; } disableEditMode() { this.#isInEditMode = false; } isInEditMode() { return this.#isInEditMode; } shouldGetKeyboardEvents() { return false; } needsToBeRebuilt() { return this.div && !this.isAttachedToDOM; } rebuild() { this.div?.addEventListener(\"focusin\", this.#boundFocusin); } serialize() { (0, _util.unreachable)(\"An editor must be serializable\"); } static deserialize(data, parent, uiManager) { const editor = new this.prototype.constructor({ parent, id: parent.getNextId(), uiManager }); editor.rotation = data.rotation; const [pageWidth, pageHeight] = editor.pageDimensions; const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight); editor.x = x / pageWidth; editor.y = y / pageHeight; editor.width = width / pageWidth; editor.height = height / pageHeight; return editor; } remove() { this.div.removeEventListener(\"focusin\", this.#boundFocusin); this.div.removeEventListener(\"focusout\", this.#boundFocusout); if (!this.isEmpty()) { this.commit(); } this.parent.remove(this); } select() { this.div?.classList.add(\"selectedEditor\"); } unselect() { this.div?.classList.remove(\"selectedEditor\"); } updateParams(type, value) {} disableEditing() {} enableEditing() {} get propertiesToUpdate() { return {}; } get contentDiv() { return this.div; } get isEditing() { return this.#isEditing; } set isEditing(value) { this.#isEditing = value; if (value) { this.parent.setSelected(this); this.parent.setActiveEditor(this); } else { this.parent.setActiveEditor(null); } } } exports.AnnotationEditor = AnnotationEditor; /***/ }), /* 5 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.KeyboardManager = exports.CommandManager = exports.ColorManager = exports.AnnotationEditorUIManager = void 0; exports.bindEvents = bindEvents; exports.opacityToHex = opacityToHex; var _util = __w_pdfjs_require__(1); var _display_utils = __w_pdfjs_require__(6); function bindEvents(obj, element, names) { for (const name of names) { element.addEventListener(name, obj[name].bind(obj)); } } function opacityToHex(opacity) { return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, \"0\"); } class IdManager { #id = 0; getId() { return `${_util.AnnotationEditorPrefix}${this.#id++}`; } } class CommandManager { #commands = []; #locked = false; #maxSize; #position = -1; constructor(maxSize = 128) { this.#maxSize = maxSize; } add({ cmd, undo, mustExec, type = NaN, overwriteIfSameType = false, keepUndo = false }) { if (mustExec) { cmd(); } if (this.#locked) { return; } const save = { cmd, undo, type }; if (this.#position === -1) { if (this.#commands.length > 0) { this.#commands.length = 0; } this.#position = 0; this.#commands.push(save); return; } if (overwriteIfSameType && this.#commands[this.#position].type === type) { if (keepUndo) { save.undo = this.#commands[this.#position].undo; } this.#commands[this.#position] = save; return; } const next = this.#position + 1; if (next === this.#maxSize) { this.#commands.splice(0, 1); } else { this.#position = next; if (next < this.#commands.length) { this.#commands.splice(next); } } this.#commands.push(save); } undo() { if (this.#position === -1) { return; } this.#locked = true; this.#commands[this.#position].undo(); this.#locked = false; this.#position -= 1; } redo() { if (this.#position < this.#commands.length - 1) { this.#position += 1; this.#locked = true; this.#commands[this.#position].cmd(); this.#locked = false; } } hasSomethingToUndo() { return this.#position !== -1; } hasSomethingToRedo() { return this.#position < this.#commands.length - 1; } destroy() { this.#commands = null; } } exports.CommandManager = CommandManager; class KeyboardManager { constructor(callbacks) { this.buffer = []; this.callbacks = new Map(); this.allKeys = new Set(); const { isMac } = _util.FeatureTest.platform; for (const [keys, callback] of callbacks) { for (const key of keys) { const isMacKey = key.startsWith(\"mac+\"); if (isMac && isMacKey) { this.callbacks.set(key.slice(4), callback); this.allKeys.add(key.split(\"+\").at(-1)); } else if (!isMac && !isMacKey) { this.callbacks.set(key, callback); this.allKeys.add(key.split(\"+\").at(-1)); } } } } #serialize(event) { if (event.altKey) { this.buffer.push(\"alt\"); } if (event.ctrlKey) { this.buffer.push(\"ctrl\"); } if (event.metaKey) { this.buffer.push(\"meta\"); } if (event.shiftKey) { this.buffer.push(\"shift\"); } this.buffer.push(event.key); const str = this.buffer.join(\"+\"); this.buffer.length = 0; return str; } exec(self, event) { if (!this.allKeys.has(event.key)) { return; } const callback = this.callbacks.get(this.#serialize(event)); if (!callback) { return; } callback.bind(self)(); event.stopPropagation(); event.preventDefault(); } } exports.KeyboardManager = KeyboardManager; class ColorManager { static _colorsMapping = new Map([[\"CanvasText\", [0, 0, 0]], [\"Canvas\", [255, 255, 255]]]); get _colors() { const colors = new Map([[\"CanvasText\", null], [\"Canvas\", null]]); (0, _display_utils.getColorValues)(colors); return (0, _util.shadow)(this, \"_colors\", colors); } convert(color) { const rgb = (0, _display_utils.getRGB)(color); if (!window.matchMedia(\"(forced-colors: active)\").matches) { return rgb; } for (const [name, RGB] of this._colors) { if (RGB.every((x, i) => x === rgb[i])) { return ColorManager._colorsMapping.get(name); } } return rgb; } getHexCode(name) { const rgb = this._colors.get(name); if (!rgb) { return name; } return _util.Util.makeHexColor(...rgb); } } exports.ColorManager = ColorManager; class AnnotationEditorUIManager { #activeEditor = null; #allEditors = new Map(); #allLayers = new Map(); #annotationStorage = null; #commandManager = new CommandManager(); #currentPageIndex = 0; #editorTypes = null; #editorsToRescale = new Set(); #eventBus = null; #idManager = new IdManager(); #isEnabled = false; #mode = _util.AnnotationEditorType.NONE; #selectedEditors = new Set(); #boundCopy = this.copy.bind(this); #boundCut = this.cut.bind(this); #boundPaste = this.paste.bind(this); #boundKeydown = this.keydown.bind(this); #boundOnEditingAction = this.onEditingAction.bind(this); #boundOnPageChanging = this.onPageChanging.bind(this); #boundOnScaleChanging = this.onScaleChanging.bind(this); #boundOnRotationChanging = this.onRotationChanging.bind(this); #previousStates = { isEditing: false, isEmpty: true, hasSomethingToUndo: false, hasSomethingToRedo: false, hasSelectedEditor: false }; #container = null; static _keyboardManager = new KeyboardManager([[[\"ctrl+a\", \"mac+meta+a\"], AnnotationEditorUIManager.prototype.selectAll], [[\"ctrl+z\", \"mac+meta+z\"], AnnotationEditorUIManager.prototype.undo], [[\"ctrl+y\", \"ctrl+shift+Z\", \"mac+meta+shift+Z\"], AnnotationEditorUIManager.prototype.redo], [[\"Backspace\", \"alt+Backspace\", \"ctrl+Backspace\", \"shift+Backspace\", \"mac+Backspace\", \"mac+alt+Backspace\", \"mac+ctrl+Backspace\", \"Delete\", \"ctrl+Delete\", \"shift+Delete\"], AnnotationEditorUIManager.prototype.delete], [[\"Escape\", \"mac+Escape\"], AnnotationEditorUIManager.prototype.unselectAll]]); constructor(container, eventBus, annotationStorage) { this.#container = container; this.#eventBus = eventBus; this.#eventBus._on(\"editingaction\", this.#boundOnEditingAction); this.#eventBus._on(\"pagechanging\", this.#boundOnPageChanging); this.#eventBus._on(\"scalechanging\", this.#boundOnScaleChanging); this.#eventBus._on(\"rotationchanging\", this.#boundOnRotationChanging); this.#annotationStorage = annotationStorage; this.viewParameters = { realScale: _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS, rotation: 0 }; } destroy() { this.#removeKeyboardManager(); this.#eventBus._off(\"editingaction\", this.#boundOnEditingAction); this.#eventBus._off(\"pagechanging\", this.#boundOnPageChanging); this.#eventBus._off(\"scalechanging\", this.#boundOnScaleChanging); this.#eventBus._off(\"rotationchanging\", this.#boundOnRotationChanging); for (const layer of this.#allLayers.values()) { layer.destroy(); } this.#allLayers.clear(); this.#allEditors.clear(); this.#editorsToRescale.clear(); this.#activeEditor = null; this.#selectedEditors.clear(); this.#commandManager.destroy(); } onPageChanging({ pageNumber }) { this.#currentPageIndex = pageNumber - 1; } focusMainContainer() { this.#container.focus(); } addShouldRescale(editor) { this.#editorsToRescale.add(editor); } removeShouldRescale(editor) { this.#editorsToRescale.delete(editor); } onScaleChanging({ scale }) { this.commitOrRemove(); this.viewParameters.realScale = scale * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS; for (const editor of this.#editorsToRescale) { editor.onScaleChanging(); } } onRotationChanging({ pagesRotation }) { this.commitOrRemove(); this.viewParameters.rotation = pagesRotation; } addToAnnotationStorage(editor) { if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) { this.#annotationStorage.setValue(editor.id, editor); } } #addKeyboardManager() { this.#container.addEventListener(\"keydown\", this.#boundKeydown); } #removeKeyboardManager() { this.#container.removeEventListener(\"keydown\", this.#boundKeydown); } #addCopyPasteListeners() { document.addEventListener(\"copy\", this.#boundCopy); document.addEventListener(\"cut\", this.#boundCut); document.addEventListener(\"paste\", this.#boundPaste); } #removeCopyPasteListeners() { document.removeEventListener(\"copy\", this.#boundCopy); document.removeEventListener(\"cut\", this.#boundCut); document.removeEventListener(\"paste\", this.#boundPaste); } copy(event) { event.preventDefault(); if (this.#activeEditor) { this.#activeEditor.commitOrRemove(); } if (!this.hasSelection) { return; } const editors = []; for (const editor of this.#selectedEditors) { if (!editor.isEmpty()) { editors.push(editor.serialize()); } } if (editors.length === 0) { return; } event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors)); } cut(event) { this.copy(event); this.delete(); } paste(event) { event.preventDefault(); let data = event.clipboardData.getData(\"application/pdfjs\"); if (!data) { return; } try { data = JSON.parse(data); } catch (ex) { (0, _util.warn)(`paste: \"${ex.message}\".`); return; } if (!Array.isArray(data)) { return; } this.unselectAll(); const layer = this.#allLayers.get(this.#currentPageIndex); try { const newEditors = []; for (const editor of data) { const deserializedEditor = layer.deserialize(editor); if (!deserializedEditor) { return; } newEditors.push(deserializedEditor); } const cmd = () => { for (const editor of newEditors) { this.#addEditorToLayer(editor); } this.#selectEditors(newEditors); }; const undo = () => { for (const editor of newEditors) { editor.remove(); } }; this.addCommands({ cmd, undo, mustExec: true }); } catch (ex) { (0, _util.warn)(`paste: \"${ex.message}\".`); } } keydown(event) { if (!this.getActive()?.shouldGetKeyboardEvents()) { AnnotationEditorUIManager._keyboardManager.exec(this, event); } } onEditingAction(details) { if ([\"undo\", \"redo\", \"delete\", \"selectAll\"].includes(details.name)) { this[details.name](); } } #dispatchUpdateStates(details) { const hasChanged = Object.entries(details).some(([key, value]) => this.#previousStates[key] !== value); if (hasChanged) { this.#eventBus.dispatch(\"annotationeditorstateschanged\", { source: this, details: Object.assign(this.#previousStates, details) }); } } #dispatchUpdateUI(details) { this.#eventBus.dispatch(\"annotationeditorparamschanged\", { source: this, details }); } setEditingState(isEditing) { if (isEditing) { this.#addKeyboardManager(); this.#addCopyPasteListeners(); this.#dispatchUpdateStates({ isEditing: this.#mode !== _util.AnnotationEditorType.NONE, isEmpty: this.#isEmpty(), hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(), hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(), hasSelectedEditor: false }); } else { this.#removeKeyboardManager(); this.#removeCopyPasteListeners(); this.#dispatchUpdateStates({ isEditing: false }); } } registerEditorTypes(types) { if (this.#editorTypes) { return; } this.#editorTypes = types; for (const editorType of this.#editorTypes) { this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate); } } getId() { return this.#idManager.getId(); } get currentLayer() { return this.#allLayers.get(this.#currentPageIndex); } get currentPageIndex() { return this.#currentPageIndex; } addLayer(layer) { this.#allLayers.set(layer.pageIndex, layer); if (this.#isEnabled) { layer.enable(); } else { layer.disable(); } } removeLayer(layer) { this.#allLayers.delete(layer.pageIndex); } updateMode(mode) { this.#mode = mode; if (mode === _util.AnnotationEditorType.NONE) { this.setEditingState(false); this.#disableAll(); } else { this.setEditingState(true); this.#enableAll(); for (const layer of this.#allLayers.values()) { layer.updateMode(mode); } } } updateToolbar(mode) { if (mode === this.#mode) { return; } this.#eventBus.dispatch(\"switchannotationeditormode\", { source: this, mode }); } updateParams(type, value) { if (!this.#editorTypes) { return; } for (const editor of this.#selectedEditors) { editor.updateParams(type, value); } for (const editorType of this.#editorTypes) { editorType.updateDefaultParams(type, value); } } #enableAll() { if (!this.#isEnabled) { this.#isEnabled = true; for (const layer of this.#allLayers.values()) { layer.enable(); } } } #disableAll() { this.unselectAll(); if (this.#isEnabled) { this.#isEnabled = false; for (const layer of this.#allLayers.values()) { layer.disable(); } } } getEditors(pageIndex) { const editors = []; for (const editor of this.#allEditors.values()) { if (editor.pageIndex === pageIndex) { editors.push(editor); } } return editors; } getEditor(id) { return this.#allEditors.get(id); } addEditor(editor) { this.#allEditors.set(editor.id, editor); } removeEditor(editor) { this.#allEditors.delete(editor.id); this.unselect(editor); this.#annotationStorage?.remove(editor.id); } #addEditorToLayer(editor) { const layer = this.#allLayers.get(editor.pageIndex); if (layer) { layer.addOrRebuild(editor); } else { this.addEditor(editor); } } setActiveEditor(editor) { if (this.#activeEditor === editor) { return; } this.#activeEditor = editor; if (editor) { this.#dispatchUpdateUI(editor.propertiesToUpdate); } } toggleSelected(editor) { if (this.#selectedEditors.has(editor)) { this.#selectedEditors.delete(editor); editor.unselect(); this.#dispatchUpdateStates({ hasSelectedEditor: this.hasSelection }); return; } this.#selectedEditors.add(editor); editor.select(); this.#dispatchUpdateUI(editor.propertiesToUpdate); this.#dispatchUpdateStates({ hasSelectedEditor: true }); } setSelected(editor) { for (const ed of this.#selectedEditors) { if (ed !== editor) { ed.unselect(); } } this.#selectedEditors.clear(); this.#selectedEditors.add(editor); editor.select(); this.#dispatchUpdateUI(editor.propertiesToUpdate); this.#dispatchUpdateStates({ hasSelectedEditor: true }); } isSelected(editor) { return this.#selectedEditors.has(editor); } unselect(editor) { editor.unselect(); this.#selectedEditors.delete(editor); this.#dispatchUpdateStates({ hasSelectedEditor: this.hasSelection }); } get hasSelection() { return this.#selectedEditors.size !== 0; } undo() { this.#commandManager.undo(); this.#dispatchUpdateStates({ hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(), hasSomethingToRedo: true, isEmpty: this.#isEmpty() }); } redo() { this.#commandManager.redo(); this.#dispatchUpdateStates({ hasSomethingToUndo: true, hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(), isEmpty: this.#isEmpty() }); } addCommands(params) { this.#commandManager.add(params); this.#dispatchUpdateStates({ hasSomethingToUndo: true, hasSomethingToRedo: false, isEmpty: this.#isEmpty() }); } #isEmpty() { if (this.#allEditors.size === 0) { return true; } if (this.#allEditors.size === 1) { for (const editor of this.#allEditors.values()) { return editor.isEmpty(); } } return false; } delete() { this.commitOrRemove(); if (!this.hasSelection) { return; } const editors = [...this.#selectedEditors]; const cmd = () => { for (const editor of editors) { editor.remove(); } }; const undo = () => { for (const editor of editors) { this.#addEditorToLayer(editor); } }; this.addCommands({ cmd, undo, mustExec: true }); } commitOrRemove() { this.#activeEditor?.commitOrRemove(); } #selectEditors(editors) { this.#selectedEditors.clear(); for (const editor of editors) { if (editor.isEmpty()) { continue; } this.#selectedEditors.add(editor); editor.select(); } this.#dispatchUpdateStates({ hasSelectedEditor: true }); } selectAll() { for (const editor of this.#selectedEditors) { editor.commit(); } this.#selectEditors(this.#allEditors.values()); } unselectAll() { if (this.#activeEditor) { this.#activeEditor.commitOrRemove(); return; } if (this.#selectedEditors.size === 0) { return; } for (const editor of this.#selectedEditors) { editor.unselect(); } this.#selectedEditors.clear(); this.#dispatchUpdateStates({ hasSelectedEditor: false }); } isActive(editor) { return this.#activeEditor === editor; } getActive() { return this.#activeEditor; } getMode() { return this.#mode; } } exports.AnnotationEditorUIManager = AnnotationEditorUIManager; /***/ }), /* 6 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = exports.AnnotationPrefix = void 0; exports.deprecated = deprecated; exports.getColorValues = getColorValues; exports.getCurrentTransform = getCurrentTransform; exports.getCurrentTransformInverse = getCurrentTransformInverse; exports.getFilenameFromUrl = getFilenameFromUrl; exports.getPdfFilenameFromUrl = getPdfFilenameFromUrl; exports.getRGB = getRGB; exports.getXfaPageViewport = getXfaPageViewport; exports.isDataScheme = isDataScheme; exports.isPdfFile = isPdfFile; exports.isValidFetchUrl = isValidFetchUrl; exports.loadScript = loadScript; exports.setLayerDimensions = setLayerDimensions; var _base_factory = __w_pdfjs_require__(7); var _util = __w_pdfjs_require__(1); const SVG_NS = \"http://www.w3.org/2000/svg\"; const AnnotationPrefix = \"pdfjs_internal_id_\"; exports.AnnotationPrefix = AnnotationPrefix; class PixelsPerInch { static CSS = 96.0; static PDF = 72.0; static PDF_TO_CSS_UNITS = this.CSS / this.PDF; } exports.PixelsPerInch = PixelsPerInch; class DOMCanvasFactory extends _base_factory.BaseCanvasFactory { constructor({ ownerDocument = globalThis.document } = {}) { super(); this._document = ownerDocument; } _createCanvas(width, height) { const canvas = this._document.createElement(\"canvas\"); canvas.width = width; canvas.height = height; return canvas; } } exports.DOMCanvasFactory = DOMCanvasFactory; async function fetchData(url, asTypedArray = false) { if (isValidFetchUrl(url, document.baseURI)) { const response = await fetch(url); if (!response.ok) { throw new Error(response.statusText); } return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util.stringToBytes)(await response.text()); } return new Promise((resolve, reject) => { const request = new XMLHttpRequest(); request.open(\"GET\", url, true); if (asTypedArray) { request.responseType = \"arraybuffer\"; } request.onreadystatechange = () => { if (request.readyState !== XMLHttpRequest.DONE) { return; } if (request.status === 200 || request.status === 0) { let data; if (asTypedArray && request.response) { data = new Uint8Array(request.response); } else if (!asTypedArray && request.responseText) { data = (0, _util.stringToBytes)(request.responseText); } if (data) { resolve(data); return; } } reject(new Error(request.statusText)); }; request.send(null); }); } class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory { _fetchData(url, compressionType) { return fetchData(url, this.isCompressed).then(data => { return { cMapData: data, compressionType }; }); } } exports.DOMCMapReaderFactory = DOMCMapReaderFactory; class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory { _fetchData(url) { return fetchData(url, true); } } exports.DOMStandardFontDataFactory = DOMStandardFontDataFactory; class DOMSVGFactory extends _base_factory.BaseSVGFactory { _createSVG(type) { return document.createElementNS(SVG_NS, type); } } exports.DOMSVGFactory = DOMSVGFactory; class PageViewport { constructor({ viewBox, scale, rotation, offsetX = 0, offsetY = 0, dontFlip = false }) { this.viewBox = viewBox; this.scale = scale; this.rotation = rotation; this.offsetX = offsetX; this.offsetY = offsetY; const centerX = (viewBox[2] + viewBox[0]) / 2; const centerY = (viewBox[3] + viewBox[1]) / 2; let rotateA, rotateB, rotateC, rotateD; rotation %= 360; if (rotation < 0) { rotation += 360; } switch (rotation) { case 180: rotateA = -1; rotateB = 0; rotateC = 0; rotateD = 1; break; case 90: rotateA = 0; rotateB = 1; rotateC = 1; rotateD = 0; break; case 270: rotateA = 0; rotateB = -1; rotateC = -1; rotateD = 0; break; case 0: rotateA = 1; rotateB = 0; rotateC = 0; rotateD = -1; break; default: throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\"); } if (dontFlip) { rotateC = -rotateC; rotateD = -rotateD; } let offsetCanvasX, offsetCanvasY; let width, height; if (rotateA === 0) { offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX; offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY; width = (viewBox[3] - viewBox[1]) * scale; height = (viewBox[2] - viewBox[0]) * scale; } else { offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX; offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY; width = (viewBox[2] - viewBox[0]) * scale; height = (viewBox[3] - viewBox[1]) * scale; } this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY]; this.width = width; this.height = height; } get rawDims() { const { viewBox } = this; return (0, _util.shadow)(this, \"rawDims\", { pageWidth: viewBox[2] - viewBox[0], pageHeight: viewBox[3] - viewBox[1], pageX: viewBox[0], pageY: viewBox[1] }); } clone({ scale = this.scale, rotation = this.rotation, offsetX = this.offsetX, offsetY = this.offsetY, dontFlip = false } = {}) { return new PageViewport({ viewBox: this.viewBox.slice(), scale, rotation, offsetX, offsetY, dontFlip }); } convertToViewportPoint(x, y) { return _util.Util.applyTransform([x, y], this.transform); } convertToViewportRectangle(rect) { const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform); const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform); return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]]; } convertToPdfPoint(x, y) { return _util.Util.applyInverseTransform([x, y], this.transform); } } exports.PageViewport = PageViewport; class RenderingCancelledException extends _util.BaseException { constructor(msg, type, extraDelay = 0) { super(msg, \"RenderingCancelledException\"); this.type = type; this.extraDelay = extraDelay; } } exports.RenderingCancelledException = RenderingCancelledException; function isDataScheme(url) { const ii = url.length; let i = 0; while (i < ii && url[i].trim() === \"\") { i++; } return url.substring(i, i + 5).toLowerCase() === \"data:\"; } function isPdfFile(filename) { return typeof filename === \"string\" && /\\.pdf$/i.test(filename); } function getFilenameFromUrl(url, onlyStripPath = false) { if (!onlyStripPath) { [url] = url.split(/[#?]/, 1); } return url.substring(url.lastIndexOf(\"/\") + 1); } function getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") { if (typeof url !== \"string\") { return defaultFilename; } if (isDataScheme(url)) { (0, _util.warn)('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.'); return defaultFilename; } const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/; const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i; const splitURI = reURI.exec(url); let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]); if (suggestedFilename) { suggestedFilename = suggestedFilename[0]; if (suggestedFilename.includes(\"%\")) { try { suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0]; } catch (ex) {} } } return suggestedFilename || defaultFilename; } class StatTimer { started = Object.create(null); times = []; time(name) { if (name in this.started) { (0, _util.warn)(`Timer is already running for ${name}`); } this.started[name] = Date.now(); } timeEnd(name) { if (!(name in this.started)) { (0, _util.warn)(`Timer has not been started for ${name}`); } this.times.push({ name, start: this.started[name], end: Date.now() }); delete this.started[name]; } toString() { const outBuf = []; let longest = 0; for (const { name } of this.times) { longest = Math.max(name.length, longest); } for (const { name, start, end } of this.times) { outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`); } return outBuf.join(\"\"); } } exports.StatTimer = StatTimer; function isValidFetchUrl(url, baseUrl) { try { const { protocol } = baseUrl ? new URL(url, baseUrl) : new URL(url); return protocol === \"http:\" || protocol === \"https:\"; } catch (ex) { return false; } } function loadScript(src, removeScriptElement = false) { return new Promise((resolve, reject) => { const script = document.createElement(\"script\"); script.src = src; script.onload = function (evt) { if (removeScriptElement) { script.remove(); } resolve(evt); }; script.onerror = function () { reject(new Error(`Cannot load script at: ${script.src}`)); }; (document.head || document.documentElement).append(script); }); } function deprecated(details) { console.log(\"Deprecated API usage: \" + details); } let pdfDateStringRegex; class PDFDateString { static toDateObject(input) { if (!input || typeof input !== \"string\") { return null; } if (!pdfDateStringRegex) { pdfDateStringRegex = new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\"); } const matches = pdfDateStringRegex.exec(input); if (!matches) { return null; } const year = parseInt(matches[1], 10); let month = parseInt(matches[2], 10); month = month >= 1 && month = 1 && day = 0 && hour = 0 && minute = 0 && second = 0 && offsetHour = 0 && offsetMinute > 16, (colorRGB & 0x00ff00) >> 8, colorRGB & 0x0000ff]; } if (color.startsWith(\"rgb(\")) { return color.slice(4, -1).split(\",\").map(x => parseInt(x)); } if (color.startsWith(\"rgba(\")) { return color.slice(5, -1).split(\",\").map(x => parseInt(x)).slice(0, 3); } (0, _util.warn)(`Not a valid color format: \"${color}\"`); return [0, 0, 0]; } function getColorValues(colors) { const span = document.createElement(\"span\"); span.style.visibility = \"hidden\"; document.body.append(span); for (const name of colors.keys()) { span.style.color = name; const computedColor = window.getComputedStyle(span).color; colors.set(name, getRGB(computedColor)); } span.remove(); } function getCurrentTransform(ctx) { const { a, b, c, d, e, f } = ctx.getTransform(); return [a, b, c, d, e, f]; } function getCurrentTransformInverse(ctx) { const { a, b, c, d, e, f } = ctx.getTransform().invertSelf(); return [a, b, c, d, e, f]; } function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) { if (viewport instanceof PageViewport) { const { pageWidth, pageHeight } = viewport.rawDims; const { style } = div; const widthStr = `calc(var(--scale-factor) * ${pageWidth}px)`; const heightStr = `calc(var(--scale-factor) * ${pageHeight}px)`; if (!mustFlip || viewport.rotation % 180 === 0) { style.width = widthStr; style.height = heightStr; } else { style.width = heightStr; style.height = widthStr; } } if (mustRotate) { div.setAttribute(\"data-main-rotation\", viewport.rotation); } } /***/ }), /* 7 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0; var _util = __w_pdfjs_require__(1); class BaseCanvasFactory { constructor() { if (this.constructor === BaseCanvasFactory) { (0, _util.unreachable)(\"Cannot initialize BaseCanvasFactory.\"); } } create(width, height) { if (width 2; const tailLength = length - blockCounts * 4; const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts); let k1 = 0, k2 = 0; let h1 = this.h1, h2 = this.h2; const C1 = 0xcc9e2d51, C2 = 0x1b873593; const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW; for (let i = 0; i < blockCounts; i++) { if (i & 1) { k1 = dataUint32[i]; k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW; k1 = k1 < 15 | k1 >>> 17; k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW; h1 ^= k1; h1 = h1 < 13 | h1 >>> 19; h1 = h1 * 5 + 0xe6546b64; } else { k2 = dataUint32[i]; k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW; k2 = k2 < 15 | k2 >>> 17; k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW; h2 ^= k2; h2 = h2 < 13 | h2 >>> 19; h2 = h2 * 5 + 0xe6546b64; } } k1 = 0; switch (tailLength) { case 3: k1 ^= data[blockCounts * 4 + 2] < 16; case 2: k1 ^= data[blockCounts * 4 + 1] < 8; case 1: k1 ^= data[blockCounts * 4]; k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW; k1 = k1 < 15 | k1 >>> 17; k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW; if (blockCounts & 1) { h1 ^= k1; } else { h2 ^= k1; } } this.h1 = h1; this.h2 = h2; } hexdigest() { let h1 = this.h1, h2 = this.h2; h1 ^= h2 >>> 1; h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW; h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 < 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16; h1 ^= h2 >>> 1; h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW; h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 < 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16; h1 ^= h2 >>> 1; return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\"); } } exports.MurmurHash3_64 = MurmurHash3_64; /***/ }), /* 9 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.FontLoader = exports.FontFaceObject = void 0; var _util = __w_pdfjs_require__(1); var _is_node = __w_pdfjs_require__(10); class FontLoader { constructor({ onUnsupportedFeature, ownerDocument = globalThis.document, styleElement = null }) { this._onUnsupportedFeature = onUnsupportedFeature; this._document = ownerDocument; this.nativeFontFaces = []; this.styleElement = null; this.loadingRequests = []; this.loadTestFontId = 0; } addNativeFontFace(nativeFontFace) { this.nativeFontFaces.push(nativeFontFace); this._document.fonts.add(nativeFontFace); } insertRule(rule) { if (!this.styleElement) { this.styleElement = this._document.createElement(\"style\"); this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement); } const styleSheet = this.styleElement.sheet; styleSheet.insertRule(rule, styleSheet.cssRules.length); } clear() { for (const nativeFontFace of this.nativeFontFaces) { this._document.fonts.delete(nativeFontFace); } this.nativeFontFaces.length = 0; if (this.styleElement) { this.styleElement.remove(); this.styleElement = null; } } async bind(font) { if (font.attached || font.missingFile) { return; } font.attached = true; if (this.isFontLoadingAPISupported) { const nativeFontFace = font.createNativeFontFace(); if (nativeFontFace) { this.addNativeFontFace(nativeFontFace); try { await nativeFontFace.loaded; } catch (ex) { this._onUnsupportedFeature({ featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative }); (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`); font.disableFontFace = true; throw ex; } } return; } const rule = font.createFontFaceRule(); if (rule) { this.insertRule(rule); if (this.isSyncFontLoadingSupported) { return; } await new Promise(resolve => { const request = this._queueLoadingCallback(resolve); this._prepareFontLoadEvent(font, request); }); } } get isFontLoadingAPISupported() { const hasFonts = !!this._document?.fonts; return (0, _util.shadow)(this, \"isFontLoadingAPISupported\", hasFonts); } get isSyncFontLoadingSupported() { let supported = false; if (_is_node.isNodeJS) { supported = true; } else if (typeof navigator !== \"undefined\" && /Mozilla\\/5.0.*?rv:\\d+.*? Gecko/.test(navigator.userAgent)) { supported = true; } return (0, _util.shadow)(this, \"isSyncFontLoadingSupported\", supported); } _queueLoadingCallback(callback) { function completeRequest() { (0, _util.assert)(!request.done, \"completeRequest() cannot be called twice.\"); request.done = true; while (loadingRequests.length > 0 && loadingRequests[0].done) { const otherRequest = loadingRequests.shift(); setTimeout(otherRequest.callback, 0); } } const { loadingRequests } = this; const request = { done: false, complete: completeRequest, callback }; loadingRequests.push(request); return request; } get _loadTestFont() { const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\"); return (0, _util.shadow)(this, \"_loadTestFont\", testFont); } _prepareFontLoadEvent(font, request) { function int32(data, offset) { return data.charCodeAt(offset) < 24 | data.charCodeAt(offset + 1) < 16 | data.charCodeAt(offset + 2) < 8 | data.charCodeAt(offset + 3) & 0xff; } function spliceString(s, offset, remove, insert) { const chunk1 = s.substring(0, offset); const chunk2 = s.substring(offset + remove); return chunk1 + insert + chunk2; } let i, ii; const canvas = this._document.createElement(\"canvas\"); canvas.width = 1; canvas.height = 1; const ctx = canvas.getContext(\"2d\"); let called = 0; function isFontReady(name, callback) { if (++called > 30) { (0, _util.warn)(\"Load test font never loaded.\"); callback(); return; } ctx.font = \"30px \" + name; ctx.fillText(\".\", 0, 20); const imageData = ctx.getImageData(0, 0, 1, 1); if (imageData.data[3] > 0) { callback(); return; } setTimeout(isFontReady.bind(null, name, callback)); } const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`; let data = this._loadTestFont; const COMMENT_OFFSET = 976; data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId); const CFF_CHECKSUM_OFFSET = 16; const XXXX_VALUE = 0x58585858; let checksum = int32(data, CFF_CHECKSUM_OFFSET); for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) { checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0; } if (i < loadTestFontId.length) { checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0; } data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum)); const url = `url(data:font/opentype;base64,${btoa(data)});`; const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`; this.insertRule(rule); const div = this._document.createElement(\"div\"); div.style.visibility = \"hidden\"; div.style.width = div.style.height = \"10px\"; div.style.position = \"absolute\"; div.style.top = div.style.left = \"0px\"; for (const name of [font.loadedName, loadTestFontId]) { const span = this._document.createElement(\"span\"); span.textContent = \"Hi\"; span.style.fontFamily = name; div.append(span); } this._document.body.append(div); isFontReady(loadTestFontId, () => { div.remove(); request.complete(); }); } } exports.FontLoader = FontLoader; class FontFaceObject { constructor(translatedData, { isEvalSupported = true, disableFontFace = false, ignoreErrors = false, onUnsupportedFeature, fontRegistry = null }) { this.compiledGlyphs = Object.create(null); for (const i in translatedData) { this[i] = translatedData[i]; } this.isEvalSupported = isEvalSupported !== false; this.disableFontFace = disableFontFace === true; this.ignoreErrors = ignoreErrors === true; this._onUnsupportedFeature = onUnsupportedFeature; this.fontRegistry = fontRegistry; } createNativeFontFace() { if (!this.data || this.disableFontFace) { return null; } let nativeFontFace; if (!this.cssFontInfo) { nativeFontFace = new FontFace(this.loadedName, this.data, {}); } else { const css = { weight: this.cssFontInfo.fontWeight }; if (this.cssFontInfo.italicAngle) { css.style = `oblique ${this.cssFontInfo.italicAngle}deg`; } nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css); } this.fontRegistry?.registerFont(this); return nativeFontFace; } createFontFaceRule() { if (!this.data || this.disableFontFace) { return null; } const data = (0, _util.bytesToString)(this.data); const url = `url(data:${this.mimetype};base64,${btoa(data)});`; let rule; if (!this.cssFontInfo) { rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`; } else { let css = `font-weight: ${this.cssFontInfo.fontWeight};`; if (this.cssFontInfo.italicAngle) { css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`; } rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`; } this.fontRegistry?.registerFont(this, url); return rule; } getPathGenerator(objs, character) { if (this.compiledGlyphs[character] !== undefined) { return this.compiledGlyphs[character]; } let cmds; try { cmds = objs.get(this.loadedName + \"_path_\" + character); } catch (ex) { if (!this.ignoreErrors) { throw ex; } this._onUnsupportedFeature({ featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath }); (0, _util.warn)(`getPathGenerator - ignoring character: \"${ex}\".`); return this.compiledGlyphs[character] = function (c, size) {}; } if (this.isEvalSupported && _util.FeatureTest.isEvalSupported) { const jsBuf = []; for (const current of cmds) { const args = current.args !== undefined ? current.args.join(\",\") : \"\"; jsBuf.push(\"c.\", current.cmd, \"(\", args, \");\\n\"); } return this.compiledGlyphs[character] = new Function(\"c\", \"size\", jsBuf.join(\"\")); } return this.compiledGlyphs[character] = function (c, size) { for (const current of cmds) { if (current.cmd === \"scale\") { current.args = [size, -size]; } c[current.cmd].apply(c, current.args); } }; } } exports.FontFaceObject = FontFaceObject; /***/ }), /* 10 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.isNodeJS = void 0; const isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\"); exports.isNodeJS = isNodeJS; /***/ }), /* 11 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.CanvasGraphics = void 0; var _util = __w_pdfjs_require__(1); var _display_utils = __w_pdfjs_require__(6); var _pattern_helper = __w_pdfjs_require__(12); var _image_utils = __w_pdfjs_require__(13); var _is_node = __w_pdfjs_require__(10); const MIN_FONT_SIZE = 16; const MAX_FONT_SIZE = 100; const MAX_GROUP_SIZE = 4096; const EXECUTION_TIME = 15; const EXECUTION_STEPS = 10; const MAX_SIZE_TO_COMPILE = _is_node.isNodeJS && typeof Path2D === \"undefined\" ? -1 : 1000; const FULL_CHUNK_HEIGHT = 16; function mirrorContextOperations(ctx, destCtx) { if (ctx._removeMirroring) { throw new Error(\"Context is already forwarding operations.\"); } ctx.__originalSave = ctx.save; ctx.__originalRestore = ctx.restore; ctx.__originalRotate = ctx.rotate; ctx.__originalScale = ctx.scale; ctx.__originalTranslate = ctx.translate; ctx.__originalTransform = ctx.transform; ctx.__originalSetTransform = ctx.setTransform; ctx.__originalResetTransform = ctx.resetTransform; ctx.__originalClip = ctx.clip; ctx.__originalMoveTo = ctx.moveTo; ctx.__originalLineTo = ctx.lineTo; ctx.__originalBezierCurveTo = ctx.bezierCurveTo; ctx.__originalRect = ctx.rect; ctx.__originalClosePath = ctx.closePath; ctx.__originalBeginPath = ctx.beginPath; ctx._removeMirroring = () => { ctx.save = ctx.__originalSave; ctx.restore = ctx.__originalRestore; ctx.rotate = ctx.__originalRotate; ctx.scale = ctx.__originalScale; ctx.translate = ctx.__originalTranslate; ctx.transform = ctx.__originalTransform; ctx.setTransform = ctx.__originalSetTransform; ctx.resetTransform = ctx.__originalResetTransform; ctx.clip = ctx.__originalClip; ctx.moveTo = ctx.__originalMoveTo; ctx.lineTo = ctx.__originalLineTo; ctx.bezierCurveTo = ctx.__originalBezierCurveTo; ctx.rect = ctx.__originalRect; ctx.closePath = ctx.__originalClosePath; ctx.beginPath = ctx.__originalBeginPath; delete ctx._removeMirroring; }; ctx.save = function ctxSave() { destCtx.save(); this.__originalSave(); }; ctx.restore = function ctxRestore() { destCtx.restore(); this.__originalRestore(); }; ctx.translate = function ctxTranslate(x, y) { destCtx.translate(x, y); this.__originalTranslate(x, y); }; ctx.scale = function ctxScale(x, y) { destCtx.scale(x, y); this.__originalScale(x, y); }; ctx.transform = function ctxTransform(a, b, c, d, e, f) { destCtx.transform(a, b, c, d, e, f); this.__originalTransform(a, b, c, d, e, f); }; ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) { destCtx.setTransform(a, b, c, d, e, f); this.__originalSetTransform(a, b, c, d, e, f); }; ctx.resetTransform = function ctxResetTransform() { destCtx.resetTransform(); this.__originalResetTransform(); }; ctx.rotate = function ctxRotate(angle) { destCtx.rotate(angle); this.__originalRotate(angle); }; ctx.clip = function ctxRotate(rule) { destCtx.clip(rule); this.__originalClip(rule); }; ctx.moveTo = function (x, y) { destCtx.moveTo(x, y); this.__originalMoveTo(x, y); }; ctx.lineTo = function (x, y) { destCtx.lineTo(x, y); this.__originalLineTo(x, y); }; ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) { destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y); this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y); }; ctx.rect = function (x, y, width, height) { destCtx.rect(x, y, width, height); this.__originalRect(x, y, width, height); }; ctx.closePath = function () { destCtx.closePath(); this.__originalClosePath(); }; ctx.beginPath = function () { destCtx.beginPath(); this.__originalBeginPath(); }; } class CachedCanvases { constructor(canvasFactory) { this.canvasFactory = canvasFactory; this.cache = Object.create(null); } getCanvas(id, width, height) { let canvasEntry; if (this.cache[id] !== undefined) { canvasEntry = this.cache[id]; this.canvasFactory.reset(canvasEntry, width, height); } else { canvasEntry = this.canvasFactory.create(width, height); this.cache[id] = canvasEntry; } return canvasEntry; } delete(id) { delete this.cache[id]; } clear() { for (const id in this.cache) { const canvasEntry = this.cache[id]; this.canvasFactory.destroy(canvasEntry); delete this.cache[id]; } } } function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) { const [a, b, c, d, tx, ty] = (0, _display_utils.getCurrentTransform)(ctx); if (b === 0 && c === 0) { const tlX = destX * a + tx; const rTlX = Math.round(tlX); const tlY = destY * d + ty; const rTlY = Math.round(tlY); const brX = (destX + destW) * a + tx; const rWidth = Math.abs(Math.round(brX) - rTlX) || 1; const brY = (destY + destH) * d + ty; const rHeight = Math.abs(Math.round(brY) - rTlY) || 1; ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY); ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight); ctx.setTransform(a, b, c, d, tx, ty); return [rWidth, rHeight]; } if (a === 0 && d === 0) { const tlX = destY * c + tx; const rTlX = Math.round(tlX); const tlY = destX * b + ty; const rTlY = Math.round(tlY); const brX = (destY + destH) * c + tx; const rWidth = Math.abs(Math.round(brX) - rTlX) || 1; const brY = (destX + destW) * b + ty; const rHeight = Math.abs(Math.round(brY) - rTlY) || 1; ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY); ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth); ctx.setTransform(a, b, c, d, tx, ty); return [rHeight, rWidth]; } ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH); const scaleX = Math.hypot(a, b); const scaleY = Math.hypot(c, d); return [scaleX * destW, scaleY * destH]; } function compileType3Glyph(imgData) { const { width, height } = imgData; if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) { return null; } const POINT_TO_PROCESS_LIMIT = 1000; const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]); const width1 = width + 1; let points = new Uint8Array(width1 * (height + 1)); let i, j, j0; const lineSize = width + 7 & ~7; let data = new Uint8Array(lineSize * height), pos = 0; for (const elem of imgData.data) { let mask = 128; while (mask > 0) { data[pos++] = elem & mask ? 0 : 255; mask >>= 1; } } let count = 0; pos = 0; if (data[pos] !== 0) { points[0] = 1; ++count; } for (j = 1; j < width; j++) { if (data[pos] !== data[pos + 1]) { points[j] = data[pos] ? 2 : 1; ++count; } pos++; } if (data[pos] !== 0) { points[j] = 2; ++count; } for (i = 1; i < height; i++) { pos = i * lineSize; j0 = i * width1; if (data[pos - lineSize] !== data[pos]) { points[j0] = data[pos] ? 1 : 8; ++count; } let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0); for (j = 1; j < width; j++) { sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0); if (POINT_TYPES[sum]) { points[j0 + j] = POINT_TYPES[sum]; ++count; } pos++; } if (data[pos - lineSize] !== data[pos]) { points[j0 + j] = data[pos] ? 2 : 4; ++count; } if (count > POINT_TO_PROCESS_LIMIT) { return null; } } pos = lineSize * (height - 1); j0 = i * width1; if (data[pos] !== 0) { points[j0] = 8; ++count; } for (j = 1; j < width; j++) { if (data[pos] !== data[pos + 1]) { points[j0 + j] = data[pos] ? 4 : 8; ++count; } pos++; } if (data[pos] !== 0) { points[j0 + j] = 4; ++count; } if (count > POINT_TO_PROCESS_LIMIT) { return null; } const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]); const path = new Path2D(); for (i = 0; count && i 1) { const mainKey = img.bitmap || img.data.buffer; cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]); cache = this._cachedBitmapsMap.get(mainKey); if (!cache) { cache = new Map(); this._cachedBitmapsMap.set(mainKey, cache); } const cachedImage = cache.get(cacheKey); if (cachedImage && !isPatternFill) { const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]); const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]); return { canvas: cachedImage, offsetX, offsetY }; } scaled = cachedImage; } if (!scaled) { maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height); putBinaryImageMask(maskCanvas.context, img); } let maskToCanvas = _util.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]); maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]); const cord1 = _util.Util.applyTransform([0, 0], maskToCanvas); const cord2 = _util.Util.applyTransform([width, height], maskToCanvas); const rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]); const drawnWidth = Math.round(rect[2] - rect[0]) || 1; const drawnHeight = Math.round(rect[3] - rect[1]) || 1; const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight); const fillCtx = fillCanvas.context; const offsetX = Math.min(cord1[0], cord2[0]); const offsetY = Math.min(cord1[1], cord2[1]); fillCtx.translate(-offsetX, -offsetY); fillCtx.transform(...maskToCanvas); if (!scaled) { scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils.getCurrentTransformInverse)(fillCtx)); scaled = scaled.img; if (cache && isPatternFill) { cache.set(cacheKey, scaled); } } fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(fillCtx), img.interpolate); drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height); fillCtx.globalCompositeOperation = \"source-in\"; const inverse = _util.Util.transform((0, _display_utils.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]); fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor; fillCtx.fillRect(0, 0, width, height); if (cache && !isPatternFill) { this.cachedCanvases.delete(\"fillCanvas\"); cache.set(cacheKey, fillCanvas.canvas); } return { canvas: fillCanvas.canvas, offsetX: Math.round(offsetX), offsetY: Math.round(offsetY) }; } setLineWidth(width) { if (width !== this.current.lineWidth) { this._cachedScaleForStroking = null; } this.current.lineWidth = width; this.ctx.lineWidth = width; } setLineCap(style) { this.ctx.lineCap = LINE_CAP_STYLES[style]; } setLineJoin(style) { this.ctx.lineJoin = LINE_JOIN_STYLES[style]; } setMiterLimit(limit) { this.ctx.miterLimit = limit; } setDash(dashArray, dashPhase) { const ctx = this.ctx; if (ctx.setLineDash !== undefined) { ctx.setLineDash(dashArray); ctx.lineDashOffset = dashPhase; } } setRenderingIntent(intent) {} setFlatness(flatness) {} setGState(states) { for (const [key, value] of states) { switch (key) { case \"LW\": this.setLineWidth(value); break; case \"LC\": this.setLineCap(value); break; case \"LJ\": this.setLineJoin(value); break; case \"ML\": this.setMiterLimit(value); break; case \"D\": this.setDash(value[0], value[1]); break; case \"RI\": this.setRenderingIntent(value); break; case \"FL\": this.setFlatness(value); break; case \"Font\": this.setFont(value[0], value[1]); break; case \"CA\": this.current.strokeAlpha = value; break; case \"ca\": this.current.fillAlpha = value; this.ctx.globalAlpha = value; break; case \"BM\": this.ctx.globalCompositeOperation = value; break; case \"SMask\": this.current.activeSMask = value ? this.tempSMask : null; this.tempSMask = null; this.checkSMaskState(); break; case \"TR\": this.current.transferMaps = value; } } } get inSMaskMode() { return !!this.suspendedCtx; } checkSMaskState() { const inSMaskMode = this.inSMaskMode; if (this.current.activeSMask && !inSMaskMode) { this.beginSMaskMode(); } else if (!this.current.activeSMask && inSMaskMode) { this.endSMaskMode(); } } beginSMaskMode() { if (this.inSMaskMode) { throw new Error(\"beginSMaskMode called while already in smask mode\"); } const drawnWidth = this.ctx.canvas.width; const drawnHeight = this.ctx.canvas.height; const cacheId = \"smaskGroupAt\" + this.groupLevel; const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight); this.suspendedCtx = this.ctx; this.ctx = scratchCanvas.context; const ctx = this.ctx; ctx.setTransform(...(0, _display_utils.getCurrentTransform)(this.suspendedCtx)); copyCtxState(this.suspendedCtx, ctx); mirrorContextOperations(ctx, this.suspendedCtx); this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]); } endSMaskMode() { if (!this.inSMaskMode) { throw new Error(\"endSMaskMode called while not in smask mode\"); } this.ctx._removeMirroring(); copyCtxState(this.ctx, this.suspendedCtx); this.ctx = this.suspendedCtx; this.suspendedCtx = null; } compose(dirtyBox) { if (!this.current.activeSMask) { return; } if (!dirtyBox) { dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height]; } else { dirtyBox[0] = Math.floor(dirtyBox[0]); dirtyBox[1] = Math.floor(dirtyBox[1]); dirtyBox[2] = Math.ceil(dirtyBox[2]); dirtyBox[3] = Math.ceil(dirtyBox[3]); } const smask = this.current.activeSMask; const suspendedCtx = this.suspendedCtx; composeSMask(suspendedCtx, smask, this.ctx, dirtyBox); this.ctx.save(); this.ctx.setTransform(1, 0, 0, 1, 0, 0); this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height); this.ctx.restore(); } save() { if (this.inSMaskMode) { copyCtxState(this.ctx, this.suspendedCtx); this.suspendedCtx.save(); } else { this.ctx.save(); } const old = this.current; this.stateStack.push(old); this.current = old.clone(); } restore() { if (this.stateStack.length === 0 && this.inSMaskMode) { this.endSMaskMode(); } if (this.stateStack.length !== 0) { this.current = this.stateStack.pop(); if (this.inSMaskMode) { this.suspendedCtx.restore(); copyCtxState(this.suspendedCtx, this.ctx); } else { this.ctx.restore(); } this.checkSMaskState(); this.pendingClip = null; this._cachedScaleForStroking = null; this._cachedGetSinglePixelWidth = null; } } transform(a, b, c, d, e, f) { this.ctx.transform(a, b, c, d, e, f); this._cachedScaleForStroking = null; this._cachedGetSinglePixelWidth = null; } constructPath(ops, args, minMax) { const ctx = this.ctx; const current = this.current; let x = current.x, y = current.y; let startX, startY; const currentTransform = (0, _display_utils.getCurrentTransform)(ctx); const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0; const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null; for (let i = 0, j = 0, ii = ops.length; i < ii; i++) { switch (ops[i] | 0) { case _util.OPS.rectangle: x = args[j++]; y = args[j++]; const width = args[j++]; const height = args[j++]; const xw = x + width; const yh = y + height; ctx.moveTo(x, y); if (width === 0 || height === 0) { ctx.lineTo(xw, yh); } else { ctx.lineTo(xw, y); ctx.lineTo(xw, yh); ctx.lineTo(x, yh); } if (!isScalingMatrix) { current.updateRectMinMax(currentTransform, [x, y, xw, yh]); } ctx.closePath(); break; case _util.OPS.moveTo: x = args[j++]; y = args[j++]; ctx.moveTo(x, y); if (!isScalingMatrix) { current.updatePathMinMax(currentTransform, x, y); } break; case _util.OPS.lineTo: x = args[j++]; y = args[j++]; ctx.lineTo(x, y); if (!isScalingMatrix) { current.updatePathMinMax(currentTransform, x, y); } break; case _util.OPS.curveTo: startX = x; startY = y; x = args[j + 4]; y = args[j + 5]; ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y); current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier); j += 6; break; case _util.OPS.curveTo2: startX = x; startY = y; ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]); current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier); x = args[j + 2]; y = args[j + 3]; j += 4; break; case _util.OPS.curveTo3: startX = x; startY = y; x = args[j + 2]; y = args[j + 3]; ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y); current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier); j += 4; break; case _util.OPS.closePath: ctx.closePath(); break; } } if (isScalingMatrix) { current.updateScalingPathMinMax(currentTransform, minMaxForBezier); } current.setCurrentPoint(x, y); } closePath() { this.ctx.closePath(); } stroke(consumePath = true) { const ctx = this.ctx; const strokeColor = this.current.strokeColor; ctx.globalAlpha = this.current.strokeAlpha; if (this.contentVisible) { if (typeof strokeColor === \"object\" && strokeColor?.getPattern) { ctx.save(); ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE); this.rescaleAndStroke(false); ctx.restore(); } else { this.rescaleAndStroke(true); } } if (consumePath) { this.consumePath(this.current.getClippedPathBoundingBox()); } ctx.globalAlpha = this.current.fillAlpha; } closeStroke() { this.closePath(); this.stroke(); } fill(consumePath = true) { const ctx = this.ctx; const fillColor = this.current.fillColor; const isPatternFill = this.current.patternFill; let needRestore = false; if (isPatternFill) { ctx.save(); ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL); needRestore = true; } const intersect = this.current.getClippedPathBoundingBox(); if (this.contentVisible && intersect !== null) { if (this.pendingEOFill) { ctx.fill(\"evenodd\"); this.pendingEOFill = false; } else { ctx.fill(); } } if (needRestore) { ctx.restore(); } if (consumePath) { this.consumePath(intersect); } } eoFill() { this.pendingEOFill = true; this.fill(); } fillStroke() { this.fill(false); this.stroke(false); this.consumePath(); } eoFillStroke() { this.pendingEOFill = true; this.fillStroke(); } closeFillStroke() { this.closePath(); this.fillStroke(); } closeEOFillStroke() { this.pendingEOFill = true; this.closePath(); this.fillStroke(); } endPath() { this.consumePath(); } clip() { this.pendingClip = NORMAL_CLIP; } eoClip() { this.pendingClip = EO_CLIP; } beginText() { this.current.textMatrix = _util.IDENTITY_MATRIX; this.current.textMatrixScale = 1; this.current.x = this.current.lineX = 0; this.current.y = this.current.lineY = 0; } endText() { const paths = this.pendingTextPaths; const ctx = this.ctx; if (paths === undefined) { ctx.beginPath(); return; } ctx.save(); ctx.beginPath(); for (const path of paths) { ctx.setTransform(...path.transform); ctx.translate(path.x, path.y); path.addToPath(ctx, path.fontSize); } ctx.restore(); ctx.clip(); ctx.beginPath(); delete this.pendingTextPaths; } setCharSpacing(spacing) { this.current.charSpacing = spacing; } setWordSpacing(spacing) { this.current.wordSpacing = spacing; } setHScale(scale) { this.current.textHScale = scale / 100; } setLeading(leading) { this.current.leading = -leading; } setFont(fontRefName, size) { const fontObj = this.commonObjs.get(fontRefName); const current = this.current; if (!fontObj) { throw new Error(`Can't find font for ${fontRefName}`); } current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX; if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) { (0, _util.warn)(\"Invalid font matrix for font \" + fontRefName); } if (size < 0) { size = -size; current.fontDirection = -1; } else { current.fontDirection = 1; } this.current.font = fontObj; this.current.fontSize = size; if (fontObj.isType3Font) { return; } const name = fontObj.loadedName || \"sans-serif\"; let bold = \"normal\"; if (fontObj.black) { bold = \"900\"; } else if (fontObj.bold) { bold = \"bold\"; } const italic = fontObj.italic ? \"italic\" : \"normal\"; const typeface = `\"${name}\", ${fontObj.fallbackName}`; let browserFontSize = size; if (size < MIN_FONT_SIZE) { browserFontSize = MIN_FONT_SIZE; } else if (size > MAX_FONT_SIZE) { browserFontSize = MAX_FONT_SIZE; } this.current.fontSizeScale = size / browserFontSize; this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`; } setTextRenderingMode(mode) { this.current.textRenderingMode = mode; } setTextRise(rise) { this.current.textRise = rise; } moveText(x, y) { this.current.x = this.current.lineX += x; this.current.y = this.current.lineY += y; } setLeadingMoveText(x, y) { this.setLeading(-y); this.moveText(x, y); } setTextMatrix(a, b, c, d, e, f) { this.current.textMatrix = [a, b, c, d, e, f]; this.current.textMatrixScale = Math.hypot(a, b); this.current.x = this.current.lineX = 0; this.current.y = this.current.lineY = 0; } nextLine() { this.moveText(0, this.current.leading); } paintChar(character, x, y, patternTransform) { const ctx = this.ctx; const current = this.current; const font = current.font; const textRenderingMode = current.textRenderingMode; const fontSize = current.fontSize / current.fontSizeScale; const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK; const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG); const patternFill = current.patternFill && !font.missingFile; let addToPath; if (font.disableFontFace || isAddToPathSet || patternFill) { addToPath = font.getPathGenerator(this.commonObjs, character); } if (font.disableFontFace || patternFill) { ctx.save(); ctx.translate(x, y); ctx.beginPath(); addToPath(ctx, fontSize); if (patternTransform) { ctx.setTransform(...patternTransform); } if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.fill(); } if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.stroke(); } ctx.restore(); } else { if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.fillText(character, x, y); } if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.strokeText(character, x, y); } } if (isAddToPathSet) { const paths = this.pendingTextPaths || (this.pendingTextPaths = []); paths.push({ transform: (0, _display_utils.getCurrentTransform)(ctx), x, y, fontSize, addToPath }); } } get isFontSubpixelAAEnabled() { const { context: ctx } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10); ctx.scale(1.5, 1); ctx.fillText(\"I\", 0, 10); const data = ctx.getImageData(0, 0, 10, 10).data; let enabled = false; for (let i = 3; i < data.length; i += 4) { if (data[i] > 0 && data[i] < 255) { enabled = true; break; } } return (0, _util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled); } showText(glyphs) { const current = this.current; const font = current.font; if (font.isType3Font) { return this.showType3Text(glyphs); } const fontSize = current.fontSize; if (fontSize === 0) { return undefined; } const ctx = this.ctx; const fontSizeScale = current.fontSizeScale; const charSpacing = current.charSpacing; const wordSpacing = current.wordSpacing; const fontDirection = current.fontDirection; const textHScale = current.textHScale * fontDirection; const glyphsLength = glyphs.length; const vertical = font.vertical; const spacingDir = vertical ? 1 : -1; const defaultVMetrics = font.defaultVMetrics; const widthAdvanceScale = fontSize * current.fontMatrix[0]; const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill; ctx.save(); ctx.transform(...current.textMatrix); ctx.translate(current.x, current.y + current.textRise); if (fontDirection > 0) { ctx.scale(textHScale, -1); } else { ctx.scale(textHScale, 1); } let patternTransform; if (current.patternFill) { ctx.save(); const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL); patternTransform = (0, _display_utils.getCurrentTransform)(ctx); ctx.restore(); ctx.fillStyle = pattern; } let lineWidth = current.lineWidth; const scale = current.textMatrixScale; if (scale === 0 || lineWidth === 0) { const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK; if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { lineWidth = this.getSinglePixelWidth(); } } else { lineWidth /= scale; } if (fontSizeScale !== 1.0) { ctx.scale(fontSizeScale, fontSizeScale); lineWidth /= fontSizeScale; } ctx.lineWidth = lineWidth; if (font.isInvalidPDFjsFont) { const chars = []; let width = 0; for (const glyph of glyphs) { chars.push(glyph.unicode); width += glyph.width; } ctx.fillText(chars.join(\"\"), 0, 0); current.x += width * widthAdvanceScale * textHScale; ctx.restore(); this.compose(); return undefined; } let x = 0, i; for (i = 0; i < glyphsLength; ++i) { const glyph = glyphs[i]; if (typeof glyph === \"number\") { x += spacingDir * glyph * fontSize / 1000; continue; } let restoreNeeded = false; const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing; const character = glyph.fontChar; const accent = glyph.accent; let scaledX, scaledY; let width = glyph.width; if (vertical) { const vmetric = glyph.vmetric || defaultVMetrics; const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale; const vy = vmetric[2] * widthAdvanceScale; width = vmetric ? -vmetric[0] : width; scaledX = vx / fontSizeScale; scaledY = (x + vy) / fontSizeScale; } else { scaledX = x / fontSizeScale; scaledY = 0; } if (font.remeasure && width > 0) { const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale; if (width < measuredWidth && this.isFontSubpixelAAEnabled) { const characterScaleX = width / measuredWidth; restoreNeeded = true; ctx.save(); ctx.scale(characterScaleX, 1); scaledX /= characterScaleX; } else if (width !== measuredWidth) { scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale; } } if (this.contentVisible && (glyph.isInFont || font.missingFile)) { if (simpleFillText && !accent) { ctx.fillText(character, scaledX, scaledY); } else { this.paintChar(character, scaledX, scaledY, patternTransform); if (accent) { const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale; const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale; this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform); } } } let charWidth; if (vertical) { charWidth = width * widthAdvanceScale - spacing * fontDirection; } else { charWidth = width * widthAdvanceScale + spacing * fontDirection; } x += charWidth; if (restoreNeeded) { ctx.restore(); } } if (vertical) { current.y -= x; } else { current.x += x * textHScale; } ctx.restore(); this.compose(); return undefined; } showType3Text(glyphs) { const ctx = this.ctx; const current = this.current; const font = current.font; const fontSize = current.fontSize; const fontDirection = current.fontDirection; const spacingDir = font.vertical ? 1 : -1; const charSpacing = current.charSpacing; const wordSpacing = current.wordSpacing; const textHScale = current.textHScale * fontDirection; const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX; const glyphsLength = glyphs.length; const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE; let i, glyph, width, spacingLength; if (isTextInvisible || fontSize === 0) { return; } this._cachedScaleForStroking = null; this._cachedGetSinglePixelWidth = null; ctx.save(); ctx.transform(...current.textMatrix); ctx.translate(current.x, current.y); ctx.scale(textHScale, fontDirection); for (i = 0; i < glyphsLength; ++i) { glyph = glyphs[i]; if (typeof glyph === \"number\") { spacingLength = spacingDir * glyph * fontSize / 1000; this.ctx.translate(spacingLength, 0); current.x += spacingLength * textHScale; continue; } const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing; const operatorList = font.charProcOperatorList[glyph.operatorListId]; if (!operatorList) { (0, _util.warn)(`Type3 character \"${glyph.operatorListId}\" is not available.`); continue; } if (this.contentVisible) { this.processingType3 = glyph; this.save(); ctx.scale(fontSize, fontSize); ctx.transform(...fontMatrix); this.executeOperatorList(operatorList); this.restore(); } const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix); width = transformed[0] * fontSize + spacing; ctx.translate(width, 0); current.x += width * textHScale; } ctx.restore(); this.processingType3 = null; } setCharWidth(xWidth, yWidth) {} setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) { this.ctx.rect(llx, lly, urx - llx, ury - lly); this.ctx.clip(); this.endPath(); } getColorN_Pattern(IR) { let pattern; if (IR[0] === \"TilingPattern\") { const color = IR[1]; const baseTransform = this.baseTransform || (0, _display_utils.getCurrentTransform)(this.ctx); const canvasGraphicsFactory = { createCanvasGraphics: ctx => { return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, { optionalContentConfig: this.optionalContentConfig, markedContentStack: this.markedContentStack }); } }; pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform); } else { pattern = this._getPattern(IR[1], IR[2]); } return pattern; } setStrokeColorN() { this.current.strokeColor = this.getColorN_Pattern(arguments); } setFillColorN() { this.current.fillColor = this.getColorN_Pattern(arguments); this.current.patternFill = true; } setStrokeRGBColor(r, g, b) { const color = this.selectColor?.(r, g, b) || _util.Util.makeHexColor(r, g, b); this.ctx.strokeStyle = color; this.current.strokeColor = color; } setFillRGBColor(r, g, b) { const color = this.selectColor?.(r, g, b) || _util.Util.makeHexColor(r, g, b); this.ctx.fillStyle = color; this.current.fillColor = color; this.current.patternFill = false; } _getPattern(objId, matrix = null) { let pattern; if (this.cachedPatterns.has(objId)) { pattern = this.cachedPatterns.get(objId); } else { pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId)); this.cachedPatterns.set(objId, pattern); } if (matrix) { pattern.matrix = matrix; } return pattern; } shadingFill(objId) { if (!this.contentVisible) { return; } const ctx = this.ctx; this.save(); const pattern = this._getPattern(objId); ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING); const inv = (0, _display_utils.getCurrentTransformInverse)(ctx); if (inv) { const canvas = ctx.canvas; const width = canvas.width; const height = canvas.height; const bl = _util.Util.applyTransform([0, 0], inv); const br = _util.Util.applyTransform([0, height], inv); const ul = _util.Util.applyTransform([width, 0], inv); const ur = _util.Util.applyTransform([width, height], inv); const x0 = Math.min(bl[0], br[0], ul[0], ur[0]); const y0 = Math.min(bl[1], br[1], ul[1], ur[1]); const x1 = Math.max(bl[0], br[0], ul[0], ur[0]); const y1 = Math.max(bl[1], br[1], ul[1], ur[1]); this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0); } else { this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10); } this.compose(this.current.getClippedPathBoundingBox()); this.restore(); } beginInlineImage() { (0, _util.unreachable)(\"Should not call beginInlineImage\"); } beginImageData() { (0, _util.unreachable)(\"Should not call beginImageData\"); } paintFormXObjectBegin(matrix, bbox) { if (!this.contentVisible) { return; } this.save(); this.baseTransformStack.push(this.baseTransform); if (Array.isArray(matrix) && matrix.length === 6) { this.transform(...matrix); } this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx); if (bbox) { const width = bbox[2] - bbox[0]; const height = bbox[3] - bbox[1]; this.ctx.rect(bbox[0], bbox[1], width, height); this.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(this.ctx), bbox); this.clip(); this.endPath(); } } paintFormXObjectEnd() { if (!this.contentVisible) { return; } this.restore(); this.baseTransform = this.baseTransformStack.pop(); } beginGroup(group) { if (!this.contentVisible) { return; } this.save(); if (this.inSMaskMode) { this.endSMaskMode(); this.current.activeSMask = null; } const currentCtx = this.ctx; if (!group.isolated) { (0, _util.info)(\"TODO: Support non-isolated groups.\"); } if (group.knockout) { (0, _util.warn)(\"Knockout groups not supported.\"); } const currentTransform = (0, _display_utils.getCurrentTransform)(currentCtx); if (group.matrix) { currentCtx.transform(...group.matrix); } if (!group.bbox) { throw new Error(\"Bounding box is required.\"); } let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils.getCurrentTransform)(currentCtx)); const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height]; bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0]; const offsetX = Math.floor(bounds[0]); const offsetY = Math.floor(bounds[1]); let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1); let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1); let scaleX = 1, scaleY = 1; if (drawnWidth > MAX_GROUP_SIZE) { scaleX = drawnWidth / MAX_GROUP_SIZE; drawnWidth = MAX_GROUP_SIZE; } if (drawnHeight > MAX_GROUP_SIZE) { scaleY = drawnHeight / MAX_GROUP_SIZE; drawnHeight = MAX_GROUP_SIZE; } this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]); let cacheId = \"groupAt\" + this.groupLevel; if (group.smask) { cacheId += \"_smask_\" + this.smaskCounter++ % 2; } const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight); const groupCtx = scratchCanvas.context; groupCtx.scale(1 / scaleX, 1 / scaleY); groupCtx.translate(-offsetX, -offsetY); groupCtx.transform(...currentTransform); if (group.smask) { this.smaskStack.push({ canvas: scratchCanvas.canvas, context: groupCtx, offsetX, offsetY, scaleX, scaleY, subtype: group.smask.subtype, backdrop: group.smask.backdrop, transferMap: group.smask.transferMap || null, startTransformInverse: null }); } else { currentCtx.setTransform(1, 0, 0, 1, 0, 0); currentCtx.translate(offsetX, offsetY); currentCtx.scale(scaleX, scaleY); currentCtx.save(); } copyCtxState(currentCtx, groupCtx); this.ctx = groupCtx; this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]); this.groupStack.push(currentCtx); this.groupLevel++; } endGroup(group) { if (!this.contentVisible) { return; } this.groupLevel--; const groupCtx = this.ctx; const ctx = this.groupStack.pop(); this.ctx = ctx; this.ctx.imageSmoothingEnabled = false; if (group.smask) { this.tempSMask = this.smaskStack.pop(); this.restore(); } else { this.ctx.restore(); const currentMtx = (0, _display_utils.getCurrentTransform)(this.ctx); this.restore(); this.ctx.save(); this.ctx.setTransform(...currentMtx); const dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx); this.ctx.drawImage(groupCtx.canvas, 0, 0); this.ctx.restore(); this.compose(dirtyBox); } } beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) { this.#restoreInitialState(); resetCtxToDefault(this.ctx, this.foregroundColor); this.ctx.save(); this.save(); if (this.baseTransform) { this.ctx.setTransform(...this.baseTransform); } if (Array.isArray(rect) && rect.length === 4) { const width = rect[2] - rect[0]; const height = rect[3] - rect[1]; if (hasOwnCanvas && this.annotationCanvasMap) { transform = transform.slice(); transform[4] -= rect[0]; transform[5] -= rect[1]; rect = rect.slice(); rect[0] = rect[1] = 0; rect[2] = width; rect[3] = height; const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(this.ctx)); const { viewportScale } = this; const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale); const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale); this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight); const { canvas, context } = this.annotationCanvas; this.annotationCanvasMap.set(id, canvas); this.annotationCanvas.savedCtx = this.ctx; this.ctx = context; this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY); resetCtxToDefault(this.ctx, this.foregroundColor); } else { resetCtxToDefault(this.ctx, this.foregroundColor); this.ctx.rect(rect[0], rect[1], width, height); this.ctx.clip(); this.endPath(); } } this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height); this.transform(...transform); this.transform(...matrix); } endAnnotation() { if (this.annotationCanvas) { this.ctx = this.annotationCanvas.savedCtx; delete this.annotationCanvas.savedCtx; delete this.annotationCanvas; } } paintImageMaskXObject(img) { if (!this.contentVisible) { return; } const count = img.count; img = this.getObject(img.data, img); img.count = count; const ctx = this.ctx; const glyph = this.processingType3; if (glyph) { if (glyph.compiled === undefined) { glyph.compiled = compileType3Glyph(img); } if (glyph.compiled) { glyph.compiled(ctx); return; } } const mask = this._createMaskCanvas(img); const maskCanvas = mask.canvas; ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY); ctx.restore(); this.compose(); } paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) { if (!this.contentVisible) { return; } img = this.getObject(img.data, img); const ctx = this.ctx; ctx.save(); const currentTransform = (0, _display_utils.getCurrentTransform)(ctx); ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0); const mask = this._createMaskCanvas(img); ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]); for (let i = 0, ii = positions.length; i < ii; i += 2) { const trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]); const [x, y] = _util.Util.applyTransform([0, 0], trans); ctx.drawImage(mask.canvas, x, y); } ctx.restore(); this.compose(); } paintImageMaskXObjectGroup(images) { if (!this.contentVisible) { return; } const ctx = this.ctx; const fillColor = this.current.fillColor; const isPatternFill = this.current.patternFill; for (const image of images) { const { data, width, height, transform } = image; const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height); const maskCtx = maskCanvas.context; maskCtx.save(); const img = this.getObject(data, image); putBinaryImageMask(maskCtx, img); maskCtx.globalCompositeOperation = \"source-in\"; maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor; maskCtx.fillRect(0, 0, width, height); maskCtx.restore(); ctx.save(); ctx.transform(...transform); ctx.scale(1, -1); drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1); ctx.restore(); } this.compose(); } paintImageXObject(objId) { if (!this.contentVisible) { return; } const imgData = this.getObject(objId); if (!imgData) { (0, _util.warn)(\"Dependent image isn't ready yet\"); return; } this.paintInlineImageXObject(imgData); } paintImageXObjectRepeat(objId, scaleX, scaleY, positions) { if (!this.contentVisible) { return; } const imgData = this.getObject(objId); if (!imgData) { (0, _util.warn)(\"Dependent image isn't ready yet\"); return; } const width = imgData.width; const height = imgData.height; const map = []; for (let i = 0, ii = positions.length; i < ii; i += 2) { map.push({ transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]], x: 0, y: 0, w: width, h: height }); } this.paintInlineImageXObjectGroup(imgData, map); } paintInlineImageXObject(imgData) { if (!this.contentVisible) { return; } const width = imgData.width; const height = imgData.height; const ctx = this.ctx; this.save(); ctx.scale(1 / width, -1 / height); let imgToPaint; if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) { imgToPaint = imgData; } else { const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height); const tmpCtx = tmpCanvas.context; putBinaryImageData(tmpCtx, imgData, this.current.transferMaps); imgToPaint = tmpCanvas.canvas; } const scaled = this._scaleImage(imgToPaint, (0, _display_utils.getCurrentTransformInverse)(ctx)); ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(ctx), imgData.interpolate); drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height); this.compose(); this.restore(); } paintInlineImageXObjectGroup(imgData, map) { if (!this.contentVisible) { return; } const ctx = this.ctx; const w = imgData.width; const h = imgData.height; const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h); const tmpCtx = tmpCanvas.context; putBinaryImageData(tmpCtx, imgData, this.current.transferMaps); for (const entry of map) { ctx.save(); ctx.transform(...entry.transform); ctx.scale(1, -1); drawImageAtIntegerCoords(ctx, tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1); ctx.restore(); } this.compose(); } paintSolidColorImageMask() { if (!this.contentVisible) { return; } this.ctx.fillRect(0, 0, 1, 1); this.compose(); } markPoint(tag) {} markPointProps(tag, properties) {} beginMarkedContent(tag) { this.markedContentStack.push({ visible: true }); } beginMarkedContentProps(tag, properties) { if (tag === \"OC\") { this.markedContentStack.push({ visible: this.optionalContentConfig.isVisible(properties) }); } else { this.markedContentStack.push({ visible: true }); } this.contentVisible = this.isContentVisible(); } endMarkedContent() { this.markedContentStack.pop(); this.contentVisible = this.isContentVisible(); } beginCompat() {} endCompat() {} consumePath(clipBox) { const isEmpty = this.current.isEmptyClip(); if (this.pendingClip) { this.current.updateClipFromPath(); } if (!this.pendingClip) { this.compose(clipBox); } const ctx = this.ctx; if (this.pendingClip) { if (!isEmpty) { if (this.pendingClip === EO_CLIP) { ctx.clip(\"evenodd\"); } else { ctx.clip(); } } this.pendingClip = null; } this.current.startNewPathAndClipBox(this.current.clipBox); ctx.beginPath(); } getSinglePixelWidth() { if (!this._cachedGetSinglePixelWidth) { const m = (0, _display_utils.getCurrentTransform)(this.ctx); if (m[1] === 0 && m[2] === 0) { this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3])); } else { const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]); const normX = Math.hypot(m[0], m[2]); const normY = Math.hypot(m[1], m[3]); this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet; } } return this._cachedGetSinglePixelWidth; } getScaleForStroking() { if (!this._cachedScaleForStroking) { const { lineWidth } = this.current; const m = (0, _display_utils.getCurrentTransform)(this.ctx); let scaleX, scaleY; if (m[1] === 0 && m[2] === 0) { const normX = Math.abs(m[0]); const normY = Math.abs(m[3]); if (lineWidth === 0) { scaleX = 1 / normX; scaleY = 1 / normY; } else { const scaledXLineWidth = normX * lineWidth; const scaledYLineWidth = normY * lineWidth; scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1; scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1; } } else { const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]); const normX = Math.hypot(m[0], m[1]); const normY = Math.hypot(m[2], m[3]); if (lineWidth === 0) { scaleX = normY / absDet; scaleY = normX / absDet; } else { const baseArea = lineWidth * absDet; scaleX = normY > baseArea ? normY / baseArea : 1; scaleY = normX > baseArea ? normX / baseArea : 1; } } this._cachedScaleForStroking = [scaleX, scaleY]; } return this._cachedScaleForStroking; } rescaleAndStroke(saveRestore) { const { ctx } = this; const { lineWidth } = this.current; const [scaleX, scaleY] = this.getScaleForStroking(); ctx.lineWidth = lineWidth || 1; if (scaleX === 1 && scaleY === 1) { ctx.stroke(); return; } let savedMatrix, savedDashes, savedDashOffset; if (saveRestore) { savedMatrix = (0, _display_utils.getCurrentTransform)(ctx); savedDashes = ctx.getLineDash().slice(); savedDashOffset = ctx.lineDashOffset; } ctx.scale(scaleX, scaleY); const scale = Math.max(scaleX, scaleY); ctx.setLineDash(ctx.getLineDash().map(x => x / scale)); ctx.lineDashOffset /= scale; ctx.stroke(); if (saveRestore) { ctx.setTransform(...savedMatrix); ctx.setLineDash(savedDashes); ctx.lineDashOffset = savedDashOffset; } } isContentVisible() { for (let i = this.markedContentStack.length - 1; i >= 0; i--) { if (!this.markedContentStack[i].visible) { return false; } } return true; } } exports.CanvasGraphics = CanvasGraphics; for (const op in _util.OPS) { if (CanvasGraphics.prototype[op] !== undefined) { CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op]; } } /***/ }), /* 12 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.TilingPattern = exports.PathType = void 0; exports.getShadingPattern = getShadingPattern; var _util = __w_pdfjs_require__(1); var _display_utils = __w_pdfjs_require__(6); var _is_node = __w_pdfjs_require__(10); const PathType = { FILL: \"Fill\", STROKE: \"Stroke\", SHADING: \"Shading\" }; exports.PathType = PathType; function applyBoundingBox(ctx, bbox) { if (!bbox || _is_node.isNodeJS) { return; } const width = bbox[2] - bbox[0]; const height = bbox[3] - bbox[1]; const region = new Path2D(); region.rect(bbox[0], bbox[1], width, height); ctx.clip(region); } class BaseShadingPattern { constructor() { if (this.constructor === BaseShadingPattern) { (0, _util.unreachable)(\"Cannot initialize BaseShadingPattern.\"); } } getPattern() { (0, _util.unreachable)(\"Abstract method `getPattern` called.\"); } } class RadialAxialShadingPattern extends BaseShadingPattern { constructor(IR) { super(); this._type = IR[1]; this._bbox = IR[2]; this._colorStops = IR[3]; this._p0 = IR[4]; this._p1 = IR[5]; this._r0 = IR[6]; this._r1 = IR[7]; this.matrix = null; } _createGradient(ctx) { let grad; if (this._type === \"axial\") { grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]); } else if (this._type === \"radial\") { grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1); } for (const colorStop of this._colorStops) { grad.addColorStop(colorStop[0], colorStop[1]); } return grad; } getPattern(ctx, owner, inverse, pathType) { let pattern; if (pathType === PathType.STROKE || pathType === PathType.FILL) { const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils.getCurrentTransform)(ctx)) || [0, 0, 0, 0]; const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1; const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1; const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height, true); const tmpCtx = tmpCanvas.context; tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height); tmpCtx.beginPath(); tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height); tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]); inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]); tmpCtx.transform(...owner.baseTransform); if (this.matrix) { tmpCtx.transform(...this.matrix); } applyBoundingBox(tmpCtx, this._bbox); tmpCtx.fillStyle = this._createGradient(tmpCtx); tmpCtx.fill(); pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\"); const domMatrix = new DOMMatrix(inverse); pattern.setTransform(domMatrix); } else { applyBoundingBox(ctx, this._bbox); pattern = this._createGradient(ctx); } return pattern; } } function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) { const coords = context.coords, colors = context.colors; const bytes = data.data, rowSize = data.width * 4; let tmp; if (coords[p1 + 1] > coords[p2 + 1]) { tmp = p1; p1 = p2; p2 = tmp; tmp = c1; c1 = c2; c2 = tmp; } if (coords[p2 + 1] > coords[p3 + 1]) { tmp = p2; p2 = p3; p3 = tmp; tmp = c2; c2 = c3; c3 = tmp; } if (coords[p1 + 1] > coords[p2 + 1]) { tmp = p1; p1 = p2; p2 = tmp; tmp = c1; c1 = c2; c2 = tmp; } const x1 = (coords[p1] + context.offsetX) * context.scaleX; const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY; const x2 = (coords[p2] + context.offsetX) * context.scaleX; const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY; const x3 = (coords[p3] + context.offsetX) * context.scaleX; const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY; if (y1 >= y3) { return; } const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2]; const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2]; const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2]; const minY = Math.round(y1), maxY = Math.round(y3); let xa, car, cag, cab; let xb, cbr, cbg, cbb; for (let y = minY; y { this._onReceiveData({ chunk }); }); this._pdfDataRangeTransport.addProgressiveDoneListener(() => { this._onProgressiveDone(); }); this._pdfDataRangeTransport.transportReady(); } _onReceiveData(args) { const buffer = new Uint8Array(args.chunk).buffer; if (args.begin === undefined) { if (this._fullRequestReader) { this._fullRequestReader._enqueue(buffer); } else { this._queuedChunks.push(buffer); } } else { const found = this._rangeReaders.some(function (rangeReader) { if (rangeReader._begin !== args.begin) { return false; } rangeReader._enqueue(buffer); return true; }); (0, _util.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\"); } } get _progressiveDataLength() { return this._fullRequestReader?._loaded ?? 0; } _onProgress(evt) { if (evt.total === undefined) { this._rangeReaders[0]?.onProgress?.({ loaded: evt.loaded }); } else { this._fullRequestReader?.onProgress?.({ loaded: evt.loaded, total: evt.total }); } } _onProgressiveDone() { this._fullRequestReader?.progressiveDone(); this._progressiveDone = true; } _removeRangeReader(reader) { const i = this._rangeReaders.indexOf(reader); if (i >= 0) { this._rangeReaders.splice(i, 1); } } getFullReader() { (0, _util.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\"); const queuedChunks = this._queuedChunks; this._queuedChunks = null; return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename); } getRangeReader(begin, end) { if (end 0) { const requestCapability = this._requests.shift(); requestCapability.resolve({ value: chunk, done: false }); } else { this._queuedChunks.push(chunk); } this._loaded += chunk.byteLength; } get headersReady() { return this._headersReady; } get filename() { return this._filename; } get isRangeSupported() { return this._stream._isRangeSupported; } get isStreamingSupported() { return this._stream._isStreamingSupported; } get contentLength() { return this._stream._contentLength; } async read() { if (this._queuedChunks.length > 0) { const chunk = this._queuedChunks.shift(); return { value: chunk, done: false }; } if (this._done) { return { value: undefined, done: true }; } const requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return requestCapability.promise; } cancel(reason) { this._done = true; for (const requestCapability of this._requests) { requestCapability.resolve({ value: undefined, done: true }); } this._requests.length = 0; } progressiveDone() { if (this._done) { return; } this._done = true; } } class PDFDataTransportStreamRangeReader { constructor(stream, begin, end) { this._stream = stream; this._begin = begin; this._end = end; this._queuedChunk = null; this._requests = []; this._done = false; this.onProgress = null; } _enqueue(chunk) { if (this._done) { return; } if (this._requests.length === 0) { this._queuedChunk = chunk; } else { const requestsCapability = this._requests.shift(); requestsCapability.resolve({ value: chunk, done: false }); for (const requestCapability of this._requests) { requestCapability.resolve({ value: undefined, done: true }); } this._requests.length = 0; } this._done = true; this._stream._removeRangeReader(this); } get isStreamingSupported() { return false; } async read() { if (this._queuedChunk) { const chunk = this._queuedChunk; this._queuedChunk = null; return { value: chunk, done: false }; } if (this._done) { return { value: undefined, done: true }; } const requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return requestCapability.promise; } cancel(reason) { this._done = true; for (const requestCapability of this._requests) { requestCapability.resolve({ value: undefined, done: true }); } this._requests.length = 0; this._stream._removeRangeReader(this); } } /***/ }), /* 19 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.XfaText = void 0; class XfaText { static textContent(xfa) { const items = []; const output = { items, styles: Object.create(null) }; function walk(node) { if (!node) { return; } let str = null; const name = node.name; if (name === \"#text\") { str = node.value; } else if (!XfaText.shouldBuildText(name)) { return; } else if (node?.attributes?.textContent) { str = node.attributes.textContent; } else if (node.value) { str = node.value; } if (str !== null) { items.push({ str }); } if (!node.children) { return; } for (const child of node.children) { walk(child); } } walk(xfa); return output; } static shouldBuildText(name) { return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\"); } } exports.XfaText = XfaText; /***/ }), /* 20 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.NodeStandardFontDataFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0; var _base_factory = __w_pdfjs_require__(7); ; const fetchData = function (url) { return new Promise((resolve, reject) => { const fs = require(\"fs\"); fs.readFile(url, (error, data) => { if (error || !data) { reject(new Error(error)); return; } resolve(new Uint8Array(data)); }); }); }; class NodeCanvasFactory extends _base_factory.BaseCanvasFactory { _createCanvas(width, height) { const Canvas = require(\"canvas\"); return Canvas.createCanvas(width, height); } } exports.NodeCanvasFactory = NodeCanvasFactory; class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory { _fetchData(url, compressionType) { return fetchData(url).then(data => { return { cMapData: data, compressionType }; }); } } exports.NodeCMapReaderFactory = NodeCMapReaderFactory; class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory { _fetchData(url) { return fetchData(url); } } exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory; /***/ }), /* 21 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.TextLayerRenderTask = void 0; exports.renderTextLayer = renderTextLayer; exports.updateTextLayer = updateTextLayer; var _util = __w_pdfjs_require__(1); var _display_utils = __w_pdfjs_require__(6); const MAX_TEXT_DIVS_TO_RENDER = 100000; const DEFAULT_FONT_SIZE = 30; const DEFAULT_FONT_ASCENT = 0.8; const ascentCache = new Map(); function getCtx(size, isOffscreenCanvasSupported) { let ctx; if (isOffscreenCanvasSupported && _util.FeatureTest.isOffscreenCanvasSupported) { ctx = new OffscreenCanvas(size, size).getContext(\"2d\", { alpha: false }); } else { const canvas = document.createElement(\"canvas\"); canvas.width = canvas.height = size; ctx = canvas.getContext(\"2d\", { alpha: false }); } return ctx; } function getAscent(fontFamily, isOffscreenCanvasSupported) { const cachedAscent = ascentCache.get(fontFamily); if (cachedAscent) { return cachedAscent; } const ctx = getCtx(DEFAULT_FONT_SIZE, isOffscreenCanvasSupported); ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`; const metrics = ctx.measureText(\"\"); let ascent = metrics.fontBoundingBoxAscent; let descent = Math.abs(metrics.fontBoundingBoxDescent); if (ascent) { const ratio = ascent / (ascent + descent); ascentCache.set(fontFamily, ratio); ctx.canvas.width = ctx.canvas.height = 0; return ratio; } ctx.strokeStyle = \"red\"; ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE); ctx.strokeText(\"g\", 0, 0); let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data; descent = 0; for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) { if (pixels[i] > 0) { descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE); break; } } ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE); ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE); pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data; ascent = 0; for (let i = 0, ii = pixels.length; i < ii; i += 4) { if (pixels[i] > 0) { ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE); break; } } ctx.canvas.width = ctx.canvas.height = 0; if (ascent) { const ratio = ascent / (ascent + descent); ascentCache.set(fontFamily, ratio); return ratio; } ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT); return DEFAULT_FONT_ASCENT; } function appendText(task, geom, styles) { const textDiv = document.createElement(\"span\"); const textDivProperties = { angle: 0, canvasWidth: 0, hasText: geom.str !== \"\", hasEOL: geom.hasEOL, fontSize: 0 }; task._textDivs.push(textDiv); const tx = _util.Util.transform(task._transform, geom.transform); let angle = Math.atan2(tx[1], tx[0]); const style = styles[geom.fontName]; if (style.vertical) { angle += Math.PI / 2; } const fontHeight = Math.hypot(tx[2], tx[3]); const fontAscent = fontHeight * getAscent(style.fontFamily, task._isOffscreenCanvasSupported); let left, top; if (angle === 0) { left = tx[4]; top = tx[5] - fontAscent; } else { left = tx[4] + fontAscent * Math.sin(angle); top = tx[5] - fontAscent * Math.cos(angle); } const scaleFactorStr = \"calc(var(--scale-factor)*\"; const divStyle = textDiv.style; if (task._container === task._rootContainer) { divStyle.left = `${(100 * left / task._pageWidth).toFixed(2)}%`; divStyle.top = `${(100 * top / task._pageHeight).toFixed(2)}%`; } else { divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`; divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`; } divStyle.fontSize = `${scaleFactorStr}${fontHeight.toFixed(2)}px)`; divStyle.fontFamily = style.fontFamily; textDivProperties.fontSize = fontHeight; textDiv.setAttribute(\"role\", \"presentation\"); textDiv.textContent = geom.str; textDiv.dir = geom.dir; if (task._fontInspectorEnabled) { textDiv.dataset.fontName = geom.fontName; } if (angle !== 0) { textDivProperties.angle = angle * (180 / Math.PI); } let shouldScaleText = false; if (geom.str.length > 1) { shouldScaleText = true; } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) { const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]); if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) { shouldScaleText = true; } } if (shouldScaleText) { textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width; } task._textDivProperties.set(textDiv, textDivProperties); if (task._isReadableStream) { task._layoutText(textDiv); } } function layout(params) { const { div, scale, properties, ctx, prevFontSize, prevFontFamily } = params; const { style } = div; let transform = \"\"; if (properties.canvasWidth !== 0 && properties.hasText) { const { fontFamily } = style; const { canvasWidth, fontSize } = properties; if (prevFontSize !== fontSize || prevFontFamily !== fontFamily) { ctx.font = `${fontSize * scale}px ${fontFamily}`; params.prevFontSize = fontSize; params.prevFontFamily = fontFamily; } const { width } = ctx.measureText(div.textContent); if (width > 0) { transform = `scaleX(${canvasWidth * scale / width})`; } } if (properties.angle !== 0) { transform = `rotate(${properties.angle}deg) ${transform}`; } if (transform.length > 0) { style.transform = transform; } } function render(task) { if (task._canceled) { return; } const textDivs = task._textDivs; const capability = task._capability; const textDivsLength = textDivs.length; if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) { capability.resolve(); return; } if (!task._isReadableStream) { for (const textDiv of textDivs) { task._layoutText(textDiv); } } capability.resolve(); } class TextLayerRenderTask { constructor({ textContentSource, container, viewport, textDivs, textDivProperties, textContentItemsStr, isOffscreenCanvasSupported }) { this._textContentSource = textContentSource; this._isReadableStream = textContentSource instanceof ReadableStream; this._container = this._rootContainer = container; this._textDivs = textDivs || []; this._textContentItemsStr = textContentItemsStr || []; this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled; this._reader = null; this._textDivProperties = textDivProperties || new WeakMap(); this._canceled = false; this._capability = (0, _util.createPromiseCapability)(); this._layoutTextParams = { prevFontSize: null, prevFontFamily: null, div: null, scale: viewport.scale * (globalThis.devicePixelRatio || 1), properties: null, ctx: getCtx(0, isOffscreenCanvasSupported) }; const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims; this._transform = [1, 0, 0, -1, -pageX, pageY + pageHeight]; this._pageWidth = pageWidth; this._pageHeight = pageHeight; (0, _display_utils.setLayerDimensions)(container, viewport); this._capability.promise.finally(() => { this._layoutTextParams = null; }).catch(() => {}); } get promise() { return this._capability.promise; } cancel() { this._canceled = true; if (this._reader) { this._reader.cancel(new _util.AbortException(\"TextLayer task cancelled.\")).catch(() => {}); this._reader = null; } this._capability.reject(new _util.AbortException(\"TextLayer task cancelled.\")); } _processItems(items, styleCache) { for (const item of items) { if (item.str === undefined) { if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") { const parent = this._container; this._container = document.createElement(\"span\"); this._container.classList.add(\"markedContent\"); if (item.id !== null) { this._container.setAttribute(\"id\", `${item.id}`); } parent.append(this._container); } else if (item.type === \"endMarkedContent\") { this._container = this._container.parentNode; } continue; } this._textContentItemsStr.push(item.str); appendText(this, item, styleCache); } } _layoutText(textDiv) { const textDivProperties = this._layoutTextParams.properties = this._textDivProperties.get(textDiv); this._layoutTextParams.div = textDiv; layout(this._layoutTextParams); if (textDivProperties.hasText) { this._container.append(textDiv); } if (textDivProperties.hasEOL) { const br = document.createElement(\"br\"); br.setAttribute(\"role\", \"presentation\"); this._container.append(br); } } _render() { const capability = (0, _util.createPromiseCapability)(); let styleCache = Object.create(null); if (this._isReadableStream) { const pump = () => { this._reader.read().then(({ value, done }) => { if (done) { capability.resolve(); return; } Object.assign(styleCache, value.styles); this._processItems(value.items, styleCache); pump(); }, capability.reject); }; this._reader = this._textContentSource.getReader(); pump(); } else if (this._textContentSource) { const { items, styles } = this._textContentSource; this._processItems(items, styles); capability.resolve(); } else { throw new Error('No \"textContentSource\" parameter specified.'); } capability.promise.then(() => { styleCache = null; render(this); }, this._capability.reject); } } exports.TextLayerRenderTask = TextLayerRenderTask; function renderTextLayer(params) { if (!params.textContentSource && (params.textContent || params.textContentStream)) { (0, _display_utils.deprecated)(\"The TextLayerRender `textContent`/`textContentStream` parameters \" + \"will be removed in the future, please use `textContentSource` instead.\"); params.textContentSource = params.textContent || params.textContentStream; } const task = new TextLayerRenderTask(params); task._render(); return task; } function updateTextLayer({ container, viewport, textDivs, textDivProperties, isOffscreenCanvasSupported, mustRotate = true, mustRescale = true }) { if (mustRotate) { (0, _display_utils.setLayerDimensions)(container, { rotation: viewport.rotation }); } if (mustRescale) { const ctx = getCtx(0, isOffscreenCanvasSupported); const scale = viewport.scale * (globalThis.devicePixelRatio || 1); const params = { prevFontSize: null, prevFontFamily: null, div: null, scale, properties: null, ctx }; for (const div of textDivs) { params.properties = textDivProperties.get(div); params.div = div; layout(params); } } } /***/ }), /* 22 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.AnnotationEditorLayer = void 0; var _util = __w_pdfjs_require__(1); var _tools = __w_pdfjs_require__(5); var _freetext = __w_pdfjs_require__(23); var _ink = __w_pdfjs_require__(24); var _display_utils = __w_pdfjs_require__(6); class AnnotationEditorLayer { #accessibilityManager; #allowClick = false; #boundPointerup = this.pointerup.bind(this); #boundPointerdown = this.pointerdown.bind(this); #editors = new Map(); #hadPointerDown = false; #isCleaningUp = false; #uiManager; static _initialized = false; constructor(options) { if (!AnnotationEditorLayer._initialized) { AnnotationEditorLayer._initialized = true; _freetext.FreeTextEditor.initialize(options.l10n); _ink.InkEditor.initialize(options.l10n); } options.uiManager.registerEditorTypes([_freetext.FreeTextEditor, _ink.InkEditor]); this.#uiManager = options.uiManager; this.pageIndex = options.pageIndex; this.div = options.div; this.#accessibilityManager = options.accessibilityManager; this.#uiManager.addLayer(this); } updateToolbar(mode) { this.#uiManager.updateToolbar(mode); } updateMode(mode = this.#uiManager.getMode()) { this.#cleanup(); if (mode === _util.AnnotationEditorType.INK) { this.addInkEditorIfNeeded(false); this.disableClick(); } else { this.enableClick(); } this.#uiManager.unselectAll(); this.div.classList.toggle(\"freeTextEditing\", mode === _util.AnnotationEditorType.FREETEXT); this.div.classList.toggle(\"inkEditing\", mode === _util.AnnotationEditorType.INK); } addInkEditorIfNeeded(isCommitting) { if (!isCommitting && this.#uiManager.getMode() !== _util.AnnotationEditorType.INK) { return; } if (!isCommitting) { for (const editor of this.#editors.values()) { if (editor.isEmpty()) { editor.setInBackground(); return; } } } const editor = this.#createAndAddNewEditor({ offsetX: 0, offsetY: 0 }); editor.setInBackground(); } setEditingState(isEditing) { this.#uiManager.setEditingState(isEditing); } addCommands(params) { this.#uiManager.addCommands(params); } enable() { this.div.style.pointerEvents = \"auto\"; for (const editor of this.#editors.values()) { editor.enableEditing(); } } disable() { this.div.style.pointerEvents = \"none\"; for (const editor of this.#editors.values()) { editor.disableEditing(); } } setActiveEditor(editor) { const currentActive = this.#uiManager.getActive(); if (currentActive === editor) { return; } this.#uiManager.setActiveEditor(editor); } enableClick() { this.div.addEventListener(\"pointerdown\", this.#boundPointerdown); this.div.addEventListener(\"pointerup\", this.#boundPointerup); } disableClick() { this.div.removeEventListener(\"pointerdown\", this.#boundPointerdown); this.div.removeEventListener(\"pointerup\", this.#boundPointerup); } attach(editor) { this.#editors.set(editor.id, editor); } detach(editor) { this.#editors.delete(editor.id); this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv); } remove(editor) { this.#uiManager.removeEditor(editor); this.detach(editor); editor.div.style.display = \"none\"; setTimeout(() => { editor.div.style.display = \"\"; editor.div.remove(); editor.isAttachedToDOM = false; if (document.activeElement === document.body) { this.#uiManager.focusMainContainer(); } }, 0); if (!this.#isCleaningUp) { this.addInkEditorIfNeeded(false); } } #changeParent(editor) { if (editor.parent === this) { return; } this.attach(editor); editor.parent?.detach(editor); editor.setParent(this); if (editor.div && editor.isAttachedToDOM) { editor.div.remove(); this.div.append(editor.div); } } add(editor) { this.#changeParent(editor); this.#uiManager.addEditor(editor); this.attach(editor); if (!editor.isAttachedToDOM) { const div = editor.render(); this.div.append(div); editor.isAttachedToDOM = true; } this.moveEditorInDOM(editor); editor.onceAdded(); this.#uiManager.addToAnnotationStorage(editor); } moveEditorInDOM(editor) { this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true); } addOrRebuild(editor) { if (editor.needsToBeRebuilt()) { editor.rebuild(); } else { this.add(editor); } } addANewEditor(editor) { const cmd = () => { this.addOrRebuild(editor); }; const undo = () => { editor.remove(); }; this.addCommands({ cmd, undo, mustExec: true }); } addUndoableEditor(editor) { const cmd = () => { this.addOrRebuild(editor); }; const undo = () => { editor.remove(); }; this.addCommands({ cmd, undo, mustExec: false }); } getNextId() { return this.#uiManager.getId(); } #createNewEditor(params) { switch (this.#uiManager.getMode()) { case _util.AnnotationEditorType.FREETEXT: return new _freetext.FreeTextEditor(params); case _util.AnnotationEditorType.INK: return new _ink.InkEditor(params); } return null; } deserialize(data) { switch (data.annotationType) { case _util.AnnotationEditorType.FREETEXT: return _freetext.FreeTextEditor.deserialize(data, this, this.#uiManager); case _util.AnnotationEditorType.INK: return _ink.InkEditor.deserialize(data, this, this.#uiManager); } return null; } #createAndAddNewEditor(event) { const id = this.getNextId(); const editor = this.#createNewEditor({ parent: this, id, x: event.offsetX, y: event.offsetY, uiManager: this.#uiManager }); if (editor) { this.add(editor); } return editor; } setSelected(editor) { this.#uiManager.setSelected(editor); } toggleSelected(editor) { this.#uiManager.toggleSelected(editor); } isSelected(editor) { return this.#uiManager.isSelected(editor); } unselect(editor) { this.#uiManager.unselect(editor); } pointerup(event) { const { isMac } = _util.FeatureTest.platform; if (event.button !== 0 || event.ctrlKey && isMac) { return; } if (event.target !== this.div) { return; } if (!this.#hadPointerDown) { return; } this.#hadPointerDown = false; if (!this.#allowClick) { this.#allowClick = true; return; } this.#createAndAddNewEditor(event); } pointerdown(event) { const { isMac } = _util.FeatureTest.platform; if (event.button !== 0 || event.ctrlKey && isMac) { return; } if (event.target !== this.div) { return; } this.#hadPointerDown = true; const editor = this.#uiManager.getActive(); this.#allowClick = !editor || editor.isEmpty(); } drop(event) { const id = event.dataTransfer.getData(\"text/plain\"); const editor = this.#uiManager.getEditor(id); if (!editor) { return; } event.preventDefault(); event.dataTransfer.dropEffect = \"move\"; this.#changeParent(editor); const rect = this.div.getBoundingClientRect(); const endX = event.clientX - rect.x; const endY = event.clientY - rect.y; editor.translate(endX - editor.startX, endY - editor.startY); this.moveEditorInDOM(editor); editor.div.focus(); } dragover(event) { event.preventDefault(); } destroy() { if (this.#uiManager.getActive()?.parent === this) { this.#uiManager.setActiveEditor(null); } for (const editor of this.#editors.values()) { this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv); editor.setParent(null); editor.isAttachedToDOM = false; editor.div.remove(); } this.div = null; this.#editors.clear(); this.#uiManager.removeLayer(this); } #cleanup() { this.#isCleaningUp = true; for (const editor of this.#editors.values()) { if (editor.isEmpty()) { editor.remove(); } } this.#isCleaningUp = false; } render({ viewport }) { this.viewport = viewport; (0, _display_utils.setLayerDimensions)(this.div, viewport); (0, _tools.bindEvents)(this, this.div, [\"dragover\", \"drop\"]); for (const editor of this.#uiManager.getEditors(this.pageIndex)) { this.add(editor); } this.updateMode(); } update({ viewport }) { this.#uiManager.commitOrRemove(); this.viewport = viewport; (0, _display_utils.setLayerDimensions)(this.div, { rotation: viewport.rotation }); this.updateMode(); } get pageDimensions() { const { pageWidth, pageHeight } = this.viewport.rawDims; return [pageWidth, pageHeight]; } } exports.AnnotationEditorLayer = AnnotationEditorLayer; /***/ }), /* 23 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.FreeTextEditor = void 0; var _util = __w_pdfjs_require__(1); var _tools = __w_pdfjs_require__(5); var _editor = __w_pdfjs_require__(4); class FreeTextEditor extends _editor.AnnotationEditor { #boundEditorDivBlur = this.editorDivBlur.bind(this); #boundEditorDivFocus = this.editorDivFocus.bind(this); #boundEditorDivInput = this.editorDivInput.bind(this); #boundEditorDivKeydown = this.editorDivKeydown.bind(this); #color; #content = \"\"; #editorDivId = `${this.id}-editor`; #hasAlreadyBeenCommitted = false; #fontSize; static _freeTextDefaultContent = \"\"; static _l10nPromise; static _internalPadding = 0; static _defaultColor = null; static _defaultFontSize = 10; static _keyboardManager = new _tools.KeyboardManager([[[\"ctrl+Enter\", \"mac+meta+Enter\", \"Escape\", \"mac+Escape\"], FreeTextEditor.prototype.commitOrRemove]]); static _type = \"freetext\"; constructor(params) { super({ ...params, name: \"freeTextEditor\" }); this.#color = params.color || FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor; this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize; } static initialize(l10n) { this._l10nPromise = new Map([\"free_text2_default_content\", \"editor_free_text2_aria_label\"].map(str => [str, l10n.get(str)])); const style = getComputedStyle(document.documentElement); this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\")); } static updateDefaultParams(type, value) { switch (type) { case _util.AnnotationEditorParamsType.FREETEXT_SIZE: FreeTextEditor._defaultFontSize = value; break; case _util.AnnotationEditorParamsType.FREETEXT_COLOR: FreeTextEditor._defaultColor = value; break; } } updateParams(type, value) { switch (type) { case _util.AnnotationEditorParamsType.FREETEXT_SIZE: this.#updateFontSize(value); break; case _util.AnnotationEditorParamsType.FREETEXT_COLOR: this.#updateColor(value); break; } } static get defaultPropertiesToUpdate() { return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]]; } get propertiesToUpdate() { return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, this.#color]]; } #updateFontSize(fontSize) { const setFontsize = size => { this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`; this.translate(0, -(size - this.#fontSize) * this.parentScale); this.#fontSize = size; this.#setEditorDimensions(); }; const savedFontsize = this.#fontSize; this.addCommands({ cmd: () => { setFontsize(fontSize); }, undo: () => { setFontsize(savedFontsize); }, mustExec: true, type: _util.AnnotationEditorParamsType.FREETEXT_SIZE, overwriteIfSameType: true, keepUndo: true }); } #updateColor(color) { const savedColor = this.#color; this.addCommands({ cmd: () => { this.#color = this.editorDiv.style.color = color; }, undo: () => { this.#color = this.editorDiv.style.color = savedColor; }, mustExec: true, type: _util.AnnotationEditorParamsType.FREETEXT_COLOR, overwriteIfSameType: true, keepUndo: true }); } getInitialTranslation() { const scale = this.parentScale; return [-FreeTextEditor._internalPadding * scale, -(FreeTextEditor._internalPadding + this.#fontSize) * scale]; } rebuild() { super.rebuild(); if (this.div === null) { return; } if (!this.isAttachedToDOM) { this.parent.add(this); } } enableEditMode() { if (this.isInEditMode()) { return; } this.parent.setEditingState(false); this.parent.updateToolbar(_util.AnnotationEditorType.FREETEXT); super.enableEditMode(); this.overlayDiv.classList.remove(\"enabled\"); this.editorDiv.contentEditable = true; this.div.draggable = false; this.div.removeAttribute(\"aria-activedescendant\"); this.editorDiv.addEventListener(\"keydown\", this.#boundEditorDivKeydown); this.editorDiv.addEventListener(\"focus\", this.#boundEditorDivFocus); this.editorDiv.addEventListener(\"blur\", this.#boundEditorDivBlur); this.editorDiv.addEventListener(\"input\", this.#boundEditorDivInput); } disableEditMode() { if (!this.isInEditMode()) { return; } this.parent.setEditingState(true); super.disableEditMode(); this.overlayDiv.classList.add(\"enabled\"); this.editorDiv.contentEditable = false; this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId); this.div.draggable = true; this.editorDiv.removeEventListener(\"keydown\", this.#boundEditorDivKeydown); this.editorDiv.removeEventListener(\"focus\", this.#boundEditorDivFocus); this.editorDiv.removeEventListener(\"blur\", this.#boundEditorDivBlur); this.editorDiv.removeEventListener(\"input\", this.#boundEditorDivInput); this.div.focus({ preventScroll: true }); this.isEditing = false; this.parent.div.classList.add(\"freeTextEditing\"); } focusin(event) { super.focusin(event); if (event.target !== this.editorDiv) { this.editorDiv.focus(); } } onceAdded() { if (this.width) { return; } this.enableEditMode(); this.editorDiv.focus(); } isEmpty() { return !this.editorDiv || this.editorDiv.innerText.trim() === \"\"; } remove() { this.isEditing = false; this.parent.setEditingState(true); this.parent.div.classList.add(\"freeTextEditing\"); super.remove(); } #extractText() { const divs = this.editorDiv.getElementsByTagName(\"div\"); if (divs.length === 0) { return this.editorDiv.innerText; } const buffer = []; for (const div of divs) { buffer.push(div.innerText.replace(/\\r\\n?|\\n/, \"\")); } return buffer.join(\"\\n\"); } #setEditorDimensions() { const [parentWidth, parentHeight] = this.parentDimensions; let rect; if (this.isAttachedToDOM) { rect = this.div.getBoundingClientRect(); } else { const { currentLayer, div } = this; const savedDisplay = div.style.display; div.style.display = \"hidden\"; currentLayer.div.append(this.div); rect = div.getBoundingClientRect(); div.remove(); div.style.display = savedDisplay; } this.width = rect.width / parentWidth; this.height = rect.height / parentHeight; } commit() { if (!this.isInEditMode()) { return; } super.commit(); if (!this.#hasAlreadyBeenCommitted) { this.#hasAlreadyBeenCommitted = true; this.parent.addUndoableEditor(this); } this.disableEditMode(); this.#content = this.#extractText().trimEnd(); this.#setEditorDimensions(); } shouldGetKeyboardEvents() { return this.isInEditMode(); } dblclick(event) { this.enableEditMode(); this.editorDiv.focus(); } keydown(event) { if (event.target === this.div && event.key === \"Enter\") { this.enableEditMode(); this.editorDiv.focus(); } } editorDivKeydown(event) { FreeTextEditor._keyboardManager.exec(this, event); } editorDivFocus(event) { this.isEditing = true; } editorDivBlur(event) { this.isEditing = false; } editorDivInput(event) { this.parent.div.classList.toggle(\"freeTextEditing\", this.isEmpty()); } disableEditing() { this.editorDiv.setAttribute(\"role\", \"comment\"); this.editorDiv.removeAttribute(\"aria-multiline\"); } enableEditing() { this.editorDiv.setAttribute(\"role\", \"textbox\"); this.editorDiv.setAttribute(\"aria-multiline\", true); } render() { if (this.div) { return this.div; } let baseX, baseY; if (this.width) { baseX = this.x; baseY = this.y; } super.render(); this.editorDiv = document.createElement(\"div\"); this.editorDiv.className = \"internal\"; this.editorDiv.setAttribute(\"id\", this.#editorDivId); this.enableEditing(); FreeTextEditor._l10nPromise.get(\"editor_free_text2_aria_label\").then(msg => this.editorDiv?.setAttribute(\"aria-label\", msg)); FreeTextEditor._l10nPromise.get(\"free_text2_default_content\").then(msg => this.editorDiv?.setAttribute(\"default-content\", msg)); this.editorDiv.contentEditable = true; const { style } = this.editorDiv; style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`; style.color = this.#color; this.div.append(this.editorDiv); this.overlayDiv = document.createElement(\"div\"); this.overlayDiv.classList.add(\"overlay\", \"enabled\"); this.div.append(this.overlayDiv); (0, _tools.bindEvents)(this, this.div, [\"dblclick\", \"keydown\"]); if (this.width) { const [parentWidth, parentHeight] = this.parentDimensions; this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight); for (const line of this.#content.split(\"\\n\")) { const div = document.createElement(\"div\"); div.append(line ? document.createTextNode(line) : document.createElement(\"br\")); this.editorDiv.append(div); } this.div.draggable = true; this.editorDiv.contentEditable = false; } else { this.div.draggable = false; this.editorDiv.contentEditable = true; } return this.div; } get contentDiv() { return this.editorDiv; } static deserialize(data, parent, uiManager) { const editor = super.deserialize(data, parent, uiManager); editor.#fontSize = data.fontSize; editor.#color = _util.Util.makeHexColor(...data.color); editor.#content = data.value; return editor; } serialize() { if (this.isEmpty()) { return null; } const padding = FreeTextEditor._internalPadding * this.parentScale; const rect = this.getRect(padding, padding); const color = _editor.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color); return { annotationType: _util.AnnotationEditorType.FREETEXT, color, fontSize: this.#fontSize, value: this.#content, pageIndex: this.pageIndex, rect, rotation: this.rotation }; } } exports.FreeTextEditor = FreeTextEditor; /***/ }), /* 24 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.InkEditor = void 0; Object.defineProperty(exports, \"fitCurve\", ({ enumerable: true, get: function () { return _pdfjsFitCurve.fitCurve; } })); var _util = __w_pdfjs_require__(1); var _editor = __w_pdfjs_require__(4); var _pdfjsFitCurve = __w_pdfjs_require__(25); var _tools = __w_pdfjs_require__(5); const RESIZER_SIZE = 16; const TIME_TO_WAIT_BEFORE_FIXING_DIMS = 100; class InkEditor extends _editor.AnnotationEditor { #aspectRatio = 0; #baseHeight = 0; #baseWidth = 0; #boundCanvasPointermove = this.canvasPointermove.bind(this); #boundCanvasPointerleave = this.canvasPointerleave.bind(this); #boundCanvasPointerup = this.canvasPointerup.bind(this); #boundCanvasPointerdown = this.canvasPointerdown.bind(this); #disableEditing = false; #isCanvasInitialized = false; #lastPoint = null; #observer = null; #realWidth = 0; #realHeight = 0; #requestFrameCallback = null; static _defaultColor = null; static _defaultOpacity = 1; static _defaultThickness = 1; static _l10nPromise; static _type = \"ink\"; constructor(params) { super({ ...params, name: \"inkEditor\" }); this.color = params.color || null; this.thickness = params.thickness || null; this.opacity = params.opacity || null; this.paths = []; this.bezierPath2D = []; this.currentPath = []; this.scaleFactor = 1; this.translationX = this.translationY = 0; this.x = 0; this.y = 0; } static initialize(l10n) { this._l10nPromise = new Map([\"editor_ink_canvas_aria_label\", \"editor_ink2_aria_label\"].map(str => [str, l10n.get(str)])); } static updateDefaultParams(type, value) { switch (type) { case _util.AnnotationEditorParamsType.INK_THICKNESS: InkEditor._defaultThickness = value; break; case _util.AnnotationEditorParamsType.INK_COLOR: InkEditor._defaultColor = value; break; case _util.AnnotationEditorParamsType.INK_OPACITY: InkEditor._defaultOpacity = value / 100; break; } } updateParams(type, value) { switch (type) { case _util.AnnotationEditorParamsType.INK_THICKNESS: this.#updateThickness(value); break; case _util.AnnotationEditorParamsType.INK_COLOR: this.#updateColor(value); break; case _util.AnnotationEditorParamsType.INK_OPACITY: this.#updateOpacity(value); break; } } static get defaultPropertiesToUpdate() { return [[_util.AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(InkEditor._defaultOpacity * 100)]]; } get propertiesToUpdate() { return [[_util.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, this.color || InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))]]; } #updateThickness(thickness) { const savedThickness = this.thickness; this.addCommands({ cmd: () => { this.thickness = thickness; this.#fitToContent(); }, undo: () => { this.thickness = savedThickness; this.#fitToContent(); }, mustExec: true, type: _util.AnnotationEditorParamsType.INK_THICKNESS, overwriteIfSameType: true, keepUndo: true }); } #updateColor(color) { const savedColor = this.color; this.addCommands({ cmd: () => { this.color = color; this.#redraw(); }, undo: () => { this.color = savedColor; this.#redraw(); }, mustExec: true, type: _util.AnnotationEditorParamsType.INK_COLOR, overwriteIfSameType: true, keepUndo: true }); } #updateOpacity(opacity) { opacity /= 100; const savedOpacity = this.opacity; this.addCommands({ cmd: () => { this.opacity = opacity; this.#redraw(); }, undo: () => { this.opacity = savedOpacity; this.#redraw(); }, mustExec: true, type: _util.AnnotationEditorParamsType.INK_OPACITY, overwriteIfSameType: true, keepUndo: true }); } rebuild() { super.rebuild(); if (this.div === null) { return; } if (!this.canvas) { this.#createCanvas(); this.#createObserver(); } if (!this.isAttachedToDOM) { this.parent.add(this); this.#setCanvasDims(); } this.#fitToContent(); } remove() { if (this.canvas === null) { return; } if (!this.isEmpty()) { this.commit(); } this.canvas.width = this.canvas.height = 0; this.canvas.remove(); this.canvas = null; this.#observer.disconnect(); this.#observer = null; super.remove(); } setParent(parent) { if (!this.parent && parent) { this._uiManager.removeShouldRescale(this); } else if (this.parent && parent === null) { this._uiManager.addShouldRescale(this); } super.setParent(parent); } onScaleChanging() { const [parentWidth, parentHeight] = this.parentDimensions; const width = this.width * parentWidth; const height = this.height * parentHeight; this.setDimensions(width, height); } enableEditMode() { if (this.#disableEditing || this.canvas === null) { return; } super.enableEditMode(); this.div.draggable = false; this.canvas.addEventListener(\"pointerdown\", this.#boundCanvasPointerdown); this.canvas.addEventListener(\"pointerup\", this.#boundCanvasPointerup); } disableEditMode() { if (!this.isInEditMode() || this.canvas === null) { return; } super.disableEditMode(); this.div.draggable = !this.isEmpty(); this.div.classList.remove(\"editing\"); this.canvas.removeEventListener(\"pointerdown\", this.#boundCanvasPointerdown); this.canvas.removeEventListener(\"pointerup\", this.#boundCanvasPointerup); } onceAdded() { this.div.draggable = !this.isEmpty(); } isEmpty() { return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0; } #getInitialBBox() { const { parentRotation, parentDimensions: [width, height] } = this; switch (parentRotation) { case 90: return [0, height, height, width]; case 180: return [width, height, width, height]; case 270: return [width, 0, height, width]; default: return [0, 0, width, height]; } } #setStroke() { const { ctx, color, opacity, thickness, parentScale, scaleFactor } = this; ctx.lineWidth = thickness * parentScale / scaleFactor; ctx.lineCap = \"round\"; ctx.lineJoin = \"round\"; ctx.miterLimit = 10; ctx.strokeStyle = `${color}${(0, _tools.opacityToHex)(opacity)}`; } #startDrawing(x, y) { this.isEditing = true; if (!this.#isCanvasInitialized) { this.#isCanvasInitialized = true; this.#setCanvasDims(); this.thickness ||= InkEditor._defaultThickness; this.color ||= InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor; this.opacity ??= InkEditor._defaultOpacity; } this.currentPath.push([x, y]); this.#lastPoint = null; this.#setStroke(); this.ctx.beginPath(); this.ctx.moveTo(x, y); this.#requestFrameCallback = () => { if (!this.#requestFrameCallback) { return; } if (this.#lastPoint) { if (this.isEmpty()) { this.ctx.setTransform(1, 0, 0, 1, 0, 0); this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); } else { this.#redraw(); } this.ctx.lineTo(...this.#lastPoint); this.#lastPoint = null; this.ctx.stroke(); } window.requestAnimationFrame(this.#requestFrameCallback); }; window.requestAnimationFrame(this.#requestFrameCallback); } #draw(x, y) { const [lastX, lastY] = this.currentPath.at(-1); if (x === lastX && y === lastY) { return; } this.currentPath.push([x, y]); this.#lastPoint = [x, y]; } #stopDrawing(x, y) { this.ctx.closePath(); this.#requestFrameCallback = null; x = Math.min(Math.max(x, 0), this.canvas.width); y = Math.min(Math.max(y, 0), this.canvas.height); const [lastX, lastY] = this.currentPath.at(-1); if (x !== lastX || y !== lastY) { this.currentPath.push([x, y]); } let bezier; if (this.currentPath.length !== 1) { bezier = (0, _pdfjsFitCurve.fitCurve)(this.currentPath, 30, null); } else { const xy = [x, y]; bezier = [[xy, xy.slice(), xy.slice(), xy]]; } const path2D = InkEditor.#buildPath2D(bezier); this.currentPath.length = 0; const cmd = () => { this.paths.push(bezier); this.bezierPath2D.push(path2D); this.rebuild(); }; const undo = () => { this.paths.pop(); this.bezierPath2D.pop(); if (this.paths.length === 0) { this.remove(); } else { if (!this.canvas) { this.#createCanvas(); this.#createObserver(); } this.#fitToContent(); } }; this.addCommands({ cmd, undo, mustExec: true }); } #redraw() { if (this.isEmpty()) { this.#updateTransform(); return; } this.#setStroke(); const { canvas, ctx } = this; ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, canvas.width, canvas.height); this.#updateTransform(); for (const path of this.bezierPath2D) { ctx.stroke(path); } } commit() { if (this.#disableEditing) { return; } super.commit(); this.isEditing = false; this.disableEditMode(); this.setInForeground(); this.#disableEditing = true; this.div.classList.add(\"disabled\"); this.#fitToContent(true); this.parent.addInkEditorIfNeeded(true); this.parent.moveEditorInDOM(this); this.div.focus({ preventScroll: true }); } focusin(event) { super.focusin(event); this.enableEditMode(); } canvasPointerdown(event) { if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) { return; } this.setInForeground(); if (event.type !== \"mouse\") { this.div.focus(); } event.stopPropagation(); this.canvas.addEventListener(\"pointerleave\", this.#boundCanvasPointerleave); this.canvas.addEventListener(\"pointermove\", this.#boundCanvasPointermove); this.#startDrawing(event.offsetX, event.offsetY); } canvasPointermove(event) { event.stopPropagation(); this.#draw(event.offsetX, event.offsetY); } canvasPointerup(event) { if (event.button !== 0) { return; } if (this.isInEditMode() && this.currentPath.length !== 0) { event.stopPropagation(); this.#endDrawing(event); this.setInBackground(); } } canvasPointerleave(event) { this.#endDrawing(event); this.setInBackground(); } #endDrawing(event) { this.#stopDrawing(event.offsetX, event.offsetY); this.canvas.removeEventListener(\"pointerleave\", this.#boundCanvasPointerleave); this.canvas.removeEventListener(\"pointermove\", this.#boundCanvasPointermove); this.addToAnnotationStorage(); } #createCanvas() { this.canvas = document.createElement(\"canvas\"); this.canvas.width = this.canvas.height = 0; this.canvas.className = \"inkEditorCanvas\"; InkEditor._l10nPromise.get(\"editor_ink_canvas_aria_label\").then(msg => this.canvas?.setAttribute(\"aria-label\", msg)); this.div.append(this.canvas); this.ctx = this.canvas.getContext(\"2d\"); } #createObserver() { let timeoutId = null; this.#observer = new ResizeObserver(entries => { const rect = entries[0].contentRect; if (rect.width && rect.height) { if (timeoutId !== null) { clearTimeout(timeoutId); } timeoutId = setTimeout(() => { this.fixDims(); timeoutId = null; }, TIME_TO_WAIT_BEFORE_FIXING_DIMS); this.setDimensions(rect.width, rect.height); } }); this.#observer.observe(this.div); } render() { if (this.div) { return this.div; } let baseX, baseY; if (this.width) { baseX = this.x; baseY = this.y; } super.render(); InkEditor._l10nPromise.get(\"editor_ink2_aria_label\").then(msg => this.div?.setAttribute(\"aria-label\", msg)); const [x, y, w, h] = this.#getInitialBBox(); this.setAt(x, y, 0, 0); this.setDims(w, h); this.#createCanvas(); if (this.width) { const [parentWidth, parentHeight] = this.parentDimensions; this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight); this.#isCanvasInitialized = true; this.#setCanvasDims(); this.setDims(this.width * parentWidth, this.height * parentHeight); this.#redraw(); this.#setMinDims(); this.div.classList.add(\"disabled\"); } else { this.div.classList.add(\"editing\"); this.enableEditMode(); } this.#createObserver(); return this.div; } #setCanvasDims() { if (!this.#isCanvasInitialized) { return; } const [parentWidth, parentHeight] = this.parentDimensions; this.canvas.width = Math.ceil(this.width * parentWidth); this.canvas.height = Math.ceil(this.height * parentHeight); this.#updateTransform(); } setDimensions(width, height) { const roundedWidth = Math.round(width); const roundedHeight = Math.round(height); if (this.#realWidth === roundedWidth && this.#realHeight === roundedHeight) { return; } this.#realWidth = roundedWidth; this.#realHeight = roundedHeight; this.canvas.style.visibility = \"hidden\"; if (this.#aspectRatio && Math.abs(this.#aspectRatio - width / height) > 1e-2) { height = Math.ceil(width / this.#aspectRatio); this.setDims(width, height); } const [parentWidth, parentHeight] = this.parentDimensions; this.width = width / parentWidth; this.height = height / parentHeight; if (this.#disableEditing) { this.#setScaleFactor(width, height); } this.#setCanvasDims(); this.#redraw(); this.canvas.style.visibility = \"visible\"; } #setScaleFactor(width, height) { const padding = this.#getPadding(); const scaleFactorW = (width - padding) / this.#baseWidth; const scaleFactorH = (height - padding) / this.#baseHeight; this.scaleFactor = Math.min(scaleFactorW, scaleFactorH); } #updateTransform() { const padding = this.#getPadding() / 2; this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding); } static #buildPath2D(bezier) { const path2D = new Path2D(); for (let i = 0, ii = bezier.length; i < ii; i++) { const [first, control1, control2, second] = bezier[i]; if (i === 0) { path2D.moveTo(...first); } path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]); } return path2D; } #serializePaths(s, tx, ty, h) { const NUMBER_OF_POINTS_ON_BEZIER_CURVE = 4; const paths = []; const padding = this.thickness / 2; let buffer, points; for (const bezier of this.paths) { buffer = []; points = []; for (let i = 0, ii = bezier.length; i < ii; i++) { const [first, control1, control2, second] = bezier[i]; const p10 = s * (first[0] + tx) + padding; const p11 = h - s * (first[1] + ty) - padding; const p20 = s * (control1[0] + tx) + padding; const p21 = h - s * (control1[1] + ty) - padding; const p30 = s * (control2[0] + tx) + padding; const p31 = h - s * (control2[1] + ty) - padding; const p40 = s * (second[0] + tx) + padding; const p41 = h - s * (second[1] + ty) - padding; if (i === 0) { buffer.push(p10, p11); points.push(p10, p11); } buffer.push(p20, p21, p30, p31, p40, p41); this.#extractPointsOnBezier(p10, p11, p20, p21, p30, p31, p40, p41, NUMBER_OF_POINTS_ON_BEZIER_CURVE, points); } paths.push({ bezier: buffer, points }); } return paths; } #extractPointsOnBezier(p10, p11, p20, p21, p30, p31, p40, p41, n, points) { if (this.#isAlmostFlat(p10, p11, p20, p21, p30, p31, p40, p41)) { points.push(p40, p41); return; } for (let i = 1; i < n - 1; i++) { const t = i / n; const mt = 1 - t; let q10 = t * p10 + mt * p20; let q11 = t * p11 + mt * p21; let q20 = t * p20 + mt * p30; let q21 = t * p21 + mt * p31; const q30 = t * p30 + mt * p40; const q31 = t * p31 + mt * p41; q10 = t * q10 + mt * q20; q11 = t * q11 + mt * q21; q20 = t * q20 + mt * q30; q21 = t * q21 + mt * q31; q10 = t * q10 + mt * q20; q11 = t * q11 + mt * q21; points.push(q10, q11); } points.push(p40, p41); } #isAlmostFlat(p10, p11, p20, p21, p30, p31, p40, p41) { const tol = 10; const ax = (3 * p20 - 2 * p10 - p40) ** 2; const ay = (3 * p21 - 2 * p11 - p41) ** 2; const bx = (3 * p30 - p10 - 2 * p40) ** 2; const by = (3 * p31 - p11 - 2 * p41) ** 2; return Math.max(ax, bx) + Math.max(ay, by) = 1) { style.minHeight = `${RESIZER_SIZE}px`; style.minWidth = `${Math.round(this.#aspectRatio * RESIZER_SIZE)}px`; } else { style.minWidth = `${RESIZER_SIZE}px`; style.minHeight = `${Math.round(RESIZER_SIZE / this.#aspectRatio)}px`; } } static deserialize(data, parent, uiManager) { const editor = super.deserialize(data, parent, uiManager); editor.thickness = data.thickness; editor.color = _util.Util.makeHexColor(...data.color); editor.opacity = data.opacity; const [pageWidth, pageHeight] = editor.pageDimensions; const width = editor.width * pageWidth; const height = editor.height * pageHeight; const scaleFactor = editor.parentScale; const padding = data.thickness / 2; editor.#aspectRatio = width / height; editor.#disableEditing = true; editor.#realWidth = Math.round(width); editor.#realHeight = Math.round(height); for (const { bezier } of data.paths) { const path = []; editor.paths.push(path); let p0 = scaleFactor * (bezier[0] - padding); let p1 = scaleFactor * (height - bezier[1] - padding); for (let i = 2, ii = bezier.length; i < ii; i += 6) { const p10 = scaleFactor * (bezier[i] - padding); const p11 = scaleFactor * (height - bezier[i + 1] - padding); const p20 = scaleFactor * (bezier[i + 2] - padding); const p21 = scaleFactor * (height - bezier[i + 3] - padding); const p30 = scaleFactor * (bezier[i + 4] - padding); const p31 = scaleFactor * (height - bezier[i + 5] - padding); path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]); p0 = p30; p1 = p31; } const path2D = this.#buildPath2D(path); editor.bezierPath2D.push(path2D); } const bbox = editor.#getBbox(); editor.#baseWidth = Math.max(RESIZER_SIZE, bbox[2] - bbox[0]); editor.#baseHeight = Math.max(RESIZER_SIZE, bbox[3] - bbox[1]); editor.#setScaleFactor(width, height); return editor; } serialize() { if (this.isEmpty()) { return null; } const rect = this.getRect(0, 0); const height = this.rotation % 180 === 0 ? rect[3] - rect[1] : rect[2] - rect[0]; const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle); return { annotationType: _util.AnnotationEditorType.INK, color, thickness: this.thickness, opacity: this.opacity, paths: this.#serializePaths(this.scaleFactor / this.parentScale, this.translationX, this.translationY, height), pageIndex: this.pageIndex, rect, rotation: this.rotation }; } } exports.InkEditor = InkEditor; /***/ }), /* 25 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.fitCurve = void 0; const fitCurve = __w_pdfjs_require__(26); exports.fitCurve = fitCurve; /***/ }), /* 26 */ /***/ ((module) => { function fitCurve(points, maxError, progressCallback) { if (!Array.isArray(points)) { throw new TypeError(\"First argument should be an array\"); } points.forEach(point => { if (!Array.isArray(point) || point.some(item => typeof item !== 'number') || point.length !== points[0].length) { throw Error(\"Each point should be an array of numbers. Each point should have the same amount of numbers.\"); } }); points = points.filter((point, i) => i === 0 || !point.every((val, j) => val === points[i - 1][j])); if (points.length < 2) { return []; } const len = points.length; const leftTangent = createTangent(points[1], points[0]); const rightTangent = createTangent(points[len - 2], points[len - 1]); return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback); } function fitCubic(points, leftTangent, rightTangent, error, progressCallback) { const MaxIterations = 20; var bezCurve, u, uPrime, maxError, prevErr, splitPoint, prevSplit, centerVector, toCenterTangent, fromCenterTangent, beziers, dist, i; if (points.length === 2) { dist = maths.vectorLen(maths.subtract(points[0], points[1])) / 3.0; bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist)), points[1]]; return [bezCurve]; } u = chordLengthParameterize(points); [bezCurve, maxError, splitPoint] = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback); if (maxError === 0 || maxError < error) { return [bezCurve]; } if (maxError < error * error) { uPrime = u; prevErr = maxError; prevSplit = splitPoint; for (i = 0; i < MaxIterations; i++) { uPrime = reparameterize(bezCurve, points, uPrime); [bezCurve, maxError, splitPoint] = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback); if (maxError < error) { return [bezCurve]; } else if (splitPoint === prevSplit) { let errChange = maxError / prevErr; if (errChange > .9999 && errChange < 1.0001) { break; } } prevErr = maxError; prevSplit = splitPoint; } } beziers = []; centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]); if (centerVector.every(val => val === 0)) { centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]); [centerVector[0], centerVector[1]] = [-centerVector[1], centerVector[0]]; } toCenterTangent = maths.normalize(centerVector); fromCenterTangent = maths.mulItems(toCenterTangent, -1); beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback)); beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback)); return beziers; } ; function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) { var bezCurve, maxError, splitPoint; bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent, progressCallback); [maxError, splitPoint] = computeMaxError(points, bezCurve, paramsOrig); if (progressCallback) { progressCallback({ bez: bezCurve, points: points, params: paramsOrig, maxErr: maxError, maxPoint: splitPoint }); } return [bezCurve, maxError, splitPoint]; } function generateBezier(points, parameters, leftTangent, rightTangent) { var bezCurve, A, a, C, X, det_C0_C1, det_C0_X, det_X_C1, alpha_l, alpha_r, epsilon, segLength, i, len, tmp, u, ux, firstPoint = points[0], lastPoint = points[points.length - 1]; bezCurve = [firstPoint, null, null, lastPoint]; A = maths.zeros_Xx2x2(parameters.length); for (i = 0, len = parameters.length; i < len; i++) { u = parameters[i]; ux = 1 - u; a = A[i]; a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux)); a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u)); } C = [[0, 0], [0, 0]]; X = [0, 0]; for (i = 0, len = points.length; i < len; i++) { u = parameters[i]; a = A[i]; C[0][0] += maths.dot(a[0], a[0]); C[0][1] += maths.dot(a[0], a[1]); C[1][0] += maths.dot(a[0], a[1]); C[1][1] += maths.dot(a[1], a[1]); tmp = maths.subtract(points[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u)); X[0] += maths.dot(a[0], tmp); X[1] += maths.dot(a[1], tmp); } det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1]; det_C0_X = C[0][0] * X[1] - C[1][0] * X[0]; det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1]; alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1; alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1; segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint)); epsilon = 1.0e-6 * segLength; if (alpha_l < epsilon || alpha_r < epsilon) { bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3.0)); bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3.0)); } else { bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l)); bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r)); } return bezCurve; } ; function reparameterize(bezier, points, parameters) { return parameters.map((p, i) => newtonRaphsonRootFind(bezier, points[i], p)); } ; function newtonRaphsonRootFind(bez, point, u) { var d = maths.subtract(bezier.q(bez, u), point), qprime = bezier.qprime(bez, u), numerator = maths.mulMatrix(d, qprime), denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier.qprimeprime(bez, u)); if (denominator === 0) { return u; } else { return u - numerator / denominator; } } ; function chordLengthParameterize(points) { var u = [], currU, prevU, prevP; points.forEach((p, i) => { currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0; u.push(currU); prevU = currU; prevP = p; }); u = u.map(x => x / prevU); return u; } ; function computeMaxError(points, bez, parameters) { var dist, maxDist, splitPoint, v, i, count, point, t; maxDist = 0; splitPoint = Math.floor(points.length / 2); const t_distMap = mapTtoRelativeDistances(bez, 10); for (i = 0, count = points.length; i < count; i++) { point = points[i]; t = find_t(bez, parameters[i], t_distMap, 10); v = maths.subtract(bezier.q(bez, t), point); dist = v[0] * v[0] + v[1] * v[1]; if (dist > maxDist) { maxDist = dist; splitPoint = i; } } return [maxDist, splitPoint]; } ; var mapTtoRelativeDistances = function (bez, B_parts) { var B_t_curr; var B_t_dist = [0]; var B_t_prev = bez[0]; var sumLen = 0; for (var i = 1; i x / sumLen); return B_t_dist; }; function find_t(bez, param, t_distMap, B_parts) { if (param < 0) { return 0; } if (param > 1) { return 1; } var lenMax, lenMin, tMax, tMin, t; for (var i = 1; i sum + x1 * m2[i], 0); } static subtract(arr1, arr2) { return arr1.map((x1, i) => x1 - arr2[i]); } static addArrays(arr1, arr2) { return arr1.map((x1, i) => x1 + arr2[i]); } static addItems(items, addition) { return items.map(x => x + addition); } static sum(items) { return items.reduce((sum, x) => sum + x); } static dot(m1, m2) { return maths.mulMatrix(m1, m2); } static vectorLen(v) { return Math.hypot(...v); } static divItems(items, divisor) { return items.map(x => x / divisor); } static squareItems(items) { return items.map(x => x * x); } static normalize(v) { return this.divItems(v, this.vectorLen(v)); } } class bezier { static q(ctrlPoly, t) { var tx = 1.0 - t; var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx), pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t), pC = maths.mulItems(ctrlPoly[2], 3 * tx * t * t), pD = maths.mulItems(ctrlPoly[3], t * t * t); return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD)); } static qprime(ctrlPoly, t) { var tx = 1.0 - t; var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx), pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t), pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t); return maths.addArrays(maths.addArrays(pA, pB), pC); } static qprimeprime(ctrlPoly, t) { return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1.0 - t)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t)); } } module.exports = fitCurve; module.exports.fitCubic = fitCubic; module.exports.createTangent = createTangent; /***/ }), /* 27 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.AnnotationLayer = void 0; var _util = __w_pdfjs_require__(1); var _display_utils = __w_pdfjs_require__(6); var _annotation_storage = __w_pdfjs_require__(3); var _scripting_utils = __w_pdfjs_require__(28); var _xfa_layer = __w_pdfjs_require__(29); const DEFAULT_TAB_INDEX = 1000; const DEFAULT_FONT_SIZE = 9; const GetElementsByNameSet = new WeakSet(); function getRectDims(rect) { return { width: rect[2] - rect[0], height: rect[3] - rect[1] }; } class AnnotationElementFactory { static create(parameters) { const subtype = parameters.data.annotationType; switch (subtype) { case _util.AnnotationType.LINK: return new LinkAnnotationElement(parameters); case _util.AnnotationType.TEXT: return new TextAnnotationElement(parameters); case _util.AnnotationType.WIDGET: const fieldType = parameters.data.fieldType; switch (fieldType) { case \"Tx\": return new TextWidgetAnnotationElement(parameters); case \"Btn\": if (parameters.data.radioButton) { return new RadioButtonWidgetAnnotationElement(parameters); } else if (parameters.data.checkBox) { return new CheckboxWidgetAnnotationElement(parameters); } return new PushButtonWidgetAnnotationElement(parameters); case \"Ch\": return new ChoiceWidgetAnnotationElement(parameters); } return new WidgetAnnotationElement(parameters); case _util.AnnotationType.POPUP: return new PopupAnnotationElement(parameters); case _util.AnnotationType.FREETEXT: return new FreeTextAnnotationElement(parameters); case _util.AnnotationType.LINE: return new LineAnnotationElement(parameters); case _util.AnnotationType.SQUARE: return new SquareAnnotationElement(parameters); case _util.AnnotationType.CIRCLE: return new CircleAnnotationElement(parameters); case _util.AnnotationType.POLYLINE: return new PolylineAnnotationElement(parameters); case _util.AnnotationType.CARET: return new CaretAnnotationElement(parameters); case _util.AnnotationType.INK: return new InkAnnotationElement(parameters); case _util.AnnotationType.POLYGON: return new PolygonAnnotationElement(parameters); case _util.AnnotationType.HIGHLIGHT: return new HighlightAnnotationElement(parameters); case _util.AnnotationType.UNDERLINE: return new UnderlineAnnotationElement(parameters); case _util.AnnotationType.SQUIGGLY: return new SquigglyAnnotationElement(parameters); case _util.AnnotationType.STRIKEOUT: return new StrikeOutAnnotationElement(parameters); case _util.AnnotationType.STAMP: return new StampAnnotationElement(parameters); case _util.AnnotationType.FILEATTACHMENT: return new FileAttachmentAnnotationElement(parameters); default: return new AnnotationElement(parameters); } } } class AnnotationElement { constructor(parameters, { isRenderable = false, ignoreBorder = false, createQuadrilaterals = false } = {}) { this.isRenderable = isRenderable; this.data = parameters.data; this.layer = parameters.layer; this.page = parameters.page; this.viewport = parameters.viewport; this.linkService = parameters.linkService; this.downloadManager = parameters.downloadManager; this.imageResourcesPath = parameters.imageResourcesPath; this.renderForms = parameters.renderForms; this.svgFactory = parameters.svgFactory; this.annotationStorage = parameters.annotationStorage; this.enableScripting = parameters.enableScripting; this.hasJSActions = parameters.hasJSActions; this._fieldObjects = parameters.fieldObjects; if (isRenderable) { this.container = this._createContainer(ignoreBorder); } if (createQuadrilaterals) { this.quadrilaterals = this._createQuadrilaterals(ignoreBorder); } } _createContainer(ignoreBorder = false) { const { data, page, viewport } = this; const container = document.createElement(\"section\"); container.setAttribute(\"data-annotation-id\", data.id); const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims; const { width, height } = getRectDims(data.rect); const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]); if (!ignoreBorder && data.borderStyle.width > 0) { container.style.borderWidth = `${data.borderStyle.width}px`; const horizontalRadius = data.borderStyle.horizontalCornerRadius; const verticalRadius = data.borderStyle.verticalCornerRadius; if (horizontalRadius > 0 || verticalRadius > 0) { const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`; container.style.borderRadius = radius; } else if (this instanceof RadioButtonWidgetAnnotationElement) { const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`; container.style.borderRadius = radius; } switch (data.borderStyle.style) { case _util.AnnotationBorderStyleType.SOLID: container.style.borderStyle = \"solid\"; break; case _util.AnnotationBorderStyleType.DASHED: container.style.borderStyle = \"dashed\"; break; case _util.AnnotationBorderStyleType.BEVELED: (0, _util.warn)(\"Unimplemented border style: beveled\"); break; case _util.AnnotationBorderStyleType.INSET: (0, _util.warn)(\"Unimplemented border style: inset\"); break; case _util.AnnotationBorderStyleType.UNDERLINE: container.style.borderBottomStyle = \"solid\"; break; default: break; } const borderColor = data.borderColor || null; if (borderColor) { container.style.borderColor = _util.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0); } else { container.style.borderWidth = 0; } } container.style.left = `${100 * (rect[0] - pageX) / pageWidth}%`; container.style.top = `${100 * (rect[1] - pageY) / pageHeight}%`; const { rotation } = data; if (data.hasOwnCanvas || rotation === 0) { container.style.width = `${100 * width / pageWidth}%`; container.style.height = `${100 * height / pageHeight}%`; } else { this.setRotation(rotation, container); } return container; } setRotation(angle, container = this.container) { const { pageWidth, pageHeight } = this.viewport.rawDims; const { width, height } = getRectDims(this.data.rect); let elementWidth, elementHeight; if (angle % 180 === 0) { elementWidth = 100 * width / pageWidth; elementHeight = 100 * height / pageHeight; } else { elementWidth = 100 * height / pageWidth; elementHeight = 100 * width / pageHeight; } container.style.width = `${elementWidth}%`; container.style.height = `${elementHeight}%`; container.setAttribute(\"data-main-rotation\", (360 - angle) % 360); } get _commonActions() { const setColor = (jsName, styleName, event) => { const color = event.detail[jsName]; event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1)); }; return (0, _util.shadow)(this, \"_commonActions\", { display: event => { const hidden = event.detail.display % 2 === 1; this.container.style.visibility = hidden ? \"hidden\" : \"visible\"; this.annotationStorage.setValue(this.data.id, { hidden, print: event.detail.display === 0 || event.detail.display === 3 }); }, print: event => { this.annotationStorage.setValue(this.data.id, { print: event.detail.print }); }, hidden: event => { this.container.style.visibility = event.detail.hidden ? \"hidden\" : \"visible\"; this.annotationStorage.setValue(this.data.id, { hidden: event.detail.hidden }); }, focus: event => { setTimeout(() => event.target.focus({ preventScroll: false }), 0); }, userName: event => { event.target.title = event.detail.userName; }, readonly: event => { if (event.detail.readonly) { event.target.setAttribute(\"readonly\", \"\"); } else { event.target.removeAttribute(\"readonly\"); } }, required: event => { this._setRequired(event.target, event.detail.required); }, bgColor: event => { setColor(\"bgColor\", \"backgroundColor\", event); }, fillColor: event => { setColor(\"fillColor\", \"backgroundColor\", event); }, fgColor: event => { setColor(\"fgColor\", \"color\", event); }, textColor: event => { setColor(\"textColor\", \"color\", event); }, borderColor: event => { setColor(\"borderColor\", \"borderColor\", event); }, strokeColor: event => { setColor(\"strokeColor\", \"borderColor\", event); }, rotation: event => { const angle = event.detail.rotation; this.setRotation(angle); this.annotationStorage.setValue(this.data.id, { rotation: angle }); } }); } _dispatchEventFromSandbox(actions, jsEvent) { const commonActions = this._commonActions; for (const name of Object.keys(jsEvent.detail)) { const action = actions[name] || commonActions[name]; action?.(jsEvent); } } _setDefaultPropertiesFromJS(element) { if (!this.enableScripting) { return; } const storedData = this.annotationStorage.getRawValue(this.data.id); if (!storedData) { return; } const commonActions = this._commonActions; for (const [actionName, detail] of Object.entries(storedData)) { const action = commonActions[actionName]; if (action) { const eventProxy = { detail: { [actionName]: detail }, target: element }; action(eventProxy); delete storedData[actionName]; } } } _createQuadrilaterals(ignoreBorder = false) { if (!this.data.quadPoints) { return null; } const quadrilaterals = []; const savedRect = this.data.rect; for (const quadPoint of this.data.quadPoints) { this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y]; quadrilaterals.push(this._createContainer(ignoreBorder)); } this.data.rect = savedRect; return quadrilaterals; } _createPopup(trigger, data) { let container = this.container; if (this.quadrilaterals) { trigger = trigger || this.quadrilaterals; container = this.quadrilaterals[0]; } if (!trigger) { trigger = document.createElement(\"div\"); trigger.className = \"popupTriggerArea\"; container.append(trigger); } const popupElement = new PopupElement({ container, trigger, color: data.color, titleObj: data.titleObj, modificationDate: data.modificationDate, contentsObj: data.contentsObj, richText: data.richText, hideWrapper: true }); const popup = popupElement.render(); popup.style.left = \"100%\"; container.append(popup); } _renderQuadrilaterals(className) { for (const quadrilateral of this.quadrilaterals) { quadrilateral.className = className; } return this.quadrilaterals; } render() { (0, _util.unreachable)(\"Abstract method `AnnotationElement.render` called\"); } _getElementsByName(name, skipId = null) { const fields = []; if (this._fieldObjects) { const fieldObj = this._fieldObjects[name]; if (fieldObj) { for (const { page, id, exportValues } of fieldObj) { if (page === -1) { continue; } if (id === skipId) { continue; } const exportValue = typeof exportValues === \"string\" ? exportValues : null; const domElement = document.querySelector(`[data-element-id=\"${id}\"]`); if (domElement && !GetElementsByNameSet.has(domElement)) { (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`); continue; } fields.push({ id, exportValue, domElement }); } } return fields; } for (const domElement of document.getElementsByName(name)) { const { exportValue } = domElement; const id = domElement.getAttribute(\"data-element-id\"); if (id === skipId) { continue; } if (!GetElementsByNameSet.has(domElement)) { continue; } fields.push({ id, exportValue, domElement }); } return fields; } } class LinkAnnotationElement extends AnnotationElement { constructor(parameters, options = null) { super(parameters, { isRenderable: true, ignoreBorder: !!options?.ignoreBorder, createQuadrilaterals: true }); this.isTooltipOnly = parameters.data.isTooltipOnly; } render() { const { data, linkService } = this; const link = document.createElement(\"a\"); link.setAttribute(\"data-element-id\", data.id); let isBound = false; if (data.url) { linkService.addLinkAttributes(link, data.url, data.newWindow); isBound = true; } else if (data.action) { this._bindNamedAction(link, data.action); isBound = true; } else if (data.attachment) { this._bindAttachment(link, data.attachment); isBound = true; } else if (data.setOCGState) { this.#bindSetOCGState(link, data.setOCGState); isBound = true; } else if (data.dest) { this._bindLink(link, data.dest); isBound = true; } else { if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) { this._bindJSAction(link, data); isBound = true; } if (data.resetForm) { this._bindResetFormAction(link, data.resetForm); isBound = true; } else if (this.isTooltipOnly && !isBound) { this._bindLink(link, \"\"); isBound = true; } } if (this.quadrilaterals) { return this._renderQuadrilaterals(\"linkAnnotation\").map((quadrilateral, index) => { const linkElement = index === 0 ? link : link.cloneNode(); quadrilateral.append(linkElement); return quadrilateral; }); } this.container.className = \"linkAnnotation\"; if (isBound) { this.container.append(link); } return this.container; } #setInternalLink() { this.container.setAttribute(\"data-internal-link\", \"\"); } _bindLink(link, destination) { link.href = this.linkService.getDestinationHash(destination); link.onclick = () => { if (destination) { this.linkService.goToDestination(destination); } return false; }; if (destination || destination === \"\") { this.#setInternalLink(); } } _bindNamedAction(link, action) { link.href = this.linkService.getAnchorUrl(\"\"); link.onclick = () => { this.linkService.executeNamedAction(action); return false; }; this.#setInternalLink(); } _bindAttachment(link, attachment) { link.href = this.linkService.getAnchorUrl(\"\"); link.onclick = () => { this.downloadManager?.openOrDownloadData(this.container, attachment.content, attachment.filename); return false; }; this.#setInternalLink(); } #bindSetOCGState(link, action) { link.href = this.linkService.getAnchorUrl(\"\"); link.onclick = () => { this.linkService.executeSetOCGState(action); return false; }; this.#setInternalLink(); } _bindJSAction(link, data) { link.href = this.linkService.getAnchorUrl(\"\"); const map = new Map([[\"Action\", \"onclick\"], [\"Mouse Up\", \"onmouseup\"], [\"Mouse Down\", \"onmousedown\"]]); for (const name of Object.keys(data.actions)) { const jsName = map.get(name); if (!jsName) { continue; } link[jsName] = () => { this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", { source: this, detail: { id: data.id, name } }); return false; }; } if (!link.onclick) { link.onclick = () => false; } this.#setInternalLink(); } _bindResetFormAction(link, resetForm) { const otherClickAction = link.onclick; if (!otherClickAction) { link.href = this.linkService.getAnchorUrl(\"\"); } this.#setInternalLink(); if (!this._fieldObjects) { (0, _util.warn)(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\"); if (!otherClickAction) { link.onclick = () => false; } return; } link.onclick = () => { otherClickAction?.(); const { fields: resetFormFields, refs: resetFormRefs, include } = resetForm; const allFields = []; if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) { const fieldIds = new Set(resetFormRefs); for (const fieldName of resetFormFields) { const fields = this._fieldObjects[fieldName] || []; for (const { id } of fields) { fieldIds.add(id); } } for (const fields of Object.values(this._fieldObjects)) { for (const field of fields) { if (fieldIds.has(field.id) === include) { allFields.push(field); } } } } else { for (const fields of Object.values(this._fieldObjects)) { allFields.push(...fields); } } const storage = this.annotationStorage; const allIds = []; for (const field of allFields) { const { id } = field; allIds.push(id); switch (field.type) { case \"text\": { const value = field.defaultValue || \"\"; storage.setValue(id, { value }); break; } case \"checkbox\": case \"radiobutton\": { const value = field.defaultValue === field.exportValues; storage.setValue(id, { value }); break; } case \"combobox\": case \"listbox\": { const value = field.defaultValue || \"\"; storage.setValue(id, { value }); break; } default: continue; } const domElement = document.querySelector(`[data-element-id=\"${id}\"]`); if (!domElement) { continue; } else if (!GetElementsByNameSet.has(domElement)) { (0, _util.warn)(`_bindResetFormAction - element not allowed: ${id}`); continue; } domElement.dispatchEvent(new Event(\"resetform\")); } if (this.enableScripting) { this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", { source: this, detail: { id: \"app\", ids: allIds, name: \"ResetForm\" } }); } return false; }; } } class TextAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable }); } render() { this.container.className = \"textAnnotation\"; const image = document.createElement(\"img\"); image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\"; image.alt = \"[ Annotation]\"; image.dataset.l10nId = \"text_annotation_type\"; image.dataset.l10nArgs = JSON.stringify({ type: this.data.name }); if (!this.data.hasPopup) { this._createPopup(image, this.data); } this.container.append(image); return this.container; } } class WidgetAnnotationElement extends AnnotationElement { render() { if (this.data.alternativeText) { this.container.title = this.data.alternativeText; } return this.container; } _getKeyModifier(event) { const { isWin, isMac } = _util.FeatureTest.platform; return isWin && event.ctrlKey || isMac && event.metaKey; } _setEventListener(element, baseName, eventName, valueGetter) { if (baseName.includes(\"mouse\")) { element.addEventListener(baseName, event => { this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", { source: this, detail: { id: this.data.id, name: eventName, value: valueGetter(event), shift: event.shiftKey, modifier: this._getKeyModifier(event) } }); }); } else { element.addEventListener(baseName, event => { this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", { source: this, detail: { id: this.data.id, name: eventName, value: valueGetter(event) } }); }); } } _setEventListeners(element, names, getter) { for (const [baseName, eventName] of names) { if (eventName === \"Action\" || this.data.actions?.[eventName]) { this._setEventListener(element, baseName, eventName, getter); } } } _setBackgroundColor(element) { const color = this.data.backgroundColor || null; element.style.backgroundColor = color === null ? \"transparent\" : _util.Util.makeHexColor(color[0], color[1], color[2]); } _setTextStyle(element) { const TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"]; const { fontColor } = this.data.defaultAppearanceData; const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE; const style = element.style; let computedFontSize; const BORDER_SIZE = 2; const roundToOneDecimal = x => Math.round(10 * x) / 10; if (this.data.multiLine) { const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE); const numberOfLines = Math.round(height / (_util.LINE_FACTOR * fontSize)) || 1; const lineHeight = height / numberOfLines; computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / _util.LINE_FACTOR)); } else { const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE); computedFontSize = Math.min(fontSize, roundToOneDecimal(height / _util.LINE_FACTOR)); } style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`; style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]); if (this.data.textAlignment !== null) { style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment]; } } _setRequired(element, isRequired) { if (isRequired) { element.setAttribute(\"required\", true); } else { element.removeAttribute(\"required\"); } element.setAttribute(\"aria-required\", isRequired); } } class TextWidgetAnnotationElement extends WidgetAnnotationElement { constructor(parameters) { const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue; super(parameters, { isRenderable }); } setPropertyOnSiblings(base, key, value, keyInStorage) { const storage = this.annotationStorage; for (const element of this._getElementsByName(base.name, base.id)) { if (element.domElement) { element.domElement[key] = value; } storage.setValue(element.id, { [keyInStorage]: value }); } } render() { const storage = this.annotationStorage; const id = this.data.id; this.container.className = \"textWidgetAnnotation\"; let element = null; if (this.renderForms) { const storedData = storage.getValue(id, { value: this.data.fieldValue }); let textContent = storedData.formattedValue || storedData.value || \"\"; const maxLen = storage.getValue(id, { charLimit: this.data.maxLen }).charLimit; if (maxLen && textContent.length > maxLen) { textContent = textContent.slice(0, maxLen); } const elementData = { userValue: textContent, formattedValue: null, lastCommittedValue: null, commitKey: 1 }; if (this.data.multiLine) { element = document.createElement(\"textarea\"); element.textContent = textContent; if (this.data.doNotScroll) { element.style.overflowY = \"hidden\"; } } else { element = document.createElement(\"input\"); element.type = \"text\"; element.setAttribute(\"value\", textContent); if (this.data.doNotScroll) { element.style.overflowX = \"hidden\"; } } GetElementsByNameSet.add(element); element.setAttribute(\"data-element-id\", id); element.disabled = this.data.readOnly; element.name = this.data.fieldName; element.tabIndex = DEFAULT_TAB_INDEX; this._setRequired(element, this.data.required); if (maxLen) { element.maxLength = maxLen; } element.addEventListener(\"input\", event => { storage.setValue(id, { value: event.target.value }); this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\"); }); element.addEventListener(\"resetform\", event => { const defaultValue = this.data.defaultFieldValue ?? \"\"; element.value = elementData.userValue = defaultValue; elementData.formattedValue = null; }); let blurListener = event => { const { formattedValue } = elementData; if (formattedValue !== null && formattedValue !== undefined) { event.target.value = formattedValue; } event.target.scrollLeft = 0; }; if (this.enableScripting && this.hasJSActions) { element.addEventListener(\"focus\", event => { const { target } = event; if (elementData.userValue) { target.value = elementData.userValue; } elementData.lastCommittedValue = target.value; elementData.commitKey = 1; }); element.addEventListener(\"updatefromsandbox\", jsEvent => { const actions = { value(event) { elementData.userValue = event.detail.value ?? \"\"; storage.setValue(id, { value: elementData.userValue.toString() }); event.target.value = elementData.userValue; }, formattedValue(event) { const { formattedValue } = event.detail; elementData.formattedValue = formattedValue; if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) { event.target.value = formattedValue; } storage.setValue(id, { formattedValue }); }, selRange(event) { event.target.setSelectionRange(...event.detail.selRange); }, charLimit: event => { const { charLimit } = event.detail; const { target } = event; if (charLimit === 0) { target.removeAttribute(\"maxLength\"); return; } target.setAttribute(\"maxLength\", charLimit); let value = elementData.userValue; if (!value || value.length { elementData.commitKey = 1; let commitKey = -1; if (event.key === \"Escape\") { commitKey = 0; } else if (event.key === \"Enter\" && !this.data.multiLine) { commitKey = 2; } else if (event.key === \"Tab\") { elementData.commitKey = 3; } if (commitKey === -1) { return; } const { value } = event.target; if (elementData.lastCommittedValue === value) { return; } elementData.lastCommittedValue = value; elementData.userValue = value; this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", { source: this, detail: { id, name: \"Keystroke\", value, willCommit: true, commitKey, selStart: event.target.selectionStart, selEnd: event.target.selectionEnd } }); }); const _blurListener = blurListener; blurListener = null; element.addEventListener(\"blur\", event => { if (!event.relatedTarget) { return; } const { value } = event.target; elementData.userValue = value; if (elementData.lastCommittedValue !== value) { this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", { source: this, detail: { id, name: \"Keystroke\", value, willCommit: true, commitKey: elementData.commitKey, selStart: event.target.selectionStart, selEnd: event.target.selectionEnd } }); } _blurListener(event); }); if (this.data.actions?.Keystroke) { element.addEventListener(\"beforeinput\", event => { elementData.lastCommittedValue = null; const { data, target } = event; const { value, selectionStart, selectionEnd } = target; let selStart = selectionStart, selEnd = selectionEnd; switch (event.inputType) { case \"deleteWordBackward\": { const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/); if (match) { selStart -= match[0].length; } break; } case \"deleteWordForward\": { const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/); if (match) { selEnd += match[0].length; } break; } case \"deleteContentBackward\": if (selectionStart === selectionEnd) { selStart -= 1; } break; case \"deleteContentForward\": if (selectionStart === selectionEnd) { selEnd += 1; } break; } event.preventDefault(); this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", { source: this, detail: { id, name: \"Keystroke\", value, change: data || \"\", willCommit: false, selStart, selEnd } }); }); } this._setEventListeners(element, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.value); } if (blurListener) { element.addEventListener(\"blur\", blurListener); } if (this.data.comb) { const fieldWidth = this.data.rect[2] - this.data.rect[0]; const combWidth = fieldWidth / maxLen; element.classList.add(\"comb\"); element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`; } } else { element = document.createElement(\"div\"); element.textContent = this.data.fieldValue; element.style.verticalAlign = \"middle\"; element.style.display = \"table-cell\"; } this._setTextStyle(element); this._setBackgroundColor(element); this._setDefaultPropertiesFromJS(element); this.container.append(element); return this.container; } } class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement { constructor(parameters) { super(parameters, { isRenderable: parameters.renderForms }); } render() { const storage = this.annotationStorage; const data = this.data; const id = data.id; let value = storage.getValue(id, { value: data.exportValue === data.fieldValue }).value; if (typeof value === \"string\") { value = value !== \"Off\"; storage.setValue(id, { value }); } this.container.className = \"buttonWidgetAnnotation checkBox\"; const element = document.createElement(\"input\"); GetElementsByNameSet.add(element); element.setAttribute(\"data-element-id\", id); element.disabled = data.readOnly; this._setRequired(element, this.data.required); element.type = \"checkbox\"; element.name = data.fieldName; if (value) { element.setAttribute(\"checked\", true); } element.setAttribute(\"exportValue\", data.exportValue); element.tabIndex = DEFAULT_TAB_INDEX; element.addEventListener(\"change\", event => { const { name, checked } = event.target; for (const checkbox of this._getElementsByName(name, id)) { const curChecked = checked && checkbox.exportValue === data.exportValue; if (checkbox.domElement) { checkbox.domElement.checked = curChecked; } storage.setValue(checkbox.id, { value: curChecked }); } storage.setValue(id, { value: checked }); }); element.addEventListener(\"resetform\", event => { const defaultValue = data.defaultFieldValue || \"Off\"; event.target.checked = defaultValue === data.exportValue; }); if (this.enableScripting && this.hasJSActions) { element.addEventListener(\"updatefromsandbox\", jsEvent => { const actions = { value(event) { event.target.checked = event.detail.value !== \"Off\"; storage.setValue(id, { value: event.target.checked }); } }; this._dispatchEventFromSandbox(actions, jsEvent); }); this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked); } this._setBackgroundColor(element); this._setDefaultPropertiesFromJS(element); this.container.append(element); return this.container; } } class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement { constructor(parameters) { super(parameters, { isRenderable: parameters.renderForms }); } render() { this.container.className = \"buttonWidgetAnnotation radioButton\"; const storage = this.annotationStorage; const data = this.data; const id = data.id; let value = storage.getValue(id, { value: data.fieldValue === data.buttonValue }).value; if (typeof value === \"string\") { value = value !== data.buttonValue; storage.setValue(id, { value }); } const element = document.createElement(\"input\"); GetElementsByNameSet.add(element); element.setAttribute(\"data-element-id\", id); element.disabled = data.readOnly; this._setRequired(element, this.data.required); element.type = \"radio\"; element.name = data.fieldName; if (value) { element.setAttribute(\"checked\", true); } element.tabIndex = DEFAULT_TAB_INDEX; element.addEventListener(\"change\", event => { const { name, checked } = event.target; for (const radio of this._getElementsByName(name, id)) { storage.setValue(radio.id, { value: false }); } storage.setValue(id, { value: checked }); }); element.addEventListener(\"resetform\", event => { const defaultValue = data.defaultFieldValue; event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue; }); if (this.enableScripting && this.hasJSActions) { const pdfButtonValue = data.buttonValue; element.addEventListener(\"updatefromsandbox\", jsEvent => { const actions = { value: event => { const checked = pdfButtonValue === event.detail.value; for (const radio of this._getElementsByName(event.target.name)) { const curChecked = checked && radio.id === id; if (radio.domElement) { radio.domElement.checked = curChecked; } storage.setValue(radio.id, { value: curChecked }); } } }; this._dispatchEventFromSandbox(actions, jsEvent); }); this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked); } this._setBackgroundColor(element); this._setDefaultPropertiesFromJS(element); this.container.append(element); return this.container; } } class PushButtonWidgetAnnotationElement extends LinkAnnotationElement { constructor(parameters) { super(parameters, { ignoreBorder: parameters.data.hasAppearance }); } render() { const container = super.render(); container.className = \"buttonWidgetAnnotation pushButton\"; if (this.data.alternativeText) { container.title = this.data.alternativeText; } const linkElement = container.lastChild; if (this.enableScripting && this.hasJSActions && linkElement) { this._setDefaultPropertiesFromJS(linkElement); linkElement.addEventListener(\"updatefromsandbox\", jsEvent => { this._dispatchEventFromSandbox({}, jsEvent); }); } return container; } } class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement { constructor(parameters) { super(parameters, { isRenderable: parameters.renderForms }); } render() { this.container.className = \"choiceWidgetAnnotation\"; const storage = this.annotationStorage; const id = this.data.id; const storedData = storage.getValue(id, { value: this.data.fieldValue }); const selectElement = document.createElement(\"select\"); GetElementsByNameSet.add(selectElement); selectElement.setAttribute(\"data-element-id\", id); selectElement.disabled = this.data.readOnly; this._setRequired(selectElement, this.data.required); selectElement.name = this.data.fieldName; selectElement.tabIndex = DEFAULT_TAB_INDEX; let addAnEmptyEntry = this.data.combo && this.data.options.length > 0; if (!this.data.combo) { selectElement.size = this.data.options.length; if (this.data.multiSelect) { selectElement.multiple = true; } } selectElement.addEventListener(\"resetform\", event => { const defaultValue = this.data.defaultFieldValue; for (const option of selectElement.options) { option.selected = option.value === defaultValue; } }); for (const option of this.data.options) { const optionElement = document.createElement(\"option\"); optionElement.textContent = option.displayValue; optionElement.value = option.exportValue; if (storedData.value.includes(option.exportValue)) { optionElement.setAttribute(\"selected\", true); addAnEmptyEntry = false; } selectElement.append(optionElement); } let removeEmptyEntry = null; if (addAnEmptyEntry) { const noneOptionElement = document.createElement(\"option\"); noneOptionElement.value = \" \"; noneOptionElement.setAttribute(\"hidden\", true); noneOptionElement.setAttribute(\"selected\", true); selectElement.prepend(noneOptionElement); removeEmptyEntry = () => { noneOptionElement.remove(); selectElement.removeEventListener(\"input\", removeEmptyEntry); removeEmptyEntry = null; }; selectElement.addEventListener(\"input\", removeEmptyEntry); } const getValue = isExport => { const name = isExport ? \"value\" : \"textContent\"; const { options, multiple } = selectElement; if (!multiple) { return options.selectedIndex === -1 ? null : options[options.selectedIndex][name]; } return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]); }; let selectedValues = getValue(false); const getItems = event => { const options = event.target.options; return Array.prototype.map.call(options, option => { return { displayValue: option.textContent, exportValue: option.value }; }); }; if (this.enableScripting && this.hasJSActions) { selectElement.addEventListener(\"updatefromsandbox\", jsEvent => { const actions = { value(event) { removeEmptyEntry?.(); const value = event.detail.value; const values = new Set(Array.isArray(value) ? value : [value]); for (const option of selectElement.options) { option.selected = values.has(option.value); } storage.setValue(id, { value: getValue(true) }); selectedValues = getValue(false); }, multipleSelection(event) { selectElement.multiple = true; }, remove(event) { const options = selectElement.options; const index = event.detail.remove; options[index].selected = false; selectElement.remove(index); if (options.length > 0) { const i = Array.prototype.findIndex.call(options, option => option.selected); if (i === -1) { options[0].selected = true; } } storage.setValue(id, { value: getValue(true), items: getItems(event) }); selectedValues = getValue(false); }, clear(event) { while (selectElement.length !== 0) { selectElement.remove(0); } storage.setValue(id, { value: null, items: [] }); selectedValues = getValue(false); }, insert(event) { const { index, displayValue, exportValue } = event.detail.insert; const selectChild = selectElement.children[index]; const optionElement = document.createElement(\"option\"); optionElement.textContent = displayValue; optionElement.value = exportValue; if (selectChild) { selectChild.before(optionElement); } else { selectElement.append(optionElement); } storage.setValue(id, { value: getValue(true), items: getItems(event) }); selectedValues = getValue(false); }, items(event) { const { items } = event.detail; while (selectElement.length !== 0) { selectElement.remove(0); } for (const item of items) { const { displayValue, exportValue } = item; const optionElement = document.createElement(\"option\"); optionElement.textContent = displayValue; optionElement.value = exportValue; selectElement.append(optionElement); } if (selectElement.options.length > 0) { selectElement.options[0].selected = true; } storage.setValue(id, { value: getValue(true), items: getItems(event) }); selectedValues = getValue(false); }, indices(event) { const indices = new Set(event.detail.indices); for (const option of event.target.options) { option.selected = indices.has(option.index); } storage.setValue(id, { value: getValue(true) }); selectedValues = getValue(false); }, editable(event) { event.target.disabled = !event.detail.editable; } }; this._dispatchEventFromSandbox(actions, jsEvent); }); selectElement.addEventListener(\"input\", event => { const exportValue = getValue(true); storage.setValue(id, { value: exportValue }); event.preventDefault(); this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", { source: this, detail: { id, name: \"Keystroke\", value: selectedValues, changeEx: exportValue, willCommit: false, commitKey: 1, keyDown: false } }); }); this._setEventListeners(selectElement, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"], [\"input\", \"Action\"]], event => event.target.checked); } else { selectElement.addEventListener(\"input\", function (event) { storage.setValue(id, { value: getValue(true) }); }); } if (this.data.combo) { this._setTextStyle(selectElement); } else {} this._setBackgroundColor(selectElement); this._setDefaultPropertiesFromJS(selectElement); this.container.append(selectElement); return this.container; } } class PopupAnnotationElement extends AnnotationElement { static IGNORE_TYPES = new Set([\"Line\", \"Square\", \"Circle\", \"PolyLine\", \"Polygon\", \"Ink\"]); constructor(parameters) { const { data } = parameters; const isRenderable = !PopupAnnotationElement.IGNORE_TYPES.has(data.parentType) && !!(data.titleObj?.str || data.contentsObj?.str || data.richText?.str); super(parameters, { isRenderable }); } render() { this.container.className = \"popupAnnotation\"; const parentElements = this.layer.querySelectorAll(`[data-annotation-id=\"${this.data.parentId}\"]`); if (parentElements.length === 0) { return this.container; } const popup = new PopupElement({ container: this.container, trigger: Array.from(parentElements), color: this.data.color, titleObj: this.data.titleObj, modificationDate: this.data.modificationDate, contentsObj: this.data.contentsObj, richText: this.data.richText }); const page = this.page; const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]); const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0]; const popupTop = rect[1]; const { pageWidth, pageHeight, pageX, pageY } = this.viewport.rawDims; this.container.style.left = `${100 * (popupLeft - pageX) / pageWidth}%`; this.container.style.top = `${100 * (popupTop - pageY) / pageHeight}%`; this.container.append(popup.render()); return this.container; } } class PopupElement { constructor(parameters) { this.container = parameters.container; this.trigger = parameters.trigger; this.color = parameters.color; this.titleObj = parameters.titleObj; this.modificationDate = parameters.modificationDate; this.contentsObj = parameters.contentsObj; this.richText = parameters.richText; this.hideWrapper = parameters.hideWrapper || false; this.pinned = false; } render() { const BACKGROUND_ENLIGHT = 0.7; const wrapper = document.createElement(\"div\"); wrapper.className = \"popupWrapper\"; this.hideElement = this.hideWrapper ? wrapper : this.container; this.hideElement.hidden = true; const popup = document.createElement(\"div\"); popup.className = \"popup\"; const color = this.color; if (color) { const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0]; const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1]; const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2]; popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0); } const title = document.createElement(\"h1\"); title.dir = this.titleObj.dir; title.textContent = this.titleObj.str; popup.append(title); const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate); if (dateObject) { const modificationDate = document.createElement(\"span\"); modificationDate.className = \"popupDate\"; modificationDate.textContent = \"1688005776912, \"; modificationDate.dataset.l10nId = \"annotation_date_string\"; modificationDate.dataset.l10nArgs = JSON.stringify({ date: dateObject.toLocaleDateString(), time: dateObject.toLocaleTimeString() }); popup.append(modificationDate); } if (this.richText?.str && (!this.contentsObj?.str || this.contentsObj.str === this.richText.str)) { _xfa_layer.XfaLayer.render({ xfaHtml: this.richText.html, intent: \"richText\", div: popup }); popup.lastChild.className = \"richText popupContent\"; } else { const contents = this._formatContents(this.contentsObj); popup.append(contents); } if (!Array.isArray(this.trigger)) { this.trigger = [this.trigger]; } for (const element of this.trigger) { element.addEventListener(\"click\", this._toggle.bind(this)); element.addEventListener(\"mouseover\", this._show.bind(this, false)); element.addEventListener(\"mouseout\", this._hide.bind(this, false)); } popup.addEventListener(\"click\", this._hide.bind(this, true)); wrapper.append(popup); return wrapper; } _formatContents({ str, dir }) { const p = document.createElement(\"p\"); p.className = \"popupContent\"; p.dir = dir; const lines = str.split(/(?:\\r\\n?|\\n)/); for (let i = 0, ii = lines.length; i < ii; ++i) { const line = lines[i]; p.append(document.createTextNode(line)); if (i < ii - 1) { p.append(document.createElement(\"br\")); } } return p; } _toggle() { if (this.pinned) { this._hide(true); } else { this._show(true); } } _show(pin = false) { if (pin) { this.pinned = true; } if (this.hideElement.hidden) { this.hideElement.hidden = false; this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1000; } } _hide(unpin = true) { if (unpin) { this.pinned = false; } if (!this.hideElement.hidden && !this.pinned) { this.hideElement.hidden = true; this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1000; } } } class FreeTextAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); this.textContent = parameters.data.textContent; } render() { this.container.className = \"freeTextAnnotation\"; if (this.textContent) { const content = document.createElement(\"div\"); content.className = \"annotationTextContent\"; content.setAttribute(\"role\", \"comment\"); for (const line of this.textContent) { const lineSpan = document.createElement(\"span\"); lineSpan.textContent = line; content.append(lineSpan); } this.container.append(content); } if (!this.data.hasPopup) { this._createPopup(null, this.data); } return this.container; } } class LineAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); } render() { this.container.className = \"lineAnnotation\"; const data = this.data; const { width, height } = getRectDims(data.rect); const svg = this.svgFactory.create(width, height, true); const line = this.svgFactory.createElement(\"svg:line\"); line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]); line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]); line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]); line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]); line.setAttribute(\"stroke-width\", data.borderStyle.width || 1); line.setAttribute(\"stroke\", \"transparent\"); line.setAttribute(\"fill\", \"transparent\"); svg.append(line); this.container.append(svg); this._createPopup(line, data); return this.container; } } class SquareAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); } render() { this.container.className = \"squareAnnotation\"; const data = this.data; const { width, height } = getRectDims(data.rect); const svg = this.svgFactory.create(width, height, true); const borderWidth = data.borderStyle.width; const square = this.svgFactory.createElement(\"svg:rect\"); square.setAttribute(\"x\", borderWidth / 2); square.setAttribute(\"y\", borderWidth / 2); square.setAttribute(\"width\", width - borderWidth); square.setAttribute(\"height\", height - borderWidth); square.setAttribute(\"stroke-width\", borderWidth || 1); square.setAttribute(\"stroke\", \"transparent\"); square.setAttribute(\"fill\", \"transparent\"); svg.append(square); this.container.append(svg); this._createPopup(square, data); return this.container; } } class CircleAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); } render() { this.container.className = \"circleAnnotation\"; const data = this.data; const { width, height } = getRectDims(data.rect); const svg = this.svgFactory.create(width, height, true); const borderWidth = data.borderStyle.width; const circle = this.svgFactory.createElement(\"svg:ellipse\"); circle.setAttribute(\"cx\", width / 2); circle.setAttribute(\"cy\", height / 2); circle.setAttribute(\"rx\", width / 2 - borderWidth / 2); circle.setAttribute(\"ry\", height / 2 - borderWidth / 2); circle.setAttribute(\"stroke-width\", borderWidth || 1); circle.setAttribute(\"stroke\", \"transparent\"); circle.setAttribute(\"fill\", \"transparent\"); svg.append(circle); this.container.append(svg); this._createPopup(circle, data); return this.container; } } class PolylineAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); this.containerClassName = \"polylineAnnotation\"; this.svgElementName = \"svg:polyline\"; } render() { this.container.className = this.containerClassName; const data = this.data; const { width, height } = getRectDims(data.rect); const svg = this.svgFactory.create(width, height, true); let points = []; for (const coordinate of data.vertices) { const x = coordinate.x - data.rect[0]; const y = data.rect[3] - coordinate.y; points.push(x + \",\" + y); } points = points.join(\" \"); const polyline = this.svgFactory.createElement(this.svgElementName); polyline.setAttribute(\"points\", points); polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1); polyline.setAttribute(\"stroke\", \"transparent\"); polyline.setAttribute(\"fill\", \"transparent\"); svg.append(polyline); this.container.append(svg); this._createPopup(polyline, data); return this.container; } } class PolygonAnnotationElement extends PolylineAnnotationElement { constructor(parameters) { super(parameters); this.containerClassName = \"polygonAnnotation\"; this.svgElementName = \"svg:polygon\"; } } class CaretAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); } render() { this.container.className = \"caretAnnotation\"; if (!this.data.hasPopup) { this._createPopup(null, this.data); } return this.container; } } class InkAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); this.containerClassName = \"inkAnnotation\"; this.svgElementName = \"svg:polyline\"; } render() { this.container.className = this.containerClassName; const data = this.data; const { width, height } = getRectDims(data.rect); const svg = this.svgFactory.create(width, height, true); for (const inkList of data.inkLists) { let points = []; for (const coordinate of inkList) { const x = coordinate.x - data.rect[0]; const y = data.rect[3] - coordinate.y; points.push(`${x},${y}`); } points = points.join(\" \"); const polyline = this.svgFactory.createElement(this.svgElementName); polyline.setAttribute(\"points\", points); polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1); polyline.setAttribute(\"stroke\", \"transparent\"); polyline.setAttribute(\"fill\", \"transparent\"); this._createPopup(polyline, data); svg.append(polyline); } this.container.append(svg); return this.container; } } class HighlightAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true, createQuadrilaterals: true }); } render() { if (!this.data.hasPopup) { this._createPopup(null, this.data); } if (this.quadrilaterals) { return this._renderQuadrilaterals(\"highlightAnnotation\"); } this.container.className = \"highlightAnnotation\"; return this.container; } } class UnderlineAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true, createQuadrilaterals: true }); } render() { if (!this.data.hasPopup) { this._createPopup(null, this.data); } if (this.quadrilaterals) { return this._renderQuadrilaterals(\"underlineAnnotation\"); } this.container.className = \"underlineAnnotation\"; return this.container; } } class SquigglyAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true, createQuadrilaterals: true }); } render() { if (!this.data.hasPopup) { this._createPopup(null, this.data); } if (this.quadrilaterals) { return this._renderQuadrilaterals(\"squigglyAnnotation\"); } this.container.className = \"squigglyAnnotation\"; return this.container; } } class StrikeOutAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true, createQuadrilaterals: true }); } render() { if (!this.data.hasPopup) { this._createPopup(null, this.data); } if (this.quadrilaterals) { return this._renderQuadrilaterals(\"strikeoutAnnotation\"); } this.container.className = \"strikeoutAnnotation\"; return this.container; } } class StampAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str); super(parameters, { isRenderable, ignoreBorder: true }); } render() { this.container.className = \"stampAnnotation\"; if (!this.data.hasPopup) { this._createPopup(null, this.data); } return this.container; } } class FileAttachmentAnnotationElement extends AnnotationElement { constructor(parameters) { super(parameters, { isRenderable: true }); const { filename, content } = this.data.file; this.filename = (0, _display_utils.getFilenameFromUrl)(filename, true); this.content = content; this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", { source: this, filename, content }); } render() { this.container.className = \"fileAttachmentAnnotation\"; let trigger; if (this.data.hasAppearance) { trigger = document.createElement(\"div\"); } else { trigger = document.createElement(\"img\"); trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(this.data.name) ? \"paperclip\" : \"pushpin\"}.svg`; } trigger.className = \"popupTriggerArea\"; trigger.addEventListener(\"dblclick\", this._download.bind(this)); if (!this.data.hasPopup && (this.data.titleObj?.str || this.data.contentsObj?.str || this.data.richText)) { this._createPopup(trigger, this.data); } this.container.append(trigger); return this.container; } _download() { this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename); } } class AnnotationLayer { static #appendElement(element, id, div, accessibilityManager) { const contentElement = element.firstChild || element; contentElement.id = `${_display_utils.AnnotationPrefix}${id}`; div.append(element); accessibilityManager?.moveElementInDOM(div, element, contentElement, false); } static render(params) { const { annotations, div, viewport, accessibilityManager } = params; (0, _display_utils.setLayerDimensions)(div, viewport); const elementParams = { data: null, layer: div, page: params.page, viewport, linkService: params.linkService, downloadManager: params.downloadManager, imageResourcesPath: params.imageResourcesPath || \"\", renderForms: params.renderForms !== false, svgFactory: new _display_utils.DOMSVGFactory(), annotationStorage: params.annotationStorage || new _annotation_storage.AnnotationStorage(), enableScripting: params.enableScripting === true, hasJSActions: params.hasJSActions, fieldObjects: params.fieldObjects }; let zIndex = 0; for (const data of annotations) { if (data.annotationType !== _util.AnnotationType.POPUP) { const { width, height } = getRectDims(data.rect); if (width { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.XfaLayer = void 0; var _xfa_text = __w_pdfjs_require__(19); class XfaLayer { static setupStorage(html, id, element, storage, intent) { const storedData = storage.getValue(id, { value: null }); switch (element.name) { case \"textarea\": if (storedData.value !== null) { html.textContent = storedData.value; } if (intent === \"print\") { break; } html.addEventListener(\"input\", event => { storage.setValue(id, { value: event.target.value }); }); break; case \"input\": if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") { if (storedData.value === element.attributes.xfaOn) { html.setAttribute(\"checked\", true); } else if (storedData.value === element.attributes.xfaOff) { html.removeAttribute(\"checked\"); } if (intent === \"print\") { break; } html.addEventListener(\"change\", event => { storage.setValue(id, { value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\") }); }); } else { if (storedData.value !== null) { html.setAttribute(\"value\", storedData.value); } if (intent === \"print\") { break; } html.addEventListener(\"input\", event => { storage.setValue(id, { value: event.target.value }); }); } break; case \"select\": if (storedData.value !== null) { for (const option of element.children) { if (option.attributes.value === storedData.value) { option.attributes.selected = true; } } } html.addEventListener(\"input\", event => { const options = event.target.options; const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value; storage.setValue(id, { value }); }); break; } } static setAttributes({ html, element, storage = null, intent, linkService }) { const { attributes } = element; const isHTMLAnchorElement = html instanceof HTMLAnchorElement; if (attributes.type === \"radio\") { attributes.name = `${attributes.name}-${intent}`; } for (const [key, value] of Object.entries(attributes)) { if (value === null || value === undefined) { continue; } switch (key) { case \"class\": if (value.length) { html.setAttribute(key, value.join(\" \")); } break; case \"dataId\": break; case \"id\": html.setAttribute(\"data-element-id\", value); break; case \"style\": Object.assign(html.style, value); break; case \"textContent\": html.textContent = value; break; default: if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") { html.setAttribute(key, value); } } } if (isHTMLAnchorElement) { linkService.addLinkAttributes(html, attributes.href, attributes.newWindow); } if (storage && attributes.dataId) { this.setupStorage(html, attributes.dataId, element, storage); } } static render(parameters) { const storage = parameters.annotationStorage; const linkService = parameters.linkService; const root = parameters.xfaHtml; const intent = parameters.intent || \"display\"; const rootHtml = document.createElement(root.name); if (root.attributes) { this.setAttributes({ html: rootHtml, element: root, intent, linkService }); } const stack = [[root, -1, rootHtml]]; const rootDiv = parameters.div; rootDiv.append(rootHtml); if (parameters.viewport) { const transform = `matrix(${parameters.viewport.transform.join(\",\")})`; rootDiv.style.transform = transform; } if (intent !== \"richText\") { rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\"); } const textDivs = []; while (stack.length > 0) { const [parent, i, html] = stack.at(-1); if (i + 1 === parent.children.length) { stack.pop(); continue; } const child = parent.children[++stack.at(-1)[1]]; if (child === null) { continue; } const { name } = child; if (name === \"#text\") { const node = document.createTextNode(child.value); textDivs.push(node); html.append(node); continue; } let childHtml; if (child?.attributes?.xmlns) { childHtml = document.createElementNS(child.attributes.xmlns, name); } else { childHtml = document.createElement(name); } html.append(childHtml); if (child.attributes) { this.setAttributes({ html: childHtml, element: child, storage, intent, linkService }); } if (child.children && child.children.length > 0) { stack.push([child, -1, childHtml]); } else if (child.value) { const node = document.createTextNode(child.value); if (_xfa_text.XfaText.shouldBuildText(name)) { textDivs.push(node); } childHtml.append(node); } } for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")) { el.setAttribute(\"readOnly\", true); } return { textDivs }; } static update(parameters) { const transform = `matrix(${parameters.viewport.transform.join(\",\")})`; parameters.div.style.transform = transform; parameters.div.hidden = false; } } exports.XfaLayer = XfaLayer; /***/ }), /* 30 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.SVGGraphics = void 0; var _display_utils = __w_pdfjs_require__(6); var _util = __w_pdfjs_require__(1); var _is_node = __w_pdfjs_require__(10); let SVGGraphics = class { constructor() { (0, _util.unreachable)(\"Not implemented: SVGGraphics\"); } }; exports.SVGGraphics = SVGGraphics; { const SVG_DEFAULTS = { fontStyle: \"normal\", fontWeight: \"normal\", fillColor: \"#000000\" }; const XML_NS = \"http://www.w3.org/XML/1998/namespace\"; const XLINK_NS = \"http://www.w3.org/1999/xlink\"; const LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"]; const LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"]; const createObjectURL = function (data, contentType = \"\", forceDataSchema = false) { if (URL.createObjectURL && typeof Blob !== \"undefined\" && !forceDataSchema) { return URL.createObjectURL(new Blob([data], { type: contentType })); } const digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; let buffer = `data:${contentType};base64,`; for (let i = 0, ii = data.length; i < ii; i += 3) { const b1 = data[i] & 0xff; const b2 = data[i + 1] & 0xff; const b3 = data[i + 2] & 0xff; const d1 = b1 >> 2, d2 = (b1 & 3) < 4 | b2 >> 4; const d3 = i + 1 < ii ? (b2 & 0xf) < 2 | b3 >> 6 : 64; const d4 = i + 2 < ii ? b3 & 0x3f : 64; buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4]; } return buffer; }; const convertImgDataToPng = function () { const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]); const CHUNK_WRAPPER_SIZE = 12; const crcTable = new Int32Array(256); for (let i = 0; i < 256; i++) { let c = i; for (let h = 0; h < 8; h++) { if (c & 1) { c = 0xedb88320 ^ c >> 1 & 0x7fffffff; } else { c = c >> 1 & 0x7fffffff; } } crcTable[i] = c; } function crc32(data, start, end) { let crc = -1; for (let i = start; i < end; i++) { const a = (crc ^ data[i]) & 0xff; const b = crcTable[a]; crc = crc >>> 8 ^ b; } return crc ^ -1; } function writePngChunk(type, body, data, offset) { let p = offset; const len = body.length; data[p] = len >> 24 & 0xff; data[p + 1] = len >> 16 & 0xff; data[p + 2] = len >> 8 & 0xff; data[p + 3] = len & 0xff; p += 4; data[p] = type.charCodeAt(0) & 0xff; data[p + 1] = type.charCodeAt(1) & 0xff; data[p + 2] = type.charCodeAt(2) & 0xff; data[p + 3] = type.charCodeAt(3) & 0xff; p += 4; data.set(body, p); p += body.length; const crc = crc32(data, offset + 4, p); data[p] = crc >> 24 & 0xff; data[p + 1] = crc >> 16 & 0xff; data[p + 2] = crc >> 8 & 0xff; data[p + 3] = crc & 0xff; } function adler32(data, start, end) { let a = 1; let b = 0; for (let i = start; i < end; ++i) { a = (a + (data[i] & 0xff)) % 65521; b = (b + a) % 65521; } return b < 16 | a; } function deflateSync(literals) { if (!_is_node.isNodeJS) { return deflateSyncUncompressed(literals); } try { let input; if (parseInt(process.versions.node) >= 8) { input = literals; } else { input = Buffer.from(literals); } const output = require(\"zlib\").deflateSync(input, { level: 9 }); return output instanceof Uint8Array ? output : new Uint8Array(output); } catch (e) { (0, _util.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e); } return deflateSyncUncompressed(literals); } function deflateSyncUncompressed(literals) { let len = literals.length; const maxBlockLength = 0xffff; const deflateBlocks = Math.ceil(len / maxBlockLength); const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4); let pi = 0; idat[pi++] = 0x78; idat[pi++] = 0x9c; let pos = 0; while (len > maxBlockLength) { idat[pi++] = 0x00; idat[pi++] = 0xff; idat[pi++] = 0xff; idat[pi++] = 0x00; idat[pi++] = 0x00; idat.set(literals.subarray(pos, pos + maxBlockLength), pi); pi += maxBlockLength; pos += maxBlockLength; len -= maxBlockLength; } idat[pi++] = 0x01; idat[pi++] = len & 0xff; idat[pi++] = len >> 8 & 0xff; idat[pi++] = ~len & 0xffff & 0xff; idat[pi++] = (~len & 0xffff) >> 8 & 0xff; idat.set(literals.subarray(pos), pi); pi += literals.length - pos; const adler = adler32(literals, 0, literals.length); idat[pi++] = adler >> 24 & 0xff; idat[pi++] = adler >> 16 & 0xff; idat[pi++] = adler >> 8 & 0xff; idat[pi++] = adler & 0xff; return idat; } function encode(imgData, kind, forceDataSchema, isMask) { const width = imgData.width; const height = imgData.height; let bitDepth, colorType, lineSize; const bytes = imgData.data; switch (kind) { case _util.ImageKind.GRAYSCALE_1BPP: colorType = 0; bitDepth = 1; lineSize = width + 7 >> 3; break; case _util.ImageKind.RGB_24BPP: colorType = 2; bitDepth = 8; lineSize = width * 3; break; case _util.ImageKind.RGBA_32BPP: colorType = 6; bitDepth = 8; lineSize = width * 4; break; default: throw new Error(\"invalid format\"); } const literals = new Uint8Array((1 + lineSize) * height); let offsetLiterals = 0, offsetBytes = 0; for (let y = 0; y < height; ++y) { literals[offsetLiterals++] = 0; literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals); offsetBytes += lineSize; offsetLiterals += lineSize; } if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) { offsetLiterals = 0; for (let y = 0; y < height; y++) { offsetLiterals++; for (let i = 0; i < lineSize; i++) { literals[offsetLiterals++] ^= 0xff; } } } const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]); const idat = deflateSync(literals); const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length; const data = new Uint8Array(pngLength); let offset = 0; data.set(PNG_HEADER, offset); offset += PNG_HEADER.length; writePngChunk(\"IHDR\", ihdr, data, offset); offset += CHUNK_WRAPPER_SIZE + ihdr.length; writePngChunk(\"IDATA\", idat, data, offset); offset += CHUNK_WRAPPER_SIZE + idat.length; writePngChunk(\"IEND\", new Uint8Array(0), data, offset); return createObjectURL(data, \"image/png\", forceDataSchema); } return function convertImgDataToPng(imgData, forceDataSchema, isMask) { const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind; return encode(imgData, kind, forceDataSchema, isMask); }; }(); class SVGExtraState { constructor() { this.fontSizeScale = 1; this.fontWeight = SVG_DEFAULTS.fontWeight; this.fontSize = 0; this.textMatrix = _util.IDENTITY_MATRIX; this.fontMatrix = _util.FONT_IDENTITY_MATRIX; this.leading = 0; this.textRenderingMode = _util.TextRenderingMode.FILL; this.textMatrixScale = 1; this.x = 0; this.y = 0; this.lineX = 0; this.lineY = 0; this.charSpacing = 0; this.wordSpacing = 0; this.textHScale = 1; this.textRise = 0; this.fillColor = SVG_DEFAULTS.fillColor; this.strokeColor = \"#000000\"; this.fillAlpha = 1; this.strokeAlpha = 1; this.lineWidth = 1; this.lineJoin = \"\"; this.lineCap = \"\"; this.miterLimit = 0; this.dashArray = []; this.dashPhase = 0; this.dependencies = []; this.activeClipUrl = null; this.clipGroup = null; this.maskId = \"\"; } clone() { return Object.create(this); } setCurrentPoint(x, y) { this.x = x; this.y = y; } } function opListToTree(opList) { let opTree = []; const tmp = []; for (const opListElement of opList) { if (opListElement.fn === \"save\") { opTree.push({ fnId: 92, fn: \"group\", items: [] }); tmp.push(opTree); opTree = opTree.at(-1).items; continue; } if (opListElement.fn === \"restore\") { opTree = tmp.pop(); } else { opTree.push(opListElement); } } return opTree; } function pf(value) { if (Number.isInteger(value)) { return value.toString(); } const s = value.toFixed(10); let i = s.length - 1; if (s[i] !== \"0\") { return s; } do { i--; } while (s[i] === \"0\"); return s.substring(0, s[i] === \".\" ? i : i + 1); } function pm(m) { if (m[4] === 0 && m[5] === 0) { if (m[1] === 0 && m[2] === 0) { if (m[0] === 1 && m[3] === 1) { return \"\"; } return `scale(${pf(m[0])} ${pf(m[3])})`; } if (m[0] === m[3] && m[1] === -m[2]) { const a = Math.acos(m[0]) * 180 / Math.PI; return `rotate(${pf(a)})`; } } else { if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) { return `translate(${pf(m[4])} ${pf(m[5])})`; } } return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`; } let clipCount = 0; let maskCount = 0; let shadingCount = 0; exports.SVGGraphics = SVGGraphics = class { constructor(commonObjs, objs, forceDataSchema = false) { (0, _display_utils.deprecated)(\"The SVG back-end is no longer maintained and *may* be removed in the future.\"); this.svgFactory = new _display_utils.DOMSVGFactory(); this.current = new SVGExtraState(); this.transformMatrix = _util.IDENTITY_MATRIX; this.transformStack = []; this.extraStack = []; this.commonObjs = commonObjs; this.objs = objs; this.pendingClip = null; this.pendingEOFill = false; this.embedFonts = false; this.embeddedFonts = Object.create(null); this.cssStyle = null; this.forceDataSchema = !!forceDataSchema; this._operatorIdMapping = []; for (const op in _util.OPS) { this._operatorIdMapping[_util.OPS[op]] = op; } } getObject(data, fallback = null) { if (typeof data === \"string\") { return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data); } return fallback; } save() { this.transformStack.push(this.transformMatrix); const old = this.current; this.extraStack.push(old); this.current = old.clone(); } restore() { this.transformMatrix = this.transformStack.pop(); this.current = this.extraStack.pop(); this.pendingClip = null; this.tgrp = null; } group(items) { this.save(); this.executeOpTree(items); this.restore(); } loadDependencies(operatorList) { const fnArray = operatorList.fnArray; const argsArray = operatorList.argsArray; for (let i = 0, ii = fnArray.length; i < ii; i++) { if (fnArray[i] !== _util.OPS.dependency) { continue; } for (const obj of argsArray[i]) { const objsPool = obj.startsWith(\"g_\") ? this.commonObjs : this.objs; const promise = new Promise(resolve => { objsPool.get(obj, resolve); }); this.current.dependencies.push(promise); } } return Promise.all(this.current.dependencies); } transform(a, b, c, d, e, f) { const transformMatrix = [a, b, c, d, e, f]; this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix); this.tgrp = null; } getSVG(operatorList, viewport) { this.viewport = viewport; const svgElement = this._initialize(viewport); return this.loadDependencies(operatorList).then(() => { this.transformMatrix = _util.IDENTITY_MATRIX; this.executeOpTree(this.convertOpList(operatorList)); return svgElement; }); } convertOpList(operatorList) { const operatorIdMapping = this._operatorIdMapping; const argsArray = operatorList.argsArray; const fnArray = operatorList.fnArray; const opList = []; for (let i = 0, ii = fnArray.length; i < ii; i++) { const fnId = fnArray[i]; opList.push({ fnId, fn: operatorIdMapping[fnId], args: argsArray[i] }); } return opListToTree(opList); } executeOpTree(opTree) { for (const opTreeElement of opTree) { const fn = opTreeElement.fn; const fnId = opTreeElement.fnId; const args = opTreeElement.args; switch (fnId | 0) { case _util.OPS.beginText: this.beginText(); break; case _util.OPS.dependency: break; case _util.OPS.setLeading: this.setLeading(args); break; case _util.OPS.setLeadingMoveText: this.setLeadingMoveText(args[0], args[1]); break; case _util.OPS.setFont: this.setFont(args); break; case _util.OPS.showText: this.showText(args[0]); break; case _util.OPS.showSpacedText: this.showText(args[0]); break; case _util.OPS.endText: this.endText(); break; case _util.OPS.moveText: this.moveText(args[0], args[1]); break; case _util.OPS.setCharSpacing: this.setCharSpacing(args[0]); break; case _util.OPS.setWordSpacing: this.setWordSpacing(args[0]); break; case _util.OPS.setHScale: this.setHScale(args[0]); break; case _util.OPS.setTextMatrix: this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]); break; case _util.OPS.setTextRise: this.setTextRise(args[0]); break; case _util.OPS.setTextRenderingMode: this.setTextRenderingMode(args[0]); break; case _util.OPS.setLineWidth: this.setLineWidth(args[0]); break; case _util.OPS.setLineJoin: this.setLineJoin(args[0]); break; case _util.OPS.setLineCap: this.setLineCap(args[0]); break; case _util.OPS.setMiterLimit: this.setMiterLimit(args[0]); break; case _util.OPS.setFillRGBColor: this.setFillRGBColor(args[0], args[1], args[2]); break; case _util.OPS.setStrokeRGBColor: this.setStrokeRGBColor(args[0], args[1], args[2]); break; case _util.OPS.setStrokeColorN: this.setStrokeColorN(args); break; case _util.OPS.setFillColorN: this.setFillColorN(args); break; case _util.OPS.shadingFill: this.shadingFill(args[0]); break; case _util.OPS.setDash: this.setDash(args[0], args[1]); break; case _util.OPS.setRenderingIntent: this.setRenderingIntent(args[0]); break; case _util.OPS.setFlatness: this.setFlatness(args[0]); break; case _util.OPS.setGState: this.setGState(args[0]); break; case _util.OPS.fill: this.fill(); break; case _util.OPS.eoFill: this.eoFill(); break; case _util.OPS.stroke: this.stroke(); break; case _util.OPS.fillStroke: this.fillStroke(); break; case _util.OPS.eoFillStroke: this.eoFillStroke(); break; case _util.OPS.clip: this.clip(\"nonzero\"); break; case _util.OPS.eoClip: this.clip(\"evenodd\"); break; case _util.OPS.paintSolidColorImageMask: this.paintSolidColorImageMask(); break; case _util.OPS.paintImageXObject: this.paintImageXObject(args[0]); break; case _util.OPS.paintInlineImageXObject: this.paintInlineImageXObject(args[0]); break; case _util.OPS.paintImageMaskXObject: this.paintImageMaskXObject(args[0]); break; case _util.OPS.paintFormXObjectBegin: this.paintFormXObjectBegin(args[0], args[1]); break; case _util.OPS.paintFormXObjectEnd: this.paintFormXObjectEnd(); break; case _util.OPS.closePath: this.closePath(); break; case _util.OPS.closeStroke: this.closeStroke(); break; case _util.OPS.closeFillStroke: this.closeFillStroke(); break; case _util.OPS.closeEOFillStroke: this.closeEOFillStroke(); break; case _util.OPS.nextLine: this.nextLine(); break; case _util.OPS.transform: this.transform(args[0], args[1], args[2], args[3], args[4], args[5]); break; case _util.OPS.constructPath: this.constructPath(args[0], args[1]); break; case _util.OPS.endPath: this.endPath(); break; case 92: this.group(opTreeElement.items); break; default: (0, _util.warn)(`Unimplemented operator ${fn}`); break; } } } setWordSpacing(wordSpacing) { this.current.wordSpacing = wordSpacing; } setCharSpacing(charSpacing) { this.current.charSpacing = charSpacing; } nextLine() { this.moveText(0, this.current.leading); } setTextMatrix(a, b, c, d, e, f) { const current = this.current; current.textMatrix = current.lineMatrix = [a, b, c, d, e, f]; current.textMatrixScale = Math.hypot(a, b); current.x = current.lineX = 0; current.y = current.lineY = 0; current.xcoords = []; current.ycoords = []; current.tspan = this.svgFactory.createElement(\"svg:tspan\"); current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily); current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`); current.tspan.setAttributeNS(null, \"y\", pf(-current.y)); current.txtElement = this.svgFactory.createElement(\"svg:text\"); current.txtElement.append(current.tspan); } beginText() { const current = this.current; current.x = current.lineX = 0; current.y = current.lineY = 0; current.textMatrix = _util.IDENTITY_MATRIX; current.lineMatrix = _util.IDENTITY_MATRIX; current.textMatrixScale = 1; current.tspan = this.svgFactory.createElement(\"svg:tspan\"); current.txtElement = this.svgFactory.createElement(\"svg:text\"); current.txtgrp = this.svgFactory.createElement(\"svg:g\"); current.xcoords = []; current.ycoords = []; } moveText(x, y) { const current = this.current; current.x = current.lineX += x; current.y = current.lineY += y; current.xcoords = []; current.ycoords = []; current.tspan = this.svgFactory.createElement(\"svg:tspan\"); current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily); current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`); current.tspan.setAttributeNS(null, \"y\", pf(-current.y)); } showText(glyphs) { const current = this.current; const font = current.font; const fontSize = current.fontSize; if (fontSize === 0) { return; } const fontSizeScale = current.fontSizeScale; const charSpacing = current.charSpacing; const wordSpacing = current.wordSpacing; const fontDirection = current.fontDirection; const textHScale = current.textHScale * fontDirection; const vertical = font.vertical; const spacingDir = vertical ? 1 : -1; const defaultVMetrics = font.defaultVMetrics; const widthAdvanceScale = fontSize * current.fontMatrix[0]; let x = 0; for (const glyph of glyphs) { if (glyph === null) { x += fontDirection * wordSpacing; continue; } else if (typeof glyph === \"number\") { x += spacingDir * glyph * fontSize / 1000; continue; } const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing; const character = glyph.fontChar; let scaledX, scaledY; let width = glyph.width; if (vertical) { let vx; const vmetric = glyph.vmetric || defaultVMetrics; vx = glyph.vmetric ? vmetric[1] : width * 0.5; vx = -vx * widthAdvanceScale; const vy = vmetric[2] * widthAdvanceScale; width = vmetric ? -vmetric[0] : width; scaledX = vx / fontSizeScale; scaledY = (x + vy) / fontSizeScale; } else { scaledX = x / fontSizeScale; scaledY = 0; } if (glyph.isInFont || font.missingFile) { current.xcoords.push(current.x + scaledX); if (vertical) { current.ycoords.push(-current.y + scaledY); } current.tspan.textContent += character; } else {} let charWidth; if (vertical) { charWidth = width * widthAdvanceScale - spacing * fontDirection; } else { charWidth = width * widthAdvanceScale + spacing * fontDirection; } x += charWidth; } current.tspan.setAttributeNS(null, \"x\", current.xcoords.map(pf).join(\" \")); if (vertical) { current.tspan.setAttributeNS(null, \"y\", current.ycoords.map(pf).join(\" \")); } else { current.tspan.setAttributeNS(null, \"y\", pf(-current.y)); } if (vertical) { current.y -= x; } else { current.x += x * textHScale; } current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily); current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`); if (current.fontStyle !== SVG_DEFAULTS.fontStyle) { current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle); } if (current.fontWeight !== SVG_DEFAULTS.fontWeight) { current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight); } const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK; if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { if (current.fillColor !== SVG_DEFAULTS.fillColor) { current.tspan.setAttributeNS(null, \"fill\", current.fillColor); } if (current.fillAlpha < 1) { current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha); } } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) { current.tspan.setAttributeNS(null, \"fill\", \"transparent\"); } else { current.tspan.setAttributeNS(null, \"fill\", \"none\"); } if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { const lineWidthScale = 1 / (current.textMatrixScale || 1); this._setStrokeAttributes(current.tspan, lineWidthScale); } let textMatrix = current.textMatrix; if (current.textRise !== 0) { textMatrix = textMatrix.slice(); textMatrix[5] += current.textRise; } current.txtElement.setAttributeNS(null, \"transform\", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`); current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\"); current.txtElement.append(current.tspan); current.txtgrp.append(current.txtElement); this._ensureTransformGroup().append(current.txtElement); } setLeadingMoveText(x, y) { this.setLeading(-y); this.moveText(x, y); } addFontStyle(fontObj) { if (!fontObj.data) { throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.'); } if (!this.cssStyle) { this.cssStyle = this.svgFactory.createElement(\"svg:style\"); this.cssStyle.setAttributeNS(null, \"type\", \"text/css\"); this.defs.append(this.cssStyle); } const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema); this.cssStyle.textContent += `@font-face { font-family: \"${fontObj.loadedName}\";` + ` src: url(${url}); }\\n`; } setFont(details) { const current = this.current; const fontObj = this.commonObjs.get(details[0]); let size = details[1]; current.font = fontObj; if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) { this.addFontStyle(fontObj); this.embeddedFonts[fontObj.loadedName] = fontObj; } current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX; let bold = \"normal\"; if (fontObj.black) { bold = \"900\"; } else if (fontObj.bold) { bold = \"bold\"; } const italic = fontObj.italic ? \"italic\" : \"normal\"; if (size < 0) { size = -size; current.fontDirection = -1; } else { current.fontDirection = 1; } current.fontSize = size; current.fontFamily = fontObj.loadedName; current.fontWeight = bold; current.fontStyle = italic; current.tspan = this.svgFactory.createElement(\"svg:tspan\"); current.tspan.setAttributeNS(null, \"y\", pf(-current.y)); current.xcoords = []; current.ycoords = []; } endText() { const current = this.current; if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) { current.element = current.txtElement; this.clip(\"nonzero\"); this.endPath(); } } setLineWidth(width) { if (width > 0) { this.current.lineWidth = width; } } setLineCap(style) { this.current.lineCap = LINE_CAP_STYLES[style]; } setLineJoin(style) { this.current.lineJoin = LINE_JOIN_STYLES[style]; } setMiterLimit(limit) { this.current.miterLimit = limit; } setStrokeAlpha(strokeAlpha) { this.current.strokeAlpha = strokeAlpha; } setStrokeRGBColor(r, g, b) { this.current.strokeColor = _util.Util.makeHexColor(r, g, b); } setFillAlpha(fillAlpha) { this.current.fillAlpha = fillAlpha; } setFillRGBColor(r, g, b) { this.current.fillColor = _util.Util.makeHexColor(r, g, b); this.current.tspan = this.svgFactory.createElement(\"svg:tspan\"); this.current.xcoords = []; this.current.ycoords = []; } setStrokeColorN(args) { this.current.strokeColor = this._makeColorN_Pattern(args); } setFillColorN(args) { this.current.fillColor = this._makeColorN_Pattern(args); } shadingFill(args) { const width = this.viewport.width; const height = this.viewport.height; const inv = _util.Util.inverseTransform(this.transformMatrix); const bl = _util.Util.applyTransform([0, 0], inv); const br = _util.Util.applyTransform([0, height], inv); const ul = _util.Util.applyTransform([width, 0], inv); const ur = _util.Util.applyTransform([width, height], inv); const x0 = Math.min(bl[0], br[0], ul[0], ur[0]); const y0 = Math.min(bl[1], br[1], ul[1], ur[1]); const x1 = Math.max(bl[0], br[0], ul[0], ur[0]); const y1 = Math.max(bl[1], br[1], ul[1], ur[1]); const rect = this.svgFactory.createElement(\"svg:rect\"); rect.setAttributeNS(null, \"x\", x0); rect.setAttributeNS(null, \"y\", y0); rect.setAttributeNS(null, \"width\", x1 - x0); rect.setAttributeNS(null, \"height\", y1 - y0); rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args)); if (this.current.fillAlpha < 1) { rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha); } this._ensureTransformGroup().append(rect); } _makeColorN_Pattern(args) { if (args[0] === \"TilingPattern\") { return this._makeTilingPattern(args); } return this._makeShadingPattern(args); } _makeTilingPattern(args) { const color = args[1]; const operatorList = args[2]; const matrix = args[3] || _util.IDENTITY_MATRIX; const [x0, y0, x1, y1] = args[4]; const xstep = args[5]; const ystep = args[6]; const paintType = args[7]; const tilingId = `shading${shadingCount++}`; const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([..._util.Util.applyTransform([x0, y0], matrix), ..._util.Util.applyTransform([x1, y1], matrix)]); const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix); const txstep = xstep * xscale; const tystep = ystep * yscale; const tiling = this.svgFactory.createElement(\"svg:pattern\"); tiling.setAttributeNS(null, \"id\", tilingId); tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\"); tiling.setAttributeNS(null, \"width\", txstep); tiling.setAttributeNS(null, \"height\", tystep); tiling.setAttributeNS(null, \"x\", `${tx0}`); tiling.setAttributeNS(null, \"y\", `${ty0}`); const svg = this.svg; const transformMatrix = this.transformMatrix; const fillColor = this.current.fillColor; const strokeColor = this.current.strokeColor; const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0); this.svg = bbox; this.transformMatrix = matrix; if (paintType === 2) { const cssColor = _util.Util.makeHexColor(...color); this.current.fillColor = cssColor; this.current.strokeColor = cssColor; } this.executeOpTree(this.convertOpList(operatorList)); this.svg = svg; this.transformMatrix = transformMatrix; this.current.fillColor = fillColor; this.current.strokeColor = strokeColor; tiling.append(bbox.childNodes[0]); this.defs.append(tiling); return `url(#${tilingId})`; } _makeShadingPattern(args) { if (typeof args === \"string\") { args = this.objs.get(args); } switch (args[0]) { case \"RadialAxial\": const shadingId = `shading${shadingCount++}`; const colorStops = args[3]; let gradient; switch (args[1]) { case \"axial\": const point0 = args[4]; const point1 = args[5]; gradient = this.svgFactory.createElement(\"svg:linearGradient\"); gradient.setAttributeNS(null, \"id\", shadingId); gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\"); gradient.setAttributeNS(null, \"x1\", point0[0]); gradient.setAttributeNS(null, \"y1\", point0[1]); gradient.setAttributeNS(null, \"x2\", point1[0]); gradient.setAttributeNS(null, \"y2\", point1[1]); break; case \"radial\": const focalPoint = args[4]; const circlePoint = args[5]; const focalRadius = args[6]; const circleRadius = args[7]; gradient = this.svgFactory.createElement(\"svg:radialGradient\"); gradient.setAttributeNS(null, \"id\", shadingId); gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\"); gradient.setAttributeNS(null, \"cx\", circlePoint[0]); gradient.setAttributeNS(null, \"cy\", circlePoint[1]); gradient.setAttributeNS(null, \"r\", circleRadius); gradient.setAttributeNS(null, \"fx\", focalPoint[0]); gradient.setAttributeNS(null, \"fy\", focalPoint[1]); gradient.setAttributeNS(null, \"fr\", focalRadius); break; default: throw new Error(`Unknown RadialAxial type: ${args[1]}`); } for (const colorStop of colorStops) { const stop = this.svgFactory.createElement(\"svg:stop\"); stop.setAttributeNS(null, \"offset\", colorStop[0]); stop.setAttributeNS(null, \"stop-color\", colorStop[1]); gradient.append(stop); } this.defs.append(gradient); return `url(#${shadingId})`; case \"Mesh\": (0, _util.warn)(\"Unimplemented pattern Mesh\"); return null; case \"Dummy\": return \"hotpink\"; default: throw new Error(`Unknown IR type: ${args[0]}`); } } setDash(dashArray, dashPhase) { this.current.dashArray = dashArray; this.current.dashPhase = dashPhase; } constructPath(ops, args) { const current = this.current; let x = current.x, y = current.y; let d = []; let j = 0; for (const op of ops) { switch (op | 0) { case _util.OPS.rectangle: x = args[j++]; y = args[j++]; const width = args[j++]; const height = args[j++]; const xw = x + width; const yh = y + height; d.push(\"M\", pf(x), pf(y), \"L\", pf(xw), pf(y), \"L\", pf(xw), pf(yh), \"L\", pf(x), pf(yh), \"Z\"); break; case _util.OPS.moveTo: x = args[j++]; y = args[j++]; d.push(\"M\", pf(x), pf(y)); break; case _util.OPS.lineTo: x = args[j++]; y = args[j++]; d.push(\"L\", pf(x), pf(y)); break; case _util.OPS.curveTo: x = args[j + 4]; y = args[j + 5]; d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y)); j += 6; break; case _util.OPS.curveTo2: d.push(\"C\", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3])); x = args[j + 2]; y = args[j + 3]; j += 4; break; case _util.OPS.curveTo3: x = args[j + 2]; y = args[j + 3]; d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y)); j += 4; break; case _util.OPS.closePath: d.push(\"Z\"); break; } } d = d.join(\" \"); if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) { d = current.path.getAttributeNS(null, \"d\") + d; } else { current.path = this.svgFactory.createElement(\"svg:path\"); this._ensureTransformGroup().append(current.path); } current.path.setAttributeNS(null, \"d\", d); current.path.setAttributeNS(null, \"fill\", \"none\"); current.element = current.path; current.setCurrentPoint(x, y); } endPath() { const current = this.current; current.path = null; if (!this.pendingClip) { return; } if (!current.element) { this.pendingClip = null; return; } const clipId = `clippath${clipCount++}`; const clipPath = this.svgFactory.createElement(\"svg:clipPath\"); clipPath.setAttributeNS(null, \"id\", clipId); clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix)); const clipElement = current.element.cloneNode(true); if (this.pendingClip === \"evenodd\") { clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\"); } else { clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\"); } this.pendingClip = null; clipPath.append(clipElement); this.defs.append(clipPath); if (current.activeClipUrl) { current.clipGroup = null; for (const prev of this.extraStack) { prev.clipGroup = null; } clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl); } current.activeClipUrl = `url(#${clipId})`; this.tgrp = null; } clip(type) { this.pendingClip = type; } closePath() { const current = this.current; if (current.path) { const d = `${current.path.getAttributeNS(null, \"d\")}Z`; current.path.setAttributeNS(null, \"d\", d); } } setLeading(leading) { this.current.leading = -leading; } setTextRise(textRise) { this.current.textRise = textRise; } setTextRenderingMode(textRenderingMode) { this.current.textRenderingMode = textRenderingMode; } setHScale(scale) { this.current.textHScale = scale / 100; } setRenderingIntent(intent) {} setFlatness(flatness) {} setGState(states) { for (const [key, value] of states) { switch (key) { case \"LW\": this.setLineWidth(value); break; case \"LC\": this.setLineCap(value); break; case \"LJ\": this.setLineJoin(value); break; case \"ML\": this.setMiterLimit(value); break; case \"D\": this.setDash(value[0], value[1]); break; case \"RI\": this.setRenderingIntent(value); break; case \"FL\": this.setFlatness(value); break; case \"Font\": this.setFont(value); break; case \"CA\": this.setStrokeAlpha(value); break; case \"ca\": this.setFillAlpha(value); break; default: (0, _util.warn)(`Unimplemented graphic state operator ${key}`); break; } } } fill() { const current = this.current; if (current.element) { current.element.setAttributeNS(null, \"fill\", current.fillColor); current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha); this.endPath(); } } stroke() { const current = this.current; if (current.element) { this._setStrokeAttributes(current.element); current.element.setAttributeNS(null, \"fill\", \"none\"); this.endPath(); } } _setStrokeAttributes(element, lineWidthScale = 1) { const current = this.current; let dashArray = current.dashArray; if (lineWidthScale !== 1 && dashArray.length > 0) { dashArray = dashArray.map(function (value) { return lineWidthScale * value; }); } element.setAttributeNS(null, \"stroke\", current.strokeColor); element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha); element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit)); element.setAttributeNS(null, \"stroke-linecap\", current.lineCap); element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin); element.setAttributeNS(null, \"stroke-width\", pf(lineWidthScale * current.lineWidth) + \"px\"); element.setAttributeNS(null, \"stroke-dasharray\", dashArray.map(pf).join(\" \")); element.setAttributeNS(null, \"stroke-dashoffset\", pf(lineWidthScale * current.dashPhase) + \"px\"); } eoFill() { this.current.element?.setAttributeNS(null, \"fill-rule\", \"evenodd\"); this.fill(); } fillStroke() { this.stroke(); this.fill(); } eoFillStroke() { this.current.element?.setAttributeNS(null, \"fill-rule\", \"evenodd\"); this.fillStroke(); } closeStroke() { this.closePath(); this.stroke(); } closeFillStroke() { this.closePath(); this.fillStroke(); } closeEOFillStroke() { this.closePath(); this.eoFillStroke(); } paintSolidColorImageMask() { const rect = this.svgFactory.createElement(\"svg:rect\"); rect.setAttributeNS(null, \"x\", \"0\"); rect.setAttributeNS(null, \"y\", \"0\"); rect.setAttributeNS(null, \"width\", \"1px\"); rect.setAttributeNS(null, \"height\", \"1px\"); rect.setAttributeNS(null, \"fill\", this.current.fillColor); this._ensureTransformGroup().append(rect); } paintImageXObject(objId) { const imgData = this.getObject(objId); if (!imgData) { (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`); return; } this.paintInlineImageXObject(imgData); } paintInlineImageXObject(imgData, mask) { const width = imgData.width; const height = imgData.height; const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask); const cliprect = this.svgFactory.createElement(\"svg:rect\"); cliprect.setAttributeNS(null, \"x\", \"0\"); cliprect.setAttributeNS(null, \"y\", \"0\"); cliprect.setAttributeNS(null, \"width\", pf(width)); cliprect.setAttributeNS(null, \"height\", pf(height)); this.current.element = cliprect; this.clip(\"nonzero\"); const imgEl = this.svgFactory.createElement(\"svg:image\"); imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc); imgEl.setAttributeNS(null, \"x\", \"0\"); imgEl.setAttributeNS(null, \"y\", pf(-height)); imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\"); imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\"); imgEl.setAttributeNS(null, \"transform\", `scale(${pf(1 / width)} ${pf(-1 / height)})`); if (mask) { mask.append(imgEl); } else { this._ensureTransformGroup().append(imgEl); } } paintImageMaskXObject(img) { const imgData = this.getObject(img.data, img); if (imgData.bitmap) { (0, _util.warn)(\"paintImageMaskXObject: ImageBitmap support is not implemented, \" + \"ensure that the `isOffscreenCanvasSupported` API parameter is disabled.\"); return; } const current = this.current; const width = imgData.width; const height = imgData.height; const fillColor = current.fillColor; current.maskId = `mask${maskCount++}`; const mask = this.svgFactory.createElement(\"svg:mask\"); mask.setAttributeNS(null, \"id\", current.maskId); const rect = this.svgFactory.createElement(\"svg:rect\"); rect.setAttributeNS(null, \"x\", \"0\"); rect.setAttributeNS(null, \"y\", \"0\"); rect.setAttributeNS(null, \"width\", pf(width)); rect.setAttributeNS(null, \"height\", pf(height)); rect.setAttributeNS(null, \"fill\", fillColor); rect.setAttributeNS(null, \"mask\", `url(#${current.maskId})`); this.defs.append(mask); this._ensureTransformGroup().append(rect); this.paintInlineImageXObject(imgData, mask); } paintFormXObjectBegin(matrix, bbox) { if (Array.isArray(matrix) && matrix.length === 6) { this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]); } if (bbox) { const width = bbox[2] - bbox[0]; const height = bbox[3] - bbox[1]; const cliprect = this.svgFactory.createElement(\"svg:rect\"); cliprect.setAttributeNS(null, \"x\", bbox[0]); cliprect.setAttributeNS(null, \"y\", bbox[1]); cliprect.setAttributeNS(null, \"width\", pf(width)); cliprect.setAttributeNS(null, \"height\", pf(height)); this.current.element = cliprect; this.clip(\"nonzero\"); this.endPath(); } } paintFormXObjectEnd() {} _initialize(viewport) { const svg = this.svgFactory.create(viewport.width, viewport.height); const definitions = this.svgFactory.createElement(\"svg:defs\"); svg.append(definitions); this.defs = definitions; const rootGroup = this.svgFactory.createElement(\"svg:g\"); rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform)); svg.append(rootGroup); this.svg = rootGroup; return svg; } _ensureClipGroup() { if (!this.current.clipGroup) { const clipGroup = this.svgFactory.createElement(\"svg:g\"); clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl); this.svg.append(clipGroup); this.current.clipGroup = clipGroup; } return this.current.clipGroup; } _ensureTransformGroup() { if (!this.tgrp) { this.tgrp = this.svgFactory.createElement(\"svg:g\"); this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix)); if (this.current.activeClipUrl) { this._ensureClipGroup().append(this.tgrp); } else { this.svg.append(this.tgrp); } } return this.tgrp; } }; } /***/ }), /* 31 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFNodeStream = void 0; var _util = __w_pdfjs_require__(1); var _network_utils = __w_pdfjs_require__(32); ; const fs = require(\"fs\"); const http = require(\"http\"); const https = require(\"https\"); const url = require(\"url\"); const fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//; function parseUrl(sourceUrl) { const parsedUrl = url.parse(sourceUrl); if (parsedUrl.protocol === \"file:\" || parsedUrl.host) { return parsedUrl; } if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) { return url.parse(`file:///${sourceUrl}`); } if (!parsedUrl.host) { parsedUrl.protocol = \"file:\"; } return parsedUrl; } class PDFNodeStream { constructor(source) { this.source = source; this.url = parseUrl(source.url); this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\"; this.isFsUrl = this.url.protocol === \"file:\"; this.httpHeaders = this.isHttp && source.httpHeaders || {}; this._fullRequestReader = null; this._rangeRequestReaders = []; } get _progressiveDataLength() { return this._fullRequestReader?._loaded ?? 0; } getFullReader() { (0, _util.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\"); this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this); return this._fullRequestReader; } getRangeReader(start, end) { if (end { this._readCapability.resolve(); }); readableStream.on(\"end\", () => { readableStream.destroy(); this._done = true; this._readCapability.resolve(); }); readableStream.on(\"error\", reason => { this._error(reason); }); if (this._storedError) { this._readableStream.destroy(this._storedError); } } } function createRequestOptions(parsedUrl, headers) { return { protocol: parsedUrl.protocol, auth: parsedUrl.auth, host: parsedUrl.hostname, port: parsedUrl.port, path: parsedUrl.path, method: \"GET\", headers }; } class PDFNodeStreamFullReader extends BaseFullReader { constructor(stream) { super(stream); const handleResponse = response => { if (response.statusCode === 404) { const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`); this._storedError = error; this._headersCapability.reject(error); return; } this._headersCapability.resolve(); this._setReadableStream(response); const getResponseHeader = name => { return this._readableStream.headers[name.toLowerCase()]; }; const { allowRangeRequests, suggestedLength } = (0, _network_utils.validateRangeRequestCapabilities)({ getResponseHeader, isHttp: stream.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }); this._isRangeSupported = allowRangeRequests; this._contentLength = suggestedLength || this._contentLength; this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader); }; this._request = null; if (this._url.protocol === \"http:\") { this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse); } else { this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse); } this._request.on(\"error\", reason => { this._storedError = reason; this._headersCapability.reject(reason); }); this._request.end(); } } class PDFNodeStreamRangeReader extends BaseRangeReader { constructor(stream, start, end) { super(stream); this._httpHeaders = {}; for (const property in stream.httpHeaders) { const value = stream.httpHeaders[property]; if (value === undefined) { continue; } this._httpHeaders[property] = value; } this._httpHeaders.Range = `bytes=${start}-${end - 1}`; const handleResponse = response => { if (response.statusCode === 404) { const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`); this._storedError = error; return; } this._setReadableStream(response); }; this._request = null; if (this._url.protocol === \"http:\") { this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse); } else { this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse); } this._request.on(\"error\", reason => { this._storedError = reason; }); this._request.end(); } } class PDFNodeStreamFsFullReader extends BaseFullReader { constructor(stream) { super(stream); let path = decodeURIComponent(this._url.path); if (fileUriRegex.test(this._url.href)) { path = path.replace(/^\\//, \"\"); } fs.lstat(path, (error, stat) => { if (error) { if (error.code === \"ENOENT\") { error = new _util.MissingPDFException(`Missing PDF \"${path}\".`); } this._storedError = error; this._headersCapability.reject(error); return; } this._contentLength = stat.size; this._setReadableStream(fs.createReadStream(path)); this._headersCapability.resolve(); }); } } class PDFNodeStreamFsRangeReader extends BaseRangeReader { constructor(stream, start, end) { super(stream); let path = decodeURIComponent(this._url.path); if (fileUriRegex.test(this._url.href)) { path = path.replace(/^\\//, \"\"); } this._setReadableStream(fs.createReadStream(path, { start, end: end - 1 })); } } /***/ }), /* 32 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.createResponseStatusError = createResponseStatusError; exports.extractFilenameFromHeader = extractFilenameFromHeader; exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities; exports.validateResponseStatus = validateResponseStatus; var _util = __w_pdfjs_require__(1); var _content_disposition = __w_pdfjs_require__(33); var _display_utils = __w_pdfjs_require__(6); function validateRangeRequestCapabilities({ getResponseHeader, isHttp, rangeChunkSize, disableRange }) { const returnValues = { allowRangeRequests: false, suggestedLength: undefined }; const length = parseInt(getResponseHeader(\"Content-Length\"), 10); if (!Number.isInteger(length)) { return returnValues; } returnValues.suggestedLength = length; if (length { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader; var _util = __w_pdfjs_require__(1); function getFilenameFromContentDispositionHeader(contentDisposition) { let needsEncodingFixup = true; let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition); if (tmp) { tmp = tmp[1]; let filename = rfc2616unquote(tmp); filename = unescape(filename); filename = rfc5987decode(filename); filename = rfc2047decode(filename); return fixupEncoding(filename); } tmp = rfc2231getparam(contentDisposition); if (tmp) { const filename = rfc2047decode(tmp); return fixupEncoding(filename); } tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition); if (tmp) { tmp = tmp[1]; let filename = rfc2616unquote(tmp); filename = rfc2047decode(filename); return fixupEncoding(filename); } function toParamRegExp(attributePattern, flags) { return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags); } function textdecode(encoding, value) { if (encoding) { if (!/^[\\x00-\\xFF]+$/.test(value)) { return value; } try { const decoder = new TextDecoder(encoding, { fatal: true }); const buffer = (0, _util.stringToBytes)(value); value = decoder.decode(buffer); needsEncodingFixup = false; } catch (e) {} } return value; } function fixupEncoding(value) { if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) { value = textdecode(\"utf-8\", value); if (needsEncodingFixup) { value = textdecode(\"iso-8859-1\", value); } } return value; } function rfc2231getparam(contentDispositionStr) { const matches = []; let match; const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\"); while ((match = iter.exec(contentDispositionStr)) !== null) { let [, n, quot, part] = match; n = parseInt(n, 10); if (n in matches) { if (n === 0) { break; } continue; } matches[n] = [quot, part]; } const parts = []; for (let n = 0; n < matches.length; ++n) { if (!(n in matches)) { break; } let [quot, part] = matches[n]; part = rfc2616unquote(part); if (quot) { part = unescape(part); if (n === 0) { part = rfc5987decode(part); } } parts.push(part); } return parts.join(\"\"); } function rfc2616unquote(value) { if (value.startsWith('\"')) { const parts = value.slice(1).split('\\\\\"'); for (let i = 0; i < parts.length; ++i) { const quotindex = parts[i].indexOf('\"'); if (quotindex !== -1) { parts[i] = parts[i].slice(0, quotindex); parts.length = i + 1; } parts[i] = parts[i].replace(/\\\\(.)/g, \"$1\"); } value = parts.join('\"'); } return value; } function rfc5987decode(extvalue) { const encodingend = extvalue.indexOf(\"'\"); if (encodingend === -1) { return extvalue; } const encoding = extvalue.slice(0, encodingend); const langvalue = extvalue.slice(encodingend + 1); const value = langvalue.replace(/^[^']*'/, \"\"); return textdecode(encoding, value); } function rfc2047decode(value) { if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) { return value; } return value.replace(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) { if (encoding === \"q\" || encoding === \"Q\") { text = text.replace(/_/g, \" \"); text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) { return String.fromCharCode(parseInt(hex, 16)); }); return textdecode(charset, text); } try { text = atob(text); } catch (e) {} return textdecode(charset, text); }); } return \"\"; } /***/ }), /* 34 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFNetworkStream = void 0; var _util = __w_pdfjs_require__(1); var _network_utils = __w_pdfjs_require__(32); ; const OK_RESPONSE = 200; const PARTIAL_CONTENT_RESPONSE = 206; function getArrayBuffer(xhr) { const data = xhr.response; if (typeof data !== \"string\") { return data; } const array = (0, _util.stringToBytes)(data); return array.buffer; } class NetworkManager { constructor(url, args = {}) { this.url = url; this.isHttp = /^https?:/i.test(url); this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null); this.withCredentials = args.withCredentials || false; this.getXhr = args.getXhr || function NetworkManager_getXhr() { return new XMLHttpRequest(); }; this.currXhrId = 0; this.pendingRequests = Object.create(null); } requestRange(begin, end, listeners) { const args = { begin, end }; for (const prop in listeners) { args[prop] = listeners[prop]; } return this.request(args); } requestFull(listeners) { return this.request(listeners); } request(args) { const xhr = this.getXhr(); const xhrId = this.currXhrId++; const pendingRequest = this.pendingRequests[xhrId] = { xhr }; xhr.open(\"GET\", this.url); xhr.withCredentials = this.withCredentials; for (const property in this.httpHeaders) { const value = this.httpHeaders[property]; if (value === undefined) { continue; } xhr.setRequestHeader(property, value); } if (this.isHttp && \"begin\" in args && \"end\" in args) { xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`); pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE; } else { pendingRequest.expectedStatus = OK_RESPONSE; } xhr.responseType = \"arraybuffer\"; if (args.onError) { xhr.onerror = function (evt) { args.onError(xhr.status); }; } xhr.onreadystatechange = this.onStateChange.bind(this, xhrId); xhr.onprogress = this.onProgress.bind(this, xhrId); pendingRequest.onHeadersReceived = args.onHeadersReceived; pendingRequest.onDone = args.onDone; pendingRequest.onError = args.onError; pendingRequest.onProgress = args.onProgress; xhr.send(null); return xhrId; } onProgress(xhrId, evt) { const pendingRequest = this.pendingRequests[xhrId]; if (!pendingRequest) { return; } pendingRequest.onProgress?.(evt); } onStateChange(xhrId, evt) { const pendingRequest = this.pendingRequests[xhrId]; if (!pendingRequest) { return; } const xhr = pendingRequest.xhr; if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) { pendingRequest.onHeadersReceived(); delete pendingRequest.onHeadersReceived; } if (xhr.readyState !== 4) { return; } if (!(xhrId in this.pendingRequests)) { return; } delete this.pendingRequests[xhrId]; if (xhr.status === 0 && this.isHttp) { pendingRequest.onError?.(xhr.status); return; } const xhrStatus = xhr.status || OK_RESPONSE; const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE; if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) { pendingRequest.onError?.(xhr.status); return; } const chunk = getArrayBuffer(xhr); if (xhrStatus === PARTIAL_CONTENT_RESPONSE) { const rangeHeader = xhr.getResponseHeader(\"Content-Range\"); const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader); pendingRequest.onDone({ begin: parseInt(matches[1], 10), chunk }); } else if (chunk) { pendingRequest.onDone({ begin: 0, chunk }); } else { pendingRequest.onError?.(xhr.status); } } getRequestXhr(xhrId) { return this.pendingRequests[xhrId].xhr; } isPendingRequest(xhrId) { return xhrId in this.pendingRequests; } abortRequest(xhrId) { const xhr = this.pendingRequests[xhrId].xhr; delete this.pendingRequests[xhrId]; xhr.abort(); } } class PDFNetworkStream { constructor(source) { this._source = source; this._manager = new NetworkManager(source.url, { httpHeaders: source.httpHeaders, withCredentials: source.withCredentials }); this._rangeChunkSize = source.rangeChunkSize; this._fullRequestReader = null; this._rangeRequestReaders = []; } _onRangeRequestReaderClosed(reader) { const i = this._rangeRequestReaders.indexOf(reader); if (i >= 0) { this._rangeRequestReaders.splice(i, 1); } } getFullReader() { (0, _util.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\"); this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source); return this._fullRequestReader; } getRangeReader(begin, end) { const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end); reader.onClosed = this._onRangeRequestReaderClosed.bind(this); this._rangeRequestReaders.push(reader); return reader; } cancelAllRequests(reason) { this._fullRequestReader?.cancel(reason); for (const reader of this._rangeRequestReaders.slice(0)) { reader.cancel(reason); } } } exports.PDFNetworkStream = PDFNetworkStream; class PDFNetworkStreamFullRequestReader { constructor(manager, source) { this._manager = manager; const args = { onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }; this._url = source.url; this._fullRequestId = manager.requestFull(args); this._headersReceivedCapability = (0, _util.createPromiseCapability)(); this._disableRange = source.disableRange || false; this._contentLength = source.length; this._rangeChunkSize = source.rangeChunkSize; if (!this._rangeChunkSize && !this._disableRange) { this._disableRange = true; } this._isStreamingSupported = false; this._isRangeSupported = false; this._cachedChunks = []; this._requests = []; this._done = false; this._storedError = undefined; this._filename = null; this.onProgress = null; } _onHeadersReceived() { const fullRequestXhrId = this._fullRequestId; const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId); const getResponseHeader = name => { return fullRequestXhr.getResponseHeader(name); }; const { allowRangeRequests, suggestedLength } = (0, _network_utils.validateRangeRequestCapabilities)({ getResponseHeader, isHttp: this._manager.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }); if (allowRangeRequests) { this._isRangeSupported = true; } this._contentLength = suggestedLength || this._contentLength; this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader); if (this._isRangeSupported) { this._manager.abortRequest(fullRequestXhrId); } this._headersReceivedCapability.resolve(); } _onDone(data) { if (data) { if (this._requests.length > 0) { const requestCapability = this._requests.shift(); requestCapability.resolve({ value: data.chunk, done: false }); } else { this._cachedChunks.push(data.chunk); } } this._done = true; if (this._cachedChunks.length > 0) { return; } for (const requestCapability of this._requests) { requestCapability.resolve({ value: undefined, done: true }); } this._requests.length = 0; } _onError(status) { this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url); this._headersReceivedCapability.reject(this._storedError); for (const requestCapability of this._requests) { requestCapability.reject(this._storedError); } this._requests.length = 0; this._cachedChunks.length = 0; } _onProgress(evt) { this.onProgress?.({ loaded: evt.loaded, total: evt.lengthComputable ? evt.total : this._contentLength }); } get filename() { return this._filename; } get isRangeSupported() { return this._isRangeSupported; } get isStreamingSupported() { return this._isStreamingSupported; } get contentLength() { return this._contentLength; } get headersReady() { return this._headersReceivedCapability.promise; } async read() { if (this._storedError) { throw this._storedError; } if (this._cachedChunks.length > 0) { const chunk = this._cachedChunks.shift(); return { value: chunk, done: false }; } if (this._done) { return { value: undefined, done: true }; } const requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return requestCapability.promise; } cancel(reason) { this._done = true; this._headersReceivedCapability.reject(reason); for (const requestCapability of this._requests) { requestCapability.resolve({ value: undefined, done: true }); } this._requests.length = 0; if (this._manager.isPendingRequest(this._fullRequestId)) { this._manager.abortRequest(this._fullRequestId); } this._fullRequestReader = null; } } class PDFNetworkStreamRangeRequestReader { constructor(manager, begin, end) { this._manager = manager; const args = { onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }; this._url = manager.url; this._requestId = manager.requestRange(begin, end, args); this._requests = []; this._queuedChunk = null; this._done = false; this._storedError = undefined; this.onProgress = null; this.onClosed = null; } _close() { this.onClosed?.(this); } _onDone(data) { const chunk = data.chunk; if (this._requests.length > 0) { const requestCapability = this._requests.shift(); requestCapability.resolve({ value: chunk, done: false }); } else { this._queuedChunk = chunk; } this._done = true; for (const requestCapability of this._requests) { requestCapability.resolve({ value: undefined, done: true }); } this._requests.length = 0; this._close(); } _onError(status) { this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url); for (const requestCapability of this._requests) { requestCapability.reject(this._storedError); } this._requests.length = 0; this._queuedChunk = null; } _onProgress(evt) { if (!this.isStreamingSupported) { this.onProgress?.({ loaded: evt.loaded }); } } get isStreamingSupported() { return false; } async read() { if (this._storedError) { throw this._storedError; } if (this._queuedChunk !== null) { const chunk = this._queuedChunk; this._queuedChunk = null; return { value: chunk, done: false }; } if (this._done) { return { value: undefined, done: true }; } const requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return requestCapability.promise; } cancel(reason) { this._done = true; for (const requestCapability of this._requests) { requestCapability.resolve({ value: undefined, done: true }); } this._requests.length = 0; if (this._manager.isPendingRequest(this._requestId)) { this._manager.abortRequest(this._requestId); } this._close(); } } /***/ }), /* 35 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFFetchStream = void 0; var _util = __w_pdfjs_require__(1); var _network_utils = __w_pdfjs_require__(32); ; function createFetchOptions(headers, withCredentials, abortController) { return { method: \"GET\", headers, signal: abortController.signal, mode: \"cors\", credentials: withCredentials ? \"include\" : \"same-origin\", redirect: \"follow\" }; } function createHeaders(httpHeaders) { const headers = new Headers(); for (const property in httpHeaders) { const value = httpHeaders[property]; if (value === undefined) { continue; } headers.append(property, value); } return headers; } class PDFFetchStream { constructor(source) { this.source = source; this.isHttp = /^https?:/i.test(source.url); this.httpHeaders = this.isHttp && source.httpHeaders || {}; this._fullRequestReader = null; this._rangeRequestReaders = []; } get _progressiveDataLength() { return this._fullRequestReader?._loaded ?? 0; } getFullReader() { (0, _util.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\"); this._fullRequestReader = new PDFFetchStreamReader(this); return this._fullRequestReader; } getRangeReader(begin, end) { if (end { if (!(0, _network_utils.validateResponseStatus)(response.status)) { throw (0, _network_utils.createResponseStatusError)(response.status, url); } this._reader = response.body.getReader(); this._headersCapability.resolve(); const getResponseHeader = name => { return response.headers.get(name); }; const { allowRangeRequests, suggestedLength } = (0, _network_utils.validateRangeRequestCapabilities)({ getResponseHeader, isHttp: this._stream.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }); this._isRangeSupported = allowRangeRequests; this._contentLength = suggestedLength || this._contentLength; this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader); if (!this._isStreamingSupported && this._isRangeSupported) { this.cancel(new _util.AbortException(\"Streaming is disabled.\")); } }).catch(this._headersCapability.reject); this.onProgress = null; } get headersReady() { return this._headersCapability.promise; } get filename() { return this._filename; } get contentLength() { return this._contentLength; } get isRangeSupported() { return this._isRangeSupported; } get isStreamingSupported() { return this._isStreamingSupported; } async read() { await this._headersCapability.promise; const { value, done } = await this._reader.read(); if (done) { return { value, done }; } this._loaded += value.byteLength; this.onProgress?.({ loaded: this._loaded, total: this._contentLength }); const buffer = new Uint8Array(value).buffer; return { value: buffer, done: false }; } cancel(reason) { this._reader?.cancel(reason); this._abortController.abort(); } } class PDFFetchStreamRangeReader { constructor(stream, begin, end) { this._stream = stream; this._reader = null; this._loaded = 0; const source = stream.source; this._withCredentials = source.withCredentials || false; this._readCapability = (0, _util.createPromiseCapability)(); this._isStreamingSupported = !source.disableStream; this._abortController = new AbortController(); this._headers = createHeaders(this._stream.httpHeaders); this._headers.append(\"Range\", `bytes=${begin}-${end - 1}`); const url = source.url; fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => { if (!(0, _network_utils.validateResponseStatus)(response.status)) { throw (0, _network_utils.createResponseStatusError)(response.status, url); } this._readCapability.resolve(); this._reader = response.body.getReader(); }).catch(this._readCapability.reject); this.onProgress = null; } get isStreamingSupported() { return this._isStreamingSupported; } async read() { await this._readCapability.promise; const { value, done } = await this._reader.read(); if (done) { return { value, done }; } this._loaded += value.byteLength; this.onProgress?.({ loaded: this._loaded }); const buffer = new Uint8Array(value).buffer; return { value: buffer, done: false }; } cancel(reason) { this._reader?.cancel(reason); this._abortController.abort(); } } /***/ }) /******/ ]); /************************************************************************/ /******/ // The module cache /******/ var __webpack_module_cache__ = {}; /******/ /******/ // The require function /******/ function __w_pdfjs_require__(moduleId) { /******/ // Check if module is in cache /******/ var cachedModule = __webpack_module_cache__[moduleId]; /******/ if (cachedModule !== undefined) { /******/ return cachedModule.exports; /******/ } /******/ // Create a new module (and put it into the cache) /******/ var module = __webpack_module_cache__[moduleId] = { /******/ // no module.id needed /******/ // no module.loaded needed /******/ exports: {} /******/ }; /******/ /******/ // Execute the module function /******/ __webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__); /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /************************************************************************/ var __webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk. (() => { var exports = __webpack_exports__; Object.defineProperty(exports, \"__esModule\", ({ value: true })); Object.defineProperty(exports, \"AbortException\", ({ enumerable: true, get: function () { return _util.AbortException; } })); Object.defineProperty(exports, \"AnnotationEditorLayer\", ({ enumerable: true, get: function () { return _annotation_editor_layer.AnnotationEditorLayer; } })); Object.defineProperty(exports, \"AnnotationEditorParamsType\", ({ enumerable: true, get: function () { return _util.AnnotationEditorParamsType; } })); Object.defineProperty(exports, \"AnnotationEditorType\", ({ enumerable: true, get: function () { return _util.AnnotationEditorType; } })); Object.defineProperty(exports, \"AnnotationEditorUIManager\", ({ enumerable: true, get: function () { return _tools.AnnotationEditorUIManager; } })); Object.defineProperty(exports, \"AnnotationLayer\", ({ enumerable: true, get: function () { return _annotation_layer.AnnotationLayer; } })); Object.defineProperty(exports, \"AnnotationMode\", ({ enumerable: true, get: function () { return _util.AnnotationMode; } })); Object.defineProperty(exports, \"CMapCompressionType\", ({ enumerable: true, get: function () { return _util.CMapCompressionType; } })); Object.defineProperty(exports, \"GlobalWorkerOptions\", ({ enumerable: true, get: function () { return _worker_options.GlobalWorkerOptions; } })); Object.defineProperty(exports, \"InvalidPDFException\", ({ enumerable: true, get: function () { return _util.InvalidPDFException; } })); Object.defineProperty(exports, \"MissingPDFException\", ({ enumerable: true, get: function () { return _util.MissingPDFException; } })); Object.defineProperty(exports, \"OPS\", ({ enumerable: true, get: function () { return _util.OPS; } })); Object.defineProperty(exports, \"PDFDataRangeTransport\", ({ enumerable: true, get: function () { return _api.PDFDataRangeTransport; } })); Object.defineProperty(exports, \"PDFDateString\", ({ enumerable: true, get: function () { return _display_utils.PDFDateString; } })); Object.defineProperty(exports, \"PDFWorker\", ({ enumerable: true, get: function () { return _api.PDFWorker; } })); Object.defineProperty(exports, \"PasswordResponses\", ({ enumerable: true, get: function () { return _util.PasswordResponses; } })); Object.defineProperty(exports, \"PermissionFlag\", ({ enumerable: true, get: function () { return _util.PermissionFlag; } })); Object.defineProperty(exports, \"PixelsPerInch\", ({ enumerable: true, get: function () { return _display_utils.PixelsPerInch; } })); Object.defineProperty(exports, \"RenderingCancelledException\", ({ enumerable: true, get: function () { return _display_utils.RenderingCancelledException; } })); Object.defineProperty(exports, \"SVGGraphics\", ({ enumerable: true, get: function () { return _svg.SVGGraphics; } })); Object.defineProperty(exports, \"UNSUPPORTED_FEATURES\", ({ enumerable: true, get: function () { return _util.UNSUPPORTED_FEATURES; } })); Object.defineProperty(exports, \"UnexpectedResponseException\", ({ enumerable: true, get: function () { return _util.UnexpectedResponseException; } })); Object.defineProperty(exports, \"Util\", ({ enumerable: true, get: function () { return _util.Util; } })); Object.defineProperty(exports, \"VerbosityLevel\", ({ enumerable: true, get: function () { return _util.VerbosityLevel; } })); Object.defineProperty(exports, \"XfaLayer\", ({ enumerable: true, get: function () { return _xfa_layer.XfaLayer; } })); Object.defineProperty(exports, \"build\", ({ enumerable: true, get: function () { return _api.build; } })); Object.defineProperty(exports, \"createPromiseCapability\", ({ enumerable: true, get: function () { return _util.createPromiseCapability; } })); Object.defineProperty(exports, \"createValidAbsoluteUrl\", ({ enumerable: true, get: function () { return _util.createValidAbsoluteUrl; } })); Object.defineProperty(exports, \"getDocument\", ({ enumerable: true, get: function () { return _api.getDocument; } })); Object.defineProperty(exports, \"getFilenameFromUrl\", ({ enumerable: true, get: function () { return _display_utils.getFilenameFromUrl; } })); Object.defineProperty(exports, \"getPdfFilenameFromUrl\", ({ enumerable: true, get: function () { return _display_utils.getPdfFilenameFromUrl; } })); Object.defineProperty(exports, \"getXfaPageViewport\", ({ enumerable: true, get: function () { return _display_utils.getXfaPageViewport; } })); Object.defineProperty(exports, \"isDataScheme\", ({ enumerable: true, get: function () { return _display_utils.isDataScheme; } })); Object.defineProperty(exports, \"isPdfFile\", ({ enumerable: true, get: function () { return _display_utils.isPdfFile; } })); Object.defineProperty(exports, \"loadScript\", ({ enumerable: true, get: function () { return _display_utils.loadScript; } })); Object.defineProperty(exports, \"renderTextLayer\", ({ enumerable: true, get: function () { return _text_layer.renderTextLayer; } })); Object.defineProperty(exports, \"setLayerDimensions\", ({ enumerable: true, get: function () { return _display_utils.setLayerDimensions; } })); Object.defineProperty(exports, \"shadow\", ({ enumerable: true, get: function () { return _util.shadow; } })); Object.defineProperty(exports, \"updateTextLayer\", ({ enumerable: true, get: function () { return _text_layer.updateTextLayer; } })); Object.defineProperty(exports, \"version\", ({ enumerable: true, get: function () { return _api.version; } })); var _util = __w_pdfjs_require__(1); var _api = __w_pdfjs_require__(2); var _display_utils = __w_pdfjs_require__(6); var _text_layer = __w_pdfjs_require__(21); var _annotation_editor_layer = __w_pdfjs_require__(22); var _tools = __w_pdfjs_require__(5); var _annotation_layer = __w_pdfjs_require__(27); var _worker_options = __w_pdfjs_require__(14); var _is_node = __w_pdfjs_require__(10); var _svg = __w_pdfjs_require__(30); var _xfa_layer = __w_pdfjs_require__(29); const pdfjsVersion = '3.2.146'; const pdfjsBuild = '3fd2a3548'; { if (_is_node.isNodeJS) { const { PDFNodeStream } = __w_pdfjs_require__(31); (0, _api.setPDFNetworkStreamFactory)(params => { return new PDFNodeStream(params); }); } else { const { PDFNetworkStream } = __w_pdfjs_require__(34); const { PDFFetchStream } = __w_pdfjs_require__(35); (0, _api.setPDFNetworkStreamFactory)(params => { if ((0, _display_utils.isValidFetchUrl)(params.url)) { return new PDFFetchStream(params); } return new PDFNetworkStream(params); }); } } })(); /******/ return __webpack_exports__; /******/ })() ; }); //# sourceMappingURL=pdf.js.map","link":"/js/pdfjs/build/pdf.js"},{"title":"","text":"/* Copyright 2014 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #PDFBug, #PDFBug input, #PDFBug button, #PDFBug select { font: message-box; } #PDFBug { background-color: rgba(255, 255, 255, 1); border: 1px solid rgba(102, 102, 102, 1); position: fixed; top: 32px; right: 0; bottom: 0; font-size: 10px; padding: 0; width: 300px; } #PDFBug .controls { background: rgba(238, 238, 238, 1); border-bottom: 1px solid rgba(102, 102, 102, 1); padding: 3px; } #PDFBug .panels { bottom: 0; left: 0; overflow: auto; position: absolute; right: 0; top: 27px; } #PDFBug .panels > div { padding: 5px; } #PDFBug button.active { font-weight: bold; } .debuggerShowText, .debuggerHideText:hover { background-color: rgba(255, 255, 0, 1); } #PDFBug .stats { font-family: courier; font-size: 10px; white-space: pre; } #PDFBug .stats .title { font-weight: bold; } #PDFBug table { font-size: 10px; white-space: pre; } #PDFBug table.showText { border-collapse: collapse; text-align: center; } #PDFBug table.showText, #PDFBug table.showText tr, #PDFBug table.showText td { border: 1px solid black; padding: 1px; } #PDFBug table.showText td.advance { color: grey; } #viewer.textLayer-visible .textLayer { opacity: 1; } #viewer.textLayer-visible .canvasWrapper { background-color: rgba(128, 255, 128, 1); } #viewer.textLayer-visible .canvasWrapper canvas { mix-blend-mode: screen; } #viewer.textLayer-visible .textLayer span { background-color: rgba(255, 255, 0, 0.1); color: rgba(0, 0, 0, 1); border: solid 1px rgba(255, 0, 0, 0.5); box-sizing: border-box; } #viewer.textLayer-visible .textLayer span[aria-owns] { background-color: rgba(255, 0, 0, 0.3); } #viewer.textLayer-hover .textLayer span:hover { background-color: rgba(255, 255, 255, 1); color: rgba(0, 0, 0, 1); } #viewer.textLayer-shadow .textLayer span { background-color: rgba(255, 255, 255, 0.6); color: rgba(0, 0, 0, 1); }","link":"/js/pdfjs/web/debugger.css"},{"title":"","text":"/* Copyright 2012 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ let opMap; const FontInspector = (function FontInspectorClosure() { let fonts; let active = false; const fontAttribute = \"data-font-name\"; function removeSelection() { const divs = document.querySelectorAll(`span[${fontAttribute}]`); for (const div of divs) { div.className = \"\"; } } function resetSelection() { const divs = document.querySelectorAll(`span[${fontAttribute}]`); for (const div of divs) { div.className = \"debuggerHideText\"; } } function selectFont(fontName, show) { const divs = document.querySelectorAll( `span[${fontAttribute}=${fontName}]` ); for (const div of divs) { div.className = show ? \"debuggerShowText\" : \"debuggerHideText\"; } } function textLayerClick(e) { if ( !e.target.dataset.fontName || e.target.tagName.toUpperCase() !== \"SPAN\" ) { return; } const fontName = e.target.dataset.fontName; const selects = document.getElementsByTagName(\"input\"); for (const select of selects) { if (select.dataset.fontName !== fontName) { continue; } select.checked = !select.checked; selectFont(fontName, select.checked); select.scrollIntoView(); } } return { // Properties/functions needed by PDFBug. id: \"FontInspector\", name: \"Font Inspector\", panel: null, manager: null, init(pdfjsLib) { const panel = this.panel; const tmp = document.createElement(\"button\"); tmp.addEventListener(\"click\", resetSelection); tmp.textContent = \"Refresh\"; panel.append(tmp); fonts = document.createElement(\"div\"); panel.append(fonts); }, cleanup() { fonts.textContent = \"\"; }, enabled: false, get active() { return active; }, set active(value) { active = value; if (active) { document.body.addEventListener(\"click\", textLayerClick, true); resetSelection(); } else { document.body.removeEventListener(\"click\", textLayerClick, true); removeSelection(); } }, // FontInspector specific functions. fontAdded(fontObj, url) { function properties(obj, list) { const moreInfo = document.createElement(\"table\"); for (const entry of list) { const tr = document.createElement(\"tr\"); const td1 = document.createElement(\"td\"); td1.textContent = entry; tr.append(td1); const td2 = document.createElement(\"td\"); td2.textContent = obj[entry].toString(); tr.append(td2); moreInfo.append(tr); } return moreInfo; } const moreInfo = properties(fontObj, [\"name\", \"type\"]); const fontName = fontObj.loadedName; const font = document.createElement(\"div\"); const name = document.createElement(\"span\"); name.textContent = fontName; const download = document.createElement(\"a\"); if (url) { url = /url\\(['\"]?([^)\"']+)/.exec(url); download.href = url[1]; } else if (fontObj.data) { download.href = URL.createObjectURL( new Blob([fontObj.data], { type: fontObj.mimetype }) ); } download.textContent = \"Download\"; const logIt = document.createElement(\"a\"); logIt.href = \"\"; logIt.textContent = \"Log\"; logIt.addEventListener(\"click\", function (event) { event.preventDefault(); console.log(fontObj); }); const select = document.createElement(\"input\"); select.setAttribute(\"type\", \"checkbox\"); select.dataset.fontName = fontName; select.addEventListener(\"click\", function () { selectFont(fontName, select.checked); }); font.append(select, name, \" \", download, \" \", logIt, moreInfo); fonts.append(font); // Somewhat of a hack, should probably add a hook for when the text layer // is done rendering. setTimeout(() => { if (this.active) { resetSelection(); } }, 2000); }, }; })(); // Manages all the page steppers. const StepperManager = (function StepperManagerClosure() { let steppers = []; let stepperDiv = null; let stepperControls = null; let stepperChooser = null; let breakPoints = Object.create(null); return { // Properties/functions needed by PDFBug. id: \"Stepper\", name: \"Stepper\", panel: null, manager: null, init(pdfjsLib) { const self = this; stepperControls = document.createElement(\"div\"); stepperChooser = document.createElement(\"select\"); stepperChooser.addEventListener(\"change\", function (event) { self.selectStepper(this.value); }); stepperControls.append(stepperChooser); stepperDiv = document.createElement(\"div\"); this.panel.append(stepperControls, stepperDiv); if (sessionStorage.getItem(\"pdfjsBreakPoints\")) { breakPoints = JSON.parse(sessionStorage.getItem(\"pdfjsBreakPoints\")); } opMap = Object.create(null); for (const key in pdfjsLib.OPS) { opMap[pdfjsLib.OPS[key]] = key; } }, cleanup() { stepperChooser.textContent = \"\"; stepperDiv.textContent = \"\"; steppers = []; }, enabled: false, active: false, // Stepper specific functions. create(pageIndex) { const debug = document.createElement(\"div\"); debug.id = \"stepper\" + pageIndex; debug.hidden = true; debug.className = \"stepper\"; stepperDiv.append(debug); const b = document.createElement(\"option\"); b.textContent = \"Page \" + (pageIndex + 1); b.value = pageIndex; stepperChooser.append(b); const initBreakPoints = breakPoints[pageIndex] || []; const stepper = new Stepper(debug, pageIndex, initBreakPoints); steppers.push(stepper); if (steppers.length === 1) { this.selectStepper(pageIndex, false); } return stepper; }, selectStepper(pageIndex, selectPanel) { pageIndex |= 0; if (selectPanel) { this.manager.selectPanel(this); } for (const stepper of steppers) { stepper.panel.hidden = stepper.pageIndex !== pageIndex; } for (const option of stepperChooser.options) { option.selected = (option.value | 0) === pageIndex; } }, saveBreakPoints(pageIndex, bps) { breakPoints[pageIndex] = bps; sessionStorage.setItem(\"pdfjsBreakPoints\", JSON.stringify(breakPoints)); }, }; })(); // The stepper for each page's operatorList. const Stepper = (function StepperClosure() { // Shorter way to create element and optionally set textContent. function c(tag, textContent) { const d = document.createElement(tag); if (textContent) { d.textContent = textContent; } return d; } function simplifyArgs(args) { if (typeof args === \"string\") { const MAX_STRING_LENGTH = 75; return args.length","link":"/js/pdfjs/web/debugger.js"},{"title":"","text":"PDF.js viewer Thumbnails Document Outline Attachments Layers Current Outline Item Previous Next Highlight All Match Case Match Diacritics Whole Words Color Size Color Thickness Opacity Open Print Save Presentation Mode Current View Go to First Page Go to Last Page Rotate Clockwise Rotate Counterclockwise Text Selection Tool Hand Tool Page Scrolling Vertical Scrolling Horizontal Scrolling Wrapped Scrolling No Spreads Odd Spreads Even Spreads Document Properties… Toggle Sidebar Find Previous Next Open Print Save Text Draw Tools Zoom Out Zoom In Automatic Zoom Actual Size Page Fit Page Width 50% 75% 100% 125% 150% 200% 300% 400% Enter the password to open this PDF file: Cancel OK File name: - File size: - Title: - Author: - Subject: - Keywords: - Creation Date: - Modification Date: - Creator: - PDF Producer: - PDF Version: - Page Count: - Page Size: - Fast Web View: - Close Preparing document for printing… 0% Cancel","link":"/js/pdfjs/web/viewer.html"},{"title":"","text":"/** * @licstart The following is the entire license notice for the * JavaScript code in this page * * Copyright 2022 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * * @licend The above is the entire license notice for the * JavaScript code in this page */ (function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' && define.amd) define(\"pdfjs-dist/build/pdf.sandbox\", [], factory); else if(typeof exports === 'object') exports[\"pdfjs-dist/build/pdf.sandbox\"] = factory(); else root[\"pdfjs-dist/build/pdf.sandbox\"] = root.pdfjsSandbox = factory(); })(globalThis, () => { return /******/ (() => { // webpackBootstrap /******/ \"use strict\"; /******/ var __webpack_modules__ = ([ /* 0 */, /* 1 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({value:true}));exports[\"default\"]=void 0;var Module=(()=>{var _scriptDir=typeof document!=='undefined'&&document.currentScript?document.currentScript.src:undefined;return function(Module){Module=Module||{};var c;c||(c=typeof Module!=='undefined'?Module:{});var h,n;c.ready=new Promise(function(a,b){h=a;n=b;});var r=Object.assign({},c),t=\"\";\"undefined\"!=typeof document&&document.currentScript&&(t=document.currentScript.src);_scriptDir&&(t=_scriptDir);0!==t.indexOf(\"blob:\")?t=t.substr(0,t.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):t=\"\";var aa=c.print||console.log.bind(console),u=c.printErr||console.warn.bind(console);Object.assign(c,r);r=null;var v;c.wasmBinary&&(v=c.wasmBinary);var noExitRuntime=c.noExitRuntime||!0;\"object\"!=typeof WebAssembly&&w(\"no native wasm support detected\");var x,y=!1;function z(a,b,d,e){var f={string:function(l){var p=0;if(null!==l&&void 0!==l&&0!==l){var S=(l.length6&63;}b[d++]=128|g&63;}}b[d]=0;}}function J(a){for(var b=0,d=0;d=e?b+3:b+4;}return b;}function K(a){var b=J(a)+1,d=L(b);d&&B(a,D,d,b);return d;}var M,D,C,N;function ba(){var a=x.buffer;M=a;c.HEAP8=D=new Int8Array(a);c.HEAP16=new Int16Array(a);c.HEAP32=N=new Int32Array(a);c.HEAPU8=C=new Uint8Array(a);c.HEAPU16=new Uint16Array(a);c.HEAPU32=new Uint32Array(a);c.HEAPF32=new Float32Array(a);c.HEAPF64=new Float64Array(a);}var O,ca=[],da=[],ea=[];function fa(){var a=c.preRun.shift();ca.unshift(a);}var P=0,Q=null,R=null;function w(a){if(c.onAbort)c.onAbort(a);a=\"Aborted(\"+a+\")\";u(a);y=!0;a=new WebAssembly.RuntimeError(a+\". Build with -sASSERTIONS for more info.\");n(a);throw a;}function T(a){return a.startsWith(\"data:application/octet-stream;base64,\");}var U;U=\"data:application/octet-stream;base64,AGFzbQEAAAAByQZtYAR/fn9/AX5gA39/fwF/YAJ/fwF/YAJ/fwBgAX8Bf2AFf35/f38BfmADf39/AGABfwBgAXwBfGACf34BfmAEf39/fwF/YAJ/fgBgAn9/AX5gAn9+AX9gA39/fgF/YAN/fn8BfmABfgF/YAN/fn8AYAZ/fn9/f38BfmADf35/AX9gBX9/f39/AX9gBn9+fn9/fwF+YAN/fn4BfmAEf39/fwBgBH9/fn8Bf2ADf39/AX5gBH9/f38BfmAGf39/f39/AX9gBX9+fn5+AGABfwF+YAN/fn4Bf2ACfHwBfGABfgF+YAV/fn9+fwF/YAV/fn5/fwF+YAd/fn9+fn5/AX9gAABgBX9/f39/AGAEf35+fwBgBX9+fn5/AX9gB39/f39/f38Bf2AGf35/fn5/AX9gBH9+f34BfmACfn8Bf2AEf35+fwF/YAJ+fwBgCX9/f39/f39/fwF/YAR/fn5/AX5gBn9/f39/fwF+YAN/fn4AYAR/fn9/AX9gBX9+fn9/AGACfn4BfmAHf35/f39/fwF+YAF/AXxgA39/fgBgBH9+f38AYAR/fn9+AX9gBH9+fn4Bf2AEf39/fgF/YAh/f39/f39/fwF/YAd/f39/f39/AGACfH8BfGADfn9/AX9gA3x8fwF8YAR/f35/AGAEf35+fgF+YAABf2AGf3x/f39/AX9gAAF8YAV/fn9+fwF+YAF8AX5gAX4BfGAFf39+f38Bf2AGf39+fn5+AX9gBn9/f39/fwBgAn98AGAEf39+fwF+YAR/fn9+AGAFf39/f34BfmAHf35+fn9/fwF+YAR+fn5+AX9gCn9/f39/f39/f38Bf2AHf39/f39/fgF+YAd8f39/f39/AGADf39+AX5gBX9/f39/AX5gBX9+f39/AGAFf3x/f38BfmAGf35+fn5/AX9gBH98f38Bf2AGf35/f39/AX9gBX9/fn5/AX9gBX9+f39/AX9gBn9/fn5/fwF/YAV/fn5+fgF/YAJ/fwF8YAR/f35+AX9gBX9/fn5+AX5gB39/f35+fn8Bf2AEf39/fgF+YAJ8fwF/YAJ8fAF/YAh/fn5+fn9+fgF+YAN/fnwBfmAAAX5gAn5+AXxgA35+fgF/YAN/f3wAAkkMAWEBYQAXAWEBYgAkAWEBYwAKAWEBZABFAWEBZQADAWEBZgAGAWEBZwADAWEBaAABAWEBaQA2AWEBagAEAWEBawAHAWEBbAAXA9QI0ggLEAMgAwQQA0YGBkcDAgMhAwEDNwMDEBEiATgLEAcECQENCQICAwwcBgQiAw0dAw0dCQIGKw4BBAcEBw45SAIBAwIDCgYdBw8CCRAKAQoeDgQDBAMMAQQJFkkGBgYNEwMCJQMPOgccJgEHDAEjARMPBBwCARRKBAoDBBAYBgEBAiwtAg0QOhQdCwQCBw0EBBMNGhAhCRYNLQwGDS4EAQdLCgMnLw4EABMCEAEKTAYBAjwEBk0CBA0PDg4ODgYHAjAGAgIxTk8UEz0bBwQUARYCDhMyLAEnA1ABAjABAgc+ASE9AgcHAgQWAwQPEAQNAwQJARlRBAYzAgYDUgIEFChTBQ0/Aw4DAQ4eAjkhDQkBLAIBAwcEJgMEKwEICAQEGwIHBiUJFgYUAQQCBgEEDgUyAzRUAgIEDFVWBAVXARYXB1gnGA8DFAYGAgECARkKCEAfBAQCAgoBBAIEAgYNADAEGRoKAQIKBgoBBAMEAQQBAgM0QQ4gAFkXDwQDWgQMBwMWAyINDBkbD1sGAQEGIgUPAw0DCgICXAECAgwrEDgKFwMBBxcCCC0IBAIBAQYKBAEEPAIGAwkUAQMAAgMBCgIuAQcBAgICFA0BCgIKCgIXIBBdNwMTAxAEEwQCBBYOBxcUAwIGEQNeXy8ZEBsIYAlhYgBCGgIdHQ0WAQINKTEKDhUADj8KAwQCAQRjGAkNEAQZCQMGDxgCAgMCAxwGFGQHAgEECAdlCCQbAgICFwQHBAoEAgECBAECKCgCAWYADw8BAQ0JBAEAAGcgCQUABSEAHhsbAQQDAy4UAQEDAgICCxABAwIEAQIBBwIMFAQEBCA0BWgyQSQDCQMDCwYGAQ4qCQoHDAADIAEGFQkQHh8FDAcQAw8FGwoXAQIHEQwFAGkOAwMDJgUFBSUCGjUMAgIiAgEEAgIDBgEHAiceEwwYQgMODgYJCgINDhhDDAceHiUBEAMEGQEZBAECAgIBAwAKBWoxHGsDAgIEFwQoPkA2HRwmHAQCAx8EbAYHHwEACB8CCAA1AAAGBgYGBgYGBgYGBQUAAAABDAEMAQwBDAEMAQwBDAEMBQAkBQEAAAAABQAACQAFAA8JAAUPEgAACQAAAAAAAAAAAAAAAAgAAAgIBRIFBQAAAAUFBQAAAAAABQUFBQAAAAAAAAAAAAAAAAAABQAAAAAAAAUAAAUFAwAAAAAABQAABQEAAAAFAAAFAAUFAAkJAAAAAAUFFgkAAAAAAAAAAAAFAAAABQUAAAAFAAUAAAIAAAAAAAAFAAAAEgUSBQAAEgUSEhIAAAAZEQsRCwsLEQsSEgUFDwUFBQUFEgApKhMjEzsYEQsAABIJAAAAAAAAAAAPCQkAIxMYExIZIwEaGhoBAxELEQsLCxELEQsLCxELEQsRCxELCxELEQsGGRUVFRUBAwMDFRUVFQAEB0MAAQADRAgICAAPAQUICAgICAEPCAgICBUICAgfCAgIAwQHAXAB+AL4AgUHAQGAAoCAAgYJAX8BQZDBxAILB0ANAW0CAAFuALMEAW8A3QgBcACBBQFxAL8HAXIAiAcBcwCzBgF0AKMCAXUA6QEBdgEAAXcAvQgBeAC8CAF5ALsICfUFAQBBAQv3ApUEsQiwCK8Irgi1CLQIswjBB9sEqweQB4MH6gbpAr4GsgbJBJ4GkQaQBo8GjgbVCIkGyQjGCMAIvgjsBboIuQi4CLcItgjqBYQErQiyCIsImgWKCOcB4QfYB6wIjQiQBesH1AfTB9IH0AfMB8oHkge1BqsIqgipCKgIpwinBaYIpQikCKMIogihCKAInwieCJ0InAibCJoImQiYCPADlwjwA5YIlQiUCJMIjAiICIcIhgiJCKUFkgiRCPUH9AfzB/IH8QfwB+8H7gftB+AH3wfeB/AD3QenBdwH2wfaB9kHkAiPCI4IhQiECIMIggiBCIAI/wf+B/0H/Af7B/oH+Qf4B/cH9gfsB+oH6QfoB+cH5gflB+QH4wfiB9cH1gfVB4wC0QfPB84HzQfLB8kHqQXIB8cHxgfFB/0ExAfDB8IHqgXAB74HvQe8B7sHuge5B7gHtweyBbYHtQfZBLQHsweyB9cEsQewB68HrgfYBK0HrAeqB6kHqAenB6YHpQekB6MHmgOiB6EHoAefB54HnQecB5sHmgeZB5gHlwf9A5YHlQexBbMFlAeTB5EHjweOB40HjAeLB4oHiQfTBNIEhweGB4UHhAeCB4EHgAf/Bv4G/Qb8BvsG+gb5BvgG9wb2BvUG9AbzBvIG8QbwBu8G7gbtBuwG6wbpBugG5wbmBuUG5AbjBuIG4QbgBt8G3gbdBtwG2wbSCNEI1gjaBsoIjQbbCLIE2QjUCK8E2gKZBcwIxQjDCNkG0wjLCMQI3AjaCNgIpgKzA80IzgjXCNgG1wbWBtUG1AbTBtIG0QbQBs8GzgbNBswGywbKBskGyAbHBsYGxQbEBsMGwgbLBMEGygTABr8GvQa8BrsGuga5BrgGtwa2BrQGsQagBp8GnQacBq4GsAasBqoGqAamBqQGogatBq8GqwapBqcGpQajBqEGxwSbBpoGmQaYBpcGlgaVBpQGkwaSBoUExwTQCIgGzwiVBJUEyAjHCMIIwQi/CArDuBLSCDUBAX8CQCABQiCIp0F1SQ0AIAGnIgIgAigCACICQQFrNgIAIAJBAUoNACAAKAIQIAEQhgULCxMAIABCgICAgHCDQoCAgIDgAFELTQECfyAAKAJAIgJBgAJqIQMgAigCnAIgACgCBEcEQCADQcABEBAgAyAAKAIEEB4gAiAAKAIENgKcAgsgAiACKAKEAjYCmAIgAyABEBALIgEBfyAAQiCIp0F1TwRAIACnIgEgASgCAEEBajYCAAsgAAsoAQF/IwBBEGsiAiQAIAIgAToADyAAIAJBD2pBARCKARogAkEQaiQAC5sWAgZ/AX4jAEEQayICJAAgACAAQRBqIgQQjwIgACAAKAI4IgE2AjQgAiABNgIMIABBADYCMCAAIAAoAhQ2AgQDQCAAIAE2AhggACAAKAIIIgM2AhQCQAJAAn8CQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgASwAACIFQf8BcSIGDn0AFxcXFxcXFxcEAwQEAhcXFxcXFxcXFxcXFxcXFxcXFwQSGAgHDBMYFxcLDRcOCQUKHBwcHBwcHBwcFxcPERAWFwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHFwYXFAcBBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcXFRcLIAEgACgCPEkNGiAEQap/NgIADB8LIAAgAUEBahDZAw0cIAIgACgCODYCDAweCyABQQFqIAEgAS0AAUEKRhshAQsgAiABQQFqNgIMDB4LIAIgAUEBajYCDAweCwJAAkAgAS0AASIDQSpHBEAgA0EvRg0BIANBPUcNAiACIAFBAmo2AgwgBEGGfzYCAAwdCyACIAFBAmoiATYCDANAAkACQAJAAkACQAJAIAEtAAAiA0EKaw4EAQMDAgALIANBKkcEQCADDQMgASAAKAI8SQ0EIABB3RhBABAVDCELIAEtAAFBL0cNAyACIAFBAmo2AgwMJQsgAEEBNgIwIAAgACgCCEEBajYCCCACIAFBAWo2AgwMAwsgAEEBNgIwIAIgAUEBajYCDAwCCyADQRh0QRh1QQBODQAgAUEGIAJBDGoQYSIBQX5xQajAAEYEQCAAQQE2AjAMAgsgAUF/Rw0BIAIgAigCDEEBajYCDAwBCyACIAFBAWo2AgwLIAIoAgwhAQwACwALIAFBAmohAUEADBULIAIgAUEBajYCDCAEQS82AgAMGgsgAS0AAUH1AEcNFCACIAFBAWo2AgQCQCACQQRqQQEQgwIiAUEATgRAIAEQxQINAQsgAigCDCEBDBULIAIgAigCBDYCDCACQQE2AggMFgsgAkEANgIIIAIgAUEBajYCDCAGIQEMFQsgAiABQQFqIgU2AgwgAiABQQJqNgIEQdwAIQMCQCABLQABIgZB3ABGBEAgAS0AAkH1AEcNASACQQRqQQEQgwIhAwwBCyAGIgNBGHRBGHVBAE4NACAFQQYgAkEEahBhIQMLIAMQxQJFBEAgAEGpzwBBABAVDBYLIAIgAigCBDYCDCACQQA2AgggACACQQxqIAJBCGogA0EBEPcEIgFFDRUgAEGpfzYCECAAIAE2AiAMFwsgAS0AASIDQS5GBEAgAS0AAkEuRw0SIAIgAUEDajYCDCAEQaV/NgIADBcLIANBMGtB/wFxQQpPDREMEgsgAS0AARBFRQ0RIAAoAkAtAG5BAXFFDREgAEHP1ABBABAVDBMLIAEtAAEiA0EqRwRAIANBPUcNECACIAFBAmo2AgwgBEGFfzYCAAwVCyABLQACQT1GBEAgAiABQQNqNgIMIARBkH82AgAMFQsgAiABQQJqNgIMIARBo382AgAMFAsgAS0AAUE9Rw0OIAIgAUECajYCDCAEQYd/NgIADBMLIAEtAAEiA0ErRwRAIANBPUcNDiACIAFBAmo2AgwgBEGIfzYCAAwTCyACIAFBAmo2AgwgBEGVfzYCAAwSCyABLQABIgVBLUcEQCAFQT1HDQ0gAiABQQJqNgIMIARBiX82AgAMEgsCQCAAKAJIRQ0AIAEtAAJBPkcNACAAKAIEIANHDQsLIAIgAUECajYCDCAEQZR/NgIADBELAkACQAJAIAEtAAEiA0E8aw4CAQACCyACIAFBAmo2AgwgBEGafzYCAAwSCyABLQACQT1GBEAgAiABQQNqNgIMIARBin82AgAMEgsgAiABQQJqNgIMIARBln82AgAMEQsgACgCSEUgA0EhR3INCyABLQACQS1HDQsgAS0AA0EtRg0JDAsLAkACQCABLQABQT1rDgIAAQwLIAIgAUECajYCDCAEQZx/NgIADBALAkACQAJAIAEtAAJBPWsOAgEAAgsgAS0AA0E9RgRAIAIgAUEEajYCDCAEQYx/NgIADBILIAIgAUEDajYCDCAEQZh/NgIADBELIAIgAUEDajYCDCAEQYt/NgIADBALIAIgAUECajYCDCAEQZd/NgIADA8LAkACQCABLQABQT1rDgIAAQsLIAEtAAJBPUYEQCACIAFBA2o2AgwgBEGefzYCAAwQCyACIAFBAmo2AgwgBEGdfzYCAAwPCyACIAFBAmo2AgwgBEGkfzYCAAwOCyABLQABQT1HDQggAS0AAkE9RgRAIAIgAUEDajYCDCAEQaB/NgIADA4LIAIgAUECajYCDCAEQZ9/NgIADA0LIAEtAAEiA0EmRwRAIANBPUcNCCACIAFBAmo2AgwgBEGNfzYCAAwNCyABLQACQT1GBEAgAiABQQNqNgIMIARBkX82AgAMDQsgAiABQQJqNgIMIARBoX82AgAMDAsgAS0AAUE9Rw0GIAIgAUECajYCDCAEQY5/NgIADAsLIAEtAAEiA0H8AEcEQCADQT1HDQYgAiABQQJqNgIMIARBj382AgAMCwsgAS0AAkE9RgRAIAIgAUEDajYCDCAEQZJ/NgIADAsLIAIgAUECajYCDCAEQaJ/NgIADAoLIAEtAAEiA0EuRwRAIANBP0cNBSABLQACQT1GBEAgAiABQQNqNgIMIARBk382AgAMCwsgAiABQQJqNgIMIARBpn82AgAMCgsgAS0AAkEwa0H/AXFBCkkNBCACIAFBAmo2AgwgBEGnfzYCAAwJCyAFQQBODQMgAUEGIAJBDGoQYSIBQX5xQajAAEYEQCAAKAIIIQMMCwsgARDlAg0LIAEQxQIEQCACQQA2AggMBgsgAEGOL0EAEBUMBgsgACAGQQEgAUEBaiAEIAJBDGoQkgNFDQcMBQtBAQshAwNAAn8CQAJAAkACQCADRQRAIAIgATYCDAwBCyABLQAAIgNFDQICQCADQQprDgQPAAAPAAsgA0EYdEEYdUEATg0DIAFBBiACQQxqEGEiA0F+cUGowABGDQ4gAigCDCEBIANBf0YNAQtBASEDDAQLIAFBAWoMAgsgASAAKAI8Tw0LCyABQQFqCyEBQQAhAwwACwALIAQgBjYCACACIAFBAWo2AgwMBAsgACgCACABIAJBDGpBAEE0EMQCIgcQDQ0BAkAgB0KAgICAcINCgICAgMB+UgRAIAIoAgxBBiACQQhqEGEQwQFFDQELIAAoAgAgBxAMIABB/j5BABAVDAILIABBgH82AhAgACAHNwMgDAMLIAAgAkEMaiACQQhqIAFBABD3BCIBRQ0AIAAgATYCICACKAIIIQYgAEEANgIoIAAgBjYCJAJAIAFBJUkNACABQS1NBEAgACgCQCIDLQBuQQFxDQEgAUEtRw0DIAMvAWwiBUEBcQ0BIAVBgP4DcUGABkcNAyADKAJkDQMgAygCBCIDRQ0DIAMtAGxBAXENAQwDCyABQS5HDQIgACgCRA0AIAAoAkAiAy8BbCIFQQJxDQAgBUGA/gNxQYAGRw0CIAMoAmQNAiADKAIEIgNFDQIgAy0AbEECcUUNAgsgBgRAIABBg382AhAgAEEBNgIoDAMLIAQgAUHWAGs2AgAMAgsgBEGofzYCAEF/DAILIARBg382AgALIAAgAigCDDYCOEEACyEAIAJBEGokACAADwsgAEEBNgIwIAAgA0EBajYCCAsgAigCDCEBDAALAAsSACAAQoCAgIBwg0KAgICAMFELFQAgARDyAUUEQCAAKAIQIAEQhAULC9AGAgV/AX4jAEEgayIHJABCgICAgOAAIQoCQAJAAkACQAJAAkACQAJAAkACQCABQiCIpyIGQQFqDggDBQUAAQUFCQILIAAgAkHHPRDIAQwGCyAAIAJBwOAAEMgBDAULIAZBeUYNAQwCCyABpyEGDAILIAGnIQYgAhBeBEAgAhB8IgUgBikCBCIKp0H/////B3FPDQEgBkEQaiECIAACfyAKQoCAgIAIg1BFBEAgAiAFQQF0ai8BAAwBCyACIAVqLQAAC0H//wNxEKYDIQoMBQsgAkEwRw0AIAYpAgRC/////weDIQoMBAsgACABEJ0EpyIGRQ0CCwNAIAYoAhAiCCAIKAIYIAJxQX9zQQJ0aigCACEFIAgQKiEJAkADQCAFRQ0BIAIgCSAFQQFrQQN0IgVqIggoAgRHBEAgCCgCAEH///8fcSEFDAELCyAGKAIUIAVqIQUCQAJAAkACQCAIKAIAQR52QQFrDgMAAQIDCyAFKAIAIgJFDQYgACACrUKAgICAcIQQDyADQQBBABA2IQoMBwsgBSgCACgCECkDACIBEIYBBEAgACACEOIBDAULIAEQDyEKDAYLIAAgBiACIAUgCBDRAkUNAgwDCyAFKQMAEA8hCgwECwJAIAYtAAUiBUEEcUUNACAFQQhxBEAgAhBeBEAgAhB8IgUgBigCKEkEQCAAIAatQoCAgIBwhCAFEHshCgwHCyAGLwEGQRVrQf//A3FBCUkNBQwCCyAGLwEGQRVrQf//A3FBCEsNASAAIAIQpQMiBUUNAUKAgICA4ABCgICAgDAgBUEASBshCgwFCyAAKAIQKAJEIAYvAQZBGGxqKAIUIgVFDQAgBSgCFARAIAAgBq1CgICAgHCEEA8iASACIAMgBSgCFBEqACEKIAAgARAMDAULIAUoAgBFDQAgACAHIAatQoCAgIBwhBAPIgEgAiAFKAIAERgAIQUgACABEAwgBUEASA0CIAVFDQAgBy0AAEEQcQRAIAAgBykDGBAMIAAgBykDECADQQBBABA2IQoMBQsgBykDCCEKDAQLIAYoAhAoAiwiBg0AC0KAgICAMCEKIARFDQIgACACENACC0KAgICA4AAhCgwBC0KAgICAMCEKCyAHQSBqJAAgCgtfAQJ/IwBBEGsiBCQAIAAoAgAhAyAEIAI2AgwgA0EDIAEgAkEAENsFIAMgAygCECkDgAEgACgCDCAAKAIIIAAoAkAiAAR/IAAoAmhBAEdBAXQFQQALEMcCIARBEGokAAsNACAAIAEgAkEEEK8DCzcBAX5CgICAgMB+IAC9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLDwAgACgCQEGAAmogARAxCysAIAEQ8gFFBEAgACgCECgCOCABQQJ0aigCACIAIAAoAgBBAWo2AgALIAELCwAgACgCECABECELKQAgACABIAIgA0KAgICAMEKAgICAMCAEQYDOAHIQeCECIAAgAxAMIAILDwAgACAAKAIAIAEQGRA6C0oAIAAQ9QJFBEBBfw8LIAJBAEgEQCAAEDUhAgsgACABQf8BcRAOIAAgAhA6IAAoAkAoAqQCIAJBFGxqIgAgACgCAEEBajYCACACCygBAX8jAEEQayICJAAgAiABNgIMIAAgAkEMakEEEIoBGiACQRBqJAALGAEBfiABKQMAIQMgASACNwMAIAAgAxAMCzEAIAFBAE4EQCAAQbQBEA4gACABEDogACgCQCIAKAKkAiABQRRsaiAAKAKEAjYCBAsLEQAgAEEQaiABIAAoAgQRAwALCwAgAEL/////b1YLGAAgAUKAgICAYFoEQCAAIAGnIAIRAwALCxcAIAAgASACQoCAgIAwIAMgBEECEOMBCzMBAX8gAgRAIAAhAwNAIAMgAS0AADoAACADQQFqIQMgAUEBaiEBIAJBAWsiAg0ACwsgAAvkBAICfgZ/IANBACADQQBKGyELA0AgCiALRwRAIAAgAiAKQQR0aiIDKAIAELUFIQYjAEHgAGsiCSQAIAMtAAQhB0KAgICAMCEEAkACQAJAAkACQAJAAkACQAJAAkAgAy0ABQ4KAQICBQcDBAgFAAYLIAAgAygCCBC1BSEIAn4CQAJAAkAgAygCDEEBag4DAgABCQsgACAAKQPAASIEIAggBEEAEBQMAgsgACAAKAIoKQMQIgQgCCAEQQAQFAwBCyAAIAEgCCABQQAQFAshBCAAIAgQEyAGQcIBRgRAQQEhBwwICyAGQcsBRw0HQQAhBwwHCwJAIAZBwgFGBEBBASEHDAELIAZBywFHDQBBACEHCyAAIAEgBkECIAMgBxCUAxoMBwsgACABIAZCgICAgDAgAygCCAR+IAkgAygCADYCECAJQSBqIghBwABBoyggCUEQahBXGiAAIAMoAgggCEEAQQpBCCADLQAFQQJGGyADLgEGEMsBBUKAgICAMAsiBCADKAIMBH4gCSADKAIANgIAIAlBIGoiCEHAAEGcKCAJEFcaIAAgAygCDCAIQQFBC0EJIAMtAAVBAkYbIAMuAQYQywEFQoCAgIAwCyIFIAdBgDpyEHgaIAAgBBAMIAAgBRAMDAYLIAMpAwgiBEKAgICACHxC/////w9YBEAgBEL/////D4MhBAwFCyAEuRAXIQQMBAsgAysDCBAXIQQMAwsgACABIAZBAiADIAcQlAMaDAMLEAEACyADNQIIIQQLIAAgASAGIAQgBxAbGgsgCUHgAGokACAAIAYQEyAKQQFqIQoMAQsLCzIBAX8CQCABQiCIp0F1SQ0AIAGnIgIgAigCACICQQFrNgIAIAJBAUoNACAAIAEQhgULCxIAIABCgICAgHCDQoCAgIAgUQsLACAAQfQcQQAQFgsHACAAQTBqC54BAQF+AkACQAJAAkACQAJAAkAgARBWQQhqDhAFAwAAAAAAAQIEAAAAAAECAAsgAEGJHEEAEBZCgICAgOAADwsgARAPDwsgAEEEEKQBIQIMAwsgACAAQQUQpAEiAkEwIAGnKQIEQv////8Hg0EAEBsaDAILIABBBhCkASECDAELIABBBxCkASECCyACEA1FBEAgACACIAEQDxDPAQsgAguzBAELfyMAQRBrIggkACAAKAIAIQUgCCACNgIMQX8hCQJAA0ACQCAIIAIiA0EEaiICNgIMIAMoAgAiB0F/Rg0AIAAoAgQhCgNAIAEiBCAKTg0DIAQgBCAFaiILLQAAIgZBAnQiDEGwmgFqLQAAaiIBIApKDQMgBkHAAUYEQCALKAABIQkMAQsLIAYgB0cEQCAHQf8BcSAGRiAHQQh2Qf8BcSAGRnIgB0EQdkH/AXEgBkZyRSAHQRh2IAZHcSAGRSAHQYACSXJyDQMgACAGNgIQCyAEQQFqIQQCQAJAAkACQAJAAkACQAJAIAxBs5oBai0AAEEFaw4YAAkACQkBCQkBCQkBAQECAgICBAUGBwkDCQsgBCAFai0AACEEIAggA0EIaiICNgIMIAMoAgQiA0F/RgRAIAAgBDYCFAwJCyADIARGDQgMCQsgBCAFai8AACEEIAggA0EIaiICNgIMIAMoAgQiA0F/RgRAIAAgBDYCFAwICyADIARGDQcMCAsgACAEIAVqKAAANgIYDAYLIAAgBCAFaiIDKAAANgIYIAAgAy8ABDYCHAwFCyAAIAQgBWooAAA2AiAMBAsgACAEIAVqIgMoAAA2AiAgACADLQAENgIcDAMLIAAgBCAFaiIDKAAANgIgIAAgAy8ABDYCHAwCCyAAIAQgBWoiAygAADYCICAAIAMoAAQ2AhggACADLQAINgIcDAELCyAAIAk2AgwgACABNgIIQQEhDQsgCEEQaiQAIA0LvwEDAn8BfgF8QX8hAgJAAkACQAJAAkACQCABQiCIpyIDQQdqDg4CBAQEBAQDAAEBAQQEBQQLIAGnQQBHDwsgAacPCyABpykCBCEEIAAgARAMIARC/////weDQgBSDwsgAactAAUhAiAAIAEQDCACQX9zQYABcUEHdg8LIANBB2tBbU0EQCABEEkiBUQAAAAAAAAAAGIgBb1C////////////AINCgYCAgICAgPj/AFRxDwsgACABEAxBASECCyACCwsAIAAgAUEAEKAECxkAIAAoAhAgARDoASIBRQRAIAAQyQELIAELPwEBfyMAQRBrIgIkAAJ/IAEgACgCEEcEQCACIAE2AgAgAEG8/QAgAhAVQX8MAQsgABARCyEAIAJBEGokACAACygBAX8jAEEQayICJAAgAiABOwEOIAAgAkEOakECEIoBGiACQRBqJAALCwAgACABQQEQ4gULxQoCBX8PfiMAQeAAayIFJAAgBEL///////8/gyEMIAIgBIVCgICAgICAgICAf4MhCiACQv///////z+DIg1CIIghDiAEQjCIp0H//wFxIQcCQAJAIAJCMIinQf//AXEiCUH//wFrQYKAfk8EQCAHQf//AWtBgYB+Sw0BCyABUCACQv///////////wCDIgtCgICAgICAwP//AFQgC0KAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEKDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQogAyEBDAILIAEgC0KAgICAgIDA//8AhYRQBEAgAiADhFAEQEKAgICAgIDg//8AIQpCACEBDAMLIApCgICAgICAwP//AIQhCkIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQCABIAuEIQJCACEBIAJQBEBCgICAgICA4P//ACEKDAMLIApCgICAgICAwP//AIQhCgwCCyABIAuEUARAQgAhAQwCCyACIAOEUARAQgAhAQwCCyALQv///////z9YBEAgBUHQAGogASANIAEgDSANUCIGG3kgBkEGdK18pyIGQQ9rEHNBECAGayEGIAUpA1giDUIgiCEOIAUpA1AhAQsgAkL///////8/Vg0AIAVBQGsgAyAMIAMgDCAMUCIIG3kgCEEGdK18pyIIQQ9rEHMgBiAIa0EQaiEGIAUpA0ghDCAFKQNAIQMLIANCD4YiC0KAgP7/D4MiAiABQiCIIgR+IhAgC0IgiCITIAFC/////w+DIgF+fCIPQiCGIhEgASACfnwiCyARVK0gAiANQv////8PgyINfiIVIAQgE358IhEgDEIPhiADQjGIhCISQv////8PgyIDIAF+fCIUIA8gEFStQiCGIA9CIIiEfCIPIAIgDkKAgASEIgx+IhYgDSATfnwiDiASQiCIQoCAgIAIhCICIAF+fCIQIAMgBH58IhJCIIZ8Ihd8IQEgByAJaiAGakH//wBrIQYCQCACIAR+IhggDCATfnwiBCAYVK0gBCAEIAMgDX58IgRWrXwgAiAMfnwgBCAEIBEgFVStIBEgFFatfHwiBFatfCADIAx+IgMgAiANfnwiAiADVK1CIIYgAkIgiIR8IAQgAkIghnwiAiAEVK18IAIgAiAQIBJWrSAOIBZUrSAOIBBWrXx8QiCGIBJCIIiEfCICVq18IAIgAiAPIBRUrSAPIBdWrXx8IgJWrXwiBEKAgICAgIDAAINQRQRAIAZBAWohBgwBCyALQj+IIQMgBEIBhiACQj+IhCEEIAJCAYYgAUI/iIQhAiALQgGGIQsgAyABQgGGhCEBCyAGQf//AU4EQCAKQoCAgICAgMD//wCEIQpCACEBDAELAn4gBkEATARAQQEgBmsiB0GAAU8EQEIAIQEMAwsgBUEwaiALIAEgBkH/AGoiBhBzIAVBIGogAiAEIAYQcyAFQRBqIAsgASAHEKECIAUgAiAEIAcQoQIgBSkDMCAFKQM4hEIAUq0gBSkDICAFKQMQhIQhCyAFKQMoIAUpAxiEIQEgBSkDACECIAUpAwgMAQsgBEL///////8/gyAGrUIwhoQLIAqEIQogC1AgAUIAWSABQoCAgICAgICAgH9RG0UEQCAKIAJCAXwiASACVK18IQoMAQsgCyABQoCAgICAgICAgH+FhFBFBEAgAiEBDAELIAogAiACQgGDfCIBIAJUrXwhCgsgACABNwMAIAAgCjcDCCAFQeAAaiQAC2oBAn8CQCAAKALYAiIDRQ0AIAAoAuACIgQgACgC3AJODQAgACgC6AIgAUsNACAAKALkAiACRg0AIAMgBEEDdGoiAyACNgIEIAMgATYCACAAIAE2AugCIAAgBEEBajYC4AIgACACNgLkAgsLDAAgACgCQEF/ENADCyEAIAAgASACQoCAgIAwIAMgBEECEOMBIQIgACABEAwgAgsZACABBEAgACABQRBrrUKAgICAkH+EEAwLC28BAn8gAUIgiKciAyABpyICQQBIckUEQCACEJUBDwsgA0F4RgRAIAAgACgCECACENYCEBkPC0EAIQIgACABEJgEIgEQDQR/QQAFIAFCgICAgHCDQoCAgICAf1EEQCAAIAEQmAIPCyAAIAGnEKUECwvrAQICfwF+QoCAgIDgACEDIAAoAhQEfkKAgICA4AAFIAAoAgQhASAAKAIIIgJFBEAgACgCACABEBogAEEANgIEIAAoAgBBLxAyDwsgACgCDCACSgRAIAAoAgAoAhAgASACIAAoAhAiAXQgAWtBEWoQ5wEiAUUEQCAAKAIEIQELIAAgATYCBAsgASAAKAIQIgIEfyACBSABIAAoAghqQQA6ABAgACgCEAtBH3StIAEpAgRC/////3eDhCIDNwIEIAEgA0KAgICAeIMgADUCCEL/////B4OENwIEIABBADYCBCABrUKAgICAkH+ECwsPACAAKAJAQYACaiABEB4LSwECfyABQoCAgIBwWgR/IAGnIgMvAQYiAkENRgRAQQEPCyACQSlGBEAgAygCIC0AEA8LIAAoAhAoAkQgAkEYbGooAhBBAEcFQQALCxAAIAAgACgCKCkDCEEBEFMLFAEBfiAAIAEQLiECIAAgARAMIAILcgEBfwJ/IAAoAggiAiAAKAIMTgRAQX8gACACQQFqIAEQ1QINARoLAkAgACgCEARAIAAgACgCCCICQQFqNgIIIAAoAgQgAkEBdGogATsBEAwBCyAAIAAoAggiAkEBajYCCCACIAAoAgRqIAE6ABALQQALCywBAX8jAEEQayIDJAAgAyACNgIMIABB3ABqQYABIAEgAhDZAhogA0EQaiQACygBAX8CQCAAQoCAgIBwVA0AIAEgAKciAS8BBkcNACABKAIgIQILIAILKAAgACACQTAgAkEAEBQiAhANBEAgAUIANwMAQX8PCyAAIAEgAhCwAQsNACAAIAEgAkEAEKoDC38BA38gACEBAkAgAEEDcQRAA0AgAS0AAEUNAiABQQFqIgFBA3ENAAsLA0AgASICQQRqIQEgAigCACIDQX9zIANBgYKECGtxQYCBgoR4cUUNAAsgA0H/AXFFBEAgAiAAaw8LA0AgAi0AASEDIAJBAWoiASECIAMNAAsLIAEgAGsLFQAgACgCACAAKAIEEBogAEEANgIECwoAIABBMGtBCkkLIwECfyAAKAIAIgEgACgC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EBAPCyAAIAJBOWtB/wFxEBAPCyAAIAJBNWtB/wFxEBAPCyAAIAJBMWtB/wFxEBAPCyAAIAJBLWtB/wFxEBAPCyAAIAJBKWtB/wFxEBAPCyAAIAJBJWtB/wFxEBAPCyAAIAJBIWtB/wFxEBAPCyAAIAJBHWtB/wFxEBAPCyACQf8BSw0BAkACQAJAIAFB2ABrDgMAAQIECyAAQcABEBAMBQsgAEHBARAQDAQLIABBwgEQEAwDCyABQSJGDQELIAAgAUH/AXEQECAAIAJB//8DcRAxDwsgACACQRRrQf8BcRAQDwsgACACQf8BcRAQCxsBAX8gACABEDsEf0EABSAAQak2QQAQFkF/CwsZAQF/IAEgAhBAIgNFBEAgACACEJwDCyADCyYBAX8jAEEQayICJAAgAkEANgIMIABBASABQQAQqwMgAkEQaiQACxkAIAAoAhAgARCcAiIBRQRAIAAQyQELIAELbQEBfyMAQYACayIFJAAgBEGAwARxIAIgA0xyRQRAIAUgAUH/AXEgAiADayICQYACIAJBgAJJIgEbEEsaIAFFBEADQCAAIAVBgAIQZyACQYACayICQf8BSw0ACwsgACAFIAIQZwsgBUGAAmokAAsPACAAKAJAQYACaiABEBALbwIBfgF/IAAhBAJAAkAgARASDQAgACABQTsgAUEAEBQiAxANBEAgAw8LIAMQIg0BIAAgAxAMIAAgARCPAyIEDQBCgICAgOAADwsgBCgCKCACQQN0aikDABAPIQMLIAAgAyACEFMhASAAIAMQDCABCzEAIAAgASACQoCAgIAIfEL/////D1gEfiACQv////8PgwUgArkQFwsgA0GHgAEQzQILEAAgACAANgIEIAAgADYCAAt1AQF+IAAgASAEfiACIAN+fCADQiCIIgIgAUIgiCIEfnwgA0L/////D4MiAyABQv////8PgyIBfiIFQiCIIAMgBH58IgNCIIh8IAEgAn4gA0L/////D4N8IgFCIIh8NwMIIAAgBUL/////D4MgAUIghoQ3AwALUAEBfgJAIANBwABxBEAgASADQUBqrYYhAkIAIQEMAQsgA0UNACACIAOtIgSGIAFBwAAgA2utiIQhAiABIASGIQELIAAgATcDACAAIAI3AwgLYgACQAJAIAFBAEgNACAAKAKsAiABTA0AIAAoAqQCIAFBFGxqIgAg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GnZxIAAgBnFyEJ8DGyEHDAILIAAgBkHG0QAQeSEHDAELQX8hBwsgCkEQaiQAIAcLTAECfyMAQRBrIgMkAAJAIAFBgIABcUUEQCABQYCAAnFFDQEgABD7AUUNAQsgA0EANgIMIABBBCACQQAQqwNBfyEECyADQRBqJAAgBAvMAQECfwJAIAFCgICAgHBaBEAgAachAwNAAkAgAy0ABUEEcUUNACAAKAIQKAJEIAMvAQZBGGxqKAIUIgRFDQAgBCgCEEUNACAAIAOtQoCAgIBwhBAPIgEgAiAEKAIQERMAIQIgACABEAwgAg8LIAOtQoCAgIBwhBAPIQEgAEEAIAMgAhBPIQQgACABEAwgBA0CAkAgAy8BBkEVa0H//wNxQQhLDQAgACACEKUDIgRFDQAgBEEfdQ8LIAMoAhAoAiwiAw0ACwtBACEECyAECxoAIAAgASACQQBOBH4gAq0FIAK4EBcLEKEBCwsAIABB/////wdxC8cJAgR+BH8jAEHwAGsiCiQAIARC////////////AIMhBQJAAkAgAVAiCSACQv///////////wCDIgZCgICAgICAwP//AH1CgICAgICAwICAf1QgBlAbRQRAIANCAFIgBUKAgICAgIDA//8AfSIIQoCAgICAgMCAgH9WIAhCgICAgICAwICAf1EbDQELIAkgBkKAgICAgIDA//8AVCAGQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQQgASEDDAILIANQIAVCgICAgICAwP//AFQgBUKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEEDAILIAEgBkKAgICAgIDA//8AhYRQBEBCgICAgICA4P//ACACIAEgA4UgAiAEhUKAgICAgICAgIB/hYRQIgkbIQRCACABIAkbIQMMAgsgAyAFQoCAgICAgMD//wCFhFANASABIAaEUARAIAMgBYRCAFINAiABIAODIQMgAiAEgyEEDAILIAMgBYRQRQ0AIAEhAyACIQQMAQsgAyABIAEgA1QgBSAGViAFIAZRGyIMGyEFIAQgAiAMGyIIQv///////z+DIQYgAiAEIAwbIgdCMIinQf//AXEhCyAIQjCIp0H//wFxIglFBEAgCkHgAGogBSAGIAUgBiAGUCIJG3kgCUEGdK18pyIJQQ9rEHMgCikDaCEGIAopA2AhBUEQIAlrIQkLIAEgAyAMGyEDIAdC////////P4MhBCALRQRAIApB0ABqIAMgBCADIAQgBFAiCxt5IAtBBnStfKciC0EPaxBzQRAgC2shCyAKKQNYIQQgCikDUCEDCyAEQgOGIANCPYiEQoCAgICAgIAEhCECIAZCA4YgBUI9iIQhBCADQgOGIQEgByAIhSEDAkAgCSALRg0AIAkgC2siC0H/AEsEQEIAIQJCASEBDAELIApBQGsgASACQYABIAtrEHMgCkEwaiABIAIgCxChAiAKKQMwIAopA0AgCikDSIRCAFKthCEBIAopAzghAgsgBEKAgICAgICABIQhByAFQgOGIQYCQCADQgBTBEBCACEDQgAhBCABIAaFIAIgB4WEUA0CIAYgAX0hBSAHIAJ9IAEgBlatfSIEQv////////8DVg0BIApBIGogBSAEIAUgBCAEUCILG3kgC0EGdK18p0EMayILEHMgCSALayEJIAopAyghBCAKKQMgIQUMAQsgASAGfCIFIAFUrSACIAd8fCIEQoCAgICAgIAIg1ANACAFQgGDIARCP4YgBUIBiISEIQUgCUEBaiEJIARCAYghBAsgCEKAgICAgICAgIB/gyEBIAlB//8BTgRAIAFCgICAgICAwP//AIQhBEIAIQMMAQtBACELAkAgCUEASgRAIAkhCwwBCyAKQRBqIAUgBCAJQf8AahBzIAogBSAEQQEgCWsQoQIgCikDACAKKQMQIAopAxiEQgBSrYQhBSAKKQMIIQQLIARCPYYgBUIDiIQiAiAFp0EHcSIJQQRLrXwiAyACVK0gBEIDiEL///////8/gyALrUIwhoQgAYR8IQQCQCAJQQRGBEAgBCADQgGDIgEgA3wiAyABVK18IQQMAQsgCUUNAQsLIAAgAzcDACAAIAQ3AwggCkHwAGokAAvJBQEFfyMAQeAAayIDJAAgAyABNgJcAkACQAJAAkACQAJAAkACQAJAAkACQANAIAJBFGwiBCADakEUayEFA0ACQCADIAMoAlwiAUEEajYCXAJAAkACQAJAAkAgASgCACIGDggAAQIDAwMECAULIAJBBE4NECADIAFBCGo2AlwgASgCBCEBIAMgBGoiBCAAKAIMIAAoAhAQiAEgAkEBaiECIAQgARC2BEUNBgwJCyACQQRODQ4gAyABQQhqNgJcIAEoAgQhASADIARqIgQg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A0EIaiACEI4ERQRAQQAhBCABIAMpAwgiAkKAgICAgICAEFoEfiAAQb8OEGtBfyEEQgAFIAILNwMACyADQRBqJAAgBAsNACAAIAEgAhAPEM4FC8wBAgF/AXwCfwNAAkACQAJ/AkACQCACEFYOCAAAAAAEBAQBBAsgAqcMAQsgAhBJIgS9IgJCNIinQf8PcSIDQZ0ISw0BIASZRAAAAAAAAOBBYwRAIASqDAELQYCAgIB4CyEAQQAMAwtBACEAQQAgA0HSCEsNAhpBACACQv////////8Hg0KAgICAgICACIQgA0GTCGuthkIgiKciAGsgACACQgBTGyEAQQAMAgsgACACEKABIgIQDUUNAAtBACEAQX8LIQMgASAANgIAIAMLCwAgACABIAIQkwILLwEBfyMAQdAAayIDJAAgAyAAIANBEGogARCJATYCACAAIAIgAxAWIANB0ABqJAALLAEBfyAAKAIQIgEtAIgBRQRAIAFBAToAiAEgAEHaC0EAEFAgAUEAOgCIAQsLDQAgACABIAEQQxCtAwsWACAAIAEgAiADIAQgBSAAKQMwEIsCCxsAIAAgAUH/AXEQECAAIAIgACgCBGtBBGsQHguOAQECfyMAQRBrIgIkAAJ/IAEEQCAAQSBqIAAgAEHBAGtBGkkbIABB/wBNDQEaIAJBBGogAEECELcDGiACKAIEDAELIABBIGsgACAAQeEAa0EaSRsgAEH/AE0NABogAkEEaiAAQQAQtwMhASACKAIEIgMgACADQf8ASxsgACABQQFGGwshACACQRBqJAAgAAtmAQF/An9BACAAKAIIIgIgAU8NABpBfyAAKAIMDQAaIAAoAhQgACgCACACQQNsQQF2IgIgASABIAJJGyIBIAAoAhARAQAiAkUEQCAAQQE2AgxBfw8LIAAgATYCCCAAIAI2AgBBAAsLVQECfwJAIAFCgICAgHBUDQAgAaciAy8BBiIEQQpLQQEgBHRB8AlxRXINACAAIAMpAyAQDCADIAI3AyAPCyAAIAIQDCABEA1FBEAgAEGszABBABAWCwsnACAAIAApA8ABIAIgARAPIgFBAxDsARogACABIAMQ7gUgACABEAwLIAEBfiAAIAAgAiABIANBBEEAEMsBIgUgASAEENABIAULjgIBAn8jAEEwayIFJAACfyACIAEoAgBPBEAgBSACNgIkIAUg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ARAOIAAgBi0AOBBuIABBDhAOIAAoAhBBPUcNACAAQREQDiAAQQYQDiAAQasBEA4gAEHpAEF/EB0hBCAAEBENBiAAQQ4QDiAAEGINBiAGKAIwIghBtgFHIAhBPEdxRQRAIAAgBigCNBCtAQsgACAEECALIAAgBigCMCAGKAIsIAYoAjQgBigCPEEBIAwQ1AELIAAoAhBB3QBGDQAgB0Glf0YEQEHOzAAhCAwECyAAQSwQMEUNAQwFCwsgAEGDARAOIAAoAkAQqgEgABARDQMLAkAgBUUNACAAKAIQQT1HDQBBfyEHIABB6wBBfxAdIQEgABARDQQgACAKECAgAwRAIABBDhAOCyAAEGINBCAAQesAIAsQHRogACABECBBASEHDAQLIANFBEAgAEGAOUEAEBUMAwsgACgCQCgCgAIgDWpBsQEgDiANaxBLGiAAKAJAKAKkAiAKQRRsaiIAIAAoAgBBAWs2AgBBACEHDAMLIAAgCEEAEBUMAQsgACgCACAGKAI0EBMLQX8hBwsgBkFAayQAIAcLKwAgACgCQCgCpAFBAE4EQCAAQQYQDiAAQdkAEA4gACAAKAJALwGkARAYCwsSACAAQYN/RiAAQdUAakEuSXILEwAgACABIAIgAyAEQQBBABCKAgusAQIBfwF+IAApAgQiBKdB/////wdxIQMCQAJAIARCgICAgAiDUEUEQCACIAMgAiADShshAyAAQRBqIQADQCACIANGDQIgACACQQF0ai8BACABRg0DIAJBAWohAgwACwALIAFB/wFLDQAgAiADIAIgA0obIQMgAEEQaiEAIAFB/wFxIQEDQCACIANGDQEgACACai0AACABRg0CIAJBAWohAgwACwALQX8hAgsgAguNAQEBfyMAQRBrIgMkACADIAI3AwgCQCAAIAFBhgEgAUEAEBQiAhANDQAgACACEDsEQCAAIAIgAUEBIANBCGoQNiICEA0NASACECINASACECgNASAAIAIQDCAAQco8QQAQFkKAgICA4AAhAgwBCyAAIAIQDCAAIAFBASADQQhqEJAFIQILIANBEGokACACC6MBAgN/AX4gAEEQaiECIAEoAgAiBEEBaiEDAkAgACkCBCIFQoCAgIAIg1BFBEAgAiAEQQF0ai8BACIAQYD4A3FBgLADRyADIAWnQf////8HcU5yDQEgAiADQQF0ai8B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BiAHQQhrIggpAwA3AwAMyQELIAkgB0EYayIGKQMAEAwgBiAHQRBrIgYpAwA3AwAgBiAHQQhrIggpAwA3AwAMyAELIAcgB0EIaykDABAPNwMAIAdBCGohCAzHAQsgByAHQRBrKQMAEA83AwAgByAHQQhrKQMAEA83AwggB0EQaiEIDMYBCyAHIAdBGGspAwAQDzcDACAHIAdBEGspAwAQDzcDCCAHIAdBCGspAwAQDzcDECAHQRhqIQgMxQELIAcgB0EIayIGKQMANwMAIAYgB0EQaykDABAPNwMAIAdBCGohCAzEAQsgByAHQQhrIgYpAwAiATcDACAGIAdBEGsiBikDADcDACAGIAEQDzcDACAHQQhqIQgMwwELIAcgB0EIayIGKQMAIgE3AwAgB0EQayIIKQMAIScgCCAHQRhrIggpAwA3AwAgBiAnNwMAIAggARAPNwMAIAdBCGohCAzCAQsgByAHQQhrIgYpAwAiATcDACAHQRBrIggpAwAhJyAIIAdBGGsiCCkDADcDACAGICc3AwAgCCAHQSBrIgYpAwA3AwAgBiABEA83AwAgB0EIaiEIDMEBCyAHQRBrIgYpAwAhASAGIAdBGGsiBikDADcDACAGIAE3AwAMvwELIAdBGGsiBikDACEBIAYgB0EQayIGKQMANwMAIAdBCGsiCCkDACEnIAggATcDACAGICc3AwAMvgELIAdBIGsiBikDACEBIAYgB0EYayIGKQMANwMAIAdBEGsiCCkDACEnIAggB0EIayIIKQMANwMAIAYgJzcDACAIIAE3AwAMvQELIAdBKGsiBikDACEBIAYgB0EgayIGKQMANwMAIAdBGGsiCCkDACEnIAggB0EQayIIKQMANwMAIAYgJzcDACAIIAdBCGsiBikDADcDACAGIAE3AwAMvAELIAdBCGsiBikDACEBIAYgB0EQayIGKQMANwMAIAdBGGsiCCkDACEnIAggATcDACAGICc3AwAMuwELIAdBEGsiBikDACEBIAYgB0EYayIGKQMANwMAIAdBIGsiCCkDACEnIAggATcDACAGICc3AwAMugELIAdBEGsiBikDACEBIAYgB0EYayIGKQMANwMAIAdBIGsiCCkDACEnIAggB0EoayIIKQMANwMAIAYgJzcDACAIIAE3AwAMuQELIAdBCGsiBikDACEBIAYgB0EQayIG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gIB4RiABQv////8PVnJFBEAgCCABQgF9Qv////8PgzcDAAwoCyARIAEQDzcDGCAJICFBjgEQkgINLCAJIAggESkDGBAfDCcLIAdBCGsiCCkDACIBQv////8PWARAIAggAUL/////D4U3AwAgByEIDCgLIAchCCMAQRBrIgokACAJIApBDGogB0EIayINKQMAEMYBIQwgDUKAgICAMCAKNQIMQv////8PhSAMGzcDACAKQRBqJABBf0EAIAwbRQ0nDCsLIAdBCGsiCCkDACIBIAdBEGsiCikDACInhEL/////D1gEQCAKICenIAGndK03AwAMJwsgCSAHQaABEMgCRQ0mDCoLIAdBCGsiCCkDACIBIAdBEGsiCikDACInhEL/////D1gEQCAKAn4gJ6cgAad2IgZBAE4EQCAGrQwBCyAGuBAXCzcDAAwmCyMAQRBrIgokACAHQQhrIg0pAwAhAQJ/AkAgCSAKQQxqIAdBEGsiDCkDABDpAwRAIAkgARAMDAELIAkgCkEIaiABEOkDDQAgDAJ+IAooAgwgCigCCHYiDEEATgRAIAytDAELIAy4EBcLNwMAQQAMAQsgDEKAgICAMDcDACANQoCAgIAwNwMAQX8LIQwgCkEQaiQAIAxFDSUMKQsgB0EIayIIKQMAIgEgB0EQayIKKQMAIieEQv////8PWARAIAogJ6cgAad1rTcDAAwlCyAJIAdBoQEQyAJFDSQMKAsgB0EIayIIKQMAIgEgB0EQayIKKQMAIieEQv////8PWARAIAogASAngzcDAAwkCyAJIAdBrQEQyAJFDSMMJwsgB0EIayIIKQMAIAdBEGsiCikDAIQiAUL/////D1gEQCAKIAE3AwAMIwsgCSAHQa8BEMgCRQ0iDCYLIAdBCGsiCCkDACIBIAdBEGsiCikDACInhEL/////D1gEQCAKIAEgJ4VC/////w+DNwMADCILIAkgB0GuARDIAkUNIQwlCyAHQQhrIggpAwAiASAHQRBrIgopAwAiJ4RC/////w9YBEAgCiAnpyABp0itQoCAgIAQhDcDAAwhCyAJIAdBowEQlgNFDSAMJAsgB0EIayIIKQMAIgEgB0EQayIKKQMAIieEQv////8PWARAIAogJ6cgAadMrUKAgICAEIQ3AwAMIAsgCSAHQaQBEJYDRQ0fDCMLIAdBCGsiCCkDACIB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ACACAn9BACACKAIQIgFBO0YNABpBACABQf0ARg0AGkEAIAIoAjANABogAhCZAQ0dQQELEPYCIAIQvQENHAweCyACEBENGyACKAIwBEAgAkGIEEEAEBUMHAsgAhCZAQ0bIAJBLxAOIAIQvQFFDRwMGwsgAhARDRogAhCFARogAhDWASACEIgCDRogAkHpAEF/EB0hACACIAIoAkAtAG5Bf3NBAXEiARDxAQ0aAkAgAigCEEGvf0cEQCAAIQMMAQsgAkHrAEF/EB0hAyACEBENGyACIAAQICACIAEQ8QENGwsgAiADECAMFwsgAhA1IQAgAhA1IQEgAigCQCAHQRBqIAsgASAAQQAQqwEgAhARDRkgAhDWASACIAAQICACEIgCDRkgAkHpACABEB0aIAIQuAINGSACQesAIAAQHRogAiABECAgAigCQBCqAQwaCyACEDUhACACEDUhASACEDUhAyACKAJAIAdBEGogCyABIABBABCrASACEBENGCACIAMQICACENYBIAIQuAINGCACIAAQICACQbp/EDANGCACEIgCDRggAigCEEE7RgRAIAIQEQ0ZCyACQeoAIAMQHRogAiABECAgAigCQBCqAQwZCyACEBENFyACENYBQQAhASAHQQA2AgwCQCACKAIQIgBBWEcEQCAAQShHDQEgAiAHQQxqQQAQqQEaDAELIAIoAkAtAGxBAnFFBEAgAkHwIUEAEBUMGQsgAhARDRhBASEBCyACQSgQMA0XIActAAxBAXFFBEAgASEEIwBBQGoiBSQAIAIoAgAhDSACKAJAIg4oArwBIRAgAhA1IQMgAhA1IREgAhA1IRIgAhA1IRMgAhCFARpBASEIIAIoAkAgBUEQaiALIBIgA0EBEKsBIAUgEDYCKCACQesAQX8QHSEUIAIoAkAoAoQCIQkgAiATECAgAigCECEAQVEhAUF/IQoCQAJAAkACQAJAAkACQAJAAkAgAkEEENYDDgIAAQgLIABBSUYhDCAAQVFGIgEhCCABIABBsX9GckUgAEFJR3ENASAAIQELIAIQEQ0EAkAgAigCECIAQfsARiAAQdsARnJFBEAgAEGDf0YEQCACKAIoRQ0CCyACQZLfAEEAEBUMBgtBASEIIAIgAUEAQQFBf0EAENUBQQBIDQcgBUEANgI8DAMLIAUgDSACKAIgEBkiBjYCPCACEBEE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/wFxakEBayEGIAoLIQcgDiAPaiIOIBBNDQALCyAJQRBqJAAgBSAAIAgoAkAQogQiBkHt7wAgBhs2AhAgBUHIAGpBlyggBUEQahCEAiAAIAYQNyAEQX9HBEAgBSAENgIAIAVByABqQYHjACAFEIQCCyAFQcgAakEpEBAMAQtBACEDIAVByABqQcP3AEEAEIQCCyAFQcgAakEKEBAgA0UNAAsLIAVByABqQQAQEEKAgICAICERIAUoAlRFBEAgACAFKAJIEHYhEQsgBUHIAGoQlwEgACABQTUgEUEDEBsaIAVB4ABqJAAL7AECAn8BfiMAQRBrIgMkACABQQhrIgQpAwAhBQJ/AkAgACADQQxqIAFBEGsiASkDABDGAQRAIAAgBRAMDAELIAAgA0EIaiAFEMYBDQAgAQJ/AkACQAJAAkACQAJAIAJBrQFrDgMBAwIACwJAIAJBoAFrDgIFAAQLIAMoAgwgAygCCHUMBQsgAygCCCADKAIMcQwECyADKAIIIAMoAgxyDAMLIAMoAgggAygCDHMMAgsQAQALIAMoAgwgAygCCHQLrTcDAEEADAELIAFCgICAgDA3AwAgBEKAgICAMDcDAEF/CyEAIANBEGokACAAC+oEAgd/An4CQCABQoCAgIBwg0KAgICAkH9SBEBCgICAgOAAIQogACABED0iARANDQELAkAgAkKAgICAcINCgICAgJB/UQ0AQoCAgIDgACEKIAAgAhA9IgIQDUUNACABIQIMAQsCQCACpyIFKQIEIgpC/////weDUA0AAkAgAaciAygCAEEBRw0AIAMpAgQgCoVCgICAgAiDQgBSDQAgACgCECADEKMEIAUoAgQiBkH/////B3EiCCADKAIEIgRB/////wdxIgdqIAZBH3Z0IARBH3YiCWtBEWpJDQAgA0EQaiEEIAkEQCAEIAdBAXRqIAVBEGogBkEBdBAlGiADIAMpAgQiCiAFKQIEfEL/////B4MgCkKAgICAeIOENwIEDAILIAQgB2ogBUEQaiAIECUaIAMgAykCBCIKIAUpAgR8Qv////8HgyILIApCgICAgHiDhDcCBCAEIAunakEAOgAADAELAn4CQAJAIAUpAgQiCqdB/////wdxIAMpAgQiC6dB/////wdxaiIGQYCAgIAETwRAIABBmsMAQQAQUAwBCyAAIAYgCiALhKciCEEfdhD9ASIHDQELQoCAgIDgAAwBCyAHQRBqIQQCQCAIQQBOBEAgBCADQRBqIAMoAgRB/////wdxECUiBCADKAIEQf////8HcWogBUEQaiAFKAIEQf////8HcRAlGiAEIAZqQQA6AAAMAQsgBCADIAMoAgRB/////wdxEJQFIAQgAygCBEEBdGogBSAFKAIEQf////8HcRCUBQsgB61CgICAgJB/hAshCiAAIAEQDAwBCyABIQoLIAAgAhAMIAoLQAAgAAJ/An8gAwRAIAEoAiQgAkEDdGpBBGoMAQtBACABKAIgIgNFDQEaIAMgAS8BKCACakEEdGoLKAIACxDiAQsLACAAQZ8JQQAQFguBDAINfwR+IwBBgAFrIgskACALIQUjAEHgAWsiCCQAAkAgAb0iEkKAgICAgICA+P8Ag0KAgICAgICA+P8AUQRAIBJC////////////AINCgYCAgICAgPj/AFoEQCAFQc7CuQI2AAAMAgsgAUQAAAAAAAAAAGMEQCAFQS06AAAgBUEBaiEFCyAFQdkLLQAAOgAIIAVB0QspAAA3AAAMAQsCQCAERQRAAn4gAZlEAAAAAAAA4ENjBEAgAbAMAQtCgICAgICAgICAfwsiE0KAgICAgICAEH1CgYCAgICAgGBUIBO5IAFicg0BIAhB1QFqIgNBADoAACATIBNCP4ciEoUgEn0hEiACrSEUA0AgAyICQQFrIgNBMEHXACASIBIgFIAiFSAUfn2nIgRBCkgbIARqOgAAIBIgFFohBCAVIRIgBA0ACyATQgBTBEAgAkECayIDQS06AAALIAUgAxCBBgwCC0QAAAAAAAAAACABIAFEAAAAAAAAAABhGyEBIARBAkcNACMAQYACayICJAACQCACQYABaiABIANBAWoiBEEAEIcDIAJqLQB/QTVHDQAgAkGAAWogASAEQYAIEIcDIgYgAiABIARBgBAQhwNHDQAgAkGAAWogAiAGEHcNAEGACEGAECACLQCAAUEtRhshCQsgBSABIAMgCRCHAxogAkGAAmokAAwBCyADIQIgCEEIaiENIAhBDGohDiAIQRBqIQwjAEGQA2siByQAAkAgBEEDcUEBRiIPRQRAQREhAkEBIQoDQCACIApNBEBBACEJDAMLIAEgAiAKakEBdiIJIA0gDiAMQQAgB0GQAmoiBhC+AiAGEPoFIAFhBEAgCUEBIAlBAEwbIQYDQCAJQQJIBEAgBiECDAMLIAkiAkEBayIJIAxqLQAAQTBGDQALBSAJQQFqIQoLDAALAAsgASACQQFqIgYgB0EMaiAHQQhqIAdBkAFqIgpBACAHQZACahC+AiACIApqLQAAQTVHDQAgASAGIAdBDGogB0EIaiAHQZABaiIKQYAIIAdBkAJqIhAQvgIgASAGIAdBBGogByAHQRBqIhFBgBAgEBC+AiAKIBEgBhB3DQAgBygCDCAHKAIERw0AQYAIQYAQIAcoAggbIQkLIAEgAiANIA4gDCAJIAdBkAJqEL4CIAdBkANqJAAgCCgCDARAIAVBLToAACAFQQFqIQULIAgoAgghBgJAIARBBHENACAGQQBMIAYgA0EVIA8bSnJFBEAgAiAGTARAQQAhBCAGIAJrIgNBACADQQBKGyEDIAUgCEEQaiACECUgAmohBQNAIAMgBEcEQCAFQTA6AAAgBEEBaiEEIAVBAWohBQwBCwsgBUEAOgAADAMLIAUgCEEQaiAGECUgBmoiBEEuOgAAQQAhBSACIAZrIgJBACACQQBKGyECA0AgBEEBaiEEIAIgBUcEQCAEIAhBEGogBSAGamotAAA6AAAgBUEBaiEFDAELCyAEQQA6AAAMAgsgBkEFakEFSw0AIAVBsNwAOwAAQQAhBEEAIAZrIQMgBUECaiEFA0AgAyAERwRAIAVBMDoAACAEQQFqIQQgBUEBaiEFDAELCyAFIAhBEGogAhAlIAJqQQA6AAAMAQsgBSAILQAQOgAAAkAgAkECSARAIAVBAWohBAwBCyAFQS46AAEgBUECaiEEQQEhBQNAIAIgBUYNASAEIAhBEGogBWotAAA6AAAgBUEBaiEFIARBAWohBAwACwALIARB5QA6AAAgBkEBayEDIAZBAEwEfyAEQQFqBSAEQSs6AAEgBEECagshAiAIIAM2AgAjAEEQayIEJAAgBCAINgIMIwBBoAFrIgMkACADQQhqIgVBgLEEQZABECUaIAMgAjYCNCADIAI2AhwgA0H/////B0F+IAJrIgYgBkH/////B0sbIgY2AjggAyACIAZqIgI2AiQgAyACNgIYIAVBnOMAIAgQqAQgBgRAIAMoAhwiAiACIAMoAhhGa0EAOgAACyADQaABaiQAIARBEGokAAsgCEHgAWokACAAIAsQdiESIAtBgAFqJAAgEgs3AQF/IAAgAhA4IQUgACACEAwgBUUEQCAAIAMQDEF/DwsgACABIAUgAyAEEBshBCAAIAUQEyAEC5MCAgJ/AXwjAEEQayIEJAACQAJAAkACQCACQiCIpyIFQQJNBEAgAqciA0EATg0DDAELIAVBB2tBbU0EQCAEAn8gAhBJIgZEAAAAAAAA8EFjIAZEAAAAAAAAAABmcQRAIAarDAELQQALIgM2AgwgBiADuGENAwwBCyADBEBBfyEDIAAgAhCgASICEA0NBCAAIARBDGogAkEBEM4CDQQgBCgCDCEDDAMLIAAgBEEMaiACEMcBBEAgACACEAwMAgtBfyEDIAAgAhCgASICEA0NAyAAIARBCGogAkEAEM4CDQMgBCgCCCIDIAQoAgxGDQILIABBx8EAEGsLQX8hAwwBCyABIAM2AgBBACEDCyAEQRBqJAAgAwsfACAAIAEgACACEMoBIgIgAUEAEBQhASAAIAIQEyABCzIBAX8jAEHQAGsiAiQAIAIgACACQRBqIAEQiQE2AgAgAEGw4QAgAhDSAiACQdAAaiQAC5EBAgF/AX4jAEEQayIFJAAgBSAENgIMQX8hBCAAIAEgBUEMahDkAUUEQCADEJsEIAEgAiADKAIEIAMoAgBBA3FBAnRBvKIBaigCABEaACEGIAMQ2AUgBSgCDCIAIAAoAgBB/////wNxNgIAIANCgICAgDAgBiAGEA0iABs3AwBBf0EAIAAbIQQLIAVBEGokACAECw0AIAAgASACQQIQrwMLDQAgACABIAJBAxCvAwsKACAAQSAgAWt2C9MBAQN/IwBBEGsiBSQAQX8hAwJAIAAoAhQNAAJAAkAgAUGAgICABE4EQCAAKAIAQZrDAEEAEFAMAQsgASAAKAIMQQNsQQJtEEpB/////wMQtAEhASAAKAIQIgQgAkGAAkhyRQRAIAAgARDuAyEDDAMLIAAoAgAgACgCBCABIAR0IARrQRFqIAVBDGoQtwEiAg0BCyAAEIoDDAELIAAoAhAhAyAFKAIMIQQgACACNgIEIAAgBCADdiABakH/////AxC0ATYCDEEAIQMLIAVBEGokACADC4EBAgJ/AX4CQCABKQIEIgRC//////////+/f1YEQCABKAIMIQAMAQsgACgCNCAEQiCIpyAAKAIkQQFrcUECdGohAiAAKAI4IQMDQCADIAIoAgAiAEECdGooAgAiAiABRg0BIAJBDGohAiAADQALQdX1AEG+4wBB+BRBrQ4QAAALIAAL8wYCBn8BfgJAAkACQAJ/IAJBAkwEQCACIAEpAgQiCUI+iKdGBEAgACABENYCIgMQ8gFFDQUgASABKAIAQQFrNgIAIAMPCyAAKAI0IAAoAiRBAWsgASACEOUFQf////8DcSIHcSIIQQJ0aiEDIAmnQf////8HcSEFA0AgAiADKAIAIgNFDQIaAkAgACgCOCADQQJ0aigCACIEKQIEIglCIIinQf////8DcSAHRyAJQj6IpyACR3IgCadB/////wdxIAVHcg0AIAQgASAFEOQFDQAgAxDyAQ0EIAQgBCgCAEEBajYCAAwECyAEQQxqIQMMAAsACyACQQNHIQdBAwshBQJAIAAoAjwNAEEAIQNB0wEgACgCLEEDbEECbRBKIgRB/////wNLDQEgACAAKAI4IARBAnQQ5wEiBkUNASAAKAIsIgJFBEAgAEEQEJwCIgJFBEAgACAGECEMAwsgAkEBNgIAIAIgAikCBEKAgICAgICAgECENwIEIAYgAjYCACAAIAAoAihBAWo2AihBASECCyAAIAI2AjwgACAGNgI4IAAgBDYCLCAEQQFrIQYDQCACIARPDQEgACgCOCACQQJ0akEAIAJBAWoiAyACIAZGGxDjBTYCACADIQIMAAsACwJAIAEEQCABKQIEIglC//////////8/WARAIAEgCSAFrUI+hoQ3AgQMAgsgACAJpyICQR91IAJB/////wdxIAJBH3Z0akERahDoASICRQRAQQAhAwwECyACQQE2AgAgAiACKQIEQv////93gyABKQIEQoCAgIAIg4QiCTcCBCACIAlCgICAgHiDIAEpAgRC/////weDhDcCBCACQRBqIAFBEGogASgCBCIDQR91IANB/////wdxIANBH3Z0akEBahAlGiAAIAEQpAQgAiEBDAELIABBEBDoASIBRQRAQQAPCyABQoGAgICAgICAgH83AgALIAAgACgCOCAAKAI8IgNBAnRqIgIoAgBBAXY2AjwgAiABNgIAIAEgAzYCDCABIAE1AgQgB61CIIaEIAWtQj6GhDcCBCAAIAAoAihBAWo2AiggBUEDRg0CIAEgACgCNCAIQQJ0aiIBKAIANgIMIAEgAzYCACAAKAIoIAAoAjBIDQIg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AgseACAAQTBrQQpJIABBX3FBwQBrQRpJciAAQd8ARnILrQEBA38gACgCQBoCQCAAKAIEIQMgACABEMYEDQBBBSADayEEA0AgACgCGCICLQAAQfwARwRAQQAPCyAAIAJBAWo2AhggACgCBCECIAAgA0EFEOsBBEAgABCsAkF/DwsgACgCACADakEJOgAAIAAoAgAgA2pBAWogAiAEahBdIABBB0EAELoBIQIgACABEMYEDQEgACgCACACaiAAKAIEIAJrQQRrEF0MAAsAC0F/C0gBAn8CQANAIAFBCkYNASABQQJ0QZLgAWovAQAgAEoNASABQQF0IQIgAUEBaiEBIAJBAXRBlOABai8BACAATA0AC0EBDwtBAAukAgEBfwJ/An8gAUH/AE0EQCAAIAE6AAAgAEEBagwBCwJAIAFB/w9NBEAgACABQQZ2QcABcjoAACAAIQIMAQsCfyABQf//A00EQCAAIAFBDHZB4AFyOgAAIABBAWoMAQsCQCABQf///wBNBEAgACABQRJ2QfABcjoAACAAIQIMAQsCfyABQf///x9NBEAgACABQRh2QfgBcjoAACAAQQFqDAELQQAgAUEASA0FGiAAIAFBHnZB/AFyOgAAIAAgAUEYdkE/cUGAAXI6AAEgAEECagsiAiABQRJ2QT9xQYABcjoAAAsgAiABQQx2QT9xQYABcjoAASACQQJqCyICIAFBBnZBP3FBgAFyOgAACyACIAFBP3FBgAFyOgABIAJBAmoLIABrCwskACAAQgA3AgAgACABNgIUIABCADcCCCAAIAJB4QIgAhs2AhALJwECfwJAIAAgAUEAEJsBIgMEQCADEJoBRQ0BIAAQdQtBfyECCyACC8kBAgN/AX4jAEEQayIFJAACQCAAIAFBAhBvIgEQDQ0AAkACQCACQQFHDQAgAykDACIHEJABRQ0AIAAgBUEMaiAHEA9BARDOAg0BIAAgAUEwAn4gBSgCDCICQQBOBEAgAq0MAQsgArgQFwsQSEEASA0BDAILIAJBACACQQBKGyECA0AgAiAERg0CIAAgASAEIAMgBEEDdGopAwAQDxCWAiEGIARBAWohBCAGQQBODQALCyAAIAEQDEKAgICA4AAhAQsgBUEQaiQAIAELEQAgACABIAIgAyAEIAUQywELDQAgAEEGQX9BBRDrBQt8AgJ+AX8gACACKQMA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CgIBBgYGBgYCAwAECyAApyEBDAULIACnQQAQ5QUhAQwECyAAp0HbGGwhAQwDCyAAp0HbGGy3DAELIAJBB0cNAUQAAAAAAAD4fyAAEEkiAyADvUL///////////8Ag0KAgICAgICA+P8AVhsLvSIAQiCIIACFp0HbGGwhAQsgASACcwsHACAAQQFxCy4BAX8gACAAIAEgACACEMoBIgIgAUEAEBQiARCmASEDIAAgARAMIAAgAhATIAMLEgAgAEEIdCAAQQh2ckH//wNxC1ABAX8gAEEgEC8iAgRAIAJBATYCACACQoCAgIDAAEKAgICAMCABGzcDGCACIAJBGGo2AhAgAiACLQAFQQFyOgAFIAAoAhAgAkEDEL4BCyACCwoAIAAoAgQgAEYLMgACQCAAIAIgAUEAQQAQJCICEA0NACACECINACAAIAIQDCAAEClCgICAgOAAIQILIAILCwAgACABIAIQxgELCwAgAEG2PEEAEBYLdQECfyMAQZABayIEJABB3PsAIQUCQAJAAkACQCABQQFqDgUDAgIAAQILQZ37ACEFDAELQdseIQULIAAgBEHQAGogAxCJASEBIAQgACAEQRBqIAIoAgQQiQE2AgQgBCABNgIAIAAgBSAEENMCCyAEQZABaiQAC2kBAn8jAEEQayIFJAAgBUEANgIIIAVCADcDACAAIAEgAiADIAQgBRChBSECA0AgBSgCACEBIAYgBSgCCE5FBEAgACABIAZBA3RqKAIEEBMgBkEBaiEGDAELCyAAIAEQGiAFQRBqJAAgAgseACABKAIAQQRHBEAgACABQQhqEIsDIAFBBDYCAAsLpQEBBX8jAEEQayIDJABBfyECAkAgACgCFA0AIAAoAgAgACgCBCABQQF0QRBqIANBDGoQtwEiBEUEQCAAEIoDDAELIARBEGohBSAAKAIIIQIgAygCDCEGA0AgAkEATEUEQCAFIAJBAWsiAkEBdGogAiAFai0AADsBAAwBCwsgAEEBNgIQIAAgBDYCBCAAIAZBAXYgAWo2AgxBACECCyADQRBqJAAgAgtUAQJ/IAAgASkDGCACECMgACABKQMAIAIQIwJAIAEoAjwiBEUNACABKAIgIQMDQCADIARPDQEgACADKQMAIAIQIyADQQhqIQMgASgCPCEEDAALAAsLGgEBfyABpygCICIDBEAgACADKQMA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BCQAAkACQCAAIARBCGogAUHiABCHASICRQ0AIAQpAwgiARASBEAgACACKQMAEJkEIQMMAgsgACABIAIpAwhBASACEDYiARANDQAgACABEC0iA0UEQEEAIQMMAgsgACACKQMAEKIBIgJBAEgNACACRQ0BIABB6iJBABAWC0F/IQMLIARBEGokACADDwsgAiACLQAFQf4BcToABUEBCy4BAX8gAKcpAyAiAEKAgICAcINCgICAgJB/UQR/IACnKAIEQf////8HcQVBAAsLCgAgACgCAEF8cQszACAAIAJBARD9ASIARQRAQoCAgIDgAA8LIABBEGogASACQQF0ECUaIACtQoCAgICQf4QLZQICfwF+QQQhAkKAgICAICEEAkACQAJAAkACQAJAIAEQViIDQQhqDgoDAgUFBQUFBQQBAAsgA0EHRg0DDAQLQQYhAgwCC0EFIQIMAQtBByECCyAAKAIoIAJBA3RqKQMAIQQLIAQLYAEBfCAAKQIEQv//////////P1gEQCABIAErAwhEAAAAAAAA8D8gACgCALciAqOgOQMIIAEgASsDECAAKAIEIgBBH3UgAEH/////B3EgAEEfdnRqQRFquCACo6A5AxALC+kGAQV/AkACQAJAAkACQAJAAkACQAJAIAEtAARBD3EOBgABBAIDBgULIAAgASgCECIHIAIRAwAgBxAqIQUDQCAHKAIgIANKBEACQCAFKAIERQ0AIAEoAhQgA0EDdGohBAJAAkACQAJAIAUoAgBBHnZBAWsOAwABAgMLIAQoAgAiBgRAIAAgBiACEQMACyAEKAIEIgRFDQMgACAEIAIRAwAMAwsgBCgCACIELQAFQQFxRQ0CIAAgBCACEQMADAILIAAgBBCbBCACEQMADAELIAAgBCkDACACECMLIANBAWohAyAFQQhqIQUMAQsLIAEvAQYiA0EBRg0GIAAoAkQgA0EYbGooAgwiA0UNBiAAIAGtQoCAgIBwhCACIAMREQAPCwNAIAEoAjggA0oEQCAAIAEoAjQgA0EDdGopAwAgAhAjIANBAWohAwwBCwsgASgCMCIBRQ0FIAAgASACEQMADwsgAS0ABUEBcUUNBSAAIAEoAhApAwAgAhAjDwsgASgCIARAIAAgAUEoaiACEO8DCyAAIAEpAxAgAhAjIAAgASkDGCACECMPCyABKAIsIgFFDQIgACABIAIRAwAPCxABAAsgAUHkAWohAyABQeABaiEHA0AgByADKAIAIgVHBEAgBUEIayEDQQAhBANAIAMoAiAgBEoEQAJAIAMoAhwgBEEUbGoiBigCCA0AIAYoAgQiBkUNACAAIAYgAhEDAAsgBEEBaiEEDAELCyAAIAMpA0AgAhAjIAAgAykDSCACECMgACADKQNgIAIQIyAAIAMpA2ggAhAjIAVBBGohAwwBCwsgACABKQPAASACECMgACABKQPIASACECMgACABKQOwASACECMgACABKQO4ASACECMgACABKQOoASACECNBACEDA0AgA0EIRgRAQQAhAwNAIAAoAkAgA0oEQCAAIAEoAiggA0EDdGopAwAgAhAjIANBAWohAwwBCwsgACABKQOYASACECMgACABKQOgASACECMgACABKQNQIAIQIyAAIAEpA0AgAhAjIAAgASkDSCACECMgACABKQM4IAIQIyAAIAEpAzAgAhAjIAEoAiQiAQRAIAAgASACEQMACwUgACABIANBA3RqKQNYIAIQIyADQQFqIQMMAQsLCw8LQZniAEG+4wBBjixB0joQAAALiAICAX4CfyMAQTBrIgQkAEHK5gAhBUKAgICA4AAhAwJAAkACQAJAAkACQAJAAkACQAJAAkACQCABEFZBCGoOEAUGCQkJCQoEAAECAwkJCwgJCyAEIAE+AgAgBEEQaiIFQSBBnOMAIAQQVxoMCQsgAEEDQQIgAacbEDIhAwwJCyAAQQEQMiEDDAgLIABBxQAQMiEDDAcLIAAgAUEAEJsDIgEQDQRAIAEhAwwHCyAAIAEgAhCgBCEDIAAgARAMDAYLIAJFDQELIAEQDyEDDAQLIABBw8MAQQAQFgwDCyAAIAEQSUEKQQBBABDMAiEDDAILQbfmACEFCyAAIAUQdiEDCyAEQTBqJAAgAwutBAIIfwF+AkACQAJAAkACQCACQoCAgIBwg0KAgICAkH9SBEAgACACEC4iAhANRQ0BDAILIAIQDyECCyACpyIEQRBqIQcgBCkCBCIMp0H/////B3EhBgJAIAxCgICAgAiDUARAQQAhBANAIAQgBkZFBEAgBSAEIAdqLQAAQQd2aiEFIARBAWohBAwBCwsgBUUEQCAHIQQgAQ0EDAYLIAAgBSAGakEAEP0BIghFDQIgCEEQaiEEQQAhBQNAIAUgBkYN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C1QAIwBBEGsiAiQAIAAgAkEIaiADKQMAEEcEfkKAgICA4AAFIAIpAwhC////////////AINCgICAgICAgPj/AFatQoCAgIAQhAshASACQRBqJAAgAQv4AgIDfwN+IwBBMGsiCCQAIANCACADQgBVGyENIAVBAWshCiAFQQBMIQVCACEDA0ACQCADIA1RBEAgBCEMDAELQn8hDCAAIAIgAyAIQShqEIwBIglBAEgNAAJAIAlFDQAgBhASRQRAIAggCCkDKDcDACADIQsgA0KAgICACFoEQCADuRAXIQsLIAggAjcDECAIIAs3AwggCCAAIAYgB0EDIAgQJCILNwMoIAAgCCkDABAMIAAgCCkDCBAMIAsQDQ0CCwJAAkACQCAFDQAgACAIKQMoIgsQwgEiCUEASA0BIAlFDQAgACAIQSBqIAsQQUEASA0BIAAgASALIAgpAyAgBCAKQoCAgIAwQoCAgIAwENQEIgRCAFMNASAAIAsQDAwDCyAEQv////////8PUw0BIABBi8MAQQAQFiAIKQMoIQsLIAAgCxAMDAILIAAgASAEIAgpAygQcEEASA0BIARCAXwhBAsgA0IBfCEDDAELCyAIQTBqJAAgDAsMACAAQgAgAEIAVRsLKAACQCABEBJFBEAgARAoRQ0BCyAAIAEQPQ8LIAAgAUE4QQBBABC6AgujAgIGfwF+IwBBMGsiAiQAAkACQCADKQMAIgEQIkUNAEKAgICA4AAhCyAAIAEQmQQiA0EASA0BIANFBEAgAEHdygBBABAWDAILIAAgAkEsaiACQShqIAGnIglBAxCSAQ0BIAIoAiwhBiACKAIoIQdBACEDAkADQCADIAdHBEAgBiADQQN0aigCBCEIQYCCASEFAkAgBEUNACAAIAJBCGogCSAIEE8iCkEASA0DIApFDQAgAigCCCEFIAAgAkEIahBOQYCGAUGAggEgBUECcRshBQsgACABIAhCgICAgDBCgICAgDBCgICAgDAgBRB4QQBIDQIgA0EBaiEDDAELCyAAIAYgBxBmDAELIAAgBiAHEGYMAQsgARAPIQsLIAJBMGokACALC+sBAQF+AkACQCABECgEQCAAQek9EHYhBAwBCyABEBIEQCAAQf/gABB2IQQMAQsgACABECsiARANDQEgACABEMIBIgNBAEgEQCAAIAEQDEKAgICA4AAPCwJ/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RQRAIAUgAigCDCABGyEDIAYhAQwCCyADQQZrDgICAAYLIABBiNgAQQAQFQwECyACQShqIAQQwAFFDQEMAwsLIABBnzNBABAVDAELIABBxDNBABAVCyACQShqEEQgAkEQahBECyACQUBrJAAgCAszAQF/A0ACQCABQQBOBH8gASACRw0BQQEFQQALDwsgACgCzAEgAUEDdGooAgAhAQwACwALQwECfyAAKAKIASECQX8hAwJAA0AgAkEATA0BIAAoAoABIAJBAWsiAkEEdGooAgAgAUcNAAsgAkGAgICAAnIhAwsgAwuDAwEGfyABKAI4IQMCQAJAAkAgAS0AbkEBcQRAIANFBEBBry4hAyABKAJADQMLQdbVACEDIAJBOkYgAkHNAEZyDQJBACECIAEoAogBIgNBACADQQBKGyEEA0AgAiAERg0CQbHVACEDIAEoAoABIAJBBHRqKAIAIgZBOkYgBkHNAEZyDQMgAkEBaiECDAALAAsgA0UNACABLwFsIgJBggxGDQAgAkEIdkEDaw4EAAICAAILQQAhBCABKAKIASICQQAgAkEAShshCEEAIQMDQCADIAhGDQJBACECAkAgASgCgAEiBSADQQR0aigCACIGRQ0AA0ACQCACIANGBEBBACECIAEoAnwiBUEAIAVBAEobIQUDQCACIAVGDQQgBiABKAJ0IAJBBHRqIgcoAgBGBEAgBygCBEUNAwsgAkEBaiECDAALAAsgAkEEdCEHIAJBAWohAiAFIAdqKAIAIAZHDQELC0GvEiEDDAILIANBAWohAwwACwALIAAgA0EAEBVBfyEECyAEC2EBAX8gAEG2ARAOIABB9gAQHCAAIAAoAkAvAbwBEBggAEEREA4gAEHpAEF/EB0hASAAQbYBEA4gAEEIEBwgAEEAEBggAEEbEA4gAEEkEA4gAEEAEBggACABECAgAEEOEA4LUQECf0F/IQJBASEDA0ACQCAAIAEQuwENACADRQRAIAAoAkBBfzYCmAILIAAoAhBBLEcEQEEAIQIMAQsgABARDQAgAEEOEA5BACEDDAELCyACCykBAX4gACABEMoBIgFFBEBCgICAgOAADwsgACABEDIhAiAAIAEQEyACC9sCAQR/IwBBoAFrIgUkACABKAIAIQcgBUGAATYCCCAFIAVBEGo2AgwgBAR/IAVBIzoAEEEBBUEACyEE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DEEHEBsLIQogACAFEBMgB0EBaiEHIApBAE4NAAsMAQsgACAGIAgQZkEAIQYgACACEGAiDBANDQAgBCALNwMYIAQgDDcDECAAIAMgAUECIARBEGoQJCEBIAAgDBAMIAAgCxAMDAELIAAgBiAEKAIMEGYgACALEAxCgICAgOAAIQELIARBIGokACABC+sCAQN/IwBBQGoiAyQAAkAgACABEGMiARANDQACQCAAIANBIGogAaciBCgCBEH/////B3FBAmoQQg0AIANBIGpBIhA+DQAgA0EANgI8A0AgBCgCBEH/////B3EgAkoEQAJAAkACQAJAAkACQAJAAkACQAJAIAQgA0E8ahDbASICQQhrDgYFAgQBBgMACyACQSJGIAJB3ABGcg0GCyACQYBwcUGAsANHIAJBIE9xDQYgAyACNgIAIANBEGoiAkEQQcAPIAMQVxogA0EgaiACEI4BDQoMBwtB9AAhAgwEC0HyACECDAMLQe4AIQIMAgtB4gAhAgwBC0HmACECCyADQSBqQdwAED4NBCADQSBqIAIQPkUNAQwECyADQSBqIAIQwAENAwsgAygCPCECDAELCyADQSBqQSIQPg0AIAAgARAMIANBIGoQOSEBDAELIAAgARAMIANBIGoQREKAgICA4AAhAQsgA0FAayQAIAELbgEEf0F/IQZBfyACKAIAIgRBAXYgBGogBEGp1arVeksbIQUCQAJAIAMgASgCACIHRgRAIAAgBRAvIgBFDQIgACADIAQQJRoMAQsgACAHIAUQmgIiAEUNAQsgASAANgIAIAIgBTYCAEEAIQYLIAYLYQECfwNAIAAoAigiAUEATEUEQCAAIAFBAWsiATYCKCAAKAIAIAAoAgQgAUEDdGopAwAQDAwBCwsgACgCBCIBIABBCGoiAkcEQCAAKAIAIAEQGgsgAEEENgIsIAAgAjYCBAukBQILfwV+IwBBMGsiAiQAIAEpAyAhDyABKQMYIQ4gASkDCCENIAEpAwAhEAJ+AkACQCABKQMoIhEQngEEQCANEJ4BDQELIABB/MMAQQAQFgwBCyAAIAJBCGpBABBCGiACQQA2AiQCQCAOEBJFBEAgACACQSRqIA4Q3AENAQsgACACQShqIBAQ3AENACAAIAJBLGogASkDEBDHAUEASA0AIA2nIQcgAigCLCIKIAIoAihqIQsgEaciBCgC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CwsNACAAIAEgAkEAEN8BC0MAAnwgAb1CgICAgICAgPj/AINCgICAgICAgPj/AFEEQEQAAAAAAAD4fyAAmUQAAAAAAADwP2ENARoLIAAgARCCBgsLewEBfgJAAn4gBEEEcQRAQSYhAiAAIAEQYwwBC0ElIQIgACABECsLIgEQDQ0AIAAgAhCkASIFEA0NACAAQRAQLyICBEAgAkEANgIMIAIgBEEDcTYCCCACIAE3AwAgBSACEI0BIAUPCyAAIAUQDAsgACABEAxCgICAgOAAC5UBAgJ+AX8gACABEDIhAwJAIAEQXg0AQQAgACgCECgCOCABQQJ0aigCACkCBCICQoCAgICAgICAQINCgICAgICAgICAf1IgAkKAgICA8P///z+DUCACQv//////////v39WcRsNACACp0F/c0EfdkEBIAJC/////weDUBshBAsgBAR+IABBhOcAIANBgucAEL8BBSADCwvcAwEFfyAAQeAAaiIEEHEgAEHQAGohBSAAKAJUIQECQAJAA0AgASAFRwRAIAFBBGstAABBEE8NAiABKAIEIQIgACABQQhrIgNBBhCfBCADIAMtAARBD3FBEHI6AAQgAiEBIAMoAgANASADQQhqIgIQRiACIAQQTAwBCwsMAQtB+vQAQb7jAEHELEG6xgAQAAALIABB1ABqIQEgAEHQAGohAwJAAkADQCADIAEoAgAiAkcEQCACQQhrIgEoAgBBAEwNAiABIAEtAARBD3E6AAQgACABQQcQnwQgAkEEaiEBDAELCyAAQeQAaiEBIABB4ABqIQIDQCACIAEoAgAiAUcEQCAAIAFBCGtBCBCfBCABQQRqIQEMAQsLDAELQZfzAEG+4wBB5yxB7DsQAAALIAAiAkECOgBoIABB2ABqIQMgAEHgAGohBANAIAQgAigCZCIARwRAIABBCGshASAAQQRrLQAAQQ5xBEAgAUEIaiIAEEYgACADEEwFIAIgARDeBQsMAQsLIAJBADoAaCACKAJcIQACQAJAA0AgACADRwRAIABBBGstAABBDnENAiAAKAIEIQEgAiAAQQhrECEgASEADAELCyADEHEMAQtBv+0AQb7jAEGdLUGwJRAAAAsLpwEBBX8gAKciAygCECIBIAEoAhhBf3NBAnRBpH5yaigCACECIAEQKiEBA0AgAkUEQEEADwsgASACQQFrIgRB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AyACNgLIBQsgA0KOgICAcDcDgAEgA0GIBWogAygCkAUgA0GAAWoQLARAIAMoApQFIgJBAEgNFyADIAI2AsgFDBcLIAEgAygCtAUgAygCyAUQNCADQbAFakEAIAdrEMcDDBYLIANCjoCAgHA3A3AgA0GIBWogBCADQfAAahAsBEAgAygClAUiAkEASA0WIAMgAjYCyAUMFgsgA0Lp1IGAcDcDYCADQYgFaiAEIANB4ABqECwEQCAHQQBHIQgMDQsgASADKAK0BSADKALIBRA0IANBsAVqIAcQxwMgBCECDBkLIAkoAAEiB0H/AUoNDyABIAMoArQFIAMoAsgFEDQgA0GwBWoiAiAFQcUAa0H/AXEQECACIAdB/wFxEBAgBCECDBgLIAkoAAEhAiADQo6AgIBwNwOgASADQYgFaiAEIANBoAFqECwEQCAAIAIQEyADKAKUBSICQQBIDRQgAyACNgLIBQwUCyACQS9HDQ4gAEEvEBMgASADKAK0BSADKALIBRA0IANBsAVqQb8BEBAgBCECDBcLIANCyYCAgHA3A9gBIANC2Lb5gnA3A9ABIANBiAVqIAQiAiADQdABahAsDRYgA0F/NgLIASADQoGEkICQCTcDwAEgA0GIBWogAiADQcABahAsDRYgA0F/NgK4ASADQoaOqMiQCTcDsAEgA0GIBWogBCADQbABahAsDRYMDQsgA0KOgICAcDcDoAIgA0GIBWogBCADQaACahAsBEAgAygClAUiAkEASA0SIAMgAjYCyAUMEgsgA0KogICAcDcDkAIgA0GIBWogBCADQZACahAsBEACQCADKAKUBSICQQBIBEAgAygCyAUhAgwBCyADIAI2AsgFCyABIAMoArQFIAIQNCADQbAFakEpEBAMEgsgA0Lp1IGAcDcDgAJBACEIIANBiAVqIAQgA0GAAmoQLA0IIANCq4GAgHA3A/ABIANBiAVqIAQgA0HwAWoQLARAAkAgAygClAUiAkEASARAIAMoAsgFIQIMAQsgAyACNgLIBQsgASADKAK0BSACEDQgA0GwBWpB8AEQEAwSCyADQX82AugBIANCrIGAgJDNGjcD4AEgA0GIBWogBCADQeABahAsRQ0MAkAgAygClAUiBUEASARAIAMoAsgFIQUMAQsgAyAFNgLIBQsgASADKAK0BSAFEDQgA0GwBWpB8AEQECAD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ACAKIAIgCmoiBDYCFCAKIAEoAoQCIgI2AhggBCABKAKAAiACECUaIAAgASgCgAIQGiABQQA2AoACIAogASgCcDYCHCABKAJ8IgcgASgCiAEiBGpBAEwNBiABLQBuQQJxRQ0EIAEoAkQNBEEAIQIDQCACIAdOBEBBACECA0AgASgCiAEgAkwEQEEAIQIDQCACIAEoAsACTg0KIAAgAkEDdCIEIAEoAsgCaigCBBATIAEoAsgCIARqQQA2AgQgAkEBaiECDAALAAUgACABKAKAASACQQR0aigCABATIAJBAWohAgwBCwALAAUgACABKAJ0IAJBBHRqKAIAEBMgAkEBaiECIAEoAnwhBwwBCwALAAtB1fMAQb7jAEGD/gFBizYQAAALBSABKAJ0IAJBBHRqIgQgASgCzAEgBCgCBEEDdGoiBCgCBDYCCCAEIAI2AgQgAkEBaiECDAELCyAAIAEQjQNCgICAgOAADAMLIAogBSAKaiICNgIgIAIgASgCgAEgBEEEdBAlGiAKKAIgIAEoAogBQQR0aiABKAJ0IAEoAnxBBHQQJRoLIAogASgCfDsBKiAKIAEoAogBOwEoIAogASgCjAE7ASwgACABKAKAARAaIAAgASgCdBAaCyAKIAEoArgCIgQ2AjggBARAIAogCCAKaiICNgI0IAIgASgCtAIgBEEDdBAlGgsgACABKAK0AhAaIAFBADYCtAIgCiAUKAIMOwEuAkAgAS0AbkECcQRAIAAgASgC7AIQEyABQfQCahCXAQwBCyAKIAovABFBgAhyOwARIAogASgC7AI2AkAgCiABKALwAjYCRCAKIAAgASgC9AIgASgC+AIQmgIiAjYCUCACRQRAIAogASgC9AI2AlALIAogASgC+AI2AkwgCiABKAKMAzYCVCAKIAEoApADNgJICyABKALMASICIAFB0AFqRwRAIAAgAhAaCyAKIAEoAsACIgQ2AjwgBARAIAogBiAKaiICNgIkIAIgASgCyAIgBEEDdBAlGgsgACABKALIAhAaIAFBADYCyAIgCiAKLwARQX5xIAEvATRBAXFyIgI7ABEgCiABLwE4QQF0QQJxIAJBfXFyIgI7ABEgCiABLQBuOgAQIAogAS8BYEECdEEEcSACQXtxciICOwARIAogAkFPcSABLwFsQQR0QTBxciICOwARIAogASgCtAFBAEgE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DAELCyAGQQEgA2tBA3RqIgNBBGohByADKAIIIQQDQCAEIAdGDQEgBCgCBCEDIAQQRiAAKAIQIAQQvAIgAyEEDAALAAsgBUEwaiQAC8ECAgN+An8jAEEQayICJABCgICAgDAhBQJAAkAgACACQQhqIAAgARArIgEQQQ0AAkAgAikDCCIHQgBXBEAMAQsgB0IBfSEGAkACQAJAAkAgASACQQRqIAIQjgJFDQAgByACKAIAIgitUg0AIAGnIQkgAigCBCEDIARFDQEgAykDACEFIAMgA0EIaiAIQQN0QQhrEIECDAILAkAgBARAIAAgAUIAEGQiBRANDQYgACABQgBCASAGQQEQggNFDQEMBgsgACABIAYQZCIFEA0NBQsgACABIAYQlAJBAE4NAgwECyAIQQN0IANqQQhrKQMAIQULIAkgCSgCKEEBazYCKAsgB0KBgICACFQNACAGuRAXIQYLIAAgAUEwIAYQSEEATg0BCyAAIAUQDEKAgICA4AAhBQsgACABEAwgAkEQaiQAIAULEAAgACADKQMAQREgBBCBAwuuAgIFfgF/IwBBEGsiCiQAAn4CQCAAIApBCGogACABECsiBRBBDQAgCikDCCIBIAKsIgh8IgZCgICAgICAgBBZBEAgAEGqwwBBABAWDAELAkAgBEUgAkEATHJFBEAgACAFIAhCACABQX8QggMNAgwBCyABIQcLIAJBACACQQBKG60hCEIAIQEDQCABIAhSBEAgASAHfCEJIAGnIQIgAUIBfCEBIAAgBSAJIAMgAkEDdGopAwAQDxCRAUEATg0BDAILCyAAIAVBMCAGQoCAgIAIfCIHQv////8PWAR+IAZC/////w+DBSAGuRAXCxBIQQBIDQAgACAFEAwgBkL/////D4MgB0L/////D1gNARogBrkQFwwBCyAAIAUQDEKAgICA4AALIQEgCkEQaiQAIAELPAAgAUEAQdAAEEsiASAENgIMIAEgADYCACABIAIgA2o2AjwgASACNgI4IAFBATYCCCABQqCAgIAQNwMQC38BBH8gAS0AAEHbAEYEQCABQQFqIgMQQ0EBayECIAAoAhAoAjghBEHCASEBA0AgAUHPAUcEQAJAIAQgAUECdGooAgAiBSgCBEH/////B3EgAkcNACAFQRBqIAMgAhB3DQAgACABEBkPCyABQQFqIQEMAQsLEAEA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CyADKQMAEA8hBQwBCyAAEHUMAQsCQCAAIAEgBBBvIgcQDQRAIAAgBRAMDAELIAAgByAFIAYgCBDzA0UNASAAIAcQDAtCgICAgOAAIQcLIAJBEGokACAHC9IDAgJ+An8jAEEgayIEJAACQCABQv///////////wCDIgNCgICAgICAwIA8fSADQoCAgICAgMD/wwB9VARAIAFCBIYgAEI8iIQhAyAAQv//////////D4MiAEKBgICAgICAgAhaBEAgA0KBgICAgICAgMAAfCECDAILIANCgICAgICAgIBAfSECIABCgICAgICAgIAIUg0BIAIgA0IBg3whAgwBCyAAUCADQoCAgICAgMD//wBUIANCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQIMAQtCgICAgICAgPj/ACECIANC////////v//DAFYNAEIAIQIgA0IwiKciBUGR9wBJDQAgBEEQaiAAIAFC////////P4NCgICAgICAwACEIgIgBUGB9wBrEHMgBCAAIAJBgfgAIAVrEKECIAQpAwhCBIYgBCkDACIAQjyIhCECIAQpAxAgBCkDGIRCAFKtIABC//////////8Pg4QiAEKBgICAgICAgAhaBEAgAkIBfCECDAELIABCgICAgICAgIAIUg0AIAJCAYMgAnwhAgsgBEEgaiQAIAIgAUKAgICAgICAgIB/g4S/Cw8AIAAgASACQQBBAxCCAguiDwIFfw5+IwBB0AJrIgUkACAEQv///////z+DIQogAkL///////8/gyEMIAIgBIVCgICAgICAgICAf4MhDSAEQjCIp0H//wFxIQgCQAJAIAJCMIinQf//AXEiCUH//wFrQYKAfk8EQCAIQf//AWtBgYB+Sw0BCyABUCACQv///////////wCDIg9CgICAgICAwP//AFQgD0KAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCENDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQ0gAyEBDAILIAEgD0KAgICAgIDA//8AhYRQBEAgAyACQoCAgICAgMD//wCFhFAEQEIAIQFCgICAgICA4P//ACENDAMLIA1CgICAgICAwP//AIQhDUIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQEIAIQEMAgsgASAPhFAEQEKAgICAgIDg//8AIA0gAiADhFAbIQ1CACEBDAILIAIgA4RQBEAgDUKAgICAgIDA//8AhCENQgAhAQwCCyAPQv///////z9YBEAgBUHAAmogASAMIAEgDCAMUCIGG3kgBkEGdK18pyIGQQ9rEHNBECAGayEGIAUpA8gCIQwgBSkDwAIhAQsgAkL///////8/Vg0AIAVBsAJqIAMgCiADIAogClAiBxt5IAdBBnStfKciB0EPaxBzIAYgB2pBEGshBiAFKQO4AiEKIAUpA7ACIQMLIAVBoAJqIApCgICAgICAwACEIhJCD4YgA0IxiIQiAkIAQoCAgICw5ryC9QAgAn0iBEIAEHIgBUGQAmpCACAFKQOoAn1CACAEQgAQciAFQYACaiAFKQOYAkIBhiAFKQOQAkI/iIQiBEIAIAJCABByIAVB8AFqIARCAEIAIAUpA4gCfUIAEHIgBUHgAWogBSkD+AFCAYYgBSkD8AFCP4iEIgRCACACQgAQciAFQdABaiAEQgBCACAFKQPoAX1CABByIAVBwAFqIAUpA9gBQgGGIAUpA9ABQj+IhCIEQgAgAkIAEHIgBUGwAWogBEIAQgAgBSkDyAF9QgAQciAFQaABaiACQgAgBSkDuAFCAYYgBSkDsAFCP4iEQgF9IgJCABByIAVBkAFqIANCD4ZCACACQgAQciAFQfAAaiACQgBCACAFKQOoASAFKQOgASIPIAUpA5gBfCIEIA9UrXwgBEIBVq18fUIAEHIgBUGAAWpCASAEfUIAIAJCABByIAYgCSAIa2ohBgJ/IAUpA3AiEEIBhiIUIAUpA4gBIg5CAYYgBSkDgAFCP4iEfCILQufsAH0iFUIgiCICIAxCgICAgICAwACEIhZCAYYgAUI/iIQiDEIgiCIEfiIRIAFCAYYiD0IgiCIKIAsgFVatIAsgFFStIAUpA3hCAYYgEEI/iIQgDkI/iHx8fEIBfSIQQiCIIgt+fCIOIBFUrSAOIA4gEEL/////D4MiECAMQv////8PgyIUfnwiDlatfCAEIAt+fCAEIBB+IhMgCyAUfnwiESATVK1CIIYgEUIgiIR8IA4gDiARQiCGfCIOVq18IA4gDiAVQv////8PgyIVIBR+IhMgAiAKfnwiESATVK0gESARIBAgD0L+////D4MiE358IhFWrXx8Ig5WrXwgDiAEIBV+IhcgCyATfnwiBCACIBR+fCILIAogEH58IhBCIIggCyAQVq0gBCAXVK0gBCALVq18fEIghoR8IgQgDlStfCAEIBEgAiATfiICIAogFX58IgpCIIggAiAKVq1CIIaEfCICIBFUrSACIBBCIIZ8IAJUrXx8IgIgBFStfCIEQv////////8AWARAIAVB0ABqIAIgBCADIBIQciABQjGGIAUpA1h9IAUpA1AiAUIAUq19IQtCACABfSEKIAZB/v8AagwBCyAFQeAAaiAEQj+GIAJCAYiEIgIgBEIBiCIEIAMgEhByIAFCMIYgBSkDaH0gBSkDYCIMQgBSrX0hC0IAIAx9IQogASEPIBYhDCAGQf//AGoLIgZB//8BTgRAIA1CgICAgICAwP//AIQhDUIAIQEMAQsCfiAGQQBKBEAgC0IBhiAKQj+IhCELIARC////////P4MgBq1CMIaEIQwgCkIBhgwBCyAGQY9/TARAQgAhAQwCCyAFQUBrIAIgBEEBIAZrEKECIAVBMGogDyAMIAZB8ABqEHMgBUEgaiADIBIgBSkDQCICIAUpA0giDBByIAUpAzggBSkDKEIBhiAFKQMgIgFCP4iEfSAFKQMwIgQgAUIBhiIBVK19IQsgBCABfQshBCAFQRBqIAMgEkIDQgAQciAFIAMgEkIFQgAQciAMIAIgAiADIAJCAYMiASAEfCIDVCALIAEgA1atfCIBIBJWIAEgElEbrXwiAlatfCIEIAIgAiAEQoCAgICAgMD//wBUIAMgBSkDEFYgASAFKQMYIgRWIAEgBFEbca18IgJWrXwiBCACIARCgICAgICAwP//AFQgAyAFKQMAViABIAUpAwgiA1YgASADURtxrXwiASACVK18IA2EIQ0LIAAgATcDACAAIA03AwggBUHQAmokAAvEAQIBfwJ+QX8hAwJAIABCAFIgAUL///////////8AgyIEQoCAgICAgMD//wBWIARCgICAgICAwP//AFEbDQBBACACQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACAAIAQgBYSEUARAQQAPCyABIAKDQgBZBEBBACABIAJTIAEgAlEbDQEgACABIAKFhEIAUg8LIABCAFIgASAC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QT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMBAsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMMBAsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQMBAsLQcSzBEEZNgIAQX8FQQELDAELIAAgAToAAEEBCwsWACAARQRAQQAPC0HEswQgADYCAEF/C8QCAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAFBCWsOEgAKCwwKCwIDBAUMCwwMCgsHCAkLIAIgAigCACIBQQRqNgIAIAAgASgCADYCAA8LAAsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsACyACIAIoAgBBB2pBeHEiAUEIajYCACAAIAErAwA5AwAPCyAAIAIgAxEDAAsPCyACIAIoAgAiAUEEajYCACAAIAE0AgA3AwAPCyACIAIoAgAiAUEEajYCACAAIAE1AgA3AwAPCyACIAIoAgBBB2pBeHEiAUEIajYCACAAIAEpAwA3AwALawEEfyAAKAIALAAAEEVFBEBBAA8LA0AgACgCACEDQX8hASACQcyZs+YATQRAQX8gAywAAEEwayIEIAJBCmwiAWogBEH/////ByABa0obIQELIAAgA0EBajYCACABIQIgAywAARBFDQALIAIL8RICEX8BfiMAQdAAayIHJAAgByABNgJMIAdBN2ohFiAHQThqIRJBACEBAkACQAJAAkADQCABQf////8HIA1rSg0BIAEgDWohDSAHKAJMIgwhAQJAAkACQCAMLQAAIgsEQANAAkACQCALQf8BcSIIRQRAIAEhCwwBCyAIQSVHDQEgASELA0AgAS0AAUElRw0BIAcgAUECaiIINgJMIAtBAWohCyABLQACIQogCCEBIApBJUYNAAsLIAsgDGsiAUH/////ByANayIXSg0HIAAEQCAAIAwgARBnCyABDQZBfyEQQQEhCCAH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AhDvBSAFKQMIIQIgBSkDACEEDAELIAEgAkL///////8/gyAGrUIwhoQiCiADIARC////////P4MgBEIwiKdB//8BcSIHrUIwhoQiCRD/AUEATARAIAEgCiADIAkQ/wEEQCABIQQMAgsgBUHwAGogASACQgBCABAzIAUpA3ghAiAFKQNwIQQMAQsgBgR+IAEFIAVB4ABqIAEgCkIAQoCAgICAgMC7wAAQMyAFKQNoIgpCMIinQfgAayEGIAUpA2ALIQQgB0UEQCAFQdAAaiADIAlCAEKAgICAgIDAu8AAEDMgBSkDWCIJQjCIp0H4AGshByAFKQNQIQMLIAlC////////P4NCgICAgICAwACEIQkgCkL///////8/g0KAgICAgIDAAIQhCiAGIAdKBEADQAJ+IAogCX0gAyAEVq19IgtCAFkEQCALIAQgA30iBIRQBEAgBUEgaiABIAJCAEIAEDMgBSkDKCECIAUpAyAhBAwFCyALQgGGIARCP4iEDAELIApCAYYgBEI/iIQLIQogBEIBhiEEIAZBAWsiBiAHSg0ACyAHIQYLAkAgCiAJfSADIARWrX0iCUIAUwRAIAohCQwBCyAJIAQgA30iBIRCAFINACAFQTBqIAEgAkIAQgAQMyAFKQM4IQIgBSkDMCEEDAELIAlC////////P1gEQANAIARCP4ghASAGQQFrIQYgBEIBhiEEIAEgCUIBhoQiCUKAgICAgIDAAFQNAAsLIAhBgIACcSEHIAZBAEwEQCAFQUBrIAQgCUL///////8/gyAGQfgAaiAHcq1CMIaEQgBCgICAgICAwMM/EDMgBSkDSCECIAUpA0AhBAwBCyAJQv///////z+DIAYgB3KtQjCGhCECCyAAIAQ3AwAgACACNwMIIAVBgAFqJAALvwIBAX8jAEHQAGsiBCQAAkAgA0GAgAFOBEAgBEEgaiABIAJCAEKAgICAgICA//8AEDMgBCkDKCECIAQpAyAhASADQf//AUkEQCADQf//AGshAwwCCyAEQRBqIAEgAkIAQoCAgICAgID//wAQMyADQf3/AiADQf3/AkgbQf7/AWshAyAEKQMYIQIgBCkDECEBDAELIANBgYB/Sg0AIARBQGsgASACQgBCgICAgICAgDkQMyAEKQNIIQIgBCkDQCEBIANB9IB+SwRAIANBjf8AaiEDDAELIARB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AykDCBA4IgJFDQAgACABIAIgBhAPIARBABCIBCEDIAAgAhATIANBAEgNACADQQBHrUKAgICAEIQhBQsgBQsqACADKQMAIgFC/////29YBEAgABApQoCAgIDgAA8LIAAgAUEDQQAQgQMLYwEBfiADKQMAIgRC/////29YBEAgABApQoCAgIDgAA8LQoCAgIDgACEBAkAgACADKQMIEDgiAkUNACAAIAQgAhB6IQMgACACEBMgA0EASA0AIANBAEetQoCAgIAQhCEBCyABC2MBAn4CQAJAIAMpAwAiAUL/////b1gEQCAAECkMAQsgAykDCCEFIAEhBCACQQNOBEAgAykDECEECyAAIAUQOCICDQELQoCAgIDgAA8LIAAgASACIARBABAUIQEgACACEBMgAQtmAQF+IAMpAwAiBEL/////b1gEQCAAEClCgICAgOAADwtCgICAgOAAIQECQCAAIAMpAwgQOCICRQ0AIAAgBCACQQAQ3gEhAyAAIAIQEyADQQBIDQAgA0EAR61CgICAgBCEIQELIAELigECAX8CfiMAQRBrIgQkACADKQMIIQUgAykDACIGIQECQAJAAkACQCACQQNIDQAgAykDECIBELUBDQAgAEHfKUEAEBYMAQsgACAEQQxqIAUQiwQiAg0BC0KAgICA4AAhAQwBCyAAIAYgASAEKAIMIgMgAhCOAyEBIAAgAiADEJgDCyAEQRBqJAAgAQscACAAIAMpAwBBACACQQFrEEogA0EIakECEJoDC0MAIwBBEGsiAiQAAn5CgICAgOAAIAAgAkEMaiADKQMAEMcBDQAaQiAgAigCDCIARQ0AGiAAZ60LIQEgAkEQaiQAIAELUAAjAEEQayICJABCgICAgOAAIQECQCAAIAJBDGogAykDABCTAg0AIAAgAkEIaiADKQMIEJMCDQAgAigCCCACKAIMbK0hAQsgAkEQaiQAIAELBgAgALa7C1AAIAAgACkD0AEiAUIMiCABhSIBQhmGIAGFIgFCG4ggAYUiATcD0AEgAUKdurP7lJL9oiV+QgyIQoCAgICAgID4P4S/RAAAAAAAAPC/oBAXC/UDAwN8BX8DfiMAQRBrIggkACAIQgA3AwgCQAJAIAJBAEwNAEKAgICA4AAhASAAIAhBCGogAykDABBHDQFBASEJIAgrAwghBCACQQFHBEADQCACIAlGDQIgACAIIAMgCUEDdGopAwAQRw0DIAlBAWohCSAIKwMAIQUjAEEgayIHJAAgBL1C////////////AIMiDSAFvUL///////////8AgyIMIAwgDVYbIg6/IQQCQCAOQjSIpyIKQf8PRg0AIA0gDCAMIA1UGyIMvyEFAkAgDlANACAMQjSIpyILQf8PRg0AIAsgCmtBwQBOBEAgBSAEoCEEDAILAnwgC0H+C08EQCAERAAAAAAAADAUoiEEIAVEAAAAAAAAMBSiIQVEAAAAAAAAsGsMAQtEAAAAAAAA8D8gCkG8BEsNABogBEQAAAAAAACwa6IhBCAFRAAAAAAAALBroiEFRAAAAAAAADAUCyEGIAdBGGogB0EQaiAFEIQGIAdBCGogByAEEIQGIAYgBysDACAHKwMQoCAHKwMIoCAHKwMYoJ+iIQQMAQsgBSEECyAHQSBqJAAMAAsACyAEmSEECyAEvQJ/IASZRAAAAAAAAOBBYwRAIASqDAELQYCAgIB4CyIAt71RBEAgAK0hAQwBCyAEEBchAQsgCEEQaiQAIAELTgAgACAARAAAAAAAAPC/RAAAAAAAAPA/IABEAAAAAAAAAABjGyAAvUL///////////8Ag0KAgICAgICA+P8AVhsgAEQAAAAAAAAAAGEbC4MBAgJ+AX8gAL0iAUI0iKdB/w9xIgNB/gdNBEAgAUKAgICAgICAgIB/gyECIANB/gdHIAFCgICAgICAgPC/f1FyRQRAIAJCgICAgICAgPg/hL8PCyACvw8LIANBsghNBHwgAUI/hyABfEIBQbMIIANrrYYiAUIBiHxCACABfYO/BSAACwvdBAICfAV/IwBBEGsiCCQAAn4gAkUEQEQAAAAAAADw/0QAAAAAAADwfyAEGxAXDAELAnwgAykDACIBQv////8PWARAIAJBASACQQFKGyELIAGnIQlBASEHA0AgByALRwRAIAm3IAMgB0EDdGopAwAiAUKAgICAEFoNAxogAachCgJ/IAQEQCAJIAoQSgwBCyAJIAoQtAELIQkgB0EBaiEHDAELCyAJrQwCC0KAgICA4AAgACAIQQhqIAEQRw0BGkEBIQcgCCsDCAshBSAHIAIgAiAHSBshAgNAIAIgB0cEQEKAgICA4AAgACAIIAMgB0EDdGopAwAQRw0CGgJAIAW9Qv///////////wCDQoCAgICAgID4/wBWDQAgCCsDACIGvUL///////////8Ag0KAgICAgICA+P8AVgRAIAYhBQwBCyAEBEAgBSAFIAalIAa9Qv///////////wCDQoCAgICAgID4/wBWGyAGIAW9Qv///////////wCDQoCAgICAgID4/wBYGyAGvSAFvYO/IAVEAAAAAAAAAABiIAZEAAAAAAAAAABichshBQwBCyAFIAUgBqQgBr1C////////////AINCgICAgICAgPj/AFYbIAYgBb1C////////////AINCgICAgICAgPj/AFgbIAa9IAW9hL8gBUQAAAAAAAAAAGIgBkQAAAAAAAAAAGJyGyEFCyAHQQFqIQcMAQsLIAW9An8gBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIgC3vVEEQCAArQwBCyAFEBcLIQEgCEEQaiQAIAEL0AEBAn8jAEEQayICJAACfiAAIAFBJhBqIgNFBEAgBEEANgIAQoCAgIDgAAwBCwJAIAMpAwAiARASRQRAIAIgAygCDCIFNgIMIAUgAaciBigCBEH/////B3FJDQEgACABEAwgA0KAgICAMDcDAAsgBEEBNgIAQoCAgIAwDAELIAYgAkEMahDbASEHIAMgAigCDDYCDCAEQQA2AgAgB0H//wNNBEAgACAHQf//A3EQpgMMAQsgACAGIAVBAXRqQRBqQQIQnAQLIQEgAkEQaiQAIAELxwICAn8CfiMAQSBrIgIkAEKAgICA4AAhBwJAIAAgARBjIgEQDQ0AIAAgAkEIaiIFQQcQQhogBUE8ED4aIAUgBEEDdCIFQfDKAWooAgAiBhCOARpBnj0gBHZBAXFFBEAgAkEIaiIEQSAQPhogBCAFQfTKAWooAgAQjgEaIARByv4AEI4BGiAAIAMpAwAQYyIIEA0EQCAAIAEQDCACQQhqEEQMAgsgCKchA0EAIQQDQCAEIAMoAgRB/////wdxT0UEQAJAIAMgBBBNIgVBIkYEQCACQQhqQfTvABCOARoMAQsgAkEIaiAFEJYBGgsgBEEBaiEEDAELCyAAIAgQDCACQQhqQSIQPhoLIAJBCGoiAEE+ED4aIAAgARCPARogAEH29QAQjgEaIAAgBhCOARogAkEIakE+ED4aIAAQOSEHCyACQSBqJAAgBwu7BAEIfyMAQTBrIgIkAAJAIAAgARBjIgEQ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IAQgCSkDCBBwQQBIDQcLIARCAXwhBCABQgF8IQEMAAsACyAEQv7///////8PVQ0DIAAgBSAEIAYQDxBwQQBIDQQgBEIBfCEECyAKQQFqIQoMAQsLIAAgBUEwIARCgICAgAh8Qv////8PWAR+IARC/////w+DBSAEuRAXCxBIQQBIDQEMAgsgAEGqwwBBABAWCyAAIAUQDEKAgICA4AAhBQsgACAIEAwgCUEQaiQAIAULLQEBfkKAgICAMCECAkAgARCoAyIARQ0AIAAtABJBBHFFDQAgADUCRCECCyACCzMCAX4Bf0KAgICAMCECAkAgARCoAyIDRQ0AIAMtABJBBHFFDQAgACADKAJAEDIhAgsgAgsoAEKAgICA4AAgACADKQMAIAEQ2QUiAEEAR61CgICAgBCEIABBAEgbC6sBAgF+An9CgICAgOAAIQQgACABEGkEfkKAgICA4AAFQeb+ACECAkAgAaciAy8BBhD4AUUNAAJAIAMoAiAiAy8AESIFQYAIcUUNACADKAJUIgZFDQAgACAGIAMoAkgQ/gEPCyAFQQR2QQNxQQFrIgNBAksNACADQQJ0QaDdAWooAgAhAgsgACACIAAgAUE2IAFBABAUIgEQEgR+IABBLxAyBSABC0GeCBC/AQsLhwQDA34EfwN8AkAgACABEGkNACAAIAApAzBBDhBTIgUQDQ0AIAWnIgkgARC1AUEEdEEQcSAJLQAFQe8BcXI6AAUCQCAAQQAgAkEBaxBKIgJBA3RBGGoQLyIHRQ0AIAcgARAPIgE3AwAgAykDABAPIQQgByACNgIQIAcgBDcDCCACQQAgAkEAShshCgNAIAggCkcEQCAHIAhBA3RqIAMgCEEBaiIIQQN0aikDABAPNwMYDAELCyAJIAc2AiACfyABQv////9vWARAIAAQKUF/DAELIABBACABp0EwEE8LIgNBAEgNAAJAIANFDQAgACABQTAgAUEAEBQiBBANDQEgBEL/////D1gEQCAEpyIDIAJrQQAgAiADSButIQYMAQsgBBBWQQdGBEACQCAEEEkiDL1C////////////AINCgICAgICAgPj/AFYNACAMnSIMIAK3Ig1lDQAgDCANoSELCyALvQJ/IAuZRAAAAAAAAOBBYwRAIAuqDAELQYCAgIB4CyICt71RBEAgAq0hBgwCCyALEBchBgwBCyAA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EIQhAQsgACAGIAcQZgsgAkEwaiQAIAELnQECAX4Bf0KAgICAMCEBAkACQCAAIAMpAwAQKyIEEA0NACACQQEgAkEBShshBUEBIQIDQCACIAVGDQICQCADIAJBA3RqKQMAIgEQKA0AIAEQEg0AIAAgARArIgEQDQ0CIAAgBCABQoCAgIAwQQEQxgUNAiAAIAEQDAsgAkEBaiECDAALAAsgACAEEAwgACABEAxCgICAgOAAIQQLIAQLGAAgACADKQMAIAMpAwgQWq1CgICAgBCEC5sCAgN+A38jAEEgayICJABCgICAgOAAIQQgACADKQMAECsiBRANRQRAQoCAgIAwIQECfgJAIAAgAkEcaiACQRhqIAWnQQMQkgENACAAEDwiARANDQAgAigCHCEHIAIoAhghCEEAIQMDQCADIAhHBEAgACAHIANBA3RqIgkoAgQQYCIGEA0NAiACIAY3AwggAiAFNwMAIABCgICAgDBBAiACQQAQ2QQhBCAAIAYQDCAEEA0NAiAEEBJFBEAgACABIAkoAgQgBEGHgAEQG0EASA0DCyADQQFqIQMMAQsLIAAgByAIEGYgAQwBCyAAIAIoAhwgAigCGBBmIAAgBRAMIAEhBUKAgICA4AALIQQgACAFEAwLIAJBIGokACAEC20AAn4CQCADKQMAIgFC/////29YBEAgBEUNASAAEClCgICAgOAADwtCgICAgOAAIAAgARCZBCICQQBIDQEaIAQEQCACQQBHrUKAgICAEIQPCyACDQAgAEHdygBBABAWQoCAgIDgAA8LIAEQDwsLTwACQAJAIAMpAwAiAUL/////b1gEQCAERQRAQoCAgIAQDwsgABApDAELIAAgARCiASIAQQBODQELQoCAgIDgAA8LIABBAEetQoCAgIAQhAsQACAAIAMpAwBBAkEAEIEDCxAAIAAgAykDAEEBQQAQgQMLLQEBfkKAgICA4AAhASAAIAMpAwAiBCADKQMIENwEBH5CgICAgOAABSAEEA8LC30BAn4gAykDACIBQv////9vWARAIAAQKUKAgICA4AAPCyADKQMQIQZCgICAgOAAIQUCQCAAIAMpAwgQOCICRQ0AIAAgASACIAYgBEVBDnQQ2gQhAyAAIAIQEyADQQBIDQAgBARAIANBAEetQoCAgIAQhA8LIAEQDyEFCyAFCycAIAAgAykDACIB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QRBqJAAgAAtGAQJ+IAIgACgCABAyIQNBACEAIAIgASgCABAyIQQCQCADEA0NACAEEA0NACADpyAEpxCVAiEACyACIAMQDCACIAQQDCAAC2sBAX4CQAJAAkACQAJAIAMtAAUiAQ4EAwICAAELIAAgAygCCBD2BA8LIAFBCEYNAgsQAQALIAAgAygCDCADKAIAIAMtAAggAy0ACSADLgEGEMsBDwsgACAAEDwiBCADKAIIIAMoAgwQJiAECwkAIAAgAxCJAws8AQF+IAAQPCIEEA1FBEAgACAEQTwgAa1CgICAgHCEEA9BAxAbQQBOBEAgBA8LIAAgBBAMC0KAgICA4AALXwEBfwJAIAFFBEAgAkUNASAAIAIQpQUPCyACRQRAIAAgACgCAEEBazYCACAAIAAoAgRBCGs2AgQgARDpAQwBCyAAKAIIIAAoAgQgAmpPBH8gASACEPIFBUEACw8LQQALJgAgAQRAIAAgACgCAEEBazYCACAAIAAoAgRBCGs2AgQgARDpAQsLKAEBfwJAIAGnKAIgIgNFDQAgAygCAEEERg0AIAAgA0EIaiACEO8DCwscAQF/IAFBKBBAIgIEQCAAIAIQ7QMgACACECELCyUBAX8gAacoAiAiAwRAIAAgAykDACACECMgACADKQMIIAIQIwsLJwEBfyABpygCICICBEAgACACKQMAECcgACACKQMIECcgACACECELCx4BAX8gAacoAiAiAgRAIAAgAikDABAnIAAgAhAhCwtDAQJ/IAGnKAIgIgIEQAJAIAIpAwAiARDdBUUNACACKAIMIgNFDQAgACADEPEDIAIpAwAhAQsgACABECcgACACECELC1gBA38CQCABpygCICIERQ0AIARBCGohAyAEQQRqIQUDQCADKAIAIgMgBUYNASAEKAIARQRAIAAgAykDECACECMLIAAgAykDGCACECMgA0EEaiEDDAALAAsLgQEBBX8gAacoAiAiAgRAIAJBBGohBSACKAIIIQMDQCADIAVHBEAgAygCBCEGIANBEGshBCADQQxrKAIARQRAAkAgAigCAARAIAQQpgUMAQsgACAEKQMgECcLIAAgBCkDKBAnCyAAIAQQISAGIQMMAQsLIAAgAigCEBAhIAAgAhAhCwshAQF/IAGnKAIgIgMEQCAAIAM1AgxCgICAgHCEIAIQIwsLQAEBfyABpygCICICBEAgACACNQIMQoCAgIBwhCIBEN0FBH4gAhBGIAI1AgxCgICAgHCEBSABCxAnIAAgAhAhCwtbAQJ/IAGnKAIgIgIEQAJAAkAgAi0ABUUNACAAKAK8ASIDRQ0AIAAoAsQBIAIoAgggAxEDAAwBCyACKAIYIgNFDQAgACACKAIUIAIoAgggAxEGAAsgACACECELCykBAX8gACABpyICNQIkQoCAgICQf4QQJyAAIAI1AiBCgICAgJB/hBAnCxEAIAAgAacoAiApAwAgAhAjCxkBAX8gACABpygCICICKQMAECcgACACECELOgECfwJAIAFBDxBAIgRFDQADQCADIAQtAAVPDQEgACAEIANBA3RqKQMIIAIQIyADQQFqIQMMAAsACws8AQJ/IAFBDxBAIgMEQANAIAIgAy0ABU9FBEAgACADIAJBA3RqKQMIECcgAkEBaiECDAELCyAAIAMQIQsLSQECfyAAIAGnKAIgIgQpAwAgAhAjIAAgBCkDCCACECMDQCADIAQoAhBORQRAIAAgBCADQQN0aikDGCACECMgA0EBaiEDDAELCwtJAQJ/IAAgAacoAiAiAikDABAnIAAgAikDCBAnA0AgAyACKAIQTkUEQCAAIAIgA0EDdGopAxgQJyADQQFqIQMMAQsLIAAgAhAhC44BAQR/IAGnIgMoAiQhBSADKAIgIQQgAygCKCIDBEAgACADrUKAgICAcIQgAhAjCyAEBEACQCAFRQ0AQQAhAwNAIAMgBCgCPE4NAQJAIAUgA0ECdGooAgAiBkUNACAGLQAFQQFxRQ0AIAAgBiACEQMACyADQQFqIQMMAAsACyAAIAStQoCAgIBghCACECMLC3MBA38gAaciAigCKCIDBEAgACADrUKAgICAcIQQJwsgAigCICIDBEAgAigCJCIEBEBBACECA0AgAiADKAI8TkUEQCAAIAQgAkECdGooAgAQ+gEgAkEBaiECDAELCyAAIAQQIQsgACADrUKAgICAYIQQJwsLEgAgAacoAiAiAARAIAAQrgMLCw4AIAAgAacpAyAgAhAjCxkAIAAgAaciACkDIBAnIABCgICAgDA3AyALNQECfyABpyEEA0AgAyAEKAIoT0UEQCAAIAQoAiQgA0EDdGopAwAgAhAjIANBAWohAwwBCwsLPQEDfyABpyEDA0AgAygCJCEEIAIg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KQwBCyABIQgLIAAgBhAMIAAgBxAMCyAKQSBqJAAgCCEGDAELQoCAgIDgACEGIAAgCUEYaiABQdoAEIcBIgVFDQAgCSkDGCEHIAUtABBFBEAgACAHEAwgAEGpNkEAEBYMAQsgBxASBEAgACAFKQMAIAIgAyAEECQhBgwBCyAAIAMgBBCRAyIIEA1FBEAgBSkDACEBIAkgCDcDECAJIAI3AwggCSABNwMAIAAgByAFKQMIQQMgCRAkIQYLIAAgBxAMIAAgCBAMCyAJQSBqJAAgBgsFACAAmwuDAgMCfAJ/AX4gAL0iBUIgiKdB/////wdxIgNBgIDA/wdPBEAgACAAoA8LQZPx/dQCIQQCQCADQf//P00EQEGT8f3LAiEEIABEAAAAAAAAUEOivSIFQiCIp0H/////B3EiA0UNAQsgBUKAgICAgICAgIB/gyADQQNuIARqrUIghoS/IgIgAqIgAiAAo6IiASABIAGioiABRNft5NQAsMI/okTZUee+y0Tov6CiIAEgAUTC1klKYPH5P6JEICTwkuAo/r+gokSS5mEP5gP+P6CgIAKivUKAgICACHxCgICAgHyDvyIBIAAgASABoqMiACABoSABIAGgIACgo6IgAaAhAAsgAAuHAQMBfgF/AXwgAL0iAUL///////////8Ag78hAAJAAnwgAUI0iKdB/w9xIgJB/QdNBEAgAkHfB0kNAiAAIACgIgMgAyAAokQAAAAAAADwPyAAoaOgDAELIABEAAAAAAAA8D8gAKGjIgAgAKALELMDRAAAAAAAAOA/oiEACyAAmiAAIAFCAFMbC6gDAgV/AX4gAL1C////////////AINCgYCAgICAgPj/AFQgAb1C////////////AINCgICAgICAgPj/AFhxRQRAIAAgAaAPCyABvSIHQiCIpyICQYCAwP8DayAHpyIFckUEQCAAELIEDwsgAkEedkECcSIGIAC9IgdCP4inciEDAkAgB0IgiKdB/////wdxIgQgB6dyRQRAAkACQCADQQJrDgIAAQMLRBgtRFT7IQlADwtEGC1EVPshCcAPCyACQf////8HcSICIAVyRQRARBgtRFT7Ifk/IACmDwsCQCACQYCAwP8HRgRAIARBgIDA/wdHDQEgA0EDdEHQhARqKwMADwsgBEGAgMD/B0cgAkGAgIAgaiAET3FFBEBEGC1EVPsh+T8gAKYPCwJ8IAYEQEQAAAAAAAAAACAEQYCAgCBqIAJJDQEaCyAAIAGjmRCyBAshAAJAAkACQCADDgMEAAECCyAAmg8LRBgtRFT7IQlAIABEB1wUMyamobygoQ8LIABEB1wUMyamobygRBgtRFT7IQnAoA8LIANBA3RB8IQEaisDACEACyAAC7IBAwF+AX8BfCAAvSIBQv///////////wCDvyEAAkAgAUI0iKdB/w9xIgJBmQhPBEAgABDaAkTvOfr+Qi7mP6AhAAwBCyACQYAITwRAIAAgAKBEAAAAAAAA8D8gACAAokQAAAAAAADwP6CfIACgo6AQ2gIhAAwBCyACQeUHSQ0AIAAgAKIiAyADRAAAAAAAAPA/oJ9EAAAAAAAA8D+goyAAoBCzAyEACyAAmiAAIAFCAFMbC7kCAwF/A3wBfiAAvSIFQiCIp0H/////B3EiAUGAgMD/A08EQCAFpyABQYCAwP8Da3JFBEAgAEQYLURU+yH5P6JEAAAAAAAAcDigDwtEAAAAAAAAAAAgACAAoaMPCwJAIAFB/////gNNBEAgAUGAgEBqQYCAgPIDSQ0BIAAgACAAohCnAqIgAKAPC0QAAAAAAADwPyAAmaFEAAAAAAAA4D+iIgOfIQAgAxCnAiEEAnwgAUGz5rz/A08EQEQYLURU+yH5PyAAIASiIACgIgAgAKBEB1wUMyamkbygoQwBC0QYLURU+yHpPyAAvUKAgICAcIO/IgIgAqChIAAgAKAgBKJEB1wUMyamkTwgAyACIAKioSAAIAKgoyIAIACgoaGhRBgtRFT7Iek/oAsiAJogACAFQgBTGyEACyAAC3YBAX8gAL1CNIinQf8PcSIBQf8HTQRAIABEAAAAAAAA8L+gIgAgACAAoiAAIACgoJ+gELMDDwsgAUGYCE0EQCAAIACgRAAAAAAAAPC/IAAgAKJEAAAAAAAA8L+gnyAAoKOgENoCDwsgABDaAkTvOfr+Qi7mP6ALWgIBfwF+AkBBsLMEKAIABEBBtLMEKAIAIQIMAQtBsLMEENYFIgI2AgBBtLMEIAIQ4AQiAjYCAAsgAiAAIAAQQ0Gt7wAQtgUiAyABEKcDGkG0swQoAgAgAxAMCwuvpgRRAEGACAvheygpe30AKCl7c3VwZXIoLi4uYXJndW1lbnRzKTt9ACgpIHsKICAgIFtuYXRpdmUgY29kZV0KfQBjYW5ub3QgbWl4ID8/IHdpdGggJiYgb3IgfHwAcHJveHk6IHByb3BlcnR5IG5vdCBwcmVzZW50IGluIHRhcmdldCB3ZXJlIHJldHVybmVkIGJ5IG5vbiBleHRlbnNpYmxlIHByb3h5AHJldm9rZWQgcHJveHkAUHJveHkAYWRkX3Byb3BlcnR5AHByb3h5OiBjYW5ub3Qgc2V0IHByb3BlcnR5AG5vIHNldHRlciBmb3IgcHJvcGVydHkAdmFsdWUgaGFzIG5vIHByb3BlcnR5AGNvdWxkIG5vdCBkZWxldGUgcHJvcGVydHkAcHJveHk6IGR1cGxpY2F0ZSBwcm9wZXJ0eQBKU19EZWZpbmVBdXRvSW5pdFByb3BlcnR5AGhhc093blByb3BlcnR5AHByb3h5OiBpbmNvbnNpc3RlbnQgZGVsZXRlUHJvcGVydHkAcHJveHk6IGluY29uc2lzdGVudCBkZWZpbmVQcm9wZXJ0eQBKU19EZWZpbmVQcm9wZXJ0eQAhbXItPmVtcHR5AGluZmluaXR5AEluZmluaXR5AG91dCBvZiBtZW1vcnkAdW5rbm93biB1bmljb2RlIGdlbmVyYWwgY2F0ZWdvcnkAR2VuZXJhbF9DYXRlZ29yeQBldmVyeQBhbnkAYXBwbHkAJyVzJyBpcyByZWFkLW9ubHkAZXhwZWN0aW5nIGNhdGNoIG9yIGZpbmFsbHkAc3RpY2t5AHN0cmluZ2lmeQBzdWJhcnJheQBlbXB0eSBhcnJheQBub24gaW50ZWdlciBpbmRleCBpbiB0eXBlZCBhcnJheQBuZWdhdGl2ZSBpbmRleCBpbiB0eXBlZCBhcnJheQBvdXQtb2YtYm91bmQgaW5kZXggaW4gdHlwZWQgYXJyYXkAY2Fubm90IGNyZWF0ZSBudW1lcmljIGluZGV4IGluIHR5cGVkIGFycmF5AGlzQXJyYXkAVHlwZWRBcnJheQBnZXREYXkAZ2V0VVRDRGF5AGpzX2dldF9hdG9tX2luZGV4AGludmFsaWQgYXJyYXkgaW5kZXgAb3V0LW9mLWJvdW5kIG51bWVyaWMgaW5kZXgASlNfQXRvbUlzQXJyYXlJbmRleABmaW5kSW5kZXgAaW52YWxpZCBleHBvcnQgc3ludGF4AGludmFsaWQgYXNzaWdubWVudCBzeW50YXgAbWF4AFx1JTA0eABpbnZhbGlkIG9wY29kZTogcGM9JXUgb3Bjb2RlPTB4JTAyeAAtKyAgIDBYMHgALTBYKzBYIDBYLTB4KzB4IDB4AGxpbmUgdGVybWluYXRvciBub3QgYWxsb3dlZCBhZnRlciB0aHJvdwBwb3cAbm93AHN0YWNrIG92ZXJmbG93AG11c3QgYmUgY2FsbGVkIHdpdGggbmV3AGlzVmlldwBEYXRhVmlldwByYXcAJXUAY2xhc3MgZGVjbGFyYXRpb25zIGNhbid0IGFwcGVhciBpbiBzaW5nbGUtc3RhdGVtZW50IGNvbnRleHQAZnVuY3Rpb24gZGVjbGFyYXRpb25zIGNhbid0IGFwcGVhciBpbiBzaW5nbGUtc3RhdGVtZW50IGNvbnRleHQAbGV4aWNhbCBkZWNsYXJhdGlvbnMgY2FuJ3QgYXBwZWFyIGluIHNpbmdsZS1zdGF0ZW1lbnQgY29udGV4dABkdXBsaWNhdGUgYXJndW1lbnQgbmFtZXMgbm90IGFsbG93ZWQgaW4gdGhpcyBjb250ZXh0AGR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZXMgbm90IGFsbG93ZWQgaW4gdGhpcyBjb250ZXh0AGltcG9ydC5tZXRhIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBjb250ZXh0AEpTX0ZyZWVDb250ZXh0AEpTQ29udGV4dABqc19tYXBfaXRlcmF0b3JfbmV4dABqc19hc3luY19nZW5lcmF0b3JfcmVzdW1lX25leHQAdW5leHBlY3RlZCBlbmQgb2YgaW5wdXQAdHQAZXhwb3J0ZWQgdmFyaWFibGUgJyVzJyBkb2VzIG5vdCBleGlzdABwcml2YXRlIGNsYXNzIGZpZWxkICclcycgZG9lcyBub3QgZXhpc3QAdGVzdABhc3NpZ25tZW50IHJlc3QgcHJvcGVydHkgbXVzdCBiZSBsYXN0AHNxcnQAc29ydABjYnJ0AHRyaW1TdGFydABwYWRTdGFydAB1bmtub3duIHVuaWNvZGUgc2NyaXB0AFNjcmlwdABoeXBvdABmcmVlX3plcm9fcmVmY291bnQAc3RyX2luZGV4ID09IG51bV9rZXlzX2NvdW50ICsgc3RyX2tleXNfY291bnQAbnVtX2luZGV4ID09IG51bV9rZXlzX2NvdW50AHN5bV9pbmRleCA9PSBhdG9tX2NvdW50AGxhYmVsID49IDAgJiYgbGFiZWwgPCBzLT5sYWJlbF9jb3VudABsYWIxID49IDAgJiYgbGFiMSA8IHMtPmxhYmVsX2NvdW50AHZhbCA8IHMtPmNhcHR1cmVfY291bnQAdmFsMiA8IHMtPmNhcHR1cmVfY291bnQAaW52YWxpZCByZXBlYXQgY291bnQAaW52YWxpZCByZXBldGl0aW9uIGNvdW50AGZvbnQAaW52YWxpZCBjb2RlIHBvaW50AGZyb21Db2RlUG9pbnQAaW52YWxpZCBoaW50AGVuY29kZVVSSUNvbXBvbmVudABkZWNvZGVVUklDb21wb25lbnQAdW5leHBlY3RlZCBlbmQgb2YgY29tbWVudABpbnZhbGlkIHN3aXRjaCBzdGF0ZW1lbnQAcGFyc2VJbnQAZHVwbGljYXRlIGRlZmF1bHQAc3BsaXQAZXhwZWN0aW5nIGhleCBkaWdpdAB0cmltUmlnaHQAcmVkdWNlUmlnaHQAdW5zaGlmdAB0cmltTGVmdABpbnZhbGlkIG9mZnNldABpbnZhbGlkIGJ5dGVPZmZzZXQAZ2V0VGltZXpvbmVPZmZzZXQAcmVzb2x2aW5nIGZ1bmN0aW9uIGFscmVhZHkgc2V0AHByb3h5OiBpbmNvbnNpc3RlbnQgc2V0AGZpbmRfanVtcF90YXJnZXQAZXhwZWN0aW5nIHRhcmdldABpbnZhbGlkIGRlc3RydWN0dXJpbmcgdGFyZ2V0AHByb3h5OiBpbmNvbnNpc3RlbnQgZ2V0AFdlYWtTZXQAY29uc3RydWN0AEpTX0ZyZWVBdG9tU3RydWN0AHVzZSBzdHJpY3QAUmVmbGVjdAByZWplY3QAbm90IGFuIEFzeW5jR2VuZXJhdG9yIG9iamVjdABjYW5ub3QgY29udmVydCB0byBvYmplY3QAaW52YWxpZCBicmFuZCBvbiBvYmplY3QAb3BlcmFuZCAncHJvdG90eXBlJyBwcm9wZXJ0eSBpcyBub3QgYW4gb2JqZWN0AHJlY2VpdmVyIGlzIG5vdCBhbiBvYmplY3QAaXRlcmF0b3IgbXVzdCByZXR1cm4gYW4gb2JqZWN0AG5vdCBhIERhdGUgb2JqZWN0AG5vdCBhIG9iamVjdABKU09iamVjdABwYXJzZUZsb2F0AGZsYXQAbm90aGluZyB0byByZXBlYXQAY29uY2F0AGNvZGVQb2ludEF0AGNoYXJBdABjaGFyQ29kZUF0AGtleXMAcHJveHk6IHRhcmdldCBwcm9wZXJ0eSBtdXN0IGJlIHByZXNlbnQgaW4gcHJveHkgb3duS2V5cwAgIGZhc3QgYXJyYXlzAGV4cG9ydCAnJXMnIGluIG1vZHVsZSAnJXMnIGlzIGFtYmlndW91cwBwcml2YXRlIGNsYXNzIGZpZWxkICclcycgYWxyZWFkeSBleGlzdHMAdG9vIG1hbnkgYXJndW1lbnRzAFRvbyBtYW55IGNhbGwgYXJndW1lbnRzACAgZWxlbWVudHMAaW52YWxpZCBudW1iZXIgb2YgZGlnaXRzAGJpbmFyeSBvYmplY3RzAGludmFsaWQgcHJvcGVydHkgYWNjZXNzAGpzX29wX2RlZmluZV9jbGFzcwBmZC0+Ynl0ZV9jb2RlLmJ1ZltkZWZpbmVfY2xhc3NfcG9zXSA9PSBPUF9kZWZpbmVfY2xhc3MAX19nZXRDbGFzcwBzZXRIb3VycwBnZXRIb3VycwBzZXRVVENIb3VycwBnZXRVVENIb3VycwBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzAHRvbyBtYW55IGltYnJpY2F0ZWQgcXVhbnRpZmllcnMAdW5pY29kZV9wcm9wX29wcwBhY29zAGZvciBhd2FpdCBpcyBvbmx5IHZhbGlkIGluIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMAbmV3LnRhcmdldCBvbmx5IGFsbG93ZWQgd2l0aGluIGZ1bmN0aW9ucwBieXRlY29kZSBmdW5jdGlvbnMAQyBmdW5jdGlvbnMAcHJveHk6IGluY29uc2lzdGVudCBwcmV2ZW50RXh0ZW5zaW9ucwBTY3JpcHRfRXh0ZW5zaW9ucwBhdG9tcwBwcm94eTogcHJvcGVydGllcyBtdXN0IGJlIHN0cmluZ3Mgb3Igc3ltYm9scwBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMAcmVzb2x2ZV9sYWJlbHMASlNfRXZhbFRoaXMAc3RyaW5ncwBpbnZhbGlkIGRlc2NyaXB0b3IgZmxhZ3MAaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ3MAdmFsdWVzAHNldE1pbnV0ZXMAZ2V0TWludXRlcwBzZXRVVENNaW51dGVzAGdldFVUQ01pbnV0ZXMAdG9vIG1hbnkgY2FwdHVyZXMAICBzaGFwZXMAZ2V0T3duUHJvcGVydHlOYW1lcwBnY19mcmVlX2N5Y2xlcwBhZGRfZXZhbF92YXJpYWJsZXMAcmVzb2x2ZV92YXJpYWJsZXMAdG9vIG1hbnkgbG9jYWwgdmFyaWFibGVzAHRvbyBtYW55IGNsb3N1cmUgdmFyaWFibGVzAGNvbXBhY3RfcHJvcGVydGllcwAgIHByb3BlcnRpZXMAZGVmaW5lUHJvcGVydGllcwBlbnRyaWVzAGZyb21FbnRyaWVzAHRvbyBtYW55IHJhbmdlcwBpbmNsdWRlcwBzZXRNaWxsaXNlY29uZHMAZ2V0TWlsbGlzZWNvbmRzAHNldFVUQ01pbGxpc2Vjb25kcwBnZXRVVENNaWxsaXNlY29uZHMAc2V0U2Vjb25kcwBnZXRTZWNvbmRzAHNldFVUQ1NlY29uZHMAZ2V0VVRDU2Vjb25kcwBpdGFsaWNzAGFicwBwcm94eTogaW5jb25zaXN0ZW50IGhhcwAlLipzACAoJXMAc2V0ICVzAGdldCAlcwAgICAgYXQgJXMAbm90IGEgJXMAdW5zdXBwb3J0ZWQga2V5d29yZDogJXMAc3Vic3RyAHByb3h5OiBpbmNvbnNpc3RlbnQgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yAHN1cGVyKCkgaXMgb25seSB2YWxpZCBpbiBhIGRlcml2ZWQgY2xhc3MgY29uc3RydWN0b3IAcGFyZW50IGNsYXNzIG11c3QgYmUgY29uc3RydWN0b3IAbm90IGEgY29uc3RydWN0b3IAQXJyYXkgSXRlcmF0b3IAU2V0IEl0ZXJhdG9yAE1hcCBJdGVyYXRvcgBSZWdFeHAgU3RyaW5nIEl0ZXJhdG9yAG5vdCBhbiBBc3luYy1mcm9tLVN5bmMgSXRlcmF0b3IAY2Fubm90IGludm9rZSBhIHJ1bm5pbmcgZ2VuZXJhdG9yAG5vdCBhIGdlbmVyYXRvcgBBc3luY0dlbmVyYXRvcgBzeW50YXggZXJyb3IAU3ludGF4RXJyb3IARXZhbEVycm9yAEludGVybmFsRXJyb3IAQWdncmVnYXRlRXJyb3IAVHlwZUVycm9yAFJhbmdlRXJyb3IAUmVmZXJlbmNlRXJyb3IAVVJJRXJyb3IAZmxvb3IAZm9udGNvbG9yAGFuY2hvcgBmb3IAa2V5Rm9yAGV4cGVjdGluZyBzdXJyb2dhdGUgcGFpcgBhIGRlY2xhcmF0aW9uIGluIHRoZSBoZWFkIG9mIGEgZm9yLSVzIGxvb3AgY2FuJ3QgaGF2ZSBhbiBpbml0aWFsaXplcgAnYXJndW1lbnRzJyBpZGVudGlmaWVyIGlzIG5vdCBhbGxvd2VkIGluIGNsYXNzIGZpZWxkIGluaXRpYWxpemVyAGludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgZ2V0dGVyIG9yIHNldHRlcgBpbnZhbGlkIHNldHRlcgBpbnZhbGlkIGdldHRlcgBmaWx0ZXIAbWlzc2luZyBmb3JtYWwgcGFyYW1ldGVyACJ1c2Ugc3RyaWN0IiBub3QgYWxsb3dlZCBpbiBmdW5jdGlvbiB3aXRoIGRlZmF1bHQgb3IgZGVzdHJ1Y3R1cmluZyBwYXJhbWV0ZXIAaW52YWxpZCBjaGFyYWN0ZXIAdW5leHBlY3RlZCBjaGFyYWN0ZXIAcHJpdmF0ZSBjbGFzcyBmaWVsZCBmb3JiaWRkZW4gYWZ0ZXIgc3VwZXIAaW52YWxpZCByZWRlZmluaXRpb24gb2YgbGV4aWNhbCBpZGVudGlmaWVyACdsZXQnIGlzIG5vdCBhIHZhbGlkIGxleGljYWwgaWRlbnRpZmllcgBpbnZhbGlkIHJlZGVmaW5pdGlvbiBvZiBnbG9iYWwgaWRlbnRpZmllcgB5aWVsZCBpcyBhIHJlc2VydmVkIGlkZW50aWZpZXIAJyVzJyBpcyBhIHJlc2VydmVkIGlkZW50aWZpZXIAb3RoZXIAYXRvbTFfaXNfaW50ZWdlciAmJiBhdG9tMl9pc19pbnRlZ2VyAGlzSW50ZWdlcgBpc1NhZmVJbnRlZ2VyAGJ1ZmZlcgBTaGFyZWRBcnJheUJ1ZmZlcgBjYW5ub3QgdXNlIGlkZW50aWNhbCBBcnJheUJ1ZmZlcgBjYW5ub3QgY29udmVydCBzeW1ib2wgdG8gbnVtYmVyAG5vdCBhIG51bWJlcgBsaW5lTnVtYmVyAG1hbGZvcm1lZCB1bmljb2RlIGNoYXIAY2xlYXIAc2V0WWVhcgBnZXRZZWFyAHNldEZ1bGxZZWFyAGdldEZ1bGxZZWFyAHNldFVUQ0Z1bGxZZWFyAGdldFVUQ0Z1bGxZZWFyAHVuZXhwZWN0ZWQgbGluZSB0ZXJtaW5hdG9yIGluIHJlZ2V4cAB1bmV4cGVjdGVkIGVuZCBvZiByZWdleHAAUmVnRXhwAHN1cABpbnZhbGlkIGdyb3VwAHBvcABjb250aW51ZSBtdXN0IGJlIGluc2lkZSBsb29wAGR1bXAAbnVtX2tleXNfY21wAHVzZSBzdHJpcABtYXAAZmxhdE1hcABXZWFrTWFwAGV4cGVjdGluZyAneycgYWZ0ZXIgXHAAbG9nMXAAaGFzT3duAGl0ZXJhdG9yX2Nsb3NlX3JldHVybgBwcm9taXNlIHNlbGYgcmVzb2x1dGlvbgBvdXQgb2YgbWVtb3J5IGluIHJlZ2V4cCBleGVjdXRpb24AZGVzY3JpcHRpb24AcHJveHk6IGRlZmluZVByb3BlcnR5IGV4Y2VwdGlvbgBqc19hc3luY19nZW5lcmF0b3JfcmVzb2x2ZV9mdW5jdGlvbgBqc19jcmVhdGVfZnVuY3Rpb24Ac2V0L2FkZCBpcyBub3QgYSBmdW5jdGlvbgByZXR1cm4gbm90IGluIGEgZnVuY3Rpb24AQXN5bmNHZW5lcmF0b3JGdW5jdGlvbgBjYWxsRXh0ZXJuYWxGdW5jdGlvbgBBc3luY0Z1bmN0aW9uAGF3YWl0IGluIGRlZmF1bHQgZXhwcmVzc2lvbgB5aWVsZCBpbiBkZWZhdWx0IGV4cHJlc3Npb24AaW52YWxpZCBkZWNpbWFsIGVzY2FwZSBpbiByZWd1bGFyIGV4cHJlc3Npb24AYmFjayByZWZlcmVuY2Ugb3V0IG9mIHJhbmdlIGluIHJlZ3VsYXIgZXhwcmVzc2lvbgBpbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSBpbiByZWd1bGFyIGV4cHJlc3Npb24AZXhwZWN0ZWQgJ29mJyBvciAnaW4nIGluIGZvciBjb250cm9sIGV4cHJlc3Npb24AdG9vIGNvbXBsaWNhdGVkIGRlc3RydWN0dXJpbmcgZXhwcmVzc2lvbgBleHBlY3RlZCAnfScgYWZ0ZXIgdGVtcGxhdGUgZXhwcmVzc2lvbgB0b1ByZWNpc2lvbgBhc2luAGpvaW4AbWluAGNvcHlXaXRoaW4AdGVtcGxhdGUgbGl0ZXJhbCBjYW5ub3QgYXBwZWFyIGluIGFuIG9wdGlvbmFsIGNoYWluAGNpcmN1bGFyIHByb3RvdHlwZSBjaGFpbgBhc3NpZ24AaXNGcm96ZW4AbWFya19jaGlsZHJlbgAocG9zICsgbGVuKSA8PSBiY19idWZfbGVuAHVuZXhwZWN0ZWQgZWxsaXBzaXMgdG9rZW4AdGhlbgBzZXR0ZXIgaXMgZm9yYmlkZGVuAG51bGwgb3IgdW5kZWZpbmVkIGFyZSBmb3JiaWRkZW4AYXRhbgBuYW4Abm90IGEgYm9vbGVhbgBCb29sZWFuAGdjX3NjYW4AYmFkIG5vcm1hbGl6YXRpb24gZm9ybQBKU19OZXdTeW1ib2xGcm9tQXRvbQBmcm9tAHJhbmRvbQB0cmltAGltdWwAbm90IGEgc3ltYm9sAFN5bWJvbABSZWdFeHAgZXhlYyBtZXRob2QgbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwAcGFyZW50IHByb3RvdHlwZSBtdXN0IGJlIGFuIG9iamVjdCBvciBudWxsAGNhbm5vdCBzZXQgcHJvcGVydHkgJyVzJyBvZiBudWxsAGNhbm5vdCByZWFkIHByb3BlcnR5ICclcycgb2YgbnVsbABOdWxsAGZpbGwAbmV3IEFycmF5QnVmZmVyIGlzIHRvbyBzbWFsbABUeXBlZEFycmF5IGxlbmd0aCBpcyB0b28gc21hbGwAY2FsbABkb3RBbGwAbWF0Y2hBbGwAcmVwbGFjZUFsbABjZWlsAHVwZGF0ZV9sYWJlbABiY19idWZbcG9zXSA9PSBPUF9sYWJlbABldmFsAGludmFsaWQgbnVtYmVyIGxpdGVyYWwAbWFsZm9ybWVkIGVzY2FwZSBzZXF1ZW5jZSBpbiBzdHJpbmcgbGl0ZXJhbABKU19TZXRQcm9wZXJ0eUludGVybmFsAEpTX0dldE93blByb3BlcnR5TmFtZXNJbnRlcm5hbABfX0pTX0V2YWxJbnRlcm5hbAB0b0V4cG9uZW50aWFsAHNlYWwAZ2xvYmFsAGJsaW5rAF9fZGF0ZV9jbG9jawBzdGFjawBscmVfZXhlY19iYWNrdHJhY2sAcy0+aXNfd2VhawBpAHNldE1vbnRoAGdldE1vbnRoAHNldFVUQ01vbnRoAGdldFVUQ01vbnRoAGludmFsaWQga2V5d29yZDogd2l0aABzdGFydHNXaXRoAGVuZHNXaXRoAHByb3AgPT0gSlNfQVRPTV9sZW5ndGgAaW52YWxpZCBhcnJheSBsZW5ndGgAaW52YWxpZCBhcnJheSBidWZmZXIgbGVuZ3RoAGludmFsaWQgbGVuZ3RoAGludmFsaWQgYnl0ZUxlbmd0aABNYXRoAHB1c2gAYWNvc2gASlNfUmVzaXplQXRvbUhhc2gAYXNpbmgAYXRhbmgAYnJlYWsgbXVzdCBiZSBpbnNpZGUgbG9vcCBvciBzd2l0Y2gAbWF0Y2gAY2F0Y2gAc2VhcmNoAGZvckVhY2gAbG9nAEFycmF5IHRvbyBsb25nAHN0cmluZyB0b28gbG9uZwBBcnJheSBsb28gbG9uZwBzdWJzdHJpbmcAY2Fubm90IGNvbnZlcnQgc3ltYm9sIHRvIHN0cmluZwB1bmV4cGVjdGVkIGVuZCBvZiBzdHJpbmcAbm90IGEgc3RyaW5nAGludmFsaWQgY2hhcmFjdGVyIGluIGEgSlNPTiBzdHJpbmcAdG9TdHJpbmcAdG9EYXRlU3RyaW5nAHRvTG9jYWxlRGF0ZVN0cmluZwB0b1RpbWVTdHJpbmcAdG9Mb2NhbGVUaW1lU3RyaW5nAHRvTG9jYWxlU3RyaW5nAHRvR01UU3RyaW5nAEpTU3RyaW5nAHRvSVNPU3RyaW5nAHRvVVRDU3RyaW5nAGR1cGxpY2F0ZSBpbXBvcnQgYmluZGluZwBpbnZhbGlkIGltcG9ydCBiaW5kaW5nAGJpZwByZWdleHAgbXVzdCBoYXZlIHRoZSAnZycgZmxhZwBvZgBpbmYAZGlmZiA9PSAoaW50OF90KWRpZmYAZGlmZiA9PSAoaW50MTZfdClkaWZmAGhyZWYAZ2NfZGVjcmVmAGZyZWVfdmFyX3JlZgBvcHRpbWl6ZV9zY29wZV9tYWtlX2dsb2JhbF9yZWYAcmVzZXRfd2Vha19yZWYAZGVsZXRlX3dlYWtfcmVmAG9wdGltaXplX3Njb3BlX21ha2VfcmVmAGluZGV4T2YAbGFzdEluZGV4T2YAdmFsdWVPZgBzZXRQcm90b3R5cGVPZgBnZXRQcm90b3R5cGVPZgBpc1Byb3RvdHlwZU9mACUuKmYAZm9udHNpemUAbmV3X3NpemUgPD0gc2gtPnByb3Bfc2l6ZQBkZXNjciA8IHJ0LT5hdG9tX3NpemUAYXRvbSA8IHJ0LT5hdG9tX3NpemUAY29tcHV0ZV9zdGFja19zaXplAG4gPCBidWZfc2l6ZQBub3JtYWxpemUAZnJlZXplAHJlc29sdmUAdG9QcmltaXRpdmUAcHV0X2x2YWx1ZQB1bmtub3duIHVuaWNvZGUgcHJvcGVydHkgdmFsdWUAcmVzdCBlbGVtZW50IGNhbm5vdCBoYXZlIGEgZGVmYXVsdCB2YWx1ZQBpbnZhbGlkIHJldCB2YWx1ZQBfX0pTX0F0b21Ub1ZhbHVlAF9fcXVvdGUAaXNGaW5pdGUAZGVsZXRlAGNyZWF0ZQBzZXREYXRlAGdldERhdGUAc2V0VVRDRGF0ZQBnZXRVVENEYXRlAEludmFsaWQgRGF0ZQByZXZlcnNlAHBhcnNlAHByb3h5IHByZXZlbnRFeHRlbnNpb25zIGhhbmRsZXIgcmV0dXJuZWQgZmFsc2UAUHJvbWlzZQB0b0xvd2VyQ2FzZQB0b0xvY2FsZUxvd2VyQ2FzZQB0b1VwcGVyQ2FzZQB0b0xvY2FsZVVwcGVyQ2FzZQBpZ25vcmVDYXNlAGxvY2FsZUNvbXBhcmUAcHJveHk6IGluY29uc2lzdGVudCBwcm90b3R5cGUAcHJveHk6IGJhZCBwcm90b3R5cGUAbm90IGEgcHJvdG90eXBlAGludmFsaWQgb2JqZWN0IHR5cGUAdW5lc2NhcGUAbm9uZQByZXN0IGVsZW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBvbmUAbXVsdGlsaW5lACAgcGMybGluZQBzb21lAEpTX0ZyZWVSdW50aW1lAEpTUnVudGltZQBzZXRUaW1lAGdldFRpbWUAc2V0X29iamVjdF9uYW1lAGV4cGVjdGluZyBwcm9wZXJ0eSBuYW1lAHVua25vd24gdW5pY29kZSBwcm9wZXJ0eSBuYW1lAGludmFsaWQgcHJvcGVydHkgbmFtZQBkdXBsaWNhdGUgX19wcm90b19fIHByb3BlcnR5IG5hbWUAaW52YWxpZCByZWRlZmluaXRpb24gb2YgcGFyYW1ldGVyIG5hbWUAZXhwZWN0aW5nIGdyb3VwIG5hbWUAZHVwbGljYXRlIGdyb3VwIG5hbWUAaW52YWxpZCBncm91cCBuYW1lAGR1cGxpY2F0ZSBsYWJlbCBuYW1lAGludmFsaWQgZmlyc3QgY2hhcmFjdGVyIG9mIHByaXZhdGUgbmFtZQBpbnZhbGlkIGxleGljYWwgdmFyaWFibGUgbmFtZQBpbnZhbGlkIG1ldGhvZCBuYW1lAGV4cGVjdGluZyBmaWVsZCBuYW1lAGludmFsaWQgZmllbGQgbmFtZQBjbGFzcyBzdGF0ZW1lbnQgcmVxdWlyZXMgYSBuYW1lAGZpbGVOYW1lAGNvbXBpbGUAb2JqZWN0IGlzIG5vdCBleHRlbnNpYmxlAHByb3h5OiBpbmNvbnNpc3RlbnQgaXNFeHRlbnNpYmxlAGNhbm5vdCBoYXZlIHNldHRlci9nZXR0ZXIgYW5kIHZhbHVlIG9yIHdyaXRhYmxlAHByb3BlcnR5IGlzIG5vdCBjb25maWd1cmFibGUAdmFsdWUgaXMgbm90IGl0ZXJhYmxlAHByb3BlcnR5SXNFbnVtZXJhYmxlAG1pc3NpbmcgaW5pdGlhbGl6ZXIgZm9yIGNvbnN0IHZhcmlhYmxlAGxleGljYWwgdmFyaWFibGUAaW52YWxpZCByZWRlZmluaXRpb24gb2YgYSB2YXJpYWJsZQByZXZvY2FibGUAc3RyaWtlAGludmFsaWQgY2xhc3MgcmFuZ2UAbWVzc2FnZQBhc3luY19mdW5jX2ZyZWUAaW52YWxpZCBsdmFsdWUgaW4gc3RyaWN0IG1vZGUAaW52YWxpZCB2YXJpYWJsZSBuYW1lIGluIHN0cmljdCBtb2RlAGNhbm5vdCBkZWxldGUgYSBkaXJlY3QgcmVmZXJlbmNlIGluIHN0cmljdCBtb2RlAG9jdGFsIGVzY2FwZSBzZXF1ZW5jZXMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlAG9jdGFsIGxpdGVyYWxzIGFyZSBkZXByZWNhdGVkIGluIHN0cmljdCBtb2RlAHVuaWNvZGUAICBieXRlY29kZQBKU0Z1bmN0aW9uQnl0ZWNvZGUAc2tpcF9kZWFkX2NvZGUAaW52YWxpZCBhcmd1bWVudCBuYW1lIGluIHN0cmljdCBjb2RlAGludmFsaWQgZnVuY3Rpb24gbmFtZSBpbiBzdHJpY3QgY29kZQBpbnZhbGlkIHJlZGVmaW5pdGlvbiBvZiBnbG9iYWwgaWRlbnRpZmllciBpbiBtb2R1bGUgY29kZQBpbXBvcnQubWV0YSBvbmx5IHZhbGlkIGluIG1vZHVsZSBjb2RlAGZyb21DaGFyQ29kZQBpbnZhbGlkIGZvciBpbi9vZiBsZWZ0IGhhbmQtc2lkZQBpbnZhbGlkIGFzc2lnbm1lbnQgbGVmdC1oYW5kIHNpZGUAcmVkdWNlAHNvdXJjZQAndGhpcycgY2FuIGJlIGluaXRpYWxpemVkIG9ubHkgb25jZQBwcm9wZXJ0eSBjb25zdHJ1Y3RvciBhcHBlYXJzIG1vcmUgdGhhbiBvbmNlAGludmFsaWQgVVRGLTggc2VxdWVuY2UAY2lyY3VsYXIgcmVmZXJlbmNlAHNsaWNlAHNwbGljZQByYWNlAHJlcGxhY2UAJSsuKmUAdW5leHBlY3RlZCAnYXdhaXQnIGtleXdvcmQAdW5leHBlY3RlZCAneWllbGQnIGtleXdvcmQAbWFwX2RlY3JlZl9yZWNvcmQAaXRlcmF0b3IgZG9lcyBub3QgaGF2ZSBhIHRocm93IG1ldGhvZABvYmplY3QgbmVlZHMgdG9JU09TdHJpbmcgbWV0aG9kACdzdXBlcicgaXMgb25seSB2YWxpZCBpbiBhIG1ldGhvZABmcm91bmQAYnJlYWsvY29udGludWUgbGFiZWwgbm90IGZvdW5kAG91dCBvZiBib3VuZABmaW5kAGJpbmQAaW52YWxpZCBpbmRleCBmb3IgYXBwZW5kAGV4dHJhbmVvdXMgY2hhcmFjdGVycyBhdCB0aGUgZW5kAHVuZXhwZWN0ZWQgZGF0YSBhdCB0aGUgZW5kAHVuZXhwZWN0ZWQgZW5kAGludmFsaWQgaW5jcmVtZW50L2RlY3JlbWVudCBvcGVyYW5kAGludmFsaWQgJ2luc3RhbmNlb2YnIHJpZ2h0IG9wZXJhbmQAaW52YWxpZCAnaW4nIG9wZXJhbmQAdHJpbUVuZABwYWRFbmQAYm9sZAAlbGxkAGdjX2RlY3JlZl9jaGlsZAByZXNvbHZlX3Njb3BlX3ByaXZhdGVfZmllbGQAY2Fubm90IGRlbGV0ZSBhIHByaXZhdGUgY2xhc3MgZmllbGQAZXhwZWN0aW5nIDxicmFuZD4gcHJpdmF0ZSBmaWVsZAAlcyBpcyBub3QgaW5pdGlhbGl6ZWQAZml4ZWQAdG9GaXhlZABzZXRfb2JqZWN0X25hbWVfY29tcHV0ZWQAcmVnZXggbm90IHN1cHBvcnRlZABldmFsIGlzIG5vdCBzdXBwb3J0ZWQAUmVnRXhwIGFyZSBub3Qgc3VwcG9ydGVkAGludGVycnVwdGVkACVzIG9iamVjdCBleHBlY3RlZABpZGVudGlmaWVyIGV4cGVjdGVkAGJ5dGVjb2RlIGZ1bmN0aW9uIGV4cGVjdGVkAHN0cmluZyBleHBlY3RlZABmcm9tIGNsYXVzZSBleHBlY3RlZABmdW5jdGlvbiBuYW1lIGV4cGVjdGVkAHZhcmlhYmxlIG5hbWUgZXhwZWN0ZWQAbWV0YSBleHBlY3RlZAByZWplY3RlZABtZW1vcnkgYWxsb2NhdGVkAG1lbW9yeSB1c2VkAGRlcml2ZWQgY2xhc3MgY29uc3RydWN0b3IgbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIHVuZGVmaW5lZABjYW5ub3Qgc2V0IHByb3BlcnR5ICclcycgb2YgdW5kZWZpbmVkAGNhbm5vdCByZWFkIHByb3BlcnR5ICclcycgb2YgdW5kZWZpbmVkAGZsYWdzIG11c3QgYmUgdW5kZWZpbmVkAFVuZGVmaW5lZABwcml2YXRlIGNsYXNzIGZpZWxkIGlzIGFscmVhZHkgZGVmaW5lZAAnJXMnIGlzIG5vdCBkZWZpbmVkAGdyb3VwIG5hbWUgbm90IGRlZmluZWQAYWxsU2V0dGxlZABmdWxmaWxsZWQAY2Fubm90IGJlIGNhbGxlZABpc1NlYWxlZAAhc2gtPmlzX2hhc2hlZAB2YXJfcmVmLT5pc19kZXRhY2hlZABBcnJheUJ1ZmZlciBpcyBkZXRhY2hlZABhZGQAJSswN2QAJTA0ZAAlMDJkJTAyZAAlMDJkLyUwMmQvJTAqZAAlLjNzICUuM3MgJTAyZCAlMCpkADolZABpbnZhbGlkIHRocm93IHZhciB0eXBlICVkAHNjAGpzX2RlZl9tYWxsb2MAdHJ1bmMAZ2MAZXhlYwAvdG1wL3F1aWNranMvcXVpY2tqcy5jAC90bXAvcXVpY2tqcy9saWJyZWdleHAuYwAvdG1wL3F1aWNranMvbGlidW5pY29kZS5jAHN1YgBwcm9taXNlX3JlYWN0aW9uX2pvYgBqc19wcm9taXNlX3Jlc29sdmVfdGhlbmFibGVfam9iAHJ3YQBfX2xvb2t1cFNldHRlcl9fAF9fZGVmaW5lU2V0dGVyX18AX19sb29rdXBHZXR0ZXJfXwBfX2RlZmluZUdldHRlcl9fAF9fcHJvdG9fXwBbU3ltYm9sLnNwbGl0XQBbU3ltYm9sLnNwZWNpZXNdAFtTeW1ib2wuaXRlcmF0b3JdAFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0AW1N5bWJvbC5tYXRjaEFsbF0AW1N5bWJvbC5tYXRjaF0AW1N5bWJvbC5zZWFyY2hdAFtTeW1ib2wudG9TdHJpbmdUYWddAFtTeW1ib2wudG9QcmltaXRpdmVdAFt1bnN1cHBvcnRlZCB0eXBlXQBbZnVuY3Rpb24gYnl0ZWNvZGVdAFtTeW1ib2wuaGFzSW5zdGFuY2VdAFtTeW1ib2wucmVwbGFjZV0AWwAlMDJkOiUwMmQ6JTAyZC4lMDNkWgBQT1NJVElWRV9JTkZJTklUWQBORUdBVElWRV9JTkZJTklUWQBwLT5jbGFzc19pZCA9PSBKU19DTEFTU19BUlJBWQBzdGFja19sZW4gPCBQT1BfU1RBQ0tfTEVOX01BWAAtJTAyZC0lMDJkVABKU19BdG9tR2V0U3RyUlQAb3Bjb2RlIDwgUkVPUF9DT1VOVABCWVRFU19QRVJfRUxFTUVOVAAlMDJkOiUwMmQ6JTAyZCBHTVQASlNfVkFMVUVfR0VUX1RBRyhzZi0+Y3VyX2Z1bmMpID09IEpTX1RBR19PQkpFQ1QAdmFyX2tpbmQgPT0gSlNfVkFSX1BSSVZBVEVfU0VUVEVSAE1BWF9TQUZFX0lOVEVHRVIATUlOX1NBRkVfSU5URUdFUgBpc05hTgBEYXRlIHZhbHVlIGlzIE5hTgB0b0pTT04ARVBTSUxPTgBOQU4AJTAyZDolMDJkOiUwMmQgJWNNAHMtPmxhYmVsX3Nsb3RzW2xhYmVsXS5maXJzdF9yZWxvYyA9PSBOVUxMAGxhYmVsX3Nsb3RzW2ldLmZpcnN0X3JlbG9jID09IE5VTEwAcHJzICE9IE5VTEwAc2YtPmN1cl9zcCAhPSBOVUxMAHNmICE9IE5VTEwAbXIxICE9IE5VTEwAdmFyX2tpbmQgIT0gSlNfVkFSX05PUk1BTABiLT5mdW5jX2tpbmQgPT0gSlNfRlVOQ19OT1JNQUwAZW5jb2RlVVJJAGRlY29kZVVSSQBQSQBzcGVjaWFsID09IFBVVF9MVkFMVUVfTk9LRUVQIHx8IHNwZWNpYWwgPT0gUFVUX0xWQUxVRV9OT0tFRVBfREVQVEgAcy0+c3RhdGUgPT0gSlNfQVNZTkNfR0VORVJBVE9SX1NUQVRFX0VYRUNVVElORwBJTkYAMDEyMzQ1Njc4OUFCQ0RFRgBTSVpFAE1BWF9WQUxVRQBNSU5fVkFMVUUATkFNRQBldmFsX3R5cGUgPT0gSlNfRVZBTF9UWVBFX0dMT0JBTCB8fCBldmFsX3R5cGUgPT0gSlNfRVZBTF9UWVBFX01PRFVMRQBwLT5nY19vYmpfdHlwZSA9PSBKU19HQ19PQkpfVFlQRV9KU19PQkpFQ1QgfHwgcC0+Z2Nfb2JqX3R5cGUgPT0gSlNfR0NfT0JKX1RZUEVfRlVOQ1RJT05fQllURUNPREUATE9HMkUATE9HMTBFAHMtPnN0YXRlID09IEpTX0FTWU5DX0dFTkVSQVRPUl9TVEFURV9BV0FJVElOR19SRVRVUk4gfHwgcy0+c3RhdGUgPT0gSlNfQVNZTkNfR0VORVJBVE9SX1NUQVRFX0NPTVBMRVRFRABVVEMAPGlucHV0PgA8aW5pdFNjcmlwdD4APGV2YWxTY3JpcHQ+ADxzZXQ+ADxhbm9ueW1vdXM+ADxjb21tRnVuPgA8Y2FsbEV4dGVybmFsRnVuY3Rpb24+ADxudWxsPgAmcXVvdDsAc2V0VWludDgAZ2V0VWludDgAc2V0SW50OABnZXRJbnQ4AG1hbGZvcm1lZCBVVEYtOAByYWRpeCBtdXN0IGJlIGJldHdlZW4gMiBhbmQgMzYAc2V0VWludDE2AGdldFVpbnQxNgBzZXRJbnQxNgBnZXRJbnQxNgBhcmdjID09IDUAc2V0RmxvYXQ2NABnZXRGbG9hdDY0AGFyZ2MgPT0gMwBhdGFuMgBsb2cyAFNRUlQxXzIAU1FSVDIATE4yAGNsejMyAHNldFVpbnQzMgBnZXRVaW50MzIAc2V0SW50MzIAZ2V0SW50MzIAc2V0RmxvYXQzMgBnZXRGbG9hdDMyAHN0YWNrX2xlbiA+PSAyAEpTX0F0b21Jc051bWVyaWNJbmRleDEAanNfZmN2dDEAZXhwbTEAbHMtPmFkZHIgPT0gLTEAc3RhY2tfbGVuID49IDEAcC0+c2hhcGUtPmhlYWRlci5yZWZfY291bnQgPT0gMQBzdGFja19sZW4gPT0gMQBqc19mcmVlX3NoYXBlMABsb2cxMABMTjEwAHAtPnJlZl9jb3VudCA+IDAAdmFyX3JlZi0+aGVhZGVyLnJlZl9jb3VudCA+IDAAc3RhY2tfc2l6ZSA+IDAAY3Bvb2xfaWR4ID49IDAAcnQtPmF0b21fY291bnQgPj0gMABscy0+cmVmX2NvdW50ID49IDAAcy0+aXNfZXZhbCB8fCBzLT5jbG9zdXJlX3Zhcl9jb3VudCA9PSAwAHAtPnJlZl9jb3VudCA9PSAwAGN0eC0+aGVhZGVyLnJlZl9jb3VudCA9PSAwAHNoLT5oZWFkZXIucmVmX2NvdW50ID09IDAAcC0+bWFyayA9PSAwAChwci0+dS5pbml0LnJlYWxtX2FuZF9pZCAmIDMpID09IDAAKG5ld19oYXNoX3NpemUgJiAobmV3X2hhc2hfc2l6ZSAtIDEpKSA9PSAwAGkgIT0gMABzaXplICE9IDAAXiRcLiorPygpW117fXwvADwvAG1pc3NpbmcgYmluZGluZyBwYXR0ZXJuLi4uAGFzeW5jIGZ1bmN0aW9uICoACn0pAGxpc3RfZW1wdHkoJnJ0LT5nY19vYmpfbGlzdCkAaiA9PSAoc2gtPnByb3BfY291bnQgLSBzaC0+ZGVsZXRlZF9wcm9wX2NvdW50KQBKU19Jc1VuZGVmaW5lZChmdW5jX3JldCkAIV9fSlNfQXRvbUlzVGFnZ2VkSW50KGRlc2NyKQAhYXRvbV9pc19mcmVlKHApAChudWxsKQAgKG5hdGl2ZSkAanNfY2xhc3NfaGFzX2J5dGVjb2RlKHAtPmNsYXNzX2lkKQB1bmNvbnNpc3RlbnQgc3RhY2sgc2l6ZTogJWQgJWQgKHBjPSVkKQBieXRlY29kZSBidWZmZXIgb3ZlcmZsb3cgKG9wPSVkLCBwYz0lZCkAc3RhY2sgb3ZlcmZsb3cgKG9wPSVkLCBwYz0lZCkAc3RhY2sgdW5kZXJmbG93IChvcD0lZCwgcGM9JWQpAGludmFsaWQgb3Bjb2RlIChvcD0lZCwgcGM9JWQpACg/OikAbm8gZnVuY3Rpb24gZmlsZW5hbWUgZm9yIGltcG9ydCgpAC1fLiF+KicoKQAgYW5vbnltb3VzKABTeW1ib2woAGV4cGVjdGluZyAnfScAY2xhc3MgY29uc3RydWN0b3JzIG11c3QgYmUgaW52b2tlZCB3aXRoICduZXcnAGV4cGVjdGluZyAnYXMnAHVuZXhwZWN0ZWQgdG9rZW4gaW4gZXhwcmVzc2lvbjogJyUuKnMnAHVuZXhwZWN0ZWQgdG9rZW46ICclLipzJwByZWRlY2xhcmF0aW9uIG9mICclcycAZHVwbGljYXRlIGV4cG9ydGVkIG5hbWUgJyVzJwBjaXJjdWxhciByZWZlcmVuY2Ugd2hlbiBsb29raW5nIGZvciBleHBvcnQgJyVzJyBpbiBtb2R1bGUgJyVzJwBDb3VsZCBub3QgZmluZCBleHBvcnQgJyVzJyBpbiBtb2R1bGUgJyVzJwBjb3VsZCBub3QgbG9hZCBtb2R1bGUgJyVzJwBjYW5ub3QgZGVmaW5lIHZhcmlhYmxlICclcycAdW5kZWZpbmVkIHByaXZhdGUgZmllbGQgJyVzJwB1bnN1cHBvcnRlZCByZWZlcmVuY2UgdG8gJ3N1cGVyJwBpbnZhbGlkIHVzZSBvZiAnc3VwZXInACdmb3IgYXdhaXQnIGxvb3Agc2hvdWxkIGJlIHVzZWQgd2l0aCAnb2YnAGV4cGVjdGluZyAnJWMnAHVucGFyZW50aGVzaXplZCB1bmFyeSBleHByZXNzaW9uIGNhbid0IGFwcGVhciBvbiB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgJyoqJwBpbnZhbGlkIHVzZSBvZiAnaW1wb3J0KCknAGV4cGVjdGluZyAlJQA7Lz86QCY9KyQsIwA9IgBzZXQgAGdldCAAW29iamVjdCAAYXN5bmMgZnVuY3Rpb24gAGJvdW5kIAAlLjNzLCAlMDJkICUuM3MgJTAqZCAAYXN5bmMgADogACAgICAgICAgICAACikgewoACkpTT2JqZWN0IGNsYXNzZXMKACUtMjBzICU4cyAlOHMKACAgJTVkICAlMi4wZCAlcwoAICAlM3UgKyAlLTJ1ICAlcwoAICBt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YWJsZQB2YWx1ZQBnZXQAc2V0AG9mAF9fcHJvdG9fXwB1bmRlZmluZWQAbnVtYmVyAGJvb2xlYW4Ac3RyaW5nAG9iamVjdABzeW1ib2wAaW50ZWdlcgB1bmtub3duAGFyZ3VtZW50cwBjYWxsZWUAY2FsbGVyADxldmFsPgA8cmV0PgA8dmFyPgA8YXJnX3Zhcj4APHdpdGg+AGxhc3RJbmRleAB0YXJnZXQAaW5kZXgAaW5wdXQAZGVmaW5lUHJvcGVydGllcwBhcHBseQBqb2luAGNvbmNhdABzcGxpdABjb25zdHJ1Y3QAZ2V0UHJvdG90eXBlT2YAc2V0UHJvdG90eXBlT2YAaXNFeHRlbnNpYmxlAHByZXZlbnRFeHRlbnNpb25zAGhhcwBkZWxldGVQcm9wZXJ0eQBkZWZpbmVQcm9wZXJ0eQBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IAb3duS2V5cwBhZGQAZG9uZQBuZXh0AHZhbHVlcwBzb3VyY2UAZmxhZ3MAZ2xvYmFsAHVuaWNvZGUAcmF3AG5ldy50YXJnZXQAdGhpcy5hY3RpdmVfZnVuYwA8aG9tZV9vYmplY3Q+ADxjb21wdXRlZF9maWVsZD4APHN0YXRpY19jb21wdXRlZF9maWVsZD4APGNsYXNzX2ZpZWxkc19pbml0PgA8YnJhbmQ+ACNjb25zdHJ1Y3RvcgBhcwBmcm9tAG1ldGEAKmRlZmF1bHQqACoATW9kdWxlAHRoZW4AcmVzb2x2ZQByZWplY3QAcHJvbWlzZQBwcm94eQByZXZva2UAYXN5bmMAZXhlYwBncm91cHMAc3RhdHVzAHJlYXNvbgBnbG9iYWxUaGlzAHRvSlNPTgBPYmplY3QAQXJyYXkARXJyb3IATnVtYmVyAFN0cmluZwBCb29sZWFuAFN5bWJvbABBcmd1bWVudHMATWF0aABKU09OAERhdGUARnVuY3Rpb24AR2VuZXJhdG9yRnVuY3Rpb24ARm9ySW5JdGVyYXRvcgBSZWdFeHAAQXJyYXlCdWZmZXIAU2hhcmVkQXJyYXlCdWZmZXIAVWludDhDbGFtcGVkQXJyYXkASW50OEFycmF5AFVpbnQ4QXJyYXkASW50MTZBcnJheQBVaW50MTZBcnJheQBJbnQzMkFycmF5AFVpbnQzMkFycmF5AEZsb2F0MzJBcnJheQBGbG9hdDY0QXJyYXkARGF0YVZpZXcATWFwAFNldABXZWFrTWFwAFdlYWtTZXQATWFwIEl0ZXJhdG9yAFNldCBJdGVyYXRvcgBBcnJheSBJdGVyYXRvcgBTdHJpbmcgSXRlcmF0b3IAUmVnRXhwIFN0cmluZyBJdGVyYXRvcgBHZW5lcmF0b3IAUHJveHkAUHJvbWlzZQBQcm9taXNlUmVzb2x2ZUZ1bmN0aW9uAFByb21pc2VSZWplY3RGdW5jdGlvbgBBc3luY0Z1bmN0aW9uAEFzeW5jRnVuY3Rpb25SZXNvbHZlAEFzeW5jRnVuY3Rpb25SZWplY3QAQXN5bmNHZW5lcmF0b3JGdW5jdGlvbgBBc3luY0dlbmVyYXRvcgBFdmFsRXJyb3IAUmFuZ2VFcnJvcgBSZWZlcmVuY2VFcnJvcgBTeW50YXhFcnJvcgBUeXBlRXJyb3IAVVJJRXJyb3IASW50ZXJuYWxFcnJvcgA8YnJhbmQ+AFN5bWJvbC50b1ByaW1pdGl2ZQBTeW1ib2wuaXRlcmF0b3IAU3ltYm9sLm1hdGNoAFN5bWJvbC5tYXRjaEFsbABTeW1ib2wucmVwbGFjZQBTeW1ib2wuc2VhcmNoAFN5bWJvbC5zcGxpdABTeW1ib2wudG9TdHJpbmdUYWcAU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZQBTeW1ib2wuaGFzSW5zdGFuY2UAU3ltYm9sLnNwZWNpZXMAU3ltYm9sLnVuc2NvcGFibGVzAFN5bWJvbC5hc3luY0l0ZXJhdG9yAAAAAAABAAAABQABFAUAARUFAAEVBQABFwUAARcBAAEAAQABAAEAAQABAAEAAQABAAEAAQACAAEFAwABCgEBAAABAgEAAQMCAAEBAgABAgMAAQIEAAEDBgABAgMAAQMEAAEEBQABAwMAAQQEAAEFBQABAgIAAQQEAAEDAwABAwMAAQQEAAEFBQADAgENAwEBDQMBAA0DAgENAwIADQMAAQ0DAwEKAQEAAAEAAAABAQIAAQAAAAECAgABAgAAAQEAAAEBAAAGAAAYBQEBDwMCAQoBAgEAAQEBAAEBAQAFAAEXBQABFwUAARcFAQAXBQEAFwUCABcBAgMAAQMAAAYAABgGAAAYBgEAGAUBARcFAQIXBQIAFwECAQABAwAAAQMB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AFCD4wBQA+UAQJDmAACB7gBAEu8AtAH4AFCD+ABAAvoAMAH7ADCB+wBAKPwAMAEQAUASEQExAR0BQIIdATCBHgExAR8BAYIfAUCCIAEwgSEBMAEiATCBIgFACiMBAQEoAQGBKAEBASkBAIEpAQABKgEAAisBAIEsAQCBLQEBAS4BAAEwAQGBMAEAgTEBAYEyAQEBMwEAATQBAIE0AQEBNQEBgTUBAQE2AQCBNwEBgTgBAAE5AQCBOgEBgT4BAAFAAQEBQQEAgUEBAYFDAQABRAEAgUQBAAJFAQABRgEAAUkBAYFOAQEBTwFzgaIBQAS4AUACuwEAg70BMIG/ATABwwEwA8QBMAHGATACxwHQAcgBMJHIATCJ0QEAAdYBAIPWAdMB2AEAkdgBcwHhAQCJ4QEAAeYBAILmATCB5wFzAegBc4HoAXOB6gFzAesBAIHrAUAY7AFzAfgBc4H4AQAB+QEAgfkBoAH6AXOB+gFAgvsBMIH8AUAC/QEwg/4BMBAAAjAgCAIAIBgCABAoAkAiMAJANkUCMAFgAkCOYAIAgWcCQGBoAjCmmAIAprACtYHDAjEmUAgxgWMIMYFmCAAraAgAg34IEVDQCRAG+AkgBvwJdAFADnSBQA50AUEOdIFBDnQBQg50gUIOdAFDDoCBQw6AAUQOMCtIDjCDXg4BgbwOAYG+DgEBxw5AfgAPQBg/D7UBSw+2gUsPtgFMD7aBTA+3AU0PgIFNDzABTw9AYFAPAAiADzAIhA8ABogPMAaMDwAIkA8wCJQPAAiYDzAInA8ABqAPMAakD7ABqA8AgagP0wGpDwCBqQ/TAaoPAIGqD9MBqw8AgasPMIGsDzCBrQ8wga4PMIGvDwAIsA8wCLQPAAK4DwAEuQ8AArsPAQK8DwECvQ8BAr4PtwjAD2cIxA+4CMgPaAjMD7gI0A9oCNQPAALYD7kB2Q+xgdkPuQHaD7EB2w/XgdsPMALcDzAC3Q9hAd4PcwHfD7kB4Q+ygeEPugHiD7IB4w/YgeMPMATkD2IB5g8AAugP0AHpD9CB6Q+wAesP0IHrDzAC7A8wAu0PAQLwD9MB8Q/TgfEPugHyDwGB8g+wAfMP04HzDzAC9A8wAvUPMQH2D7oB+Q+ygfkPuwH6D7IB+w/ZgfsPMAL8DzAC/Q9iAf4PoAGTEKABlRCggZUQMQGZEAEBpxAxELAQARC4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iacwH4CIiq2PQZQ4h4+Jt5WAjfkqAAgwB4mvIAgniUFIg2BLaInViaWEuoaYiUP0ALYz0ICKgWBMqoFSYK2BlkIdIi85hp2DQJOCRYixQf+2g7E4jYCVII5FTzCQDgEEQQSGiIlBY4C8jUXVhuw0iVKViWwFBUDv+gYAcAkA8ApAVwwA8A1Axw8A6hcgRRsgVSAgDKhgN6oAUP4AOg0BgxEBxBQhRBkhWh1Bn7xhsNoh8AEOAAAAAEFkbGFtLEFkbG0AQWhvbSxBaG9tAEFuYXRvbGlhbl9IaWVyb2dseXBocyxIbHV3AEFyYWJpYyxBcmFiAEFybWVuaWFuLEFybW4AQXZlc3RhbixBdnN0AEJhbGluZXNlLEJhbGkAQmFtdW0sQmFtdQBCYXNzYV9WYWgsQmFzcwBCYXRhayxCYXRrAEJlbmdhbGksQmVuZwBCaGFpa3N1a2ksQmhrcwBCb3BvbW9mbyxCb3BvAEJyYWhtaSxCcmFoAEJyYWlsbGUsQnJhaQBCdWdpbmVzZSxCdWdpAEJ1aGlkLEJ1aGQAQ2FuYWRpYW5fQWJvcmlnaW5hbCxDYW5zAENhcmlhbixDYXJpAENhdWNhc2lhbl9BbGJhbmlhbixBZ2hiAENoYWttYSxDYWttAENoYW0sQ2hhbQBDaGVyb2tlZSxDaGVyAENob3Jhc21pYW4sQ2hycwBDb21tb24sWnl5eQBDb3B0aWMsQ29wdCxRYWFjAEN1bmVpZm9ybSxYc3V4AEN5cHJpb3QsQ3BydABDeXJpbGxpYyxDeXJsAEN5cHJvX01pbm9hbixDcG1uAERlc2VyZXQsRHNydABEZXZhbmFnYXJpLERldmEARGl2ZXNfQWt1cnUsRGlhawBEb2dyYSxEb2dyAER1cGxveWFuLER1cGwARWd5cHRpYW5fSGllcm9nbHlwaHMsRWd5cABFbGJhc2FuLEVsYmEARWx5bWFpYyxFbHltAEV0aGlvcGljLEV0aGkAR2VvcmdpYW4sR2VvcgBHbGFnb2xpdGljLEdsYWcAR290aGljLEdvdGgAR3JhbnRoYSxHcmFuAEdyZWVrLEdyZWsAR3VqYXJhdGksR3VqcgBHdW5qYWxhX0dvbmRpLEdvbmcAR3VybXVraGksR3VydQBIYW4sSGFuaQBIYW5ndWwsSGFuZwBIYW5pZmlfUm9oaW5neWEsUm9oZwBIYW51bm9vLEhhbm8ASGF0cmFuLEhhdHIASGVicmV3LEhlYnIASGlyYWdhbmEsSGlyYQBJbXBlcmlhbF9BcmFtYWljLEFybWkASW5oZXJpdGVkLFppbmgsUWFhaQBJbnNjcmlwdGlvbmFsX1BhaGxhdmksUGhsaQBJbnNjcmlwdGlvbmFsX1BhcnRoaWFuLFBydGkASmF2YW5lc2UsSmF2YQBLYWl0aGksS3RoaQBLYW5uYWRhLEtuZGEAS2F0YWthbmEsS2FuYQBLYXlhaF9MaSxLYWxpAEtoYXJvc2h0aGksS2hhcgBLaG1lcixLaG1yAEtob2praSxLaG9qAEtoaXRhbl9TbWFsbF9TY3JpcHQsS2l0cwBLaHVkYXdhZGksU2luZABMYW8sTGFvbwBMYXRpbixMYXRuAExlcGNoYSxMZXBjAExpbWJ1LExpbWIATGluZWFyX0EsTGluYQBMaW5lYXJfQixMaW5iAExpc3UsTGlzdQBMeWNpYW4sTHljaQBMeWRpYW4sTHlkaQBNYWthc2FyLE1ha2EATWFoYWphbmksTWFoagBNYWxheWFsYW0sTWx5bQBNYW5kYWljLE1hbmQATWFuaWNoYWVhbixNYW5pAE1hcmNoZW4sTWFyYwBNYXNhcmFtX0dvbmRpLEdvbm0ATWVkZWZhaWRyaW4sTWVkZgBNZWV0ZWlfTWF5ZWssTXRlaQBNZW5kZV9LaWtha3VpLE1lbmQATWVyb2l0aWNfQ3Vyc2l2ZSxNZXJjAE1lcm9pdGljX0hpZXJvZ2x5cGhzLE1lcm8ATWlhbyxQbHJkAE1vZGksTW9kaQBNb25nb2xpYW4sTW9uZwBNcm8sTXJvbwBNdWx0YW5pLE11bHQATXlhbm1hcixNeW1yAE5hYmF0YWVhbixOYmF0AE5hbmRpbmFnYXJpLE5hbmQATmV3X1RhaV9MdWUsVGFsdQBOZXdhLE5ld2EATmtvLE5rb28ATnVzaHUsTnNodQBOeWlha2VuZ19QdWFjaHVlX0htb25nLEhtbnAAT2doYW0sT2dhbQBPbF9DaGlraSxPbGNrAE9sZF9IdW5nYXJpYW4sSHVuZwBPbGRfSXRhbGljLEl0YWwAT2xkX05vcnRoX0FyYWJpYW4sTmFyYgBPbGRfUGVybWljLFBlcm0AT2xkX1BlcnNpYW4sWHBlbwBPbGRfU29nZGlhbixTb2dvAE9sZF9Tb3V0aF9BcmFiaWFuLFNhcmIAT2xkX1R1cmtpYyxPcmtoAE9sZF9VeWdodXIsT3VncgBPcml5YSxPcnlhAE9zYWdlLE9zZ2UAT3NtYW55YSxPc21hAFBhaGF3aF9IbW9uZyxIbW5nAFBhbG15cmVuZSxQYWxtAFBhdV9DaW5fSGF1LFBhdWMAUGhhZ3NfUGEsUGhhZwBQaG9lbmljaWFuLFBobngAUHNhbHRlcl9QYWhsYXZpLFBobHAAUmVqYW5nLFJqbmcAUnVuaWMsUnVucgBTYW1hcml0YW4sU2FtcgBTYXVyYXNodHJhLFNhdXIAU2hhcmFkYSxTaHJkAFNoYXZpYW4sU2hhdwBTaWRkaGFtLFNpZGQAU2lnbldyaXRpbmcsU2dudwBTaW5oYWxhLFNpbmgAU29nZGlhbixTb2dkAFNvcmFfU29tcGVuZyxTb3JhAFNveW9tYm8sU295bwBTdW5kYW5lc2UsU3VuZABTeWxvdGlfTmFncmksU3lsbwBTeXJpYWMsU3lyYwBUYWdhbG9nLFRnbGcAVGFnYmFud2EsVGFnYgBUYWlfTGUsVGFsZQBUYWlfVGhhbSxMYW5hAFRhaV9WaWV0LFRhdnQAVGFrcmksVGFrcgBUYW1pbCxUYW1sAFRhbmd1dCxUYW5nAFRlbHVndSxUZWx1AFRoYWFuYSxUaGFhAFRoYWksVGhhaQBUaWJldGFuLFRpYnQAVGlmaW5hZ2gsVGZuZwBUaXJodXRhLFRpcmgAVGFuZ3NhLFRuc2EAVG90byxUb3RvAFVnYXJpdGljLFVnYXIAVmFpLFZhaWkAVml0aGt1cWksVml0aABXYW5jaG8sV2NobwBXYXJhbmdfQ2l0aSxXYXJhAFllemlkaSxZZXppAFlpLFlpaWkAWmFuYWJhemFyX1NxdWFyZSxaYW5iAAAAAAAAAMAZmUaFGZlGrhmARo4ZgEaEGZZGgBmeRoAZ4WBGphmERoQZgQ2TGeAPOIMsgBmCLAGDLIAZgCwDgCyAGYAsgBmCLACALACTLAC+LI0ajyzgJB2BOOBIHQClBQGxBQGCBQC2NQeaNQOFNQqEBIAZhQSAGY0EgBmCBIAZnwSAGYkEijiZBIA44AsEgBmhBI2JALuJAYKJrwSxkw26ZAGCZK19AY59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U2MsQ3VycmVuY3lfU3ltYm9sAFNrLE1vZGlmaWVyX1N5bWJvbABTbyxPdGhlcl9TeW1ib2wAUGMsQ29ubmVjdG9yX1B1bmN0dWF0aW9uAFBkLERhc2hfUHVuY3R1YXRpb24AUHMsT3Blbl9QdW5jdHVhdGlvbgBQZSxDbG9zZV9QdW5jdHVhdGlvbgBQaSxJbml0aWFsX1B1bmN0dWF0aW9uAFBmLEZpbmFsX1B1bmN0dWF0aW9uAFBvLE90aGVyX1B1bmN0dWF0aW9uAFpzLFNwYWNlX1NlcGFyYXRvcgBabCxMaW5lX1NlcGFyYXRvcgBacCxQYXJhZ3JhcGhfU2VwYXJhdG9yAENjLENvbnRyb2wsY250cmwAQ2YsRm9ybWF0AENzLFN1cnJvZ2F0ZQBDbyxQcml2YXRlX1VzZQBMQyxDYXNlZF9MZXR0ZXIATCxMZXR0ZXIATSxNYXJrLENvbWJpbmluZ19NYXJrAE4sTnVtYmVyAFMsU3ltYm9sAFAsUHVuY3R1YXRpb24scHVuY3QAWixTZXBhcmF0b3IAQyxPdGhlcgBBoLsCC7AIDgAAAD4AAADAAQAAAA4AAADwAAAAAH8AAACAAwEAADxBU0NJSV9IZXhfRGlnaXQsQUhleABCaWRpX0NvbnRyb2wsQmlkaV9DAERhc2gARGVwcmVjYXRlZCxEZXAARGlhY3JpdGljLERpYQBFeHRlbmRlcixFeHQASGV4X0RpZ2l0LEhleABJRFNfQmluYXJ5X09wZXJhdG9yLElEU0IASURTX1RyaW5hcnlfT3BlcmF0b3IsSURTVABJZGVvZ3JhcGhpYyxJZGVvAEpvaW5fQ29udHJvbCxKb2luX0MATG9naWNhbF9PcmRlcl9FeGNlcHRpb24sTE9FAE5vbmNoYXJhY3Rlcl9Db2RlX1BvaW50LE5DaGFyAFBhdHRlcm5fU3ludGF4LFBhdF9TeW4AUGF0dGVybl9XaGl0ZV9TcGFjZSxQYXRfV1MAUXVvdGF0aW9uX01hcmssUU1hcmsAUmFkaWNhbABSZWdpb25hbF9JbmRpY2F0b3IsUkkAU2VudGVuY2VfVGVybWluYWwsU1Rlcm0AU29mdF9Eb3R0ZWQsU0QAVGVybWluYWxfUHVuY3R1YXRpb24sVGVybQBVbmlmaWVkX0lkZW9ncmFwaCxVSWRlbwBWYXJpYXRpb25fU2VsZWN0b3IsVlMAV2hpdGVfU3BhY2Usc3BhY2UAQmlkaV9NaXJyb3JlZCxCaWRpX00ARW1vamkARW1vamlfQ29tcG9uZW50LEVDb21wAEVtb2ppX01vZGlmaWVyLEVNb2QARW1vamlfTW9kaWZpZXJfQmFzZSxFQmFzZQBFbW9qaV9QcmVzZW50YXRpb24sRVByZXMARXh0ZW5kZWRfUGljdG9ncmFwaGljLEV4dFBpY3QARGVmYXVsdF9JZ25vcmFibGVfQ29kZV9Qb2ludCxESQBJRF9TdGFydCxJRFMAQ2FzZV9JZ25vcmFibGUsQ0kAQVNDSUkAQWxwaGFiZXRpYyxBbHBoYQBBbnkAQXNzaWduZWQAQ2FzZWQAQ2hhbmdlc19XaGVuX0Nhc2Vmb2xkZWQsQ1dDRgBDaGFuZ2VzX1doZW5fQ2FzZW1hcHBlZCxDV0NNAENoYW5nZXNfV2hlbl9Mb3dlcmNhc2VkLENXTABDaGFuZ2VzX1doZW5fTkZLQ19DYXNlZm9sZGVkLENXS0NGAENoYW5nZXNfV2hlbl9UaXRsZWNhc2VkLENXVABDaGFuZ2VzX1doZW5fVXBwZXJjYXNlZCxDV1UAR3JhcGhlbWVfQmFzZSxHcl9CYXNlAEdyYXBoZW1lX0V4dGVuZCxHcl9FeHQASURfQ29udGludWUsSURDAExvd2VyY2FzZSxMb3dlcgBNYXRoAFVwcGVyY2FzZSxVcHBlcgBYSURfQ29udGludWUsWElEQwBYSURfU3RhcnQsWElEUwBB4MMCC9QVgQAoAJcAKgCBgCoAl8ArABWBLACXAC0AgUAtAJcALgAVQS4AmQEvABYgMABCCEAAQopEAEIESgCWAEwAF4FMAEICTQBCQ04AL8FPAELDUAC/QFIAQgNTAEIJVQBCCFoAlgBeAEJDXgCBwF8AQgFoAELBawCFAXEAF8NxAERIcwBEg3cAQoN5AL4CewCXQXwAQgF9AEQEfgBCDoAAQoGHAESHiQCDBKwAFwO2AIMCuAAUAtAAlgDRAIAA3QCXgN4AgIDfAJcA4QA+QeEAgMDhAL4E4gCug+oAroLyAK0B9AAuwfQAA0H1AAMD/ACBQP4APgIAAb7AAQG+AQMBvkAGAb5ADgE+AhQBvsAVAb4BFwFEgR0BREEwAUQCNAFEgTUB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QmNhbGtjYWxwAEZuAEa8A0a8A2dtAGdrAGdIAHprSHpNSHpHSHpUSHq8AxMhbQATIWQAEyFrABMhZgBtbgBtvANtbQBtYwBtawBtYwAKCk8ACk9tALIAYwAICk8KClAAClBtALMAawBtALMAbQAVInMAbQAVInMAsgBQYWtQYU1QYUdQYXJhZHJhZNFzcgBhAGQAFSJzALIAcABzbgBzvANzbQBzcABWbgBWvANWbQBWawBWTQBWcABXbgBXvANXbQBXawBXTQBXawCpA00AqQNhLm0uQnFjY2NkQ9FrZ0NvLmRCR3loYUhQaW5LS0tNa3RsbWxubG9nbHhtYm1pbG1vbFBIcC5tLlBQTVBSc3JTdldiVtFtQdFtMQDlZTEAMADlZTIAMADlZTMAMADlZWdhbEoETARDRlEmAVMBJ6c3q2sCUqtIjPRmyo7IjNFuMk7lU5yfnJ9RWdGRh1VIWfZhaXaFfz+Guof4iI+QAmobbdlw3nM9hGqR8ZmCTnVTBGsbci2GHp5QXetvzYVkicli2IEfiMpeF2dqbfxyzpCGT7dR3lLEZNNqEHLndgGABoZchu+NMpdvm/qdjHh/eaB9yYMEk3+e1orfWARfYHx+gGJyynjCjPeW2FhiXBNq2m0Pby99N35LltJSi4DcUcxRHHq+ffGDdZaAi89iAmr+ijlO51sSYIdzcHUXU/t4v0+pXw1OzGx4ZSJ9w1NeWAF3SYSqirprsI+IbP5i5YKgY2V1rk5pUclRgWjnfG+C0orPkfVSQlRzWexexWX+byp5rZVqmpeezp6bUsZmd2tij3RekGEAYppkI29JcYl0ynn0fW+AJo/uhCOQSpMXUqNSvVTIcMKIqorJXvVfe2Ouaz58dXPkTvlW51u6XRxgsnNpdJp/RoA0kvaWSJcYmItPrnm0kbiW4WCGTtpQ7ls/XJllAmrOcUJ2/IR8kI2fiGYulolSe2fzZ0FtnG4JdFl1a3gQfV6YbVEuYniWK1AZXeptKo+LX0RhF2iHc4aWKVIPVGVcE2ZOZ6ho5WwGdOJ1eX/PiOGIzJHilj9Tum4dVNBxmHT6haOWV5yfnpdny23ogct6IHuSfMBymXBYi8BONoM6UgdSpl7TYtZ8hVsebbRmO49MiE2Wi4nTXkBRwFUAAAAAWlgAAHRmAAAAAN5RKnPKdjx5XnlleY95Vpe+fL1/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\";if(!T(U)){var ha=U;U=c.locateFile?c.locateFile(ha,t):t+ha;}function ia(){var a=U;try{if(a==U&&v)return new Uint8Array(v);if(T(a))try{var b=ja(a.slice(37)),d=new Uint8Array(b.length);for(a=0;a2]=60*Math.max(f,m);N[b>>2]=Number(f!=m);a=e(g);b=e(k);a=K(a);b=K(b);m>2]=a,N[d+4>>2]=b):(N[d>>2]=b,N[d+4>>2]=a);}function W(a,b,d){W.B||(W.B=!0,la(a,b,d));}function X(a){var b=J(a)+1,d=L(b);B(a,C,d,b);return d;}function ma(){}var na=[null,[],[]];ma=(a,b,d)=>{a=G(a);b=null!==b?JSON.parse(G(b)):[];try{const e=c.externalCall(a,b);return e?X(e):null;}catch(e){return c.HEAPU8[d]=1,X(e.message);}};var ja=\"function\"==typeof atob?atob:function(a){var b=\"\",d=0;a=a.replace(/[^A-Za-z0-9\\+\\/=]/g,\"\");do{var e=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(a.charAt(d++));var f=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(a.charAt(d++));var g=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(a.charAt(d++));var k=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(a.charAt(d++));e=e4;f=(f&15)2;var m=(g&3)>2]=a.getSeconds();N[b+4>>2]=a.getMinutes();N[b+8>>2]=a.getHours();N[b+12>>2]=a.getDate();N[b+16>>2]=a.getMonth();N[b+20>>2]=a.getFullYear()-1900;N[b+24>>2]=a.getDay();var d=new Date(a.getFullYear(),0,1);N[b+28>>2]=(a.getTime()-d.getTime())/864E5|0;N[b+36>>2]=-(60*a.getTimezoneOffset());var e=new Date(a.getFullYear(),6,1).getTimezoneOffset();d=d.getTimezoneOffset();N[b+32>>2]=(e!=d&&a.getTimezoneOffset()==Math.min(d,e))|0;},f:W,b:function(){w(\"\");},h:ma,g:function(a,b){a=G(a);let d;try{d=window.JSON.parse(a);}catch(e){d=a;}0!==b?window.alert(a):window.console.log(\"DUMP\",d);},j:function(a){var b=C.length;a>>>=0;if(2147483648=d;d*=2){var e=b*(1+.2/d);e=Math.min(e,a+100663296);var f=Math;e=Math.max(a,e);f=f.min.call(f,2147483648,e+(65536-e%65536)%65536);a:{try{x.grow(f-M.byteLength+65535>>>16);ba();var g=1;break a;}catch(k){}g=void 0;}if(g)return!0;}return!1;},c:function(a,b,d,e){for(var f=0,g=0;g>2],m=N[b+4>>2];b+=8;for(var q=0;q>2]=f;return 0;},k:function(a){a=G(a);window.console.log(a);},i:function(a){a=G(a);return Date.parse(a);},l:function(a,b,d,e){a=G(a);b=G(b);d=G(d);d=`Quickjs -- ${a}: ${b}\\n${d}`;0!==e?window.alert(d):window.console.error(d);}};(function(){function a(f){c.asm=f.exports;x=c.asm.m;ba();O=c.asm.v;da.unshift(c.asm.n);P--;c.monitorRunDependencies&&c.monitorRunDependencies(P);0==P&&(null!==Q&&(clearInterval(Q),Q=null),R&&(f=R,R=null,f()));}function b(f){a(f.instance);}function d(f){return ka().then(function(g){return WebAssembly.instantiate(g,e);}).then(function(g){return g;}).then(f,function(g){u(\"failed to asynchronously prepare wasm: \"+g);w(g);});}var e={a:oa};P++;c.monitorRunDependencies&&c.monitorRunDependencies(P);if(c.instantiateWasm)try{return c.instantiateWasm(e,a);}catch(f){return u(\"Module.instantiateWasm callback failed with error: \"+f),!1;}(function(){return v||\"function\"!=typeof WebAssembly.instantiateStreaming||T(U)||\"function\"!=typeof fetch?d(b):fetch(U,{credentials:\"same-origin\"}).then(function(f){return WebAssembly.instantiateStreaming(f,e).then(b,function(g){u(\"wasm streaming compile failed: \"+g);u(\"falling back to ArrayBuffer instantiation\");return d(b);});});})().catch(n);return{};})();c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.n).apply(null,arguments);};c._evalInSandbox=function(){return(c._evalInSandbox=c.asm.o).apply(null,arguments);};c._nukeSandbox=function(){return(c._nukeSandbox=c.asm.p).apply(null,arguments);};c._init=function(){return(c._init=c.asm.q).apply(null,arguments);};c._commFun=function(){return(c._commFun=c.asm.r).apply(null,arguments);};c._dumpMemoryUse=function(){return(c._dumpMemoryUse=c.asm.s).apply(null,arguments);};var L=c._malloc=function(){return(L=c._malloc=c.asm.t).apply(null,arguments);};c._free=function(){return(c._free=c.asm.u).apply(null,arguments);};var E=c.stackSave=function(){return(E=c.stackSave=c.asm.w).apply(null,arguments);},F=c.stackRestore=function(){return(F=c.stackRestore=c.asm.x).apply(null,arguments);},A=c.stackAlloc=function(){return(A=c.stackAlloc=c.asm.y).apply(null,arguments);};c.ccall=z;c.cwrap=function(a,b,d,e){d=d||[];var f=d.every(function(g){return\"number\"===g;});return\"string\"!==b&&f&&!e?c[\"_\"+a]:function(){return z(a,b,d,arguments,e);};};c.stringToNewUTF8=X;var Y;R=function pa(){Y||Z();Y||(R=pa);};function Z(){function a(){if(!Y&&(Y=!0,c.calledRun=!0,!y)){V(da);h(c);if(c.onRuntimeInitialized)c.onRuntimeInitialized();if(c.postRun)for(\"function\"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;){var b=c.postRun.shift();ea.unshift(b);}V(ea);}}if(!(0 { this.timeoutIds.delete(callbackId); this.callSandboxFunction(\"timeoutCb\", { callbackId, interval: false }); }, nMilliseconds); this.timeoutIds.set(callbackId, id); }, clearTimeout: callbackId => { this.win.clearTimeout(this.timeoutIds.get(callbackId)); this.timeoutIds.delete(callbackId); }, setInterval: (callbackId, nMilliseconds) => { if (typeof callbackId !== \"number\" || typeof nMilliseconds !== \"number\") { return; } const id = this.win.setInterval(() => { this.callSandboxFunction(\"timeoutCb\", { callbackId, interval: true }); }, nMilliseconds); this.timeoutIds.set(callbackId, id); }, clearInterval: callbackId => { this.win.clearInterval(this.timeoutIds.get(callbackId)); this.timeoutIds.delete(callbackId); }, alert: cMsg => { if (typeof cMsg !== \"string\") { return; } this.win.alert(cMsg); }, confirm: cMsg => { if (typeof cMsg !== \"string\") { return false; } return this.win.confirm(cMsg); }, prompt: (cQuestion, cDefault) => { if (typeof cQuestion !== \"string\" || typeof cDefault !== \"string\") { return null; } return this.win.prompt(cQuestion, cDefault); }, parseURL: cUrl => { const url = new this.win.URL(cUrl); const props = [\"hash\", \"host\", \"hostname\", \"href\", \"origin\", \"password\", \"pathname\", \"port\", \"protocol\", \"search\", \"searchParams\", \"username\"]; return Object.fromEntries(props.map(name => [name, url[name].toString()])); }, send: data => { if (!data) { return; } const event = new this.win.CustomEvent(\"updatefromsandbox\", { detail: this.importValueFromSandbox(data) }); this.win.dispatchEvent(event); } }; Object.setPrototypeOf(externals, null); return (name, args) => { try { const result = externals[name](...args); return this.exportValueToSandbox(result); } catch (error) { throw this.createErrorForSandbox(error?.toString() ?? \"\"); } }; } } { exports.SandboxSupportBase = SandboxSupportBase; } /***/ }) /******/ ]); /************************************************************************/ /******/ // The module cache /******/ var __webpack_module_cache__ = {}; /******/ /******/ // The require function /******/ function __w_pdfjs_require__(moduleId) { /******/ // Check if module is in cache /******/ var cachedModule = __webpack_module_cache__[moduleId]; /******/ if (cachedModule !== undefined) { /******/ return cachedModule.exports; /******/ } /******/ // Create a new module (and put it into the cache) /******/ var module = __webpack_module_cache__[moduleId] = { /******/ // no module.id needed /******/ // no module.loaded needed /******/ exports: {} /******/ }; /******/ /******/ // Execute the module function /******/ __webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__); /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /************************************************************************/ var __webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk. (() => { var exports = __webpack_exports__; Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.QuickJSSandbox = QuickJSSandbox; var _quickjsEval = _interopRequireDefault(__w_pdfjs_require__(1)); var _pdfSandboxExternal = __w_pdfjs_require__(2); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } const pdfjsVersion = '3.2.146'; const pdfjsBuild = '3fd2a3548'; class SandboxSupport extends _pdfSandboxExternal.SandboxSupportBase { exportValueToSandbox(val) { return JSON.stringify(val); } importValueFromSandbox(val) { return val; } createErrorForSandbox(errorMessage) { return new Error(errorMessage); } } class Sandbox { constructor(win, module) { this.support = new SandboxSupport(win, this); module.externalCall = this.support.createSandboxExternals(); this._module = module; this._alertOnError = 0; } create(data) { const code = ['(function webpackUniversalModuleDefinition(root, factory) {\\n\\tif(typeof exports === \\'object\\' && typeof module === \\'object\\')\\n\\t\\tmodule.exports = factory();\\n\\telse if(typeof define === \\'function\\' && define.amd)\\n\\t\\tdefine(\"pdfjs-dist/build/pdf.scripting\", [], factory);\\n\\telse if(typeof exports === \\'object\\')\\n\\t\\texports[\"pdfjs-dist/build/pdf.scripting\"] = factory();\\n\\telse\\n\\t\\troot.pdfjsScripting = factory();\\n})(globalThis, () => {\\nreturn /******/ (() => { // webpackBootstrap\\n/******/ \\t\"use strict\";\\n/******/ \\tvar __webpack_modules__ = ([\\n/* 0 */,\\n/* 1 */\\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\\n\\n\\n\\nObject.defineProperty(exports, \"__esModule\", ({\\n value: true\\n}));\\nexports.initSandbox = initSandbox;\\nvar _constants = __w_pdfjs_require__(2);\\nvar _field = __w_pdfjs_require__(3);\\nvar _aform = __w_pdfjs_require__(8);\\nvar _app = __w_pdfjs_require__(9);\\nvar _color = __w_pdfjs_require__(5);\\nvar _console = __w_pdfjs_require__(15);\\nvar _doc = __w_pdfjs_require__(11);\\nvar _proxy = __w_pdfjs_require__(16);\\nvar _util = __w_pdfjs_require__(17);\\nfunction initSandbox(params) {\\n delete globalThis.pdfjsScripting;\\n const externalCall = globalThis.callExternalFunction;\\n delete globalThis.callExternalFunction;\\n const globalEval = code => globalThis.eval(code);\\n const send = data => externalCall(\"send\", [data]);\\n const proxyHandler = new _proxy.ProxyHandler();\\n const {\\n data\\n } = params;\\n const doc = new _doc.Doc({\\n send,\\n globalEval,\\n ...data.docInfo\\n });\\n const _document = {\\n obj: doc,\\n wrapped: new Proxy(doc, proxyHandler)\\n };\\n const app = new _app.App({\\n send,\\n globalEval,\\n externalCall,\\n _document,\\n calculationOrder: data.calculationOrder,\\n proxyHandler,\\n ...data.appInfo\\n });\\n const util = new _util.Util({\\n externalCall\\n });\\n const appObjects = app._objects;\\n if (data.objects) {\\n const annotations = [];\\n for (const [name, objs] of Object.entries(data.objects)) {\\n annotations.length = 0;\\n let container = null;\\n for (const obj of objs) {\\n if (obj.type !== \"\") {\\n annotations.push(obj);\\n } else {\\n container = obj;\\n }\\n }\\n let obj = container;\\n if (annotations.length > 0) {\\n obj = annotations[0];\\n obj.send = send;\\n }\\n obj.globalEval = globalEval;\\n obj.doc = _document;\\n obj.fieldPath = name;\\n obj.appObjects = appObjects;\\n let field;\\n switch (obj.type) {\\n case \"radiobutton\":\\n {\\n const otherButtons = annotations.slice(1);\\n field = new _field.RadioButtonField(otherButtons, obj);\\n break;\\n }\\n case \"checkbox\":\\n {\\n const otherButtons = annotations.slice(1);\\n field = new _field.CheckboxField(otherButtons, obj);\\n break;\\n }\\n case \"text\":\\n if (annotations.length x.id).slice(1);\\n field = new _field.Field(obj);\\n break;\\n default:\\n field = new _field.Field(obj);\\n }\\n const wrapped = new Proxy(field, proxyHandler);\\n const _object = {\\n obj: field,\\n wrapped\\n };\\n doc._addField(name, _object);\\n for (const object of objs) {\\n appObjects[object.id] = _object;\\n }\\n if (container) {\\n appObjects[container.id] = _object;\\n }\\n }\\n }\\n const color = new _color.Color();\\n globalThis.event = null;\\n globalThis.global = Object.create(null);\\n globalThis.app = new Proxy(app, proxyHandler);\\n globalThis.color = new Proxy(color, proxyHandler);\\n globalThis.console = new Proxy(new _console.Console({\\n send\\n }), proxyHandler);\\n globalThis.util = new Proxy(util, proxyHandler);\\n globalThis.border = _constants.Border;\\n globalThis.cursor = _constants.Cursor;\\n globalThis.display = _constants.Display;\\n globalThis.font = _constants.Font;\\n globalThis.highlight = _constants.Highlight;\\n globalThis.position = _constants.Position;\\n globalThis.scaleHow = _constants.ScaleHow;\\n globalThis.scaleWhen = _constants.ScaleWhen;\\n globalThis.style = _constants.Style;\\n globalThis.trans = _constants.Trans;\\n globalThis.zoomtype = _constants.ZoomType;\\n globalThis.ADBE = {\\n Reader_Value_Asked: true,\\n Viewer_Value_Asked: true\\n };\\n const aform = new _aform.AForm(doc, app, util, color);\\n for (const name of Object.getOwnPropertyNames(_aform.AForm.prototype)) {\\n if (name !== \"constructor\" && !name.startsWith(\"_\")) {\\n globalThis[name] = aform[name].bind(aform);\\n }\\n }\\n for (const [name, value] of Object.entries(_constants.GlobalConstants)) {\\n Object.defineProperty(globalThis, name, {\\n value,\\n writable: false\\n });\\n }\\n Object.defineProperties(globalThis, {\\n ColorConvert: {\\n value: color.convert.bind(color),\\n writable: true\\n },\\n ColorEqual: {\\n value: color.equal.bind(color),\\n writable: true\\n }\\n });\\n const properties = Object.create(null);\\n for (const name of Object.getOwnPropertyNames(_doc.Doc.prototype)) {\\n if (name === \"constructor\" || name.startsWith(\"_\")) {\\n continue;\\n }\\n const descriptor = Object.getOwnPropertyDescriptor(_doc.Doc.prototype, name);\\n if (descriptor.get) {\\n properties[name] = {\\n get: descriptor.get.bind(doc),\\n set: descriptor.set.bind(doc)\\n };\\n } else {\\n properties[name] = {\\n value: _doc.Doc.prototype[name].bind(doc)\\n };\\n }\\n }\\n Object.defineProperties(globalThis, properties);\\n const functions = {\\n dispatchEvent: app._dispatchEvent.bind(app),\\n timeoutCb: app._evalCallback.bind(app)\\n };\\n return (name, args) => {\\n try {\\n functions[name](args);\\n } catch (error) {\\n const value = `${error.toString()}\\\\n${error.stack}`;\\n send({\\n command: \"error\",\\n value\\n });\\n }\\n };\\n}\\n\\n/***/ }),\\n/* 2 */\\n/***/ ((__unused_webpack_module, exports) => {\\n\\n\\n\\nObject.defineProperty(exports, \"__esModule\", ({\\n value: true\\n}));\\nexports.ZoomType = exports.Trans = exports.Style = exports.ScaleWhen = exports.ScaleHow = exports.Position = exports.Highlight = exports.GlobalConstants = exports.Font = exports.Display = exports.Cursor = exports.Border = void 0;\\nconst Border = Object.freeze({\\n s: \"solid\",\\n d: \"dashed\",\\n b: \"beveled\",\\n i: \"inset\",\\n u: \"underline\"\\n});\\nexports.Border = Border;\\nconst Cursor = Object.freeze({\\n visible: 0,\\n hidden: 1,\\n delay: 2\\n});\\nexports.Cursor = Cursor;\\nconst Display = Object.freeze({\\n visible: 0,\\n hidden: 1,\\n noPrint: 2,\\n noView: 3\\n});\\nexports.Display = Display;\\nconst Font = Object.freeze({\\n Times: \"Times-Roman\",\\n TimesB: \"Times-Bold\",\\n TimesI: \"Times-Italic\",\\n TimesBI: \"Times-BoldItalic\",\\n Helv: \"Helvetica\",\\n HelvB: \"Helvetica-Bold\",\\n HelvI: \"Helvetica-Oblique\",\\n HelvBI: \"Helvetica-BoldOblique\",\\n Cour: \"Courier\",\\n CourB: \"Courier-Bold\",\\n CourI: \"Courier-Oblique\",\\n CourBI: \"Courier-BoldOblique\",\\n Symbol: \"Symbol\",\\n ZapfD: \"ZapfDingbats\",\\n KaGo: \"HeiseiKakuGo-W5-UniJIS-UCS2-H\",\\n KaMi: \"HeiseiMin-W3-UniJIS-UCS2-H\"\\n});\\nexports.Font = Font;\\nconst Highlight = Object.freeze({\\n n: \"none\",\\n i: \"invert\",\\n p: \"push\",\\n o: \"outline\"\\n});\\nexports.Highlight = Highlight;\\nconst Position = Object.freeze({\\n textOnly: 0,\\n iconOnly: 1,\\n iconTextV: 2,\\n textIconV: 3,\\n iconTextH: 4,\\n textIconH: 5,\\n overlay: 6\\n});\\nexports.Position = Position;\\nconst ScaleHow = Object.freeze({\\n proportional: 0,\\n anamorphic: 1\\n});\\nexports.ScaleHow = ScaleHow;\\nconst ScaleWhen = Object.freeze({\\n always: 0,\\n never: 1,\\n tooBig: 2,\\n tooSmall: 3\\n});\\nexports.ScaleWhen = ScaleWhen;\\nconst Style = Object.freeze({\\n ch: \"check\",\\n cr: \"cross\",\\n di: \"diamond\",\\n ci: \"circle\",\\n st: \"star\",\\n sq: \"square\"\\n});\\nexports.Style = Style;\\nconst Trans = Object.freeze({\\n blindsH: \"BlindsHorizontal\",\\n blindsV: \"BlindsVertical\",\\n boxI: \"BoxIn\",\\n boxO: \"BoxOut\",\\n dissolve: \"Dissolve\",\\n glitterD: \"GlitterDown\",\\n glitterR: \"GlitterRight\",\\n glitterRD: \"GlitterRightDown\",\\n random: \"Random\",\\n replace: \"Replace\",\\n splitHI: \"SplitHorizontalIn\",\\n splitHO: \"SplitHorizontalOut\",\\n splitVI: \"SplitVerticalIn\",\\n splitVO: \"SplitVerticalOut\",\\n wipeD: \"WipeDown\",\\n wipeL: \"WipeLeft\",\\n wipeR: \"WipeRight\",\\n wipeU: \"WipeUp\"\\n});\\nexports.Trans = Trans;\\nconst ZoomType = Object.freeze({\\n none: \"NoVary\",\\n fitP: \"FitPage\",\\n fitW: \"FitWidth\",\\n fitH: \"FitHeight\",\\n fitV: \"FitVisibleWidth\",\\n pref: \"Preferred\",\\n refW: \"ReflowWidth\"\\n});\\nexports.ZoomType = ZoomType;\\nconst GlobalConstants = Object.freeze({\\n IDS_GREATER_THAN: \"Invalid value: must be greater than or equal to % s.\",\\n IDS_GT_AND_LT: \"Invalid value: must be greater than or equal to % s \" + \"and less than or equal to % s.\",\\n IDS_LESS_THAN: \"Invalid value: must be less than or equal to % s.\",\\n IDS_INVALID_MONTH: \"** Invalid **\",\\n IDS_INVALID_DATE: \"Invalid date / time: please ensure that the date / time exists.Field\",\\n IDS_INVALID_DATE2: \" should match format \",\\n IDS_INVALID_VALUE: \"The value entered does not match the format of the field\",\\n IDS_AM: \"am\",\\n IDS_PM: \"pm\",\\n IDS_MONTH_INFO: \"January[1] February[2] March[3] April[4] May[5] \" + \"June[6] July[7] August[8] September[9] October[10] \" + \"November[11] December[12] Sept[9] Jan[1] Feb[2] Mar[3] \" + \"Apr[4] Jun[6] Jul[7] Aug[8] Sep[9] Oct[10] Nov[11] Dec[12]\",\\n IDS_STARTUP_CONSOLE_MSG: \"** ^ _ ^ **\",\\n RE_NUMBER_ENTRY_DOT_SEP: [\"[+-]?\\\\\\\\d*\\\\\\\\.?\\\\\\\\d*\"],\\n RE_NUMBER_COMMIT_DOT_SEP: [\"[+-]?\\\\\\\\d+(\\\\\\\\.\\\\\\\\d+)?\", \"[+-]?\\\\\\\\.\\\\\\\\d+\", \"[+-]?\\\\\\\\d+\\\\\\\\.\"],\\n RE_NUMBER_ENTRY_COMMA_SEP: [\"[+-]?\\\\\\\\d*,?\\\\\\\\d*\"],\\n RE_NUMBER_COMMIT_COMMA_SEP: [\"[+-]?\\\\\\\\d+([.,]\\\\\\\\d+)?\", \"[+-]?[.,]\\\\\\\\d+\", \"[+-]?\\\\\\\\d+[.,]\"],\\n RE_ZIP_ENTRY: [\"\\\\\\\\d{0,5}\"],\\n RE_ZIP_COMMIT: [\"\\\\\\\\d{5}\"],\\n RE_ZIP4_ENTRY: [\"\\\\\\\\d{0,5}(\\\\\\\\.|[- ])?\\\\\\\\d{0,4}\"],\\n RE_ZIP4_COMMIT: [\"\\\\\\\\d{5}(\\\\\\\\.|[- ])?\\\\\\\\d{4}\"],\\n RE_PHONE_ENTRY: [\"\\\\\\\\d{0,3}(\\\\\\\\.|[- ])?\\\\\\\\d{0,3}(\\\\\\\\.|[- ])?\\\\\\\\d{0,4}\", \"\\\\\\\\(\\\\\\\\d{0,3}\", \"\\\\\\\\(\\\\\\\\d{0,3}\\\\\\\\)(\\\\\\\\.|[- ])?\\\\\\\\d{0,3}(\\\\\\\\.|[- ])?\\\\\\\\d{0,4}\", \"\\\\\\\\(\\\\\\\\d{0,3}(\\\\\\\\.|[- ])?\\\\\\\\d{0,3}(\\\\\\\\.|[- ])?\\\\\\\\d{0,4}\", \"\\\\\\\\d{0,3}\\\\\\\\)(\\\\\\\\.|[- ])?\\\\\\\\d{0,3}(\\\\\\\\.|[- ])?\\\\\\\\d{0,4}\", \"011(\\\\\\\\.|[- \\\\\\\\d])*\"],\\n RE_PHONE_COMMIT: [\"\\\\\\\\d{3}(\\\\\\\\.|[- ])?\\\\\\\\d{4}\", \"\\\\\\\\d{3}(\\\\\\\\.|[- ])?\\\\\\\\d{3}(\\\\\\\\.|[- ])?\\\\\\\\d{4}\", \"\\\\\\\\(\\\\\\\\d{3}\\\\\\\\)(\\\\\\\\.|[- ])?\\\\\\\\d{3}(\\\\\\\\.|[- ])?\\\\\\\\d{4}\", \"011(\\\\\\\\.|[- \\\\\\\\d])*\"],\\n RE_SSN_ENTRY: [\"\\\\\\\\d{0,3}(\\\\\\\\.|[- ])?\\\\\\\\d{0,2}(\\\\\\\\.|[- ])?\\\\\\\\d{0,4}\"],\\n RE_SSN_COMMIT: [\"\\\\\\\\d{3}(\\\\\\\\.|[- ])?\\\\\\\\d{2}(\\\\\\\\.|[- ])?\\\\\\\\d{4}\"]\\n});\\nexports.GlobalConstants = GlobalConstants;\\n\\n/***/ }),\\n/* 3 */\\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\\n\\n\\n\\nObject.defineProperty(exports, \"__esModule\", ({\\n value: true\\n}));\\nexports.RadioButtonField = exports.Field = exports.CheckboxField = void 0;\\nvar _common = __w_pdfjs_require__(4);\\nvar _color = __w_pdfjs_require__(5);\\nvar _pdf_object = __w_pdfjs_require__(7);\\nclass Field extends _pdf_object.PDFObject {\\n constructor(data) {\\n super(data);\\n this.alignment = data.alignment || \"left\";\\n this.borderStyle = data.borderStyle || \"\";\\n this.buttonAlignX = data.buttonAlignX || 50;\\n this.buttonAlignY = data.buttonAlignY || 50;\\n this.buttonFitBounds = data.buttonFitBounds;\\n this.buttonPosition = data.buttonPosition;\\n this.buttonScaleHow = data.buttonScaleHow;\\n this.ButtonScaleWhen = data.buttonScaleWhen;\\n this.calcOrderIndex = data.calcOrderIndex;\\n this.comb = data.comb;\\n this.commitOnSelChange = data.commitOnSelChange;\\n this.currentValueIndices = data.currentValueIndices;\\n this.defaultStyle = data.defaultStyle;\\n this.defaultValue = data.defaultValue;\\n this.doNotScroll = data.doNotScroll;\\n this.doNotSpellCheck = data.doNotSpellCheck;\\n this.delay = data.delay;\\n this.display = data.display;\\n this.doc = data.doc.wrapped;\\n this.editable = data.editable;\\n this.exportValues = data.exportValues;\\n this.fileSelect = data.fileSelect;\\n this.hidden = data.hidden;\\n this.highlight = data.highlight;\\n this.lineWidth = data.lineWidth;\\n this.multiline = data.multiline;\\n this.multipleSelection = !!data.multipleSelection;\\n this.name = data.name;\\n this.password = data.password;\\n this.print = data.print;\\n this.radiosInUnison = data.radiosInUnison;\\n this.readonly = data.readonly;\\n this.rect = data.rect;\\n this.required = data.required;\\n this.richText = data.richText;\\n this.richValue = data.richValue;\\n this.style = data.style;\\n this.submitName = data.submitName;\\n this.textFont = data.textFont;\\n this.textSize = data.textSize;\\n this.type = data.type;\\n this.userName = data.userName;\\n this._actions = (0, _common.createActionsMap)(data.actions);\\n this._browseForFileToSubmit = data.browseForFileToSubmit || null;\\n this._buttonCaption = null;\\n this._buttonIcon = null;\\n this._charLimit = data.charLimit;\\n this._children = null;\\n this._currentValueIndices = data.currentValueIndices || 0;\\n this._document = data.doc;\\n this._fieldPath = data.fieldPath;\\n this._fillColor = data.fillColor || [\"T\"];\\n this._isChoice = Array.isArray(data.items);\\n this._items = data.items || [];\\n this._hasValue = data.hasOwnProperty(\"value\");\\n this._page = data.page || 0;\\n this._strokeColor = data.strokeColor || [\"G\", 0];\\n this._textColor = data.textColor || [\"G\", 0];\\n this._value = null;\\n this._kidIds = data.kidIds || null;\\n this._fieldType = (0, _common.getFieldType)(this._actions);\\n this._siblings = data.siblings || null;\\n this._rotation = data.rotation || 0;\\n this._globalEval = data.globalEval;\\n this._appObjects = data.appObjects;\\n this.value = data.value || \"\";\\n }\\n get currentValueIndices() {\\n if (!this._isChoice) {\\n return 0;\\n }\\n return this._currentValueIndices;\\n }\\n set currentValueIndices(indices) {\\n if (!this._isChoice) {\\n return;\\n }\\n if (!Array.isArray(indices)) {\\n indices = [indices];\\n }\\n if (!indices.every(i => typeof i === \"number\" && Number.isInteger(i) && i >= 0 && i < this.numItems)) {\\n return;\\n }\\n indices.sort();\\n if (this.multipleSelection) {\\n this._currentValueIndices = indices;\\n this._value = [];\\n indices.forEach(i => {\\n this._value.push(this._items[i].displayValue);\\n });\\n } else {\\n if (indices.length > 0) {\\n indices = indices.splice(1, indices.length - 1);\\n this._currentValueIndices = indices[0];\\n this._value = this._items[this._currentValueIndices];\\n }\\n }\\n this._send({\\n id: this._id,\\n indices\\n });\\n }\\n get fillColor() {\\n return this._fillColor;\\n }\\n set fillColor(color) {\\n if (_color.Color._isValidColor(color)) {\\n this._fillColor = color;\\n }\\n }\\n get bgColor() {\\n return this.fillColor;\\n }\\n set bgColor(color) {\\n this.fillColor = color;\\n }\\n get charLimit() {\\n return this._charLimit;\\n }\\n set charLimit(limit) {\\n if (typeof limit !== \"number\") {\\n throw new Error(\"Invalid argument value\");\\n }\\n this._charLimit = Math.max(0, Math.floor(limit));\\n }\\n get numItems() {\\n if (!this._isChoice) {\\n throw new Error(\"Not a choice widget\");\\n }\\n return this._items.length;\\n }\\n set numItems(_) {\\n throw new Error(\"field.numItems is read-only\");\\n }\\n get strokeColor() {\\n return this._strokeColor;\\n }\\n set strokeColor(color) {\\n if (_color.Color._isValidColor(color)) {\\n this._strokeColor = color;\\n }\\n }\\n get borderColor() {\\n return this.strokeColor;\\n }\\n set borderColor(color) {\\n this.strokeColor = color;\\n }\\n get page() {\\n return this._page;\\n }\\n set page(_) {\\n throw new Error(\"field.page is read-only\");\\n }\\n get rotation() {\\n return this._rotation;\\n }\\n set rotation(angle) {\\n angle = Math.floor(angle);\\n if (angle % 90 !== 0) {\\n throw new Error(\"Invalid rotation: must be a multiple of 90\");\\n }\\n angle %= 360;\\n if (angle < 0) {\\n angle += 360;\\n }\\n this._rotation = angle;\\n }\\n get textColor() {\\n return this._textColor;\\n }\\n set textColor(color) {\\n if (_color.Color._isValidColor(color)) {\\n this._textColor = color;\\n }\\n }\\n get fgColor() {\\n return this.textColor;\\n }\\n set fgColor(color) {\\n this.textColor = color;\\n }\\n get value() {\\n return this._value;\\n }\\n set value(value) {\\n if (this._isChoice) {\\n this._setChoiceValue(value);\\n return;\\n }\\n if (value === \"\") {\\n this._value = \"\";\\n } else if (typeof value === \"string\") {\\n switch (this._fieldType) {\\n case _common.FieldType.none:\\n this._value = !isNaN(value) ? parseFloat(value) : value;\\n break;\\n case _common.FieldType.number:\\n case _common.FieldType.percent:\\n const number = parseFloat(value);\\n this._value = !isNaN(number) ? number : 0;\\n break;\\n default:\\n this._value = value;\\n }\\n } else {\\n this._value = value;\\n }\\n }\\n _setChoiceValue(value) {\\n if (this.multipleSelection) {\\n if (!Array.isArray(value)) {\\n value = [value];\\n }\\n const values = new Set(value);\\n if (Array.isArray(this._currentValueIndices)) {\\n this._currentValueIndices.length = 0;\\n this._value.length = 0;\\n } else {\\n this._currentValueIndices = [];\\n this._value = [];\\n }\\n this._items.forEach((item, i) => {\\n if (values.has(item.exportValue)) {\\n this._currentValueIndices.push(i);\\n this._value.push(item.exportValue);\\n }\\n });\\n } else {\\n if (Array.isArray(value)) {\\n value = value[0];\\n }\\n const index = this._items.findIndex(({\\n exportValue\\n }) => value === exportValue);\\n if (index !== -1) {\\n this._currentValueIndices = index;\\n this._value = this._items[index].exportValue;\\n }\\n }\\n }\\n get valueAsString() {\\n return (this._value ?? \"\").toString();\\n }\\n set valueAsString(_) {}\\n browseForFileToSubmit() {\\n if (this._browseForFileToSubmit) {\\n this._browseForFileToSubmit();\\n }\\n }\\n buttonGetCaption(nFace = 0) {\\n if (this._buttonCaption) {\\n return this._buttonCaption[nFace];\\n }\\n return \"\";\\n }\\n buttonGetIcon(nFace = 0) {\\n if (this._buttonIcon) {\\n return this._buttonIcon[nFace];\\n }\\n return null;\\n }\\n buttonImportIcon(cPath = null, nPave = 0) {}\\n buttonSetCaption(cCaption, nFace = 0) {\\n if (!this._buttonCaption) {\\n this._buttonCaption = [\"\", \"\", \"\"];\\n }\\n this._buttonCaption[nFace] = cCaption;\\n }\\n buttonSetIcon(oIcon, nFace = 0) {\\n if (!this._buttonIcon) {\\n this._buttonIcon = [null, null, null];\\n }\\n this._buttonIcon[nFace] = oIcon;\\n }\\n checkThisBox(nWidget, bCheckIt = true) {}\\n clearItems() {\\n if (!this._isChoice) {\\n throw new Error(\"Not a choice widget\");\\n }\\n this._items = [];\\n this._send({\\n id: this._id,\\n clear: null\\n });\\n }\\n deleteItemAt(nIdx = null) {\\n if (!this._isChoice) {\\n throw new Error(\"Not a choice widget\");\\n }\\n if (!this.numItems) {\\n return;\\n }\\n if (nIdx === null) {\\n nIdx = Array.isArray(this._currentValueIndices) ? this._currentValueIndices[0] : this._currentValueIndices;\\n nIdx = nIdx || 0;\\n }\\n if (nIdx < 0 || nIdx >= this.numItems) {\\n nIdx = this.numItems - 1;\\n }\\n this._items.splice(nIdx, 1);\\n if (Array.isArray(this._currentValueIndices)) {\\n let index = this._currentValueIndices.findIndex(i => i >= nIdx);\\n if (index !== -1) {\\n if (this._currentValueIndices[index] === nIdx) {\\n this._currentValueIndices.splice(index, 1);\\n }\\n for (const ii = this._currentValueIndices.length; index < ii; index++) {\\n --this._currentValueIndices[index];\\n }\\n }\\n } else {\\n if (this._currentValueIndices === nIdx) {\\n this._currentValueIndices = this.numItems > 0 ? 0 : -1;\\n } else if (this._currentValueIndices > nIdx) {\\n --this._currentValueIndices;\\n }\\n }\\n this._send({\\n id: this._id,\\n remove: nIdx\\n });\\n }\\n getItemAt(nIdx = -1, bExportValue = false) {\\n if (!this._isChoice) {\\n throw new Error(\"Not a choice widget\");\\n }\\n if (nIdx < 0 || nIdx >= this.numItems) {\\n nIdx = this.numItems - 1;\\n }\\n const item = this._items[nIdx];\\n return bExportValue ? item.exportValue : item.displayValue;\\n }\\n getArray() {\\n if (this._kidIds) {\\n const array = [];\\n const fillArrayWithKids = kidIds => {\\n for (const id of kidIds) {\\n const obj = this._appObjects[id];\\n if (!obj) {\\n continue;\\n }\\n if (obj.obj._hasValue) {\\n array.push(obj.wrapped);\\n }\\n if (obj.obj._kidIds) {\\n fillArrayWithKids(obj.obj._kidIds);\\n }\\n }\\n };\\n fillArrayWithKids(this._kidIds);\\n return array;\\n }\\n if (this._children === null) {\\n this._children = this._document.obj._getTerminalChildren(this._fieldPath);\\n }\\n return this._children;\\n }\\n getLock() {\\n return undefined;\\n }\\n isBoxChecked(nWidget) {\\n return false;\\n }\\n isDefaultChecked(nWidget) {\\n return false;\\n }\\n insertItemAt(cName, cExport = undefined, nIdx = 0) {\\n if (!this._isChoice) {\\n throw new Error(\"Not a choice widget\");\\n }\\n if (!cName) {\\n return;\\n }\\n if (nIdx < 0 || nIdx > this.numItems) {\\n nIdx = this.numItems;\\n }\\n if (this._items.some(({\\n displayValue\\n }) => displayValue === cName)) {\\n return;\\n }\\n if (cExport === undefined) {\\n cExport = cName;\\n }\\n const data = {\\n displayValue: cName,\\n exportValue: cExport\\n };\\n this._items.splice(nIdx, 0, data);\\n if (Array.isArray(this._currentValueIndices)) {\\n let index = this._currentValueIndices.findIndex(i => i >= nIdx);\\n if (index !== -1) {\\n for (const ii = this._currentValueIndices.length; index < ii; index++) {\\n ++this._currentValueIndices[index];\\n }\\n }\\n } else if (this._currentValueIndices >= nIdx) {\\n ++this._currentValueIndices;\\n }\\n this._send({\\n id: this._id,\\n insert: {\\n index: nIdx,\\n ...data\\n }\\n });\\n }\\n setAction(cTrigger, cScript) {\\n if (typeof cTrigger !== \"string\" || typeof cScript !== \"string\") {\\n return;\\n }\\n if (!(cTrigger in this._actions)) {\\n this._actions[cTrigger] = [];\\n }\\n this._actions[cTrigger].push(cScript);\\n }\\n setFocus() {\\n this._send({\\n id: this._id,\\n focus: true\\n });\\n }\\n setItems(oArray) {\\n if (!this._isChoice) {\\n throw new Error(\"Not a choice widget\");\\n }\\n this._items.length = 0;\\n for (const element of oArray) {\\n let displayValue, exportValue;\\n if (Array.isArray(element)) {\\n displayValue = element[0]?.toString() || \"\";\\n exportValue = element[1]?.toString() || \"\";\\n } else {\\n displayValue = exportValue = element?.toString() || \"\";\\n }\\n this._items.push({\\n displayValue,\\n exportValue\\n });\\n }\\n this._currentValueIndices = 0;\\n this._send({\\n id: this._id,\\n items: this._items\\n });\\n }\\n setLock() {}\\n signatureGetModifications() {}\\n signatureGetSeedValue() {}\\n signatureInfo() {}\\n signatureSetSeedValue() {}\\n signatureSign() {}\\n signatureValidate() {}\\n _isButton() {\\n return false;\\n }\\n _reset() {\\n this.value = this.defaultValue;\\n }\\n _runActions(event) {\\n const eventName = event.name;\\n if (!this._actions.has(eventName)) {\\n return false;\\n }\\n const actions = this._actions.get(eventName);\\n try {\\n for (const action of actions) {\\n this._globalEval(action);\\n }\\n } catch (error) {\\n event.rc = false;\\n throw error;\\n }\\n return true;\\n }\\n}\\nexports.Field = Field;\\nclass RadioButtonField extends Field {\\n constructor(otherButtons, data) {\\n super(data);\\n this.exportValues = [this.exportValues];\\n this._radioIds = [this._id];\\n this._radioActions = [this._actions];\\n for (const radioData of otherButtons) {\\n this.exportValues.push(radioData.exportValues);\\n this._radioIds.push(radioData.id);\\n this._radioActions.push((0, _common.createActionsMap)(radioData.actions));\\n if (this._value === radioData.exportValues) {\\n this._id = radioData.id;\\n }\\n }\\n this._hasBeenInitialized = true;\\n this._value = data.value || \"\";\\n }\\n get value() {\\n return this._value;\\n }\\n set value(value) {\\n if (!this._hasBeenInitialized) {\\n return;\\n }\\n if (value === null || value === undefined) {\\n this._value = \"\";\\n }\\n const i = this.exportValues.indexOf(value);\\n if (0 {\\n\\n\\n\\nObject.defineProperty(exports, \"__esModule\", ({\\n value: true\\n}));\\nexports.Color = void 0;\\nvar _scripting_utils = __w_pdfjs_require__(6);\\nvar _pdf_object = __w_pdfjs_require__(7);\\nclass Color extends _pdf_object.PDFObject {\\n constructor() {\\n super({});\\n this.transparent = [\"T\"];\\n this.black = [\"G\", 0];\\n this.white = [\"G\", 1];\\n this.red = [\"RGB\", 1, 0, 0];\\n this.green = [\"RGB\", 0, 1, 0];\\n this.blue = [\"RGB\", 0, 0, 1];\\n this.cyan = [\"CMYK\", 1, 0, 0, 0];\\n this.magenta = [\"CMYK\", 0, 1, 0, 0];\\n this.yellow = [\"CMYK\", 0, 0, 1, 0];\\n this.dkGray = [\"G\", 0.25];\\n this.gray = [\"G\", 0.5];\\n this.ltGray = [\"G\", 0.75];\\n }\\n static _isValidSpace(cColorSpace) {\\n return typeof cColorSpace === \"string\" && (cColorSpace === \"T\" || cColorSpace === \"G\" || cColorSpace === \"RGB\" || cColorSpace === \"CMYK\");\\n }\\n static _isValidColor(colorArray) {\\n if (!Array.isArray(colorArray) || colorArray.length === 0) {\\n return false;\\n }\\n const space = colorArray[0];\\n if (!Color._isValidSpace(space)) {\\n return false;\\n }\\n switch (space) {\\n case \"T\":\\n if (colorArray.length !== 1) {\\n return false;\\n }\\n break;\\n case \"G\":\\n if (colorArray.length !== 2) {\\n return false;\\n }\\n break;\\n case \"RGB\":\\n if (colorArray.length !== 4) {\\n return false;\\n }\\n break;\\n case \"CMYK\":\\n if (colorArray.length !== 5) {\\n return false;\\n }\\n break;\\n default:\\n return false;\\n }\\n return colorArray.slice(1).every(c => typeof c === \"number\" && c >= 0 && c c === colorArray2[i + 1]);\\n }\\n}\\nexports.Color = Color;\\n\\n/***/ }),\\n/* 6 */\\n/***/ ((__unused_webpack_module, exports) => {\\n\\n\\n\\nObject.defineProperty(exports, \"__esModule\", ({\\n value: true\\n}));\\nexports.ColorConverters = void 0;\\nfunction makeColorComp(n) {\\n return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\\n}\\nclass ColorConverters {\\n static CMYK_G([c, y, m, k]) {\\n return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\\n }\\n static G_CMYK([g]) {\\n return [\"CMYK\", 0, 0, 0, 1 - g];\\n }\\n static G_RGB([g]) {\\n return [\"RGB\", g, g, g];\\n }\\n static G_HTML([g]) {\\n const G = makeColorComp(g);\\n return `#${G}${G}${G}`;\\n }\\n static RGB_G([r, g, b]) {\\n return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\\n }\\n static RGB_HTML([r, g, b]) {\\n const R = makeColorComp(r);\\n const G = makeColorComp(g);\\n const B = makeColorComp(b);\\n return `#${R}${G}${B}`;\\n }\\n static T_HTML() {\\n return \"#00000000\";\\n }\\n static CMYK_RGB([c, y, m, k]) {\\n return [\"RGB\", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\\n }\\n static CMYK_HTML(components) {\\n const rgb = this.CMYK_RGB(components).slice(1);\\n return this.RGB_HTML(rgb);\\n }\\n static RGB_CMYK([r, g, b]) {\\n const c = 1 - r;\\n const m = 1 - g;\\n const y = 1 - b;\\n const k = Math.min(c, m, y);\\n return [\"CMYK\", c, m, y, k];\\n }\\n}\\nexports.ColorConverters = ColorConverters;\\n\\n/***/ }),\\n/* 7 */\\n/***/ ((__unused_webpack_module, exports) => {\\n\\n\\n\\nObject.defineProperty(exports, \"__esModule\", ({\\n value: true\\n}));\\nexports.PDFObject = void 0;\\nclass PDFObject {\\n constructor(data) {\\n this._expandos = Object.create(null);\\n this._send = data.send || null;\\n this._id = data.id || null;\\n }\\n}\\nexports.PDFObject = PDFObject;\\n\\n/***/ }),\\n/* 8 */\\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\\n\\n\\n\\nObject.defineProperty(exports, \"__esModule\", ({\\n value: true\\n}));\\nexports.AForm = void 0;\\nvar _constants = __w_pdfjs_require__(2);\\nclass AForm {\\n constructor(document, app, util, color) {\\n this._document = document;\\n this._app = app;\\n this._util = util;\\n this._color = color;\\n this._dateFormats = [\"m/d\", \"m/d/yy\", \"mm/dd/yy\", \"mm/yy\", \"d-mmm\", \"d-mmm-yy\", \"dd-mmm-yy\", \"yy-mm-dd\", \"mmm-yy\", \"mmmm-yy\", \"mmm d, yyyy\", \"mmmm d, yyyy\", \"m/d/yy h:MM tt\", \"m/d/yy HH:MM\"];\\n this._timeFormats = [\"HH:MM\", \"h:MM tt\", \"HH:MM:ss\", \"h:MM:ss tt\"];\\n this._dateActionsCache = new Map();\\n this._emailRegex = new RegExp(\"^[a-zA-Z0-9.!#$%&\\'*+\\\\\\\\/=?^_`{|}~-]+\" + \"@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\" + \"(?:\\\\\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$\");\\n }\\n _mkTargetName(event) {\\n return event.target ? `[ ${event.target.name} ]` : \"\";\\n }\\n _tryToGuessDate(cFormat, cDate) {\\n let actions = this._dateActionsCache.get(cFormat);\\n if (!actions) {\\n actions = [];\\n this._dateActionsCache.set(cFormat, actions);\\n cFormat.replace(/(d+)|(m+)|(y+)|(H+)|(M+)|(s+)/g, function (match, d, m, y, H, M, s) {\\n if (d) {\\n actions.push((n, date) => {\\n if (n >= 1 && n {\\n if (n >= 1 && n {\\n if (n < 50) {\\n n += 2000;\\n } else if (n < 100) {\\n n += 1900;\\n }\\n date.setYear(n);\\n return true;\\n });\\n } else if (H) {\\n actions.push((n, date) => {\\n if (n >= 0 && n {\\n if (n >= 0 && n {\\n if (n >= 0 && n 1) {\\n event.value = parseFloat(value.replace(\",\", \".\"));\\n }\\n }\\n AFPercent_Format(nDec, sepStyle, percentPrepend = false) {\\n if (typeof nDec !== \"number\") {\\n return;\\n }\\n if (typeof sepStyle !== \"number\") {\\n return;\\n }\\n if (nDec < 0) {\\n throw new Error(\"Invalid nDec value in AFPercent_Format\");\\n }\\n const event = globalThis.event;\\n if (nDec > 512) {\\n event.value = \"%\";\\n return;\\n }\\n nDec = Math.floor(nDec);\\n sepStyle = Math.min(Math.max(0, Math.floor(sepStyle)), 4);\\n let value = this.AFMakeNumber(event.value);\\n if (value === null) {\\n event.value = \"%\";\\n return;\\n }\\n const formatStr = `%,${sepStyle}.${nDec}f`;\\n value = this._util.printf(formatStr, value * 100);\\n if (percentPrepend) {\\n event.value = `%${value}`;\\n } else {\\n event.value = `${value}%`;\\n }\\n }\\n AFPercent_Keystroke(nDec, sepStyle) {\\n this.AFNumber_Keystroke(nDec, sepStyle, 0, 0, \"\", true);\\n }\\n AFDate_FormatEx(cFormat) {\\n const event = globalThis.event;\\n const value = event.value;\\n if (!value) {\\n return;\\n }\\n const date = this._parseDate(cFormat, value);\\n if (date !== null) {\\n event.value = this._util.printd(cFormat, date);\\n }\\n }\\n AFDate_Format(pdf) {\\n if (pdf >= 0 && pdf < this._dateFormats.length) {\\n this.AFDate_FormatEx(this._dateFormats[pdf]);\\n }\\n }\\n AFDate_KeystrokeEx(cFormat) {\\n const event = globalThis.event;\\n if (!event.willCommit) {\\n return;\\n }\\n const value = this.AFMergeChange(event);\\n if (!value) {\\n return;\\n }\\n if (this._parseDate(cFormat, value) === null) {\\n const invalid = _constants.GlobalConstants.IDS_INVALID_DATE;\\n const invalid2 = _constants.GlobalConstants.IDS_INVALID_DATE2;\\n const err = `${invalid} ${this._mkTargetName(event)}${invalid2}${cFormat}`;\\n this._app.alert(err);\\n event.rc = false;\\n }\\n }\\n AFDate_Keystroke(pdf) {\\n if (pdf >= 0 && pdf < this._dateFormats.length) {\\n this.AFDate_KeystrokeEx(this._dateFormats[pdf]);\\n }\\n }\\n AFRange_Validate(bGreaterThan, nGreaterThan, bLessThan, nLessThan) {\\n const event = globalThis.event;\\n if (!event.value) {\\n return;\\n }\\n const value = this.AFMakeNumber(event.value);\\n if (value === null) {\\n return;\\n }\\n bGreaterThan = !!bGreaterThan;\\n bLessThan = !!bLessThan;\\n if (bGreaterThan) {\\n nGreaterThan = this.AFMakeNumber(nGreaterThan);\\n if (nGreaterThan === null) {\\n return;\\n }\\n }\\n if (bLessThan) {\\n nLessThan = this.AFMakeNumber(nLessThan);\\n if (nLessThan === null) {\\n return;\\n }\\n }\\n let err = \"\";\\n if (bGreaterThan && bLessThan) {\\n if (value < nGreaterThan || value > nLessThan) {\\n err = this._util.printf(_constants.GlobalConstants.IDS_GT_AND_LT, nGreaterThan, nLessThan);\\n }\\n } else if (bGreaterThan) {\\n if (value < nGreaterThan) {\\n err = this._util.printf(_constants.GlobalConstants.IDS_GREATER_THAN, nGreaterThan);\\n }\\n } else if (value > nLessThan) {\\n err = this._util.printf(_constants.GlobalConstants.IDS_LESS_THAN, nLessThan);\\n }\\n if (err) {\\n this._app.alert(err);\\n event.rc = false;\\n }\\n }\\n AFSimple(cFunction, nValue1, nValue2) {\\n const value1 = this.AFMakeNumber(nValue1);\\n if (value1 === null) {\\n throw new Error(\"Invalid nValue1 in AFSimple\");\\n }\\n const value2 = this.AFMakeNumber(nValue2);\\n if (value2 === null) {\\n throw new Error(\"Invalid nValue2 in AFSimple\");\\n }\\n switch (cFunction) {\\n case \"AVG\":\\n return (value1 + value2) / 2;\\n case \"SUM\":\\n return value1 + value2;\\n case \"PRD\":\\n return value1 * value2;\\n case \"MIN\":\\n return Math.min(value1, value2);\\n case \"MAX\":\\n return Math.max(value1, value2);\\n }\\n throw new Error(\"Invalid cFunction in AFSimple\");\\n }\\n AFSimple_Calculate(cFunction, cFields) {\\n const actions = {\\n AVG: args => args.reduce((acc, value) => acc + value, 0) / args.length,\\n SUM: args => args.reduce((acc, value) => acc + value, 0),\\n PRD: args => args.reduce((acc, value) => acc * value, 1),\\n MIN: args => args.reduce((acc, value) => Math.min(acc, value), Number.MAX_VALUE),\\n MAX: args => args.reduce((acc, value) => Math.max(acc, value), Number.MIN_VALUE)\\n };\\n if (!(cFunction in actions)) {\\n throw new TypeError(\"Invalid function in AFSimple_Calculate\");\\n }\\n const event = globalThis.event;\\n const values = [];\\n cFields = this.AFMakeArrayFromList(cFields);\\n for (const cField of cFields) {\\n const field = this._document.getField(cField);\\n if (!field) {\\n continue;\\n }\\n for (const child of field.getArray()) {\\n const number = this.AFMakeNumber(child.value);\\n if (number !== null) {\\n values.push(number);\\n }\\n }\\n }\\n if (values.length === 0) {\\n event.value = cFunction === \"PRD\" ? 1 : 0;\\n return;\\n }\\n const res = actions[cFunction](values);\\n event.value = Math.round(1e6 * res) / 1e6;\\n }\\n AFSpecial_Format(psf) {\\n const event = globalThis.event;\\n if (!event.value) {\\n return;\\n }\\n psf = this.AFMakeNumber(psf);\\n let formatStr;\\n switch (psf) {\\n case 0:\\n formatStr = \"99999\";\\n break;\\n case 1:\\n formatStr = \"99999-9999\";\\n break;\\n case 2:\\n if (this._util.printx(\"9999999999\", event.value).length >= 10) {\\n formatStr = \"(999) 999-9999\";\\n } else {\\n formatStr = \"999-9999\";\\n }\\n break;\\n case 3:\\n formatStr = \"999-99-9999\";\\n break;\\n default:\\n throw new Error(\"Invalid psf in AFSpecial_Format\");\\n }\\n event.value = this._util.printx(formatStr, event.value);\\n }\\n AFSpecial_KeystrokeEx(cMask) {\\n if (!cMask) {\\n return;\\n }\\n const event = globalThis.event;\\n const value = this.AFMergeChange(event);\\n if (!value) {\\n return;\\n }\\n const checkers = new Map([[\"9\", char => char >= \"0\" && char \"a\"","link":"/js/pdfjs/build/pdf.sandbox.js"},{"title":"","text":"/* Copyright 2014 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ .textLayer { position: absolute; text-align: initial; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; opacity: 0.25; line-height: 1; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; text-size-adjust: none; forced-color-adjust: none; transform-origin: 0 0; z-index: 2; } .textLayer span, .textLayer br { color: transparent; position: absolute; white-space: pre; cursor: text; transform-origin: 0% 0%; } /* Only necessary in Google Chrome, see issue 14205, and most unfortunately * the problem doesn't show up in \"text\" reference tests. */ .textLayer span.markedContent { top: 0; height: 0; } .textLayer .highlight { margin: -1px; padding: 1px; background-color: rgba(180, 0, 170, 1); border-radius: 4px; } .textLayer .highlight.appended { position: initial; } .textLayer .highlight.begin { border-radius: 4px 0 0 4px; } .textLayer .highlight.end { border-radius: 0 4px 4px 0; } .textLayer .highlight.middle { border-radius: 0; } .textLayer .highlight.selected { background-color: rgba(0, 100, 0, 1); } .textLayer ::-moz-selection { background: blue; background: AccentColor; } .textLayer ::selection { background: blue; background: AccentColor; } /* Avoids https://github.com/mozilla/pdf.js/issues/13840 in Chrome */ .textLayer br::-moz-selection { background: transparent; } .textLayer br::selection { background: transparent; } .textLayer .endOfContent { display: block; position: absolute; left: 0; top: 100%; right: 0; bottom: 0; z-index: -1; cursor: default; -webkit-user-select: none; -moz-user-select: none; user-select: none; } .textLayer .endOfContent.active { top: 0; } :root { --annotation-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,\"); --input-focus-border-color: Highlight; --input-focus-outline: 1px solid Canvas; --input-unfocused-border-color: transparent; --input-disabled-border-color: transparent; --input-hover-border-color: black; } @media (forced-colors: active) { :root { --input-focus-border-color: CanvasText; --input-unfocused-border-color: ActiveText; --input-disabled-border-color: GrayText; --input-hover-border-color: Highlight; } .annotationLayer .textWidgetAnnotation input:required, .annotationLayer .textWidgetAnnotation textarea:required, .annotationLayer .choiceWidgetAnnotation select:required, .annotationLayer .buttonWidgetAnnotation.checkBox input:required, .annotationLayer .buttonWidgetAnnotation.radioButton input:required { outline: 1.5px solid selectedItem; } } .annotationLayer { position: absolute; top: 0; left: 0; pointer-events: none; transform-origin: 0 0; z-index: 3; } .annotationLayer section { position: absolute; text-align: initial; pointer-events: auto; box-sizing: border-box; transform-origin: 0 0; } .annotationLayer .linkAnnotation > a, .annotationLayer .buttonWidgetAnnotation.pushButton > a { position: absolute; font-size: 1em; top: 0; left: 0; width: 100%; height: 100%; } .annotationLayer .buttonWidgetAnnotation.pushButton > canvas { width: 100%; height: 100%; } .annotationLayer .linkAnnotation > a:hover, .annotationLayer .buttonWidgetAnnotation.pushButton > a:hover { opacity: 0.2; background: rgba(255, 255, 0, 1); box-shadow: 0 2px 10px rgba(255, 255, 0, 1); } .annotationLayer .textAnnotation img { position: absolute; cursor: pointer; width: 100%; height: 100%; } .annotationLayer .textWidgetAnnotation input, .annotationLayer .textWidgetAnnotation textarea, .annotationLayer .choiceWidgetAnnotation select, .annotationLayer .buttonWidgetAnnotation.checkBox input, .annotationLayer .buttonWidgetAnnotation.radioButton input { background-image: var(--annotation-unfocused-field-background); border: 2px solid var(--input-unfocused-border-color); box-sizing: border-box; font: calc(9px * var(--scale-factor)) sans-serif; height: 100%; margin: 0; vertical-align: top; width: 100%; } .annotationLayer .textWidgetAnnotation input:required, .annotationLayer .textWidgetAnnotation textarea:required, .annotationLayer .choiceWidgetAnnotation select:required, .annotationLayer .buttonWidgetAnnotation.checkBox input:required, .annotationLayer .buttonWidgetAnnotation.radioButton input:required { outline: 1.5px solid red; } .annotationLayer .choiceWidgetAnnotation select option { padding: 0; } .annotationLayer .buttonWidgetAnnotation.radioButton input { border-radius: 50%; } .annotationLayer .textWidgetAnnotation textarea { resize: none; } .annotationLayer .textWidgetAnnotation input[disabled], .annotationLayer .textWidgetAnnotation textarea[disabled], .annotationLayer .choiceWidgetAnnotation select[disabled], .annotationLayer .buttonWidgetAnnotation.checkBox input[disabled], .annotationLayer .buttonWidgetAnnotation.radioButton input[disabled] { background: none; border: 2px solid var(--input-disabled-border-color); cursor: not-allowed; } .annotationLayer .textWidgetAnnotation input:hover, .annotationLayer .textWidgetAnnotation textarea:hover, .annotationLayer .choiceWidgetAnnotation select:hover, .annotationLayer .buttonWidgetAnnotation.checkBox input:hover, .annotationLayer .buttonWidgetAnnotation.radioButton input:hover { border: 2px solid var(--input-hover-border-color); } .annotationLayer .textWidgetAnnotation input:hover, .annotationLayer .textWidgetAnnotation textarea:hover, .annotationLayer .choiceWidgetAnnotation select:hover, .annotationLayer .buttonWidgetAnnotation.checkBox input:hover { border-radius: 2px; } .annotationLayer .textWidgetAnnotation input:focus, .annotationLayer .textWidgetAnnotation textarea:focus, .annotationLayer .choiceWidgetAnnotation select:focus { background: none; border: 2px solid var(--input-focus-border-color); border-radius: 2px; outline: var(--input-focus-outline); } .annotationLayer .buttonWidgetAnnotation.checkBox :focus, .annotationLayer .buttonWidgetAnnotation.radioButton :focus { background-image: none; background-color: transparent; } .annotationLayer .buttonWidgetAnnotation.checkBox :focus { border: 2px solid var(--input-focus-border-color); border-radius: 2px; outline: var(--input-focus-outline); } .annotationLayer .buttonWidgetAnnotation.radioButton :focus { border: 2px solid var(--input-focus-border-color); outline: var(--input-focus-outline); } .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before, .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after, .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before { background-color: CanvasText; content: \"\"; display: block; position: absolute; } .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before, .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after { height: 80%; left: 45%; width: 1px; } .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before { transform: rotate(45deg); } .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after { transform: rotate(-45deg); } .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before { border-radius: 50%; height: 50%; left: 30%; top: 20%; width: 50%; } .annotationLayer .textWidgetAnnotation input.comb { font-family: monospace; padding-left: 2px; padding-right: 0; } .annotationLayer .textWidgetAnnotation input.comb:focus { /* * Letter spacing is placed on the right side of each character. Hence, the * letter spacing of the last character may be placed outside the visible * area, causing horizontal scrolling. We avoid this by extending the width * when the element has focus and revert this when it loses focus. */ width: 103%; } .annotationLayer .buttonWidgetAnnotation.checkBox input, .annotationLayer .buttonWidgetAnnotation.radioButton input { -webkit-appearance: none; -moz-appearance: none; appearance: none; } .annotationLayer .popupTriggerArea { height: 100%; width: 100%; } .annotationLayer .popupWrapper { position: absolute; font-size: calc(9px * var(--scale-factor)); width: 100%; min-width: calc(180px * var(--scale-factor)); pointer-events: none; } .annotationLayer .popup { position: absolute; max-width: calc(180px * var(--scale-factor)); background-color: rgba(255, 255, 153, 1); box-shadow: 0 calc(2px * var(--scale-factor)) calc(5px * var(--scale-factor)) rgba(136, 136, 136, 1); border-radius: calc(2px * var(--scale-factor)); padding: calc(6px * var(--scale-factor)); margin-left: calc(5px * var(--scale-factor)); cursor: pointer; font: message-box; white-space: normal; word-wrap: break-word; pointer-events: auto; } .annotationLayer .popup > * { font-size: calc(9px * var(--scale-factor)); } .annotationLayer .popup h1 { display: inline-block; } .annotationLayer .popupDate { display: inline-block; margin-left: calc(5px * var(--scale-factor)); } .annotationLayer .popupContent { border-top: 1px solid rgba(51, 51, 51, 1); margin-top: calc(2px * var(--scale-factor)); padding-top: calc(2px * var(--scale-factor)); } .annotationLayer .richText > * { white-space: pre-wrap; font-size: calc(9px * var(--scale-factor)); } .annotationLayer .highlightAnnotation, .annotationLayer .underlineAnnotation, .annotationLayer .squigglyAnnotation, .annotationLayer .strikeoutAnnotation, .annotationLayer .freeTextAnnotation, .annotationLayer .lineAnnotation svg line, .annotationLayer .squareAnnotation svg rect, .annotationLayer .circleAnnotation svg ellipse, .annotationLayer .polylineAnnotation svg polyline, .annotationLayer .polygonAnnotation svg polygon, .annotationLayer .caretAnnotation, .annotationLayer .inkAnnotation svg polyline, .annotationLayer .stampAnnotation, .annotationLayer .fileAttachmentAnnotation { cursor: pointer; } .annotationLayer section svg { position: absolute; width: 100%; height: 100%; } .annotationLayer .annotationTextContent { position: absolute; width: 100%; height: 100%; opacity: 0; color: transparent; -webkit-user-select: none; -moz-user-select: none; user-select: none; pointer-events: none; } .annotationLayer .annotationTextContent span { width: 100%; display: inline-block; } :root { --xfa-unfocused-field-background: url(\"data:image/svg+xml;charset=UTF-8,\"); --xfa-focus-outline: auto; } @media (forced-colors: active) { :root { --xfa-focus-outline: 2px solid CanvasText; } .xfaLayer *:required { outline: 1.5px solid selectedItem; } } .xfaLayer { background-color: transparent; } .xfaLayer .highlight { margin: -1px; padding: 1px; background-color: rgba(239, 203, 237, 1); border-radius: 4px; } .xfaLayer .highlight.appended { position: initial; } .xfaLayer .highlight.begin { border-radius: 4px 0 0 4px; } .xfaLayer .highlight.end { border-radius: 0 4px 4px 0; } .xfaLayer .highlight.middle { border-radius: 0; } .xfaLayer .highlight.selected { background-color: rgba(203, 223, 203, 1); } .xfaPage { overflow: hidden; position: relative; } .xfaContentarea { position: absolute; } .xfaPrintOnly { display: none; } .xfaLayer { position: absolute; text-align: initial; top: 0; left: 0; transform-origin: 0 0; line-height: 1.2; } .xfaLayer * { color: inherit; font: inherit; font-style: inherit; font-weight: inherit; font-kerning: inherit; letter-spacing: -0.01px; text-align: inherit; text-decoration: inherit; box-sizing: border-box; background-color: transparent; padding: 0; margin: 0; pointer-events: auto; line-height: inherit; } .xfaLayer *:required { outline: 1.5px solid red; } .xfaLayer div { pointer-events: none; } .xfaLayer svg { pointer-events: none; } .xfaLayer svg * { pointer-events: none; } .xfaLayer a { color: blue; } .xfaRich li { margin-left: 3em; } .xfaFont { color: black; font-weight: normal; font-kerning: none; font-size: 10px; font-style: normal; letter-spacing: 0; text-decoration: none; vertical-align: 0; } .xfaCaption { overflow: hidden; flex: 0 0 auto; } .xfaCaptionForCheckButton { overflow: hidden; flex: 1 1 auto; } .xfaLabel { height: 100%; width: 100%; } .xfaLeft { display: flex; flex-direction: row; align-items: center; } .xfaRight { display: flex; flex-direction: row-reverse; align-items: center; } .xfaLeft > .xfaCaption, .xfaLeft > .xfaCaptionForCheckButton, .xfaRight > .xfaCaption, .xfaRight > .xfaCaptionForCheckButton { max-height: 100%; } .xfaTop { display: flex; flex-direction: column; align-items: flex-start; } .xfaBottom { display: flex; flex-direction: column-reverse; align-items: flex-start; } .xfaTop > .xfaCaption, .xfaTop > .xfaCaptionForCheckButton, .xfaBottom > .xfaCaption, .xfaBottom > .xfaCaptionForCheckButton { width: 100%; } .xfaBorder { background-color: transparent; position: absolute; pointer-events: none; } .xfaWrapped { width: 100%; height: 100%; } .xfaTextfield:focus, .xfaSelect:focus { background-image: none; background-color: transparent; outline: var(--xfa-focus-outline); outline-offset: -1px; } .xfaCheckbox:focus, .xfaRadio:focus { outline: var(--xfa-focus-outline); } .xfaTextfield, .xfaSelect { height: 100%; width: 100%; flex: 1 1 auto; border: none; resize: none; background-image: var(--xfa-unfocused-field-background); } .xfaSelect { padding-left: 2px; padding-right: 2px; padding-inline: 2px; } .xfaTop > .xfaTextfield, .xfaTop > .xfaSelect, .xfaBottom > .xfaTextfield, .xfaBottom > .xfaSelect { flex: 0 1 auto; } .xfaButton { cursor: pointer; width: 100%; height: 100%; border: none; text-align: center; } .xfaLink { width: 100%; height: 100%; position: absolute; top: 0; left: 0; } .xfaCheckbox, .xfaRadio { width: 100%; height: 100%; flex: 0 0 auto; border: none; } .xfaRich { white-space: pre-wrap; width: 100%; height: 100%; } .xfaImage { -o-object-position: left top; object-position: left top; -o-object-fit: contain; object-fit: contain; width: 100%; height: 100%; } .xfaLrTb, .xfaRlTb, .xfaTb { display: flex; flex-direction: column; align-items: stretch; } .xfaLr { display: flex; flex-direction: row; align-items: stretch; } .xfaRl { display: flex; flex-direction: row-reverse; align-items: stretch; } .xfaTb > div { justify-content: left; } .xfaPosition { position: relative; } .xfaArea { position: relative; } .xfaValignMiddle { display: flex; align-items: center; } .xfaTable { display: flex; flex-direction: column; align-items: stretch; } .xfaTable .xfaRow { display: flex; flex-direction: row; align-items: stretch; } .xfaTable .xfaRlRow { display: flex; flex-direction: row-reverse; align-items: stretch; flex: 1; } .xfaTable .xfaRlRow > div { flex: 1; } .xfaNonInteractive input, .xfaNonInteractive textarea, .xfaDisabled input, .xfaDisabled textarea, .xfaReadOnly input, .xfaReadOnly textarea { background: initial; } @media print { .xfaTextfield, .xfaSelect { background: transparent; } .xfaSelect { -webkit-appearance: none; -moz-appearance: none; appearance: none; text-indent: 1px; text-overflow: \"\"; } } :root { --focus-outline: solid 2px blue; --hover-outline: dashed 2px blue; --freetext-line-height: 1.35; --freetext-padding: 2px; --editorFreeText-editing-cursor: text; --editorInk-editing-cursor: url(images/cursor-editorInk.svg) 0 16, pointer; } @media (-webkit-min-device-pixel-ratio: 1.1), (min-resolution: 1.1dppx) { :root { --editorFreeText-editing-cursor: url(images/cursor-editorFreeText.svg) 0 16, text; } } @media (forced-colors: active) { :root { --focus-outline: solid 3px ButtonText; --hover-outline: dashed 3px ButtonText; } } [data-editor-rotation=\"90\"] { transform: rotate(90deg); } [data-editor-rotation=\"180\"] { transform: rotate(180deg); } [data-editor-rotation=\"270\"] { transform: rotate(270deg); } .annotationEditorLayer { background: transparent; position: absolute; top: 0; left: 0; font-size: calc(100px * var(--scale-factor)); transform-origin: 0 0; cursor: auto; z-index: 4; } .annotationEditorLayer.freeTextEditing { cursor: var(--editorFreeText-editing-cursor); } .annotationEditorLayer.inkEditing { cursor: var(--editorInk-editing-cursor); } .annotationEditorLayer .selectedEditor { outline: var(--focus-outline); resize: none; } .annotationEditorLayer .freeTextEditor { position: absolute; background: transparent; border-radius: 3px; padding: calc(var(--freetext-padding) * var(--scale-factor)); resize: none; width: auto; height: auto; z-index: 1; transform-origin: 0 0; touch-action: none; cursor: auto; } .annotationEditorLayer .freeTextEditor .internal { background: transparent; border: none; top: 0; left: 0; overflow: visible; white-space: nowrap; resize: none; font: 10px sans-serif; line-height: var(--freetext-line-height); } .annotationEditorLayer .freeTextEditor .overlay { position: absolute; display: none; background: transparent; top: 0; left: 0; width: 100%; height: 100%; } .annotationEditorLayer .freeTextEditor .overlay.enabled { display: block; } .annotationEditorLayer .freeTextEditor .internal:empty::before { content: attr(default-content); color: gray; } .annotationEditorLayer .freeTextEditor .internal:focus { outline: none; } .annotationEditorLayer .inkEditor.disabled { resize: none; } .annotationEditorLayer .inkEditor.disabled.selectedEditor { resize: horizontal; } .annotationEditorLayer .freeTextEditor:hover:not(.selectedEditor), .annotationEditorLayer .inkEditor:hover:not(.selectedEditor) { outline: var(--hover-outline); } .annotationEditorLayer .inkEditor { position: absolute; background: transparent; border-radius: 3px; overflow: auto; width: 100%; height: 100%; z-index: 1; transform-origin: 0 0; cursor: auto; } .annotationEditorLayer .inkEditor.editing { resize: none; cursor: inherit; } .annotationEditorLayer .inkEditor .inkEditorCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; touch-action: none; } :root { --viewer-container-height: 0; --pdfViewer-padding-bottom: 0; --page-margin: 1px auto -8px; --page-border: 9px solid transparent; --page-border-image: url(images/shadow.png) 9 9 repeat; --spreadHorizontalWrapped-margin-LR: -3.5px; --scale-factor: 1; } @media screen and (forced-colors: active) { :root { --pdfViewer-padding-bottom: 9px; --page-margin: 8px auto -1px; --page-border: 1px solid CanvasText; --page-border-image: none; --spreadHorizontalWrapped-margin-LR: 3.5px; } } [data-main-rotation=\"90\"] { transform: rotate(90deg) translateY(-100%); } [data-main-rotation=\"180\"] { transform: rotate(180deg) translate(-100%, -100%); } [data-main-rotation=\"270\"] { transform: rotate(270deg) translateX(-100%); } .pdfViewer { padding-bottom: var(--pdfViewer-padding-bottom); } .pdfViewer .canvasWrapper { overflow: hidden; width: 100%; height: 100%; z-index: 1; } .pdfViewer .page { direction: ltr; width: 816px; height: 1056px; margin: var(--page-margin); position: relative; overflow: visible; border: var(--page-border); -o-border-image: var(--page-border-image); border-image: var(--page-border-image); background-clip: content-box; background-color: rgba(255, 255, 255, 1); } .pdfViewer .dummyPage { position: relative; width: 0; height: var(--viewer-container-height); } .pdfViewer.removePageBorders .page { margin: 0 auto 10px; border: none; } .pdfViewer.singlePageView { display: inline-block; } .pdfViewer.singlePageView .page { margin: 0; border: none; } .pdfViewer.scrollHorizontal, .pdfViewer.scrollWrapped, .spread { margin-left: 3.5px; margin-right: 3.5px; text-align: center; } .pdfViewer.scrollHorizontal, .spread { white-space: nowrap; } .pdfViewer.removePageBorders, .pdfViewer.scrollHorizontal .spread, .pdfViewer.scrollWrapped .spread { margin-left: 0; margin-right: 0; } .spread .page, .spread .dummyPage, .pdfViewer.scrollHorizontal .page, .pdfViewer.scrollWrapped .page, .pdfViewer.scrollHorizontal .spread, .pdfViewer.scrollWrapped .spread { display: inline-block; vertical-align: middle; } .spread .page, .pdfViewer.scrollHorizontal .page, .pdfViewer.scrollWrapped .page { margin-left: var(--spreadHorizontalWrapped-margin-LR); margin-right: var(--spreadHorizontalWrapped-margin-LR); } .pdfViewer.removePageBorders .spread .page, .pdfViewer.removePageBorders.scrollHorizontal .page, .pdfViewer.removePageBorders.scrollWrapped .page { margin-left: 5px; margin-right: 5px; } .pdfViewer .page canvas { margin: 0; display: block; } .pdfViewer .page canvas[hidden] { display: none; } .pdfViewer .page canvas[zooming] { width: 100%; height: 100%; } .pdfViewer .page .loadingIcon { position: absolute; display: block; left: 0; top: 0; right: 0; bottom: 0; background: url(\"images/loading-icon.gif\") center no-repeat; z-index: 5; } .pdfViewer .page .loadingIcon.notVisible { background: none; } .pdfViewer.enablePermissions .textLayer span { -webkit-user-select: none !important; -moz-user-select: none !important; user-select: none !important; cursor: not-allowed; } .pdfPresentationMode .pdfViewer { padding-bottom: 0; } .pdfPresentationMode .spread { margin: 0; } .pdfPresentationMode .pdfViewer .page { margin: 0 auto; border: 2px solid transparent; } :root { --dir-factor: 1; --sidebar-width: 200px; --sidebar-transition-duration: 200ms; --sidebar-transition-timing-function: ease; --scale-select-width: 140px; --toolbar-icon-opacity: 0.7; --doorhanger-icon-opacity: 0.9; --main-color: rgba(12, 12, 13, 1); --body-bg-color: rgba(237, 237, 240, 1); --progressBar-percent: 0%; --progressBar-end-offset: 0; --progressBar-color: rgba(10, 132, 255, 1); --progressBar-bg-color: rgba(221, 221, 222, 1); --progressBar-blend-color: rgba(116, 177, 239, 1); --scrollbar-color: auto; --scrollbar-bg-color: auto; --toolbar-icon-bg-color: rgba(0, 0, 0, 1); --toolbar-icon-hover-bg-color: rgba(0, 0, 0, 1); --sidebar-narrow-bg-color: rgba(237, 237, 240, 0.9); --sidebar-toolbar-bg-color: rgba(245, 246, 247, 1); --toolbar-bg-color: rgba(249, 249, 250, 1); --toolbar-border-color: rgba(204, 204, 204, 1); --toolbar-box-shadow: 0 1px 0 var(--toolbar-border-color); --toolbar-border-bottom: none; --toolbarSidebar-box-shadow: inset calc(-1px * var(--dir-factor)) 0 0 rgba(0, 0, 0, 0.25), 0 1px 0 rgba(0, 0, 0, 0.15), 0 0 1px rgba(0, 0, 0, 0.1); --toolbarSidebar-border-bottom: none; --button-hover-color: rgba(221, 222, 223, 1); --toggled-btn-color: rgba(0, 0, 0, 1); --toggled-btn-bg-color: rgba(0, 0, 0, 0.3); --toggled-hover-active-btn-color: rgba(0, 0, 0, 0.4); --dropdown-btn-bg-color: rgba(215, 215, 219, 1); --dropdown-btn-border: none; --separator-color: rgba(0, 0, 0, 0.3); --field-color: rgba(6, 6, 6, 1); --field-bg-color: rgba(255, 255, 255, 1); --field-border-color: rgba(187, 187, 188, 1); --treeitem-color: rgba(0, 0, 0, 0.8); --treeitem-hover-color: rgba(0, 0, 0, 0.9); --treeitem-selected-color: rgba(0, 0, 0, 0.9); --treeitem-selected-bg-color: rgba(0, 0, 0, 0.25); --sidebaritem-bg-color: rgba(0, 0, 0, 0.15); --doorhanger-bg-color: rgba(255, 255, 255, 1); --doorhanger-border-color: rgba(12, 12, 13, 0.2); --doorhanger-hover-color: rgba(12, 12, 13, 1); --doorhanger-hover-bg-color: rgba(237, 237, 237, 1); --doorhanger-separator-color: rgba(222, 222, 222, 1); --dialog-button-border: none; --dialog-button-bg-color: rgba(12, 12, 13, 0.1); --dialog-button-hover-bg-color: rgba(12, 12, 13, 0.3); --loading-icon: url(images/loading.svg); --treeitem-expanded-icon: url(images/treeitem-expanded.svg); --treeitem-collapsed-icon: url(images/treeitem-collapsed.svg); --toolbarButton-editorFreeText-icon: url(images/toolbarButton-editorFreeText.svg); --toolbarButton-editorInk-icon: url(images/toolbarButton-editorInk.svg); --toolbarButton-menuArrow-icon: url(images/toolbarButton-menuArrow.svg); --toolbarButton-sidebarToggle-icon: url(images/toolbarButton-sidebarToggle.svg); --toolbarButton-secondaryToolbarToggle-icon: url(images/toolbarButton-secondaryToolbarToggle.svg); --toolbarButton-pageUp-icon: url(images/toolbarButton-pageUp.svg); --toolbarButton-pageDown-icon: url(images/toolbarButton-pageDown.svg); --toolbarButton-zoomOut-icon: url(images/toolbarButton-zoomOut.svg); --toolbarButton-zoomIn-icon: url(images/toolbarButton-zoomIn.svg); --toolbarButton-presentationMode-icon: url(images/toolbarButton-presentationMode.svg); --toolbarButton-print-icon: url(images/toolbarButton-print.svg); --toolbarButton-openFile-icon: url(images/toolbarButton-openFile.svg); --toolbarButton-download-icon: url(images/toolbarButton-download.svg); --toolbarButton-bookmark-icon: url(images/toolbarButton-bookmark.svg); --toolbarButton-viewThumbnail-icon: url(images/toolbarButton-viewThumbnail.svg); --toolbarButton-viewOutline-icon: url(images/toolbarButton-viewOutline.svg); --toolbarButton-viewAttachments-icon: url(images/toolbarButton-viewAttachments.svg); --toolbarButton-viewLayers-icon: url(images/toolbarButton-viewLayers.svg); --toolbarButton-currentOutlineItem-icon: url(images/toolbarButton-currentOutlineItem.svg); --toolbarButton-search-icon: url(images/toolbarButton-search.svg); --findbarButton-previous-icon: url(images/findbarButton-previous.svg); --findbarButton-next-icon: url(images/findbarButton-next.svg); --secondaryToolbarButton-firstPage-icon: url(images/secondaryToolbarButton-firstPage.svg); --secondaryToolbarButton-lastPage-icon: url(images/secondaryToolbarButton-lastPage.svg); --secondaryToolbarButton-rotateCcw-icon: url(images/secondaryToolbarButton-rotateCcw.svg); --secondaryToolbarButton-rotateCw-icon: url(images/secondaryToolbarButton-rotateCw.svg); --secondaryToolbarButton-selectTool-icon: url(images/secondaryToolbarButton-selectTool.svg); --secondaryToolbarButton-handTool-icon: url(images/secondaryToolbarButton-handTool.svg); --secondaryToolbarButton-scrollPage-icon: url(images/secondaryToolbarButton-scrollPage.svg); --secondaryToolbarButton-scrollVertical-icon: url(images/secondaryToolbarButton-scrollVertical.svg); --secondaryToolbarButton-scrollHorizontal-icon: url(images/secondaryToolbarButton-scrollHorizontal.svg); --secondaryToolbarButton-scrollWrapped-icon: url(images/secondaryToolbarButton-scrollWrapped.svg); --secondaryToolbarButton-spreadNone-icon: url(images/secondaryToolbarButton-spreadNone.svg); --secondaryToolbarButton-spreadOdd-icon: url(images/secondaryToolbarButton-spreadOdd.svg); --secondaryToolbarButton-spreadEven-icon: url(images/secondaryToolbarButton-spreadEven.svg); --secondaryToolbarButton-documentProperties-icon: url(images/secondaryToolbarButton-documentProperties.svg); } [dir=\"rtl\"]:root { --dir-factor: -1; } @media (prefers-color-scheme: dark) { :root { --main-color: rgba(249, 249, 250, 1); --body-bg-color: rgba(42, 42, 46, 1); --progressBar-color: rgba(0, 96, 223, 1); --progressBar-bg-color: rgba(40, 40, 43, 1); --progressBar-blend-color: rgba(20, 68, 133, 1); --scrollbar-color: rgba(121, 121, 123, 1); --scrollbar-bg-color: rgba(35, 35, 39, 1); --toolbar-icon-bg-color: rgba(255, 255, 255, 1); --toolbar-icon-hover-bg-color: rgba(255, 255, 255, 1); --sidebar-narrow-bg-color: rgba(42, 42, 46, 0.9); --sidebar-toolbar-bg-color: rgba(50, 50, 52, 1); --toolbar-bg-color: rgba(56, 56, 61, 1); --toolbar-border-color: rgba(12, 12, 13, 1); --button-hover-color: rgba(102, 102, 103, 1); --toggled-btn-color: rgba(255, 255, 255, 1); --toggled-btn-bg-color: rgba(0, 0, 0, 0.3); --toggled-hover-active-btn-color: rgba(0, 0, 0, 0.4); --dropdown-btn-bg-color: rgba(74, 74, 79, 1); --separator-color: rgba(0, 0, 0, 0.3); --field-color: rgba(250, 250, 250, 1); --field-bg-color: rgba(64, 64, 68, 1); --field-border-color: rgba(115, 115, 115, 1); --treeitem-color: rgba(255, 255, 255, 0.8); --treeitem-hover-color: rgba(255, 255, 255, 0.9); --treeitem-selected-color: rgba(255, 255, 255, 0.9); --treeitem-selected-bg-color: rgba(255, 255, 255, 0.25); --sidebaritem-bg-color: rgba(255, 255, 255, 0.15); --doorhanger-bg-color: rgba(74, 74, 79, 1); --doorhanger-border-color: rgba(39, 39, 43, 1); --doorhanger-hover-color: rgba(249, 249, 250, 1); --doorhanger-hover-bg-color: rgba(93, 94, 98, 1); --doorhanger-separator-color: rgba(92, 92, 97, 1); --dialog-button-bg-color: rgba(92, 92, 97, 1); --dialog-button-hover-bg-color: rgba(115, 115, 115, 1); /* This image is used in elements, which unfortunately means that * the `mask-image` approach used with all of the other images doesn't work * here; hence why we still have two versions of this particular image. */ --loading-icon: url(images/loading-dark.svg); } } @media screen and (forced-colors: active) { :root { --button-hover-color: Highlight; --doorhanger-hover-bg-color: Highlight; --toolbar-icon-opacity: 1; --toolbar-icon-bg-color: ButtonText; --toolbar-icon-hover-bg-color: ButtonFace; --toolbar-border-color: CanvasText; --toolbar-border-bottom: 1px solid var(--toolbar-border-color); --toolbar-box-shadow: none; --toggled-btn-color: HighlightText; --toggled-btn-bg-color: LinkText; --doorhanger-hover-color: ButtonFace; --doorhanger-border-color-whcm: 1px solid ButtonText; --doorhanger-triangle-opacity-whcm: 0; --dialog-button-border: 1px solid Highlight; --dialog-button-hover-bg-color: Highlight; --dialog-button-hover-color: ButtonFace; --dropdown-btn-border: 1px solid ButtonText; --field-border-color: ButtonText; --main-color: CanvasText; --separator-color: GrayText; --doorhanger-separator-color: GrayText; --toolbarSidebar-box-shadow: none; --toolbarSidebar-border-bottom: 1px solid var(--toolbar-border-color); } } * { padding: 0; margin: 0; } html, body { height: 100%; width: 100%; } body { background-color: var(--body-bg-color); scrollbar-color: var(--scrollbar-color) var(--scrollbar-bg-color); } .hidden, [hidden] { display: none !important; } #viewerContainer.pdfPresentationMode:-webkit-full-screen { top: 0; background-color: rgba(0, 0, 0, 1); width: 100%; height: 100%; overflow: hidden; cursor: none; -webkit-user-select: none; user-select: none; } #viewerContainer.pdfPresentationMode:fullscreen { top: 0; background-color: rgba(0, 0, 0, 1); width: 100%; height: 100%; overflow: hidden; cursor: none; -webkit-user-select: none; -moz-user-select: none; user-select: none; } .pdfPresentationMode:-webkit-full-screen section:not([data-internal-link]) { pointer-events: none; } .pdfPresentationMode:fullscreen section:not([data-internal-link]) { pointer-events: none; } .pdfPresentationMode:-webkit-full-screen .textLayer span { cursor: none; } .pdfPresentationMode:fullscreen .textLayer span { cursor: none; } .pdfPresentationMode.pdfPresentationModeControls > *, .pdfPresentationMode.pdfPresentationModeControls .textLayer span { cursor: default; } #outerContainer { width: 100%; height: 100%; position: relative; } [dir=\"ltr\"] #sidebarContainer { left: calc(-1 * var(--sidebar-width)); } [dir=\"rtl\"] #sidebarContainer { right: calc(-1 * var(--sidebar-width)); } [dir=\"ltr\"] #sidebarContainer { border-right: var(--doorhanger-border-color-whcm); } [dir=\"rtl\"] #sidebarContainer { border-left: var(--doorhanger-border-color-whcm); } [dir=\"ltr\"] #sidebarContainer { transition-property: left; } [dir=\"rtl\"] #sidebarContainer { transition-property: right; } #sidebarContainer { position: absolute; top: 32px; bottom: 0; inset-inline-start: calc(-1 * var(--sidebar-width)); width: var(--sidebar-width); visibility: hidden; z-index: 100; font: message-box; border-top: 1px solid rgba(51, 51, 51, 1); -webkit-border-end: var(--doorhanger-border-color-whcm); border-inline-end: var(--doorhanger-border-color-whcm); transition-property: inset-inline-start; transition-duration: var(--sidebar-transition-duration); transition-timing-function: var(--sidebar-transition-timing-function); } #outerContainer.sidebarMoving #sidebarContainer, #outerContainer.sidebarOpen #sidebarContainer { visibility: visible; } [dir=\"ltr\"] #outerContainer.sidebarOpen #sidebarContainer { left: 0; } [dir=\"rtl\"] #outerContainer.sidebarOpen #sidebarContainer { right: 0; } #outerContainer.sidebarOpen #sidebarContainer { inset-inline-start: 0; } #mainContainer { position: absolute; top: 0; right: 0; bottom: 0; left: 0; min-width: 350px; } [dir=\"ltr\"] #sidebarContent { left: 0; } [dir=\"rtl\"] #sidebarContent { right: 0; } #sidebarContent { top: 32px; bottom: 0; inset-inline-start: 0; overflow: auto; position: absolute; width: 100%; background-color: rgba(0, 0, 0, 0.1); box-shadow: inset calc(-1px * var(--dir-factor)) 0 0 rgba(0, 0, 0, 0.25); } #viewerContainer { overflow: auto; position: absolute; top: 32px; right: 0; bottom: 0; left: 0; outline: none; } #viewerContainer:not(.pdfPresentationMode) { transition-duration: var(--sidebar-transition-duration); transition-timing-function: var(--sidebar-transition-timing-function); } [dir=\"ltr\"] #outerContainer.sidebarOpen #viewerContainer:not(.pdfPresentationMode) { left: var(--sidebar-width); } [dir=\"rtl\"] #outerContainer.sidebarOpen #viewerContainer:not(.pdfPresentationMode) { right: var(--sidebar-width); } [dir=\"ltr\"] #outerContainer.sidebarOpen #viewerContainer:not(.pdfPresentationMode) { transition-property: left; } [dir=\"rtl\"] #outerContainer.sidebarOpen #viewerContainer:not(.pdfPresentationMode) { transition-property: right; } #outerContainer.sidebarOpen #viewerContainer:not(.pdfPresentationMode) { inset-inline-start: var(--sidebar-width); transition-property: inset-inline-start; } .toolbar { position: relative; left: 0; right: 0; z-index: 9999; cursor: default; font: message-box; } .toolbar input, .toolbar button, .toolbar select, .secondaryToolbar input, .secondaryToolbar button, .secondaryToolbar a, .secondaryToolbar select, .editorParamsToolbar input, .editorParamsToolbar button, .editorParamsToolbar select, .findbar input, .findbar button, .findbar select, #sidebarContainer input, #sidebarContainer button, #sidebarContainer select { outline: none; font: message-box; } #toolbarContainer { width: 100%; } #toolbarSidebar { width: 100%; height: 32px; background-color: var(--sidebar-toolbar-bg-color); box-shadow: var(--toolbarSidebar-box-shadow); border-bottom: var(--toolbarSidebar-border-bottom); } [dir=\"ltr\"] #sidebarResizer { right: -6px; } [dir=\"rtl\"] #sidebarResizer { left: -6px; } #sidebarResizer { position: absolute; top: 0; bottom: 0; inset-inline-end: -6px; width: 6px; z-index: 200; cursor: ew-resize; } #toolbarContainer, .findbar, .secondaryToolbar, .editorParamsToolbar { position: relative; height: 32px; background-color: var(--toolbar-bg-color); box-shadow: var(--toolbar-box-shadow); border-bottom: var(--toolbar-border-bottom); } #toolbarViewer { height: 32px; } [dir=\"ltr\"] #loadingBar { left: 0; right: var(--progressBar-end-offset); } [dir=\"rtl\"] #loadingBar { right: 0; left: var(--progressBar-end-offset); } [dir=\"ltr\"] #loadingBar { transition-property: left; } [dir=\"rtl\"] #loadingBar { transition-property: right; } #loadingBar { position: absolute; inset-inline: 0 var(--progressBar-end-offset); height: 4px; background-color: var(--progressBar-bg-color); border-bottom: 1px solid var(--toolbar-border-color); transition-property: inset-inline-start; transition-duration: var(--sidebar-transition-duration); transition-timing-function: var(--sidebar-transition-timing-function); } [dir=\"ltr\"] #outerContainer.sidebarOpen #loadingBar { left: var(--sidebar-width); } [dir=\"rtl\"] #outerContainer.sidebarOpen #loadingBar { right: var(--sidebar-width); } #outerContainer.sidebarOpen #loadingBar { inset-inline-start: var(--sidebar-width); } #loadingBar .progress { position: absolute; top: 0; left: 0; width: 100%; transform: scaleX(var(--progressBar-percent)); transform-origin: 0 0; height: 100%; background-color: var(--progressBar-color); overflow: hidden; transition: transform 200ms; } @keyframes progressIndeterminate { 0% { transform: translateX(-142px); } 100% { transform: translateX(0); } } #loadingBar.indeterminate .progress { transform: none; background-color: var(--progressBar-bg-color); transition: none; } #loadingBar.indeterminate .progress .glimmer { position: absolute; top: 0; left: 0; height: 100%; width: calc(100% + 150px); background: repeating-linear-gradient( 135deg, var(--progressBar-blend-color) 0, var(--progressBar-bg-color) 5px, var(--progressBar-bg-color) 45px, var(--progressBar-color) 55px, var(--progressBar-color) 95px, var(--progressBar-blend-color) 100px ); animation: progressIndeterminate 1s linear infinite; } #outerContainer.sidebarResizing #sidebarContainer, #outerContainer.sidebarResizing #viewerContainer, #outerContainer.sidebarResizing #loadingBar { /* Improve responsiveness and avoid visual glitches when the sidebar is resized. */ transition-duration: 0s; } .findbar, .secondaryToolbar, .editorParamsToolbar { top: 32px; position: absolute; z-index: 30000; height: auto; padding: 0 4px; margin: 4px 2px; font: message-box; font-size: 12px; line-height: 14px; text-align: left; cursor: default; } [dir=\"ltr\"] .findbar { left: 64px; } [dir=\"rtl\"] .findbar { right: 64px; } .findbar { inset-inline-start: 64px; min-width: 300px; background-color: var(--toolbar-bg-color); } .findbar > div { height: 32px; } [dir=\"ltr\"] .findbar > div#findbarInputContainer { margin-right: 4px; } [dir=\"rtl\"] .findbar > div#findbarInputContainer { margin-left: 4px; } .findbar > div#findbarInputContainer { -webkit-margin-end: 4px; margin-inline-end: 4px; } .findbar.wrapContainers > div, .findbar.wrapContainers > div#findbarMessageContainer > * { clear: both; } .findbar.wrapContainers > div#findbarMessageContainer { height: auto; } .findbar input[type=\"checkbox\"] { pointer-events: none; } .findbar label { -webkit-user-select: none; -moz-user-select: none; user-select: none; } .findbar label:hover, .findbar input:focus-visible + label { color: var(--toggled-btn-color); background-color: var(--button-hover-color); } .findbar .toolbarField[type=\"checkbox\"]:checked + .toolbarLabel { background-color: var(--toggled-btn-bg-color) !important; color: var(--toggled-btn-color); } #findInput { width: 200px; } #findInput::-moz-placeholder { font-style: normal; } #findInput::placeholder { font-style: normal; } #findInput[data-status=\"pending\"] { background-image: var(--loading-icon); background-repeat: no-repeat; background-position: calc(50% + 48% * var(--dir-factor)); } #findInput[data-status=\"notFound\"] { background-color: rgba(255, 102, 102, 1); } [dir=\"ltr\"] .secondaryToolbar,[dir=\"ltr\"] .editorParamsToolbar { right: 4px; } [dir=\"rtl\"] .secondaryToolbar,[dir=\"rtl\"] .editorParamsToolbar { left: 4px; } .secondaryToolbar, .editorParamsToolbar { padding: 6px 0 10px; inset-inline-end: 4px; height: auto; background-color: var(--doorhanger-bg-color); } .editorParamsToolbarContainer { width: 220px; margin-bottom: -4px; } .editorParamsToolbarContainer > .editorParamsSetter { min-height: 26px; display: flex; align-items: center; justify-content: space-between; padding-left: 10px; padding-right: 10px; padding-inline: 10px; } [dir=\"ltr\"] .editorParamsToolbarContainer .editorParamsLabel { padding-right: 10px; } [dir=\"rtl\"] .editorParamsToolbarContainer .editorParamsLabel { padding-left: 10px; } .editorParamsToolbarContainer .editorParamsLabel { -webkit-padding-end: 10px; padding-inline-end: 10px; flex: none; color: var(--main-color); } .editorParamsToolbarContainer .editorParamsColor { width: 32px; height: 32px; flex: none; } .editorParamsToolbarContainer .editorParamsSlider { background-color: transparent; width: 90px; flex: 0 1 0; } .editorParamsToolbarContainer .editorParamsSlider::-moz-range-progress { background-color: black; } .editorParamsToolbarContainer .editorParamsSlider::-webkit-slider-runnable-track, .editorParamsToolbarContainer .editorParamsSlider::-moz-range-track { background-color: black; } .editorParamsToolbarContainer .editorParamsSlider::-webkit-slider-thumb, .editorParamsToolbarContainer .editorParamsSlider::-moz-range-thumb { background-color: white; } #secondaryToolbarButtonContainer { max-width: 220px; min-height: 26px; max-height: calc(var(--viewer-container-height) - 40px); overflow-y: auto; margin-bottom: -4px; } [dir=\"ltr\"] #editorInkParamsToolbar { right: 40px; } [dir=\"rtl\"] #editorInkParamsToolbar { left: 40px; } #editorInkParamsToolbar { inset-inline-end: 40px; background-color: var(--toolbar-bg-color); } [dir=\"ltr\"] #editorFreeTextParamsToolbar { right: 68px; } [dir=\"rtl\"] #editorFreeTextParamsToolbar { left: 68px; } #editorFreeTextParamsToolbar { inset-inline-end: 68px; background-color: var(--toolbar-bg-color); } .doorHanger, .doorHangerRight { border-radius: 2px; box-shadow: 0 1px 5px var(--doorhanger-border-color), 0 0 0 1px var(--doorhanger-border-color); border: var(--doorhanger-border-color-whcm); } .doorHanger:after, .doorHanger:before, .doorHangerRight:after, .doorHangerRight:before { bottom: 100%; border: 8px solid rgba(0, 0, 0, 0); content: \" \"; height: 0; width: 0; position: absolute; pointer-events: none; opacity: var(--doorhanger-triangle-opacity-whcm); } [dir=\"ltr\"] .doorHanger:after { left: 10px; } [dir=\"rtl\"] .doorHanger:after { right: 10px; } [dir=\"ltr\"] .doorHanger:after { margin-left: -8px; } [dir=\"rtl\"] .doorHanger:after { margin-right: -8px; } .doorHanger:after { inset-inline-start: 10px; -webkit-margin-start: -8px; margin-inline-start: -8px; border-bottom-color: var(--toolbar-bg-color); } [dir=\"ltr\"] .doorHangerRight:after { right: 10px; } [dir=\"rtl\"] .doorHangerRight:after { left: 10px; } [dir=\"ltr\"] .doorHangerRight:after { margin-right: -8px; } [dir=\"rtl\"] .doorHangerRight:after { margin-left: -8px; } .doorHangerRight:after { inset-inline-end: 10px; -webkit-margin-end: -8px; margin-inline-end: -8px; border-bottom-color: var(--doorhanger-bg-color); } .doorHanger:before, .doorHangerRight:before { border-bottom-color: var(--doorhanger-border-color); border-width: 9px; } [dir=\"ltr\"] .doorHanger:before { left: 10px; } [dir=\"rtl\"] .doorHanger:before { right: 10px; } [dir=\"ltr\"] .doorHanger:before { margin-left: -9px; } [dir=\"rtl\"] .doorHanger:before { margin-right: -9px; } .doorHanger:before { inset-inline-start: 10px; -webkit-margin-start: -9px; margin-inline-start: -9px; } [dir=\"ltr\"] .doorHangerRight:before { right: 10px; } [dir=\"rtl\"] .doorHangerRight:before { left: 10px; } [dir=\"ltr\"] .doorHangerRight:before { margin-right: -9px; } [dir=\"rtl\"] .doorHangerRight:before { margin-left: -9px; } .doorHangerRight:before { inset-inline-end: 10px; -webkit-margin-end: -9px; margin-inline-end: -9px; } #findResultsCount { background-color: rgba(217, 217, 217, 1); color: rgba(82, 82, 82, 1); text-align: center; padding: 4px 5px; margin: 5px; } #findMsg { color: rgba(251, 0, 0, 1); } #findResultsCount:empty, #findMsg:empty { display: none; } #toolbarViewerMiddle { position: absolute; left: 50%; transform: translateX(-50%); } [dir=\"ltr\"] #toolbarViewerLeft,[dir=\"ltr\"] #toolbarSidebarLeft { float: left; } [dir=\"rtl\"] #toolbarViewerLeft,[dir=\"rtl\"] #toolbarSidebarLeft { float: right; } #toolbarViewerLeft, #toolbarSidebarLeft { float: inline-start; } [dir=\"ltr\"] #toolbarViewerRight,[dir=\"ltr\"] #toolbarSidebarRight { float: right; } [dir=\"rtl\"] #toolbarViewerRight,[dir=\"rtl\"] #toolbarSidebarRight { float: left; } #toolbarViewerRight, #toolbarSidebarRight { float: inline-end; } [dir=\"ltr\"] #toolbarViewerLeft > *,[dir=\"ltr\"] #toolbarViewerMiddle > *,[dir=\"ltr\"] #toolbarViewerRight > *,[dir=\"ltr\"] #toolbarSidebarLeft *,[dir=\"ltr\"] #toolbarSidebarRight *,[dir=\"ltr\"] .findbar * { float: left; } [dir=\"rtl\"] #toolbarViewerLeft > *,[dir=\"rtl\"] #toolbarViewerMiddle > *,[dir=\"rtl\"] #toolbarViewerRight > *,[dir=\"rtl\"] #toolbarSidebarLeft *,[dir=\"rtl\"] #toolbarSidebarRight *,[dir=\"rtl\"] .findbar * { float: right; } #toolbarViewerLeft > *, #toolbarViewerMiddle > *, #toolbarViewerRight > *, #toolbarSidebarLeft *, #toolbarSidebarRight *, .findbar * { position: relative; float: inline-start; } [dir=\"ltr\"] #toolbarViewerLeft { padding-left: 1px; } [dir=\"rtl\"] #toolbarViewerLeft { padding-right: 1px; } #toolbarViewerLeft { -webkit-padding-start: 1px; padding-inline-start: 1px; } [dir=\"ltr\"] #toolbarViewerRight { padding-right: 1px; } [dir=\"rtl\"] #toolbarViewerRight { padding-left: 1px; } #toolbarViewerRight { -webkit-padding-end: 1px; padding-inline-end: 1px; } [dir=\"ltr\"] #toolbarSidebarRight { padding-right: 2px; } [dir=\"rtl\"] #toolbarSidebarRight { padding-left: 2px; } #toolbarSidebarRight { -webkit-padding-end: 2px; padding-inline-end: 2px; } .splitToolbarButton { margin: 2px; display: inline-block; } [dir=\"ltr\"] .splitToolbarButton > .toolbarButton { float: left; } [dir=\"rtl\"] .splitToolbarButton > .toolbarButton { float: right; } .splitToolbarButton > .toolbarButton { float: inline-start; } .toolbarButton, .secondaryToolbarButton, .dialogButton { border: none; background: none; width: 28px; height: 28px; outline: none; } .dialogButton:hover, .dialogButton:focus-visible { background-color: var(--dialog-button-hover-bg-color); } .dialogButton:hover > span, .dialogButton:focus-visible > span { color: var(--dialog-button-hover-color); } .toolbarButton > span { display: inline-block; width: 0; height: 0; overflow: hidden; } .toolbarButton[disabled], .secondaryToolbarButton[disabled], .dialogButton[disabled] { opacity: 0.5; } .splitToolbarButton > .toolbarButton:hover, .splitToolbarButton > .toolbarButton:focus-visible, .dropdownToolbarButton:hover { background-color: var(--button-hover-color); } .splitToolbarButton > .toolbarButton { position: relative; margin: 0; } [dir=\"ltr\"] #toolbarSidebar .splitToolbarButton > .toolbarButton { margin-right: 2px; } [dir=\"rtl\"] #toolbarSidebar .splitToolbarButton > .toolbarButton { margin-left: 2px; } #toolbarSidebar .splitToolbarButton > .toolbarButton { -webkit-margin-end: 2px; margin-inline-end: 2px; } [dir=\"ltr\"] .splitToolbarButtonSeparator { float: left; } [dir=\"rtl\"] .splitToolbarButtonSeparator { float: right; } .splitToolbarButtonSeparator { float: inline-start; margin: 4px 0; width: 1px; height: 20px; background-color: var(--separator-color); } .toolbarButton, .dropdownToolbarButton, .secondaryToolbarButton, .dialogButton { min-width: 16px; margin: 2px 1px; padding: 2px 6px 0; border: none; border-radius: 2px; color: var(--main-color); font-size: 12px; line-height: 14px; -webkit-user-select: none; -moz-user-select: none; user-select: none; cursor: default; box-sizing: border-box; } .toolbarButton:hover, .toolbarButton:focus-visible { background-color: var(--button-hover-color); } .secondaryToolbarButton:hover, .secondaryToolbarButton:focus-visible { background-color: var(--doorhanger-hover-bg-color); color: var(--doorhanger-hover-color); } .toolbarButton.toggled, .splitToolbarButton.toggled > .toolbarButton.toggled, .secondaryToolbarButton.toggled { background-color: var(--toggled-btn-bg-color); color: var(--toggled-btn-color); } .toolbarButton.toggled::before, .secondaryToolbarButton.toggled::before { background-color: var(--toggled-btn-color); } .toolbarButton.toggled:hover:active, .splitToolbarButton.toggled > .toolbarButton.toggled:hover:active, .secondaryToolbarButton.toggled:hover:active { background-color: var(--toggled-hover-active-btn-color); } .dropdownToolbarButton { width: var(--scale-select-width); padding: 0; background-color: var(--dropdown-btn-bg-color); border: var(--dropdown-btn-border); } [dir=\"ltr\"] .dropdownToolbarButton::after { right: 6px; } [dir=\"rtl\"] .dropdownToolbarButton::after { left: 6px; } .dropdownToolbarButton::after { top: 6px; inset-inline-end: 6px; pointer-events: none; -webkit-mask-image: var(--toolbarButton-menuArrow-icon); mask-image: var(--toolbarButton-menuArrow-icon); } [dir=\"ltr\"] .dropdownToolbarButton > select { padding-left: 6px; } [dir=\"rtl\"] .dropdownToolbarButton > select { padding-right: 6px; } .dropdownToolbarButton > select { -webkit-appearance: none; -moz-appearance: none; appearance: none; width: inherit; height: 28px; font-size: 12px; color: var(--main-color); margin: 0; padding: 1px 0 2px; -webkit-padding-start: 6px; padding-inline-start: 6px; border: none; background-color: var(--dropdown-btn-bg-color); } .dropdownToolbarButton > select:hover, .dropdownToolbarButton > select:focus-visible { background-color: var(--button-hover-color); color: var(--toggled-btn-color); } .dropdownToolbarButton > select > option { background: var(--doorhanger-bg-color); color: var(--main-color); } .toolbarButtonSpacer { width: 30px; display: inline-block; height: 1px; } .toolbarButton::before, .secondaryToolbarButton::before, .dropdownToolbarButton::after, .treeItemToggler::before { /* All matching images have a size of 16x16 * All relevant containers have a size of 28x28 */ position: absolute; display: inline-block; width: 16px; height: 16px; content: \"\"; background-color: var(--toolbar-icon-bg-color); -webkit-mask-size: cover; mask-size: cover; } .dropdownToolbarButton:hover::after, .dropdownToolbarButton:focus-visible::after, .dropdownToolbarButton:active::after { background-color: var(--toolbar-icon-hover-bg-color); } .toolbarButton::before { opacity: var(--toolbar-icon-opacity); top: 6px; left: 6px; } .toolbarButton:hover::before, .toolbarButton:focus-visible::before, .secondaryToolbarButton:hover::before, .secondaryToolbarButton:focus-visible::before { background-color: var(--toolbar-icon-hover-bg-color); } [dir=\"ltr\"] .secondaryToolbarButton::before { left: 12px; } [dir=\"rtl\"] .secondaryToolbarButton::before { right: 12px; } .secondaryToolbarButton::before { opacity: var(--doorhanger-icon-opacity); top: 5px; inset-inline-start: 12px; } #sidebarToggle::before { -webkit-mask-image: var(--toolbarButton-sidebarToggle-icon); mask-image: var(--toolbarButton-sidebarToggle-icon); transform: scaleX(var(--dir-factor)); } #secondaryToolbarToggle::before { -webkit-mask-image: var(--toolbarButton-secondaryToolbarToggle-icon); mask-image: var(--toolbarButton-secondaryToolbarToggle-icon); transform: scaleX(var(--dir-factor)); } #findPrevious::before { -webkit-mask-image: var(--findbarButton-previous-icon); mask-image: var(--findbarButton-previous-icon); } #findNext::before { -webkit-mask-image: var(--findbarButton-next-icon); mask-image: var(--findbarButton-next-icon); } #previous::before { -webkit-mask-image: var(--toolbarButton-pageUp-icon); mask-image: var(--toolbarButton-pageUp-icon); } #next::before { -webkit-mask-image: var(--toolbarButton-pageDown-icon); mask-image: var(--toolbarButton-pageDown-icon); } #zoomOut::before { -webkit-mask-image: var(--toolbarButton-zoomOut-icon); mask-image: var(--toolbarButton-zoomOut-icon); } #zoomIn::before { -webkit-mask-image: var(--toolbarButton-zoomIn-icon); mask-image: var(--toolbarButton-zoomIn-icon); } #presentationMode::before { -webkit-mask-image: var(--toolbarButton-presentationMode-icon); mask-image: var(--toolbarButton-presentationMode-icon); } #editorFreeText::before { -webkit-mask-image: var(--toolbarButton-editorFreeText-icon); mask-image: var(--toolbarButton-editorFreeText-icon); } #editorInk::before { -webkit-mask-image: var(--toolbarButton-editorInk-icon); mask-image: var(--toolbarButton-editorInk-icon); } #print::before, #secondaryPrint::before { -webkit-mask-image: var(--toolbarButton-print-icon); mask-image: var(--toolbarButton-print-icon); } #openFile::before, #secondaryOpenFile::before { -webkit-mask-image: var(--toolbarButton-openFile-icon); mask-image: var(--toolbarButton-openFile-icon); } #download::before, #secondaryDownload::before { -webkit-mask-image: var(--toolbarButton-download-icon); mask-image: var(--toolbarButton-download-icon); } a.secondaryToolbarButton { padding-top: 5px; text-decoration: none; } a.toolbarButton[href=\"#\"], a.secondaryToolbarButton[href=\"#\"] { opacity: 0.5; pointer-events: none; } #viewBookmark::before { -webkit-mask-image: var(--toolbarButton-bookmark-icon); mask-image: var(--toolbarButton-bookmark-icon); } #viewThumbnail::before { -webkit-mask-image: var(--toolbarButton-viewThumbnail-icon); mask-image: var(--toolbarButton-viewThumbnail-icon); } #viewOutline::before { -webkit-mask-image: var(--toolbarButton-viewOutline-icon); mask-image: var(--toolbarButton-viewOutline-icon); transform: scaleX(var(--dir-factor)); } #viewAttachments::before { -webkit-mask-image: var(--toolbarButton-viewAttachments-icon); mask-image: var(--toolbarButton-viewAttachments-icon); } #viewLayers::before { -webkit-mask-image: var(--toolbarButton-viewLayers-icon); mask-image: var(--toolbarButton-viewLayers-icon); } #currentOutlineItem::before { -webkit-mask-image: var(--toolbarButton-currentOutlineItem-icon); mask-image: var(--toolbarButton-currentOutlineItem-icon); transform: scaleX(var(--dir-factor)); } #viewFind::before { -webkit-mask-image: var(--toolbarButton-search-icon); mask-image: var(--toolbarButton-search-icon); } [dir=\"ltr\"] .pdfSidebarNotification::after { right: 2px; } [dir=\"rtl\"] .pdfSidebarNotification::after { left: 2px; } .pdfSidebarNotification::after { position: absolute; display: inline-block; top: 2px; inset-inline-end: 2px; /* Create a filled circle, with a diameter of 9 pixels, using only CSS: */ content: \"\"; background-color: rgba(112, 219, 85, 1); height: 9px; width: 9px; border-radius: 50%; } [dir=\"ltr\"] .secondaryToolbarButton { padding-left: 36px; } [dir=\"rtl\"] .secondaryToolbarButton { padding-right: 36px; } [dir=\"ltr\"] .secondaryToolbarButton { text-align: left; } [dir=\"rtl\"] .secondaryToolbarButton { text-align: right; } .secondaryToolbarButton { position: relative; margin: 0; padding: 0 0 1px; -webkit-padding-start: 36px; padding-inline-start: 36px; height: auto; min-height: 26px; width: auto; min-width: 100%; text-align: start; white-space: normal; border-radius: 0; box-sizing: border-box; display: inline-block; } [dir=\"ltr\"] .secondaryToolbarButton > span { padding-right: 4px; } [dir=\"rtl\"] .secondaryToolbarButton > span { padding-left: 4px; } .secondaryToolbarButton > span { -webkit-padding-end: 4px; padding-inline-end: 4px; } #firstPage::before { -webkit-mask-image: var(--secondaryToolbarButton-firstPage-icon); mask-image: var(--secondaryToolbarButton-firstPage-icon); } #lastPage::before { -webkit-mask-image: var(--secondaryToolbarButton-lastPage-icon); mask-image: var(--secondaryToolbarButton-lastPage-icon); } #pageRotateCcw::before { -webkit-mask-image: var(--secondaryToolbarButton-rotateCcw-icon); mask-image: var(--secondaryToolbarButton-rotateCcw-icon); } #pageRotateCw::before { -webkit-mask-image: var(--secondaryToolbarButton-rotateCw-icon); mask-image: var(--secondaryToolbarButton-rotateCw-icon); } #cursorSelectTool::before { -webkit-mask-image: var(--secondaryToolbarButton-selectTool-icon); mask-image: var(--secondaryToolbarButton-selectTool-icon); } #cursorHandTool::before { -webkit-mask-image: var(--secondaryToolbarButton-handTool-icon); mask-image: var(--secondaryToolbarButton-handTool-icon); } #scrollPage::before { -webkit-mask-image: var(--secondaryToolbarButton-scrollPage-icon); mask-image: var(--secondaryToolbarButton-scrollPage-icon); } #scrollVertical::before { -webkit-mask-image: var(--secondaryToolbarButton-scrollVertical-icon); mask-image: var(--secondaryToolbarButton-scrollVertical-icon); } #scrollHorizontal::before { -webkit-mask-image: var(--secondaryToolbarButton-scrollHorizontal-icon); mask-image: var(--secondaryToolbarButton-scrollHorizontal-icon); } #scrollWrapped::before { -webkit-mask-image: var(--secondaryToolbarButton-scrollWrapped-icon); mask-image: var(--secondaryToolbarButton-scrollWrapped-icon); } #spreadNone::before { -webkit-mask-image: var(--secondaryToolbarButton-spreadNone-icon); mask-image: var(--secondaryToolbarButton-spreadNone-icon); } #spreadOdd::before { -webkit-mask-image: var(--secondaryToolbarButton-spreadOdd-icon); mask-image: var(--secondaryToolbarButton-spreadOdd-icon); } #spreadEven::before { -webkit-mask-image: var(--secondaryToolbarButton-spreadEven-icon); mask-image: var(--secondaryToolbarButton-spreadEven-icon); } #documentProperties::before { -webkit-mask-image: var(--secondaryToolbarButton-documentProperties-icon); mask-image: var(--secondaryToolbarButton-documentProperties-icon); } .verticalToolbarSeparator { display: block; margin: 5px 2px; width: 1px; height: 22px; background-color: var(--separator-color); } .horizontalToolbarSeparator { display: block; margin: 6px 0; height: 1px; width: 100%; background-color: var(--doorhanger-separator-color); } .toolbarField { padding: 4px 7px; margin: 3px 0; border-radius: 2px; background-color: var(--field-bg-color); background-clip: padding-box; border: 1px solid var(--field-border-color); box-shadow: none; color: var(--field-color); font-size: 12px; line-height: 16px; outline: none; } [dir=\"ltr\"] .toolbarField[type=\"checkbox\"] { margin-left: 7px; } [dir=\"rtl\"] .toolbarField[type=\"checkbox\"] { margin-right: 7px; } .toolbarField[type=\"checkbox\"] { opacity: 0; position: absolute !important; left: 0; margin: 10px 0 3px; -webkit-margin-start: 7px; margin-inline-start: 7px; } #pageNumber { -moz-appearance: textfield; /* hides the spinner in moz */ text-align: right; width: 40px; } #pageNumber.visiblePageIsLoading { background-image: var(--loading-icon); background-repeat: no-repeat; background-position: 3px; } #pageNumber::-webkit-inner-spin-button { -webkit-appearance: none; } .toolbarField:focus { border-color: #0a84ff; } .toolbarLabel { min-width: 16px; padding: 7px; margin: 2px; border-radius: 2px; color: var(--main-color); font-size: 12px; line-height: 14px; text-align: left; -webkit-user-select: none; -moz-user-select: none; user-select: none; cursor: default; } [dir=\"ltr\"] #numPages.toolbarLabel { padding-left: 3px; } [dir=\"rtl\"] #numPages.toolbarLabel { padding-right: 3px; } #numPages.toolbarLabel { -webkit-padding-start: 3px; padding-inline-start: 3px; } #thumbnailView, #outlineView, #attachmentsView, #layersView { position: absolute; width: calc(100% - 8px); top: 0; bottom: 0; padding: 4px 4px 0; overflow: auto; -webkit-user-select: none; -moz-user-select: none; user-select: none; } #thumbnailView { width: calc(100% - 60px); padding: 10px 30px 0; } #thumbnailView > a:active, #thumbnailView > a:focus { outline: 0; } [dir=\"ltr\"] .thumbnail { float: left; } [dir=\"rtl\"] .thumbnail { float: right; } .thumbnail { float: inline-start; margin: 0 10px 5px; } #thumbnailView > a:last-of-type > .thumbnail { margin-bottom: 10px; } #thumbnailView > a:last-of-type > .thumbnail:not([data-loaded]) { margin-bottom: 9px; } .thumbnail:not([data-loaded]) { border: 1px dashed rgba(132, 132, 132, 1); margin: -1px 9px 4px; } .thumbnailImage { border: 1px solid rgba(0, 0, 0, 0); box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.5), 0 2px 8px rgba(0, 0, 0, 0.3); opacity: 0.8; z-index: 99; background-color: rgba(255, 255, 255, 1); background-clip: content-box; } .thumbnailSelectionRing { border-radius: 2px; padding: 7px; } a:focus > .thumbnail > .thumbnailSelectionRing > .thumbnailImage, .thumbnail:hover > .thumbnailSelectionRing > .thumbnailImage { opacity: 0.9; } a:focus > .thumbnail > .thumbnailSelectionRing, .thumbnail:hover > .thumbnailSelectionRing { background-color: var(--sidebaritem-bg-color); background-clip: padding-box; color: rgba(255, 255, 255, 0.9); } .thumbnail.selected > .thumbnailSelectionRing > .thumbnailImage { opacity: 1; } .thumbnail.selected > .thumbnailSelectionRing { background-color: var(--sidebaritem-bg-color); background-clip: padding-box; color: rgba(255, 255, 255, 1); } [dir=\"ltr\"] .treeWithDeepNesting > .treeItem,[dir=\"ltr\"] .treeItem > .treeItems { margin-left: 20px; } [dir=\"rtl\"] .treeWithDeepNesting > .treeItem,[dir=\"rtl\"] .treeItem > .treeItems { margin-right: 20px; } .treeWithDeepNesting > .treeItem, .treeItem > .treeItems { -webkit-margin-start: 20px; margin-inline-start: 20px; } [dir=\"ltr\"] .treeItem > a { padding-left: 4px; } [dir=\"rtl\"] .treeItem > a { padding-right: 4px; } .treeItem > a { text-decoration: none; display: inline-block; /* Subtract the right padding (left, in RTL mode) of the container: */ min-width: calc(100% - 4px); height: auto; margin-bottom: 1px; padding: 2px 0 5px; -webkit-padding-start: 4px; padding-inline-start: 4px; border-radius: 2px; color: var(--treeitem-color); font-size: 13px; line-height: 15px; -webkit-user-select: none; -moz-user-select: none; user-select: none; white-space: normal; cursor: pointer; } #layersView .treeItem > a * { cursor: pointer; } [dir=\"ltr\"] #layersView .treeItem > a > label { padding-left: 4px; } [dir=\"rtl\"] #layersView .treeItem > a > label { padding-right: 4px; } #layersView .treeItem > a > label { -webkit-padding-start: 4px; padding-inline-start: 4px; } [dir=\"ltr\"] #layersView .treeItem > a > label > input { float: left; } [dir=\"rtl\"] #layersView .treeItem > a > label > input { float: right; } #layersView .treeItem > a > label > input { float: inline-start; margin-top: 1px; } [dir=\"ltr\"] .treeItemToggler { float: left; } [dir=\"rtl\"] .treeItemToggler { float: right; } .treeItemToggler { position: relative; float: inline-start; height: 0; width: 0; color: rgba(255, 255, 255, 0.5); } [dir=\"ltr\"] .treeItemToggler::before { right: 4px; } [dir=\"rtl\"] .treeItemToggler::before { left: 4px; } .treeItemToggler::before { inset-inline-end: 4px; -webkit-mask-image: var(--treeitem-expanded-icon); mask-image: var(--treeitem-expanded-icon); } .treeItemToggler.treeItemsHidden::before { -webkit-mask-image: var(--treeitem-collapsed-icon); mask-image: var(--treeitem-collapsed-icon); transform: scaleX(var(--dir-factor)); } .treeItemToggler.treeItemsHidden ~ .treeItems { display: none; } .treeItem.selected > a { background-color: var(--treeitem-selected-bg-color); color: var(--treeitem-selected-color); } .treeItemToggler:hover, .treeItemToggler:hover + a, .treeItemToggler:hover ~ .treeItems, .treeItem > a:hover { background-color: var(--sidebaritem-bg-color); background-clip: padding-box; border-radius: 2px; color: var(--treeitem-hover-color); } .dialogButton { width: auto; margin: 3px 4px 2px !important; padding: 2px 11px; color: var(--main-color); background-color: var(--dialog-button-bg-color); border: var(--dialog-button-border) !important; } dialog { margin: auto; padding: 15px; border-spacing: 4px; color: var(--main-color); font: message-box; font-size: 12px; line-height: 14px; background-color: var(--doorhanger-bg-color); border: 1px solid rgba(0, 0, 0, 0.5); border-radius: 4px; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3); } dialog::-webkit-backdrop { background-color: rgba(0, 0, 0, 0.2); } dialog::backdrop { background-color: rgba(0, 0, 0, 0.2); } dialog > .row { display: table-row; } dialog > .row > * { display: table-cell; } dialog .toolbarField { margin: 5px 0; } dialog .separator { display: block; margin: 4px 0; height: 1px; width: 100%; background-color: var(--separator-color); } dialog .buttonRow { text-align: center; vertical-align: middle; } dialog :link { color: rgba(255, 255, 255, 1); } #passwordDialog { text-align: center; } #passwordDialog .toolbarField { width: 200px; } #documentPropertiesDialog { text-align: left; } [dir=\"ltr\"] #documentPropertiesDialog .row > * { text-align: left; } [dir=\"rtl\"] #documentPropertiesDialog .row > * { text-align: right; } #documentPropertiesDialog .row > * { min-width: 100px; text-align: start; } #documentPropertiesDialog .row > span { width: 125px; word-wrap: break-word; } #documentPropertiesDialog .row > p { max-width: 225px; word-wrap: break-word; } #documentPropertiesDialog .buttonRow { margin-top: 10px; } .grab-to-pan-grab { cursor: grab !important; } .grab-to-pan-grab *:not(input):not(textarea):not(button):not(select):not(:link) { cursor: inherit !important; } .grab-to-pan-grab:active, .grab-to-pan-grabbing { cursor: grabbing !important; position: fixed; background: rgba(0, 0, 0, 0); display: block; top: 0; left: 0; right: 0; bottom: 0; overflow: hidden; z-index: 50000; /* should be higher than anything else in PDF.js! */ } @page { margin: 0; } #printContainer { display: none; } @media print { body { background: rgba(0, 0, 0, 0) none; } body[data-pdfjsprinting] #outerContainer { display: none; } body[data-pdfjsprinting] #printContainer { display: block; } #printContainer { height: 100%; } /* wrapper around (scaled) print canvas elements */ #printContainer > .printedPage { page-break-after: always; page-break-inside: avoid; /* The wrapper always cover the whole page. */ height: 100%; width: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; } #printContainer > .xfaPrintedPage .xfaPage { position: absolute; } #printContainer > .xfaPrintedPage { page-break-after: always; page-break-inside: avoid; width: 100%; height: 100%; position: relative; } #printContainer > .printedPage canvas, #printContainer > .printedPage img { /* The intrinsic canvas / image size will make sure that we fit the page. */ max-width: 100%; max-height: 100%; direction: ltr; display: block; } } .visibleLargeView, .visibleMediumView { display: none; } @media all and (max-width: 900px) { #toolbarViewerMiddle { display: table; margin: auto; left: auto; position: inherit; transform: none; } } @media all and (max-width: 840px) { #sidebarContainer { background-color: var(--sidebar-narrow-bg-color); } [dir=\"ltr\"] #outerContainer.sidebarOpen #viewerContainer { left: 0 !important; } [dir=\"rtl\"] #outerContainer.sidebarOpen #viewerContainer { right: 0 !important; } #outerContainer.sidebarOpen #viewerContainer { inset-inline-start: 0 !important; } } @media all and (max-width: 820px) { #outerContainer .hiddenLargeView { display: none; } #outerContainer .visibleLargeView { display: inherit; } } @media all and (max-width: 750px) { #outerContainer .hiddenMediumView { display: none; } #outerContainer .visibleMediumView { display: inherit; } } @media all and (max-width: 690px) { .hiddenSmallView, .hiddenSmallView * { display: none; } .toolbarButtonSpacer { width: 0; } [dir=\"ltr\"] .findbar { left: 34px; } [dir=\"rtl\"] .findbar { right: 34px; } .findbar { inset-inline-start: 34px; } } @media all and (max-width: 560px) { #scaleSelectContainer { display: none; } }","link":"/js/pdfjs/web/viewer.css"},{"title":"","text":"/** * @licstart The following is the entire license notice for the * JavaScript code in this page * * Copyright 2022 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * * @licend The above is the entire license notice for the * JavaScript code in this page */ /******/ (() => { // webpackBootstrap /******/ \"use strict\"; /******/ var __webpack_modules__ = ([ /* 0 */, /* 1 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.animationStarted = exports.VERTICAL_PADDING = exports.UNKNOWN_SCALE = exports.TextLayerMode = exports.SpreadMode = exports.SidebarView = exports.ScrollMode = exports.SCROLLBAR_PADDING = exports.RenderingStates = exports.RendererType = exports.ProgressBar = exports.PresentationModeState = exports.OutputScale = exports.MIN_SCALE = exports.MAX_SCALE = exports.MAX_AUTO_SCALE = exports.DEFAULT_SCALE_VALUE = exports.DEFAULT_SCALE_DELTA = exports.DEFAULT_SCALE = exports.AutoPrintRegExp = void 0; exports.apiPageLayoutToViewerModes = apiPageLayoutToViewerModes; exports.apiPageModeToSidebarView = apiPageModeToSidebarView; exports.approximateFraction = approximateFraction; exports.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements; exports.binarySearchFirstItem = binarySearchFirstItem; exports.docStyle = void 0; exports.getActiveOrFocusedElement = getActiveOrFocusedElement; exports.getPageSizeInches = getPageSizeInches; exports.getVisibleElements = getVisibleElements; exports.isPortraitOrientation = isPortraitOrientation; exports.isValidRotation = isValidRotation; exports.isValidScrollMode = isValidScrollMode; exports.isValidSpreadMode = isValidSpreadMode; exports.noContextMenuHandler = noContextMenuHandler; exports.normalizeWheelEventDelta = normalizeWheelEventDelta; exports.normalizeWheelEventDirection = normalizeWheelEventDirection; exports.parseQueryString = parseQueryString; exports.removeNullCharacters = removeNullCharacters; exports.roundToDivide = roundToDivide; exports.scrollIntoView = scrollIntoView; exports.watchScroll = watchScroll; const DEFAULT_SCALE_VALUE = \"auto\"; exports.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE; const DEFAULT_SCALE = 1.0; exports.DEFAULT_SCALE = DEFAULT_SCALE; const DEFAULT_SCALE_DELTA = 1.1; exports.DEFAULT_SCALE_DELTA = DEFAULT_SCALE_DELTA; const MIN_SCALE = 0.1; exports.MIN_SCALE = MIN_SCALE; const MAX_SCALE = 10.0; exports.MAX_SCALE = MAX_SCALE; const UNKNOWN_SCALE = 0; exports.UNKNOWN_SCALE = UNKNOWN_SCALE; const MAX_AUTO_SCALE = 1.25; exports.MAX_AUTO_SCALE = MAX_AUTO_SCALE; const SCROLLBAR_PADDING = 40; exports.SCROLLBAR_PADDING = SCROLLBAR_PADDING; const VERTICAL_PADDING = 5; exports.VERTICAL_PADDING = VERTICAL_PADDING; const RenderingStates = { INITIAL: 0, RUNNING: 1, PAUSED: 2, FINISHED: 3 }; exports.RenderingStates = RenderingStates; const PresentationModeState = { UNKNOWN: 0, NORMAL: 1, CHANGING: 2, FULLSCREEN: 3 }; exports.PresentationModeState = PresentationModeState; const SidebarView = { UNKNOWN: -1, NONE: 0, THUMBS: 1, OUTLINE: 2, ATTACHMENTS: 3, LAYERS: 4 }; exports.SidebarView = SidebarView; const RendererType = { CANVAS: \"canvas\", SVG: \"svg\" }; exports.RendererType = RendererType; const TextLayerMode = { DISABLE: 0, ENABLE: 1 }; exports.TextLayerMode = TextLayerMode; const ScrollMode = { UNKNOWN: -1, VERTICAL: 0, HORIZONTAL: 1, WRAPPED: 2, PAGE: 3 }; exports.ScrollMode = ScrollMode; const SpreadMode = { UNKNOWN: -1, NONE: 0, ODD: 1, EVEN: 2 }; exports.SpreadMode = SpreadMode; const AutoPrintRegExp = /\\bprint\\s*\\(/; exports.AutoPrintRegExp = AutoPrintRegExp; class OutputScale { constructor() { const pixelRatio = window.devicePixelRatio || 1; this.sx = pixelRatio; this.sy = pixelRatio; } get scaled() { return this.sx !== 1 || this.sy !== 1; } } exports.OutputScale = OutputScale; function scrollIntoView(element, spot, scrollMatches = false) { let parent = element.offsetParent; if (!parent) { console.error(\"offsetParent is not set -- cannot scroll\"); return; } let offsetY = element.offsetTop + element.clientTop; let offsetX = element.offsetLeft + element.clientLeft; while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || scrollMatches && (parent.classList.contains(\"markedContent\") || getComputedStyle(parent).overflow === \"hidden\")) { offsetY += parent.offsetTop; offsetX += parent.offsetLeft; parent = parent.offsetParent; if (!parent) { return; } } if (spot) { if (spot.top !== undefined) { offsetY += spot.top; } if (spot.left !== undefined) { offsetX += spot.left; parent.scrollLeft = offsetX; } } parent.scrollTop = offsetY; } function watchScroll(viewAreaElement, callback) { const debounceScroll = function (evt) { if (rAF) { return; } rAF = window.requestAnimationFrame(function viewAreaElementScrolled() { rAF = null; const currentX = viewAreaElement.scrollLeft; const lastX = state.lastX; if (currentX !== lastX) { state.right = currentX > lastX; } state.lastX = currentX; const currentY = viewAreaElement.scrollTop; const lastY = state.lastY; if (currentY !== lastY) { state.down = currentY > lastY; } state.lastY = currentY; callback(state); }); }; const state = { right: true, down: true, lastX: viewAreaElement.scrollLeft, lastY: viewAreaElement.scrollTop, _eventHandler: debounceScroll }; let rAF = null; viewAreaElement.addEventListener(\"scroll\", debounceScroll, true); return state; } function parseQueryString(query) { const params = new Map(); for (const [key, value] of new URLSearchParams(query)) { params.set(key.toLowerCase(), value); } return params; } const NullCharactersRegExp = /\\x00/g; const InvisibleCharactersRegExp = /[\\x01-\\x1F]/g; function removeNullCharacters(str, replaceInvisible = false) { if (typeof str !== \"string\") { console.error(`The argument must be a string.`); return str; } if (replaceInvisible) { str = str.replace(InvisibleCharactersRegExp, \" \"); } return str.replace(NullCharactersRegExp, \"\"); } function binarySearchFirstItem(items, condition, start = 0) { let minIndex = start; let maxIndex = items.length - 1; if (maxIndex < 0 || !condition(items[maxIndex])) { return items.length; } if (condition(items[minIndex])) { return minIndex; } while (minIndex < maxIndex) { const currentIndex = minIndex + maxIndex >> 1; const currentItem = items[currentIndex]; if (condition(currentItem)) { maxIndex = currentIndex; } else { minIndex = currentIndex + 1; } } return minIndex; } function approximateFraction(x) { if (Math.floor(x) === x) { return [x, 1]; } const xinv = 1 / x; const limit = 8; if (xinv > limit) { return [1, limit]; } else if (Math.floor(xinv) === xinv) { return [1, xinv]; } const x_ = x > 1 ? xinv : x; let a = 0, b = 1, c = 1, d = 1; while (true) { const p = a + c, q = b + d; if (q > limit) { break; } if (x_ 0 && firstVisibleElementInd < numViews && !horizontal) { firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top); } let lastEdge = horizontal ? right : -1; for (let i = firstVisibleElementInd; i < numViews; i++) { const view = views[i], element = view.div; const currentWidth = element.offsetLeft + element.clientLeft; const currentHeight = element.offsetTop + element.clientTop; const viewWidth = element.clientWidth, viewHeight = element.clientHeight; const viewRight = currentWidth + viewWidth; const viewBottom = currentHeight + viewHeight; if (lastEdge === -1) { if (viewBottom >= bottom) { lastEdge = viewBottom; } } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) { break; } if (viewBottom = bottom || viewRight = right) { continue; } const hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom); const hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right); const fractionHeight = (viewHeight - hiddenHeight) / viewHeight, fractionWidth = (viewWidth - hiddenWidth) / viewWidth; const percent = fractionHeight * fractionWidth * 100 | 0; visible.push({ id: view.id, x: currentWidth, y: currentHeight, view, percent, widthPercent: fractionWidth * 100 | 0 }); ids.add(view.id); } const first = visible[0], last = visible.at(-1); if (sortByVisibility) { visible.sort(function (a, b) { const pc = a.percent - b.percent; if (Math.abs(pc) > 0.001) { return -pc; } return a.id - b.id; }); } return { first, last, views: visible, ids }; } function noContextMenuHandler(evt) { evt.preventDefault(); } function normalizeWheelEventDirection(evt) { let delta = Math.hypot(evt.deltaX, evt.deltaY); const angle = Math.atan2(evt.deltaY, evt.deltaX); if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) { delta = -delta; } return delta; } function normalizeWheelEventDelta(evt) { let delta = normalizeWheelEventDirection(evt); const MOUSE_DOM_DELTA_PIXEL_MODE = 0; const MOUSE_DOM_DELTA_LINE_MODE = 1; const MOUSE_PIXELS_PER_LINE = 30; const MOUSE_LINES_PER_PAGE = 30; if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) { delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE; } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) { delta /= MOUSE_LINES_PER_PAGE; } return delta; } function isValidRotation(angle) { return Number.isInteger(angle) && angle % 90 === 0; } function isValidScrollMode(mode) { return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN; } function isValidSpreadMode(mode) { return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN; } function isPortraitOrientation(size) { return size.width 0) { docStyle.setProperty(\"--progressBar-end-offset\", `${scrollbarWidth}px`); } } hide() { if (!this.#visible) { return; } this.#visible = false; this.#classList.add(\"hidden\"); } show() { if (this.#visible) { return; } this.#visible = true; this.#classList.remove(\"hidden\"); } } exports.ProgressBar = ProgressBar; function getActiveOrFocusedElement() { let curRoot = document; let curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(\":focus\"); while (curActiveOrFocused?.shadowRoot) { curRoot = curActiveOrFocused.shadowRoot; curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(\":focus\"); } return curActiveOrFocused; } function apiPageLayoutToViewerModes(layout) { let scrollMode = ScrollMode.VERTICAL, spreadMode = SpreadMode.NONE; switch (layout) { case \"SinglePage\": scrollMode = ScrollMode.PAGE; break; case \"OneColumn\": break; case \"TwoPageLeft\": scrollMode = ScrollMode.PAGE; case \"TwoColumnLeft\": spreadMode = SpreadMode.ODD; break; case \"TwoPageRight\": scrollMode = ScrollMode.PAGE; case \"TwoColumnRight\": spreadMode = SpreadMode.EVEN; break; } return { scrollMode, spreadMode }; } function apiPageModeToSidebarView(mode) { switch (mode) { case \"UseNone\": return SidebarView.NONE; case \"UseThumbs\": return SidebarView.THUMBS; case \"UseOutlines\": return SidebarView.OUTLINE; case \"UseAttachments\": return SidebarView.ATTACHMENTS; case \"UseOC\": return SidebarView.LAYERS; } return SidebarView.NONE; } /***/ }), /* 2 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.compatibilityParams = exports.OptionKind = exports.AppOptions = void 0; const compatibilityParams = Object.create(null); exports.compatibilityParams = compatibilityParams; { const userAgent = navigator.userAgent || \"\"; const platform = navigator.platform || \"\"; const maxTouchPoints = navigator.maxTouchPoints || 1; const isAndroid = /Android/.test(userAgent); const isIOS = /\\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === \"MacIntel\" && maxTouchPoints > 1; (function checkCanvasSizeLimitation() { if (isIOS || isAndroid) { compatibilityParams.maxCanvasPixels = 5242880; } })(); } const OptionKind = { VIEWER: 0x02, API: 0x04, WORKER: 0x08, PREFERENCE: 0x80 }; exports.OptionKind = OptionKind; const defaultOptions = { annotationEditorMode: { value: 0, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, annotationMode: { value: 2, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, cursorToolOnLoad: { value: 0, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, defaultZoomDelay: { value: -1, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, defaultZoomValue: { value: \"\", kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, disableHistory: { value: false, kind: OptionKind.VIEWER }, disablePageLabels: { value: false, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, enablePermissions: { value: false, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, enablePrintAutoRotate: { value: true, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, enableScripting: { value: true, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, externalLinkRel: { value: \"noopener noreferrer nofollow\", kind: OptionKind.VIEWER }, externalLinkTarget: { value: 0, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, historyUpdateUrl: { value: false, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, ignoreDestinationZoom: { value: false, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, imageResourcesPath: { value: \"./images/\", kind: OptionKind.VIEWER }, maxCanvasPixels: { value: 16777216, kind: OptionKind.VIEWER }, forcePageColors: { value: false, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, pageColorsBackground: { value: \"Canvas\", kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, pageColorsForeground: { value: \"CanvasText\", kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, pdfBugEnabled: { value: false, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, printResolution: { value: 150, kind: OptionKind.VIEWER }, sidebarViewOnLoad: { value: -1, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, scrollModeOnLoad: { value: -1, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, spreadModeOnLoad: { value: -1, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, textLayerMode: { value: 1, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, useOnlyCssZoom: { value: false, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, viewerCssTheme: { value: 0, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, viewOnLoad: { value: 0, kind: OptionKind.VIEWER + OptionKind.PREFERENCE }, cMapPacked: { value: true, kind: OptionKind.API }, cMapUrl: { value: \"../web/cmaps/\", kind: OptionKind.API }, disableAutoFetch: { value: false, kind: OptionKind.API + OptionKind.PREFERENCE }, disableFontFace: { value: false, kind: OptionKind.API + OptionKind.PREFERENCE }, disableRange: { value: false, kind: OptionKind.API + OptionKind.PREFERENCE }, disableStream: { value: false, kind: OptionKind.API + OptionKind.PREFERENCE }, docBaseUrl: { value: \"\", kind: OptionKind.API }, enableXfa: { value: true, kind: OptionKind.API + OptionKind.PREFERENCE }, fontExtraProperties: { value: false, kind: OptionKind.API }, isEvalSupported: { value: true, kind: OptionKind.API }, isOffscreenCanvasSupported: { value: true, kind: OptionKind.API }, maxImageSize: { value: -1, kind: OptionKind.API }, pdfBug: { value: false, kind: OptionKind.API }, standardFontDataUrl: { value: \"../web/standard_fonts/\", kind: OptionKind.API }, verbosity: { value: 1, kind: OptionKind.API }, workerPort: { value: null, kind: OptionKind.WORKER }, workerSrc: { value: \"../build/pdf.worker.js\", kind: OptionKind.WORKER } }; { defaultOptions.defaultUrl = { value: \"compressed.tracemonkey-pldi-09.pdf\", kind: OptionKind.VIEWER }; defaultOptions.disablePreferences = { value: false, kind: OptionKind.VIEWER }; defaultOptions.locale = { value: navigator.language || \"en-US\", kind: OptionKind.VIEWER }; defaultOptions.renderer = { value: \"canvas\", kind: OptionKind.VIEWER + OptionKind.PREFERENCE }; defaultOptions.sandboxBundleSrc = { value: \"../build/pdf.sandbox.js\", kind: OptionKind.VIEWER }; } const userOptions = Object.create(null); class AppOptions { constructor() { throw new Error(\"Cannot initialize AppOptions.\"); } static get(name) { const userOption = userOptions[name]; if (userOption !== undefined) { return userOption; } const defaultOption = defaultOptions[name]; if (defaultOption !== undefined) { return compatibilityParams[name] ?? defaultOption.value; } return undefined; } static getAll(kind = null) { const options = Object.create(null); for (const name in defaultOptions) { const defaultOption = defaultOptions[name]; if (kind) { if ((kind & defaultOption.kind) === 0) { continue; } if (kind === OptionKind.PREFERENCE) { const value = defaultOption.value, valueType = typeof value; if (valueType === \"boolean\" || valueType === \"string\" || valueType === \"number\" && Number.isInteger(value)) { options[name] = value; continue; } throw new Error(`Invalid type for preference: ${name}`); } } const userOption = userOptions[name]; options[name] = userOption !== undefined ? userOption : compatibilityParams[name] ?? defaultOption.value; } return options; } static set(name, value) { userOptions[name] = value; } static setAll(options) { for (const name in options) { userOptions[name] = options[name]; } } static remove(name) { delete userOptions[name]; } static _hasUserOptions() { return Object.keys(userOptions).length > 0; } } exports.AppOptions = AppOptions; /***/ }), /* 3 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.SimpleLinkService = exports.PDFLinkService = exports.LinkTarget = void 0; var _ui_utils = __webpack_require__(1); const DEFAULT_LINK_REL = \"noopener noreferrer nofollow\"; const LinkTarget = { NONE: 0, SELF: 1, BLANK: 2, PARENT: 3, TOP: 4 }; exports.LinkTarget = LinkTarget; function addLinkAttributes(link, { url, target, rel, enabled = true } = {}) { if (!url || typeof url !== \"string\") { throw new Error('A valid \"url\" parameter must provided.'); } const urlNullRemoved = (0, _ui_utils.removeNullCharacters)(url); if (enabled) { link.href = link.title = urlNullRemoved; } else { link.href = \"\"; link.title = `Disabled: ${urlNullRemoved}`; link.onclick = () => { return false; }; } let targetStr = \"\"; switch (target) { case LinkTarget.NONE: break; case LinkTarget.SELF: targetStr = \"_self\"; break; case LinkTarget.BLANK: targetStr = \"_blank\"; break; case LinkTarget.PARENT: targetStr = \"_parent\"; break; case LinkTarget.TOP: targetStr = \"_top\"; break; } link.target = targetStr; link.rel = typeof rel === \"string\" ? rel : DEFAULT_LINK_REL; } class PDFLinkService { #pagesRefCache = new Map(); constructor({ eventBus, externalLinkTarget = null, externalLinkRel = null, ignoreDestinationZoom = false } = {}) { this.eventBus = eventBus; this.externalLinkTarget = externalLinkTarget; this.externalLinkRel = externalLinkRel; this.externalLinkEnabled = true; this._ignoreDestinationZoom = ignoreDestinationZoom; this.baseUrl = null; this.pdfDocument = null; this.pdfViewer = null; this.pdfHistory = null; } setDocument(pdfDocument, baseUrl = null) { this.baseUrl = baseUrl; this.pdfDocument = pdfDocument; this.#pagesRefCache.clear(); } setViewer(pdfViewer) { this.pdfViewer = pdfViewer; } setHistory(pdfHistory) { this.pdfHistory = pdfHistory; } get pagesCount() { return this.pdfDocument ? this.pdfDocument.numPages : 0; } get page() { return this.pdfViewer.currentPageNumber; } set page(value) { this.pdfViewer.currentPageNumber = value; } get rotation() { return this.pdfViewer.pagesRotation; } set rotation(value) { this.pdfViewer.pagesRotation = value; } get isInPresentationMode() { return this.pdfViewer.isInPresentationMode; } #goToDestinationHelper(rawDest, namedDest = null, explicitDest) { const destRef = explicitDest[0]; let pageNumber; if (typeof destRef === \"object\" && destRef !== null) { pageNumber = this._cachedPageNumber(destRef); if (!pageNumber) { this.pdfDocument.getPageIndex(destRef).then(pageIndex => { this.cachePageRef(pageIndex + 1, destRef); this.#goToDestinationHelper(rawDest, namedDest, explicitDest); }).catch(() => { console.error(`PDFLinkService.#goToDestinationHelper: \"${destRef}\" is not ` + `a valid page reference, for dest=\"${rawDest}\".`); }); return; } } else if (Number.isInteger(destRef)) { pageNumber = destRef + 1; } else { console.error(`PDFLinkService.#goToDestinationHelper: \"${destRef}\" is not ` + `a valid destination reference, for dest=\"${rawDest}\".`); return; } if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) { console.error(`PDFLinkService.#goToDestinationHelper: \"${pageNumber}\" is not ` + `a valid page number, for dest=\"${rawDest}\".`); return; } if (this.pdfHistory) { this.pdfHistory.pushCurrentPosition(); this.pdfHistory.push({ namedDest, explicitDest, pageNumber }); } this.pdfViewer.scrollPageIntoView({ pageNumber, destArray: explicitDest, ignoreDestinationZoom: this._ignoreDestinationZoom }); } async goToDestination(dest) { if (!this.pdfDocument) { return; } let namedDest, explicitDest; if (typeof dest === \"string\") { namedDest = dest; explicitDest = await this.pdfDocument.getDestination(dest); } else { namedDest = null; explicitDest = await dest; } if (!Array.isArray(explicitDest)) { console.error(`PDFLinkService.goToDestination: \"${explicitDest}\" is not ` + `a valid destination array, for dest=\"${dest}\".`); return; } this.#goToDestinationHelper(dest, namedDest, explicitDest); } goToPage(val) { if (!this.pdfDocument) { return; } const pageNumber = typeof val === \"string\" && this.pdfViewer.pageLabelToPageNumber(val) || val | 0; if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber 0) { return this.getAnchorUrl(\"#\" + escape(dest)); } } else if (Array.isArray(dest)) { const str = JSON.stringify(dest); if (str.length > 0) { return this.getAnchorUrl(\"#\" + escape(str)); } } return this.getAnchorUrl(\"\"); } getAnchorUrl(anchor) { return (this.baseUrl || \"\") + anchor; } setHash(hash) { if (!this.pdfDocument) { return; } let pageNumber, dest; if (hash.includes(\"=\")) { const params = (0, _ui_utils.parseQueryString)(hash); if (params.has(\"search\")) { this.eventBus.dispatch(\"findfromurlhash\", { source: this, query: params.get(\"search\").replace(/\"/g, \"\"), phraseSearch: params.get(\"phrase\") === \"true\" }); } if (params.has(\"page\")) { pageNumber = params.get(\"page\") | 0 || 1; } if (params.has(\"zoom\")) { const zoomArgs = params.get(\"zoom\").split(\",\"); const zoomArg = zoomArgs[0]; const zoomArgNumber = parseFloat(zoomArg); if (!zoomArg.includes(\"Fit\")) { dest = [null, { name: \"XYZ\" }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg]; } else { if (zoomArg === \"Fit\" || zoomArg === \"FitB\") { dest = [null, { name: zoomArg }]; } else if (zoomArg === \"FitH\" || zoomArg === \"FitBH\" || zoomArg === \"FitV\" || zoomArg === \"FitBV\") { dest = [null, { name: zoomArg }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null]; } else if (zoomArg === \"FitR\") { if (zoomArgs.length !== 5) { console.error('PDFLinkService.setHash: Not enough parameters for \"FitR\".'); } else { dest = [null, { name: zoomArg }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0]; } } else { console.error(`PDFLinkService.setHash: \"${zoomArg}\" is not a valid zoom value.`); } } } if (dest) { this.pdfViewer.scrollPageIntoView({ pageNumber: pageNumber || this.page, destArray: dest, allowNegativeOffset: true }); } else if (pageNumber) { this.page = pageNumber; } if (params.has(\"pagemode\")) { this.eventBus.dispatch(\"pagemode\", { source: this, mode: params.get(\"pagemode\") }); } if (params.has(\"nameddest\")) { this.goToDestination(params.get(\"nameddest\")); } } else { dest = unescape(hash); try { dest = JSON.parse(dest); if (!Array.isArray(dest)) { dest = dest.toString(); } } catch (ex) {} if (typeof dest === \"string\" || PDFLinkService.#isValidExplicitDestination(dest)) { this.goToDestination(dest); return; } console.error(`PDFLinkService.setHash: \"${unescape(hash)}\" is not a valid destination.`); } } executeNamedAction(action) { switch (action) { case \"GoBack\": this.pdfHistory?.back(); break; case \"GoForward\": this.pdfHistory?.forward(); break; case \"NextPage\": this.pdfViewer.nextPage(); break; case \"PrevPage\": this.pdfViewer.previousPage(); break; case \"LastPage\": this.page = this.pagesCount; break; case \"FirstPage\": this.page = 1; break; default: break; } this.eventBus.dispatch(\"namedaction\", { source: this, action }); } async executeSetOCGState(action) { const pdfDocument = this.pdfDocument; const optionalContentConfig = await this.pdfViewer.optionalContentConfigPromise; if (pdfDocument !== this.pdfDocument) { return; } let operator; for (const elem of action.state) { switch (elem) { case \"ON\": case \"OFF\": case \"Toggle\": operator = elem; continue; } switch (operator) { case \"ON\": optionalContentConfig.setVisibility(elem, true); break; case \"OFF\": optionalContentConfig.setVisibility(elem, false); break; case \"Toggle\": const group = optionalContentConfig.getGroup(elem); if (group) { optionalContentConfig.setVisibility(elem, !group.visible); } break; } } this.pdfViewer.optionalContentConfigPromise = Promise.resolve(optionalContentConfig); } cachePageRef(pageNum, pageRef) { if (!pageRef) { return; } const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`; this.#pagesRefCache.set(refStr, pageNum); } _cachedPageNumber(pageRef) { if (!pageRef) { return null; } const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`; return this.#pagesRefCache.get(refStr) || null; } isPageVisible(pageNumber) { return this.pdfViewer.isPageVisible(pageNumber); } isPageCached(pageNumber) { return this.pdfViewer.isPageCached(pageNumber); } static #isValidExplicitDestination(dest) { if (!Array.isArray(dest)) { return false; } const destLength = dest.length; if (destLength < 2) { return false; } const page = dest[0]; if (!(typeof page === \"object\" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) { return false; } const zoom = dest[1]; if (!(typeof zoom === \"object\" && typeof zoom.name === \"string\")) { return false; } let allowNull = true; switch (zoom.name) { case \"XYZ\": if (destLength !== 5) { return false; } break; case \"Fit\": case \"FitB\": return destLength === 2; case \"FitH\": case \"FitBH\": case \"FitV\": case \"FitBV\": if (destLength !== 3) { return false; } break; case \"FitR\": if (destLength !== 6) { return false; } allowNull = false; break; default: return false; } for (let i = 2; i < destLength; i++) { const param = dest[i]; if (!(typeof param === \"number\" || allowNull && param === null)) { return false; } } return true; } } exports.PDFLinkService = PDFLinkService; class SimpleLinkService { constructor() { this.externalLinkEnabled = true; } get pagesCount() { return 0; } get page() { return 0; } set page(value) {} get rotation() { return 0; } set rotation(value) {} get isInPresentationMode() { return false; } async goToDestination(dest) {} goToPage(val) {} addLinkAttributes(link, url, newWindow = false) { addLinkAttributes(link, { url, enabled: this.externalLinkEnabled }); } getDestinationHash(dest) { return \"#\"; } getAnchorUrl(hash) { return \"#\"; } setHash(hash) {} executeNamedAction(action) {} executeSetOCGState(action) {} cachePageRef(pageNum, pageRef) {} isPageVisible(pageNumber) { return true; } isPageCached(pageNumber) { return true; } } exports.SimpleLinkService = SimpleLinkService; /***/ }), /* 4 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFViewerApplication = exports.PDFPrintServiceFactory = exports.DefaultExternalServices = void 0; var _ui_utils = __webpack_require__(1); var _pdfjsLib = __webpack_require__(5); var _app_options = __webpack_require__(2); var _event_utils = __webpack_require__(6); var _pdf_cursor_tools = __webpack_require__(7); var _pdf_link_service = __webpack_require__(3); var _annotation_editor_params = __webpack_require__(9); var _overlay_manager = __webpack_require__(10); var _password_prompt = __webpack_require__(11); var _pdf_attachment_viewer = __webpack_require__(12); var _pdf_document_properties = __webpack_require__(14); var _pdf_find_bar = __webpack_require__(15); var _pdf_find_controller = __webpack_require__(16); var _pdf_history = __webpack_require__(18); var _pdf_layer_viewer = __webpack_require__(19); var _pdf_outline_viewer = __webpack_require__(20); var _pdf_presentation_mode = __webpack_require__(21); var _pdf_rendering_queue = __webpack_require__(22); var _pdf_scripting_manager = __webpack_require__(23); var _pdf_sidebar = __webpack_require__(24); var _pdf_sidebar_resizer = __webpack_require__(25); var _pdf_thumbnail_viewer = __webpack_require__(26); var _pdf_viewer = __webpack_require__(28); var _secondary_toolbar = __webpack_require__(38); var _toolbar = __webpack_require__(39); var _view_history = __webpack_require__(40); const DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT = 5000; const FORCE_PAGES_LOADED_TIMEOUT = 10000; const WHEEL_ZOOM_DISABLED_TIMEOUT = 1000; const ViewOnLoad = { UNKNOWN: -1, PREVIOUS: 0, INITIAL: 1 }; const ViewerCssTheme = { AUTOMATIC: 0, LIGHT: 1, DARK: 2 }; class DefaultExternalServices { constructor() { throw new Error(\"Cannot initialize DefaultExternalServices.\"); } static updateFindControlState(data) {} static updateFindMatchesCount(data) {} static initPassiveLoading(callbacks) {} static reportTelemetry(data) {} static createDownloadManager() { throw new Error(\"Not implemented: createDownloadManager\"); } static createPreferences() { throw new Error(\"Not implemented: createPreferences\"); } static createL10n(options) { throw new Error(\"Not implemented: createL10n\"); } static createScripting(options) { throw new Error(\"Not implemented: createScripting\"); } static get supportsIntegratedFind() { return (0, _pdfjsLib.shadow)(this, \"supportsIntegratedFind\", false); } static get supportsDocumentFonts() { return (0, _pdfjsLib.shadow)(this, \"supportsDocumentFonts\", true); } static get supportedMouseWheelZoomModifierKeys() { return (0, _pdfjsLib.shadow)(this, \"supportedMouseWheelZoomModifierKeys\", { ctrlKey: true, metaKey: true }); } static get isInAutomation() { return (0, _pdfjsLib.shadow)(this, \"isInAutomation\", false); } static updateEditorStates(data) { throw new Error(\"Not implemented: updateEditorStates\"); } } exports.DefaultExternalServices = DefaultExternalServices; const PDFViewerApplication = { initialBookmark: document.location.hash.substring(1), _initializedCapability: (0, _pdfjsLib.createPromiseCapability)(), appConfig: null, pdfDocument: null, pdfLoadingTask: null, printService: null, pdfViewer: null, pdfThumbnailViewer: null, pdfRenderingQueue: null, pdfPresentationMode: null, pdfDocumentProperties: null, pdfLinkService: null, pdfHistory: null, pdfSidebar: null, pdfSidebarResizer: null, pdfOutlineViewer: null, pdfAttachmentViewer: null, pdfLayerViewer: null, pdfCursorTools: null, pdfScriptingManager: null, store: null, downloadManager: null, overlayManager: null, preferences: null, toolbar: null, secondaryToolbar: null, eventBus: null, l10n: null, annotationEditorParams: null, isInitialViewSet: false, downloadComplete: false, isViewerEmbedded: window.parent !== window, url: \"\", baseUrl: \"\", _downloadUrl: \"\", externalServices: DefaultExternalServices, _boundEvents: Object.create(null), documentInfo: null, metadata: null, _contentDispositionFilename: null, _contentLength: null, _saveInProgress: false, _wheelUnusedTicks: 0, _PDFBug: null, _hasAnnotationEditors: false, _title: document.title, _printAnnotationStoragePromise: null, async initialize(appConfig) { this.preferences = this.externalServices.createPreferences(); this.appConfig = appConfig; await this._readPreferences(); await this._parseHashParameters(); this._forceCssTheme(); await this._initializeL10n(); if (this.isViewerEmbedded && _app_options.AppOptions.get(\"externalLinkTarget\") === _pdf_link_service.LinkTarget.NONE) { _app_options.AppOptions.set(\"externalLinkTarget\", _pdf_link_service.LinkTarget.TOP); } await this._initializeViewerComponents(); this.bindEvents(); this.bindWindowEvents(); const appContainer = appConfig.appContainer || document.documentElement; this.l10n.translate(appContainer).then(() => { this.eventBus.dispatch(\"localized\", { source: this }); }); this._initializedCapability.resolve(); }, async _readPreferences() { if (_app_options.AppOptions.get(\"disablePreferences\")) { return; } if (_app_options.AppOptions._hasUserOptions()) { console.warn(\"_readPreferences: The Preferences may override manually set AppOptions; \" + 'please use the \"disablePreferences\"-option in order to prevent that.'); } try { _app_options.AppOptions.setAll(await this.preferences.getAll()); } catch (reason) { console.error(`_readPreferences: \"${reason?.message}\".`); } }, async _parseHashParameters() { if (!_app_options.AppOptions.get(\"pdfBugEnabled\")) { return; } const hash = document.location.hash.substring(1); if (!hash) { return; } const { mainContainer, viewerContainer } = this.appConfig, params = (0, _ui_utils.parseQueryString)(hash); if (params.get(\"disableworker\") === \"true\") { try { await loadFakeWorker(); } catch (ex) { console.error(`_parseHashParameters: \"${ex.message}\".`); } } if (params.has(\"disablerange\")) { _app_options.AppOptions.set(\"disableRange\", params.get(\"disablerange\") === \"true\"); } if (params.has(\"disablestream\")) { _app_options.AppOptions.set(\"disableStream\", params.get(\"disablestream\") === \"true\"); } if (params.has(\"disableautofetch\")) { _app_options.AppOptions.set(\"disableAutoFetch\", params.get(\"disableautofetch\") === \"true\"); } if (params.has(\"disablefontface\")) { _app_options.AppOptions.set(\"disableFontFace\", params.get(\"disablefontface\") === \"true\"); } if (params.has(\"disablehistory\")) { _app_options.AppOptions.set(\"disableHistory\", params.get(\"disablehistory\") === \"true\"); } if (params.has(\"verbosity\")) { _app_options.AppOptions.set(\"verbosity\", params.get(\"verbosity\") | 0); } if (params.has(\"textlayer\")) { switch (params.get(\"textlayer\")) { case \"off\": _app_options.AppOptions.set(\"textLayerMode\", _ui_utils.TextLayerMode.DISABLE); break; case \"visible\": case \"shadow\": case \"hover\": viewerContainer.classList.add(`textLayer-${params.get(\"textlayer\")}`); try { await loadPDFBug(this); this._PDFBug.loadCSS(); } catch (ex) { console.error(`_parseHashParameters: \"${ex.message}\".`); } break; } } if (params.has(\"pdfbug\")) { _app_options.AppOptions.set(\"pdfBug\", true); _app_options.AppOptions.set(\"fontExtraProperties\", true); const enabled = params.get(\"pdfbug\").split(\",\"); try { await loadPDFBug(this); this._PDFBug.init({ OPS: _pdfjsLib.OPS }, mainContainer, enabled); } catch (ex) { console.error(`_parseHashParameters: \"${ex.message}\".`); } } if (params.has(\"locale\")) { _app_options.AppOptions.set(\"locale\", params.get(\"locale\")); } }, async _initializeL10n() { this.l10n = this.externalServices.createL10n({ locale: _app_options.AppOptions.get(\"locale\") }); const dir = await this.l10n.getDirection(); document.getElementsByTagName(\"html\")[0].dir = dir; }, _forceCssTheme() { const cssTheme = _app_options.AppOptions.get(\"viewerCssTheme\"); if (cssTheme === ViewerCssTheme.AUTOMATIC || !Object.values(ViewerCssTheme).includes(cssTheme)) { return; } try { const styleSheet = document.styleSheets[0]; const cssRules = styleSheet?.cssRules || []; for (let i = 0, ii = cssRules.length; i < ii; i++) { const rule = cssRules[i]; if (rule instanceof CSSMediaRule && rule.media?.[0] === \"(prefers-color-scheme: dark)\") { if (cssTheme === ViewerCssTheme.LIGHT) { styleSheet.deleteRule(i); return; } const darkRules = /^@media \\(prefers-color-scheme: dark\\) {\\n\\s*([\\w\\s-.,:;/\\\\{}()]+)\\n}$/.exec(rule.cssText); if (darkRules?.[1]) { styleSheet.deleteRule(i); styleSheet.insertRule(darkRules[1], i); } return; } } } catch (reason) { console.error(`_forceCssTheme: \"${reason?.message}\".`); } }, async _initializeViewerComponents() { const { appConfig, externalServices } = this; const eventBus = externalServices.isInAutomation ? new _event_utils.AutomationEventBus() : new _event_utils.EventBus(); this.eventBus = eventBus; this.overlayManager = new _overlay_manager.OverlayManager(); const pdfRenderingQueue = new _pdf_rendering_queue.PDFRenderingQueue(); pdfRenderingQueue.onIdle = this._cleanup.bind(this); this.pdfRenderingQueue = pdfRenderingQueue; const pdfLinkService = new _pdf_link_service.PDFLinkService({ eventBus, externalLinkTarget: _app_options.AppOptions.get(\"externalLinkTarget\"), externalLinkRel: _app_options.AppOptions.get(\"externalLinkRel\"), ignoreDestinationZoom: _app_options.AppOptions.get(\"ignoreDestinationZoom\") }); this.pdfLinkService = pdfLinkService; const downloadManager = externalServices.createDownloadManager(); this.downloadManager = downloadManager; const findController = new _pdf_find_controller.PDFFindController({ linkService: pdfLinkService, eventBus }); this.findController = findController; const pdfScriptingManager = new _pdf_scripting_manager.PDFScriptingManager({ eventBus, sandboxBundleSrc: _app_options.AppOptions.get(\"sandboxBundleSrc\"), scriptingFactory: externalServices, docPropertiesLookup: this._scriptingDocProperties.bind(this) }); this.pdfScriptingManager = pdfScriptingManager; const container = appConfig.mainContainer, viewer = appConfig.viewerContainer; const annotationEditorMode = _app_options.AppOptions.get(\"annotationEditorMode\"); const pageColors = _app_options.AppOptions.get(\"forcePageColors\") || window.matchMedia(\"(forced-colors: active)\").matches ? { background: _app_options.AppOptions.get(\"pageColorsBackground\"), foreground: _app_options.AppOptions.get(\"pageColorsForeground\") } : null; this.pdfViewer = new _pdf_viewer.PDFViewer({ container, viewer, eventBus, renderingQueue: pdfRenderingQueue, linkService: pdfLinkService, downloadManager, findController, scriptingManager: _app_options.AppOptions.get(\"enableScripting\") && pdfScriptingManager, renderer: _app_options.AppOptions.get(\"renderer\"), l10n: this.l10n, textLayerMode: _app_options.AppOptions.get(\"textLayerMode\"), annotationMode: _app_options.AppOptions.get(\"annotationMode\"), annotationEditorMode, imageResourcesPath: _app_options.AppOptions.get(\"imageResourcesPath\"), enablePrintAutoRotate: _app_options.AppOptions.get(\"enablePrintAutoRotate\"), useOnlyCssZoom: _app_options.AppOptions.get(\"useOnlyCssZoom\"), isOffscreenCanvasSupported: _app_options.AppOptions.get(\"isOffscreenCanvasSupported\"), maxCanvasPixels: _app_options.AppOptions.get(\"maxCanvasPixels\"), enablePermissions: _app_options.AppOptions.get(\"enablePermissions\"), pageColors }); pdfRenderingQueue.setViewer(this.pdfViewer); pdfLinkService.setViewer(this.pdfViewer); pdfScriptingManager.setViewer(this.pdfViewer); if (appConfig.sidebar?.thumbnailView) { this.pdfThumbnailViewer = new _pdf_thumbnail_viewer.PDFThumbnailViewer({ container: appConfig.sidebar.thumbnailView, eventBus, renderingQueue: pdfRenderingQueue, linkService: pdfLinkService, l10n: this.l10n, pageColors }); pdfRenderingQueue.setThumbnailViewer(this.pdfThumbnailViewer); } if (!this.isViewerEmbedded && !_app_options.AppOptions.get(\"disableHistory\")) { this.pdfHistory = new _pdf_history.PDFHistory({ linkService: pdfLinkService, eventBus }); pdfLinkService.setHistory(this.pdfHistory); } if (!this.supportsIntegratedFind && appConfig.findBar) { this.findBar = new _pdf_find_bar.PDFFindBar(appConfig.findBar, eventBus, this.l10n); } if (appConfig.annotationEditorParams) { if (annotationEditorMode !== _pdfjsLib.AnnotationEditorType.DISABLE) { this.annotationEditorParams = new _annotation_editor_params.AnnotationEditorParams(appConfig.annotationEditorParams, eventBus); } else { for (const id of [\"editorModeButtons\", \"editorModeSeparator\"]) { document.getElementById(id)?.classList.add(\"hidden\"); } } } if (appConfig.documentProperties) { this.pdfDocumentProperties = new _pdf_document_properties.PDFDocumentProperties(appConfig.documentProperties, this.overlayManager, eventBus, this.l10n, () => { return this._docFilename; }); } this.pdfCursorTools = new _pdf_cursor_tools.PDFCursorTools({ container, eventBus, cursorToolOnLoad: _app_options.AppOptions.get(\"cursorToolOnLoad\") }); if (appConfig.toolbar) { this.toolbar = new _toolbar.Toolbar(appConfig.toolbar, eventBus, this.l10n); } if (appConfig.secondaryToolbar) { this.secondaryToolbar = new _secondary_toolbar.SecondaryToolbar(appConfig.secondaryToolbar, eventBus, this.externalServices); } if (this.supportsFullscreen) { this.pdfPresentationMode = new _pdf_presentation_mode.PDFPresentationMode({ container, pdfViewer: this.pdfViewer, eventBus }); } if (appConfig.passwordOverlay) { this.passwordPrompt = new _password_prompt.PasswordPrompt(appConfig.passwordOverlay, this.overlayManager, this.l10n, this.isViewerEmbedded); } if (appConfig.sidebar?.outlineView) { this.pdfOutlineViewer = new _pdf_outline_viewer.PDFOutlineViewer({ container: appConfig.sidebar.outlineView, eventBus, linkService: pdfLinkService, downloadManager }); } if (appConfig.sidebar?.attachmentsView) { this.pdfAttachmentViewer = new _pdf_attachment_viewer.PDFAttachmentViewer({ container: appConfig.sidebar.attachmentsView, eventBus, downloadManager }); } if (appConfig.sidebar?.layersView) { this.pdfLayerViewer = new _pdf_layer_viewer.PDFLayerViewer({ container: appConfig.sidebar.layersView, eventBus, l10n: this.l10n }); } if (appConfig.sidebar) { this.pdfSidebar = new _pdf_sidebar.PDFSidebar({ elements: appConfig.sidebar, pdfViewer: this.pdfViewer, pdfThumbnailViewer: this.pdfThumbnailViewer, eventBus, l10n: this.l10n }); this.pdfSidebar.onToggled = this.forceRendering.bind(this); this.pdfSidebarResizer = new _pdf_sidebar_resizer.PDFSidebarResizer(appConfig.sidebarResizer, eventBus, this.l10n); } }, run(config) { this.initialize(config).then(webViewerInitialized); }, get initialized() { return this._initializedCapability.settled; }, get initializedPromise() { return this._initializedCapability.promise; }, zoomIn(steps) { if (this.pdfViewer.isInPresentationMode) { return; } this.pdfViewer.increaseScale(steps, { drawingDelay: _app_options.AppOptions.get(\"defaultZoomDelay\") }); }, zoomOut(steps) { if (this.pdfViewer.isInPresentationMode) { return; } this.pdfViewer.decreaseScale(steps, { drawingDelay: _app_options.AppOptions.get(\"defaultZoomDelay\") }); }, zoomReset() { if (this.pdfViewer.isInPresentationMode) { return; } this.pdfViewer.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE; }, get pagesCount() { return this.pdfDocument ? this.pdfDocument.numPages : 0; }, get page() { return this.pdfViewer.currentPageNumber; }, set page(val) { this.pdfViewer.currentPageNumber = val; }, get supportsPrinting() { return PDFPrintServiceFactory.instance.supportsPrinting; }, get supportsFullscreen() { return (0, _pdfjsLib.shadow)(this, \"supportsFullscreen\", document.fullscreenEnabled); }, get supportsIntegratedFind() { return this.externalServices.supportsIntegratedFind; }, get supportsDocumentFonts() { return this.externalServices.supportsDocumentFonts; }, get loadingBar() { const barElement = document.getElementById(\"loadingBar\"); const bar = barElement ? new _ui_utils.ProgressBar(barElement) : null; return (0, _pdfjsLib.shadow)(this, \"loadingBar\", bar); }, get supportedMouseWheelZoomModifierKeys() { return this.externalServices.supportedMouseWheelZoomModifierKeys; }, initPassiveLoading() { throw new Error(\"Not implemented: initPassiveLoading\"); }, setTitleUsingUrl(url = \"\", downloadUrl = null) { this.url = url; this.baseUrl = url.split(\"#\")[0]; if (downloadUrl) { this._downloadUrl = downloadUrl === url ? this.baseUrl : downloadUrl.split(\"#\")[0]; } if ((0, _pdfjsLib.isDataScheme)(url)) { this._hideViewBookmark(); } let title = (0, _pdfjsLib.getPdfFilenameFromUrl)(url, \"\"); if (!title) { try { title = decodeURIComponent((0, _pdfjsLib.getFilenameFromUrl)(url)) || url; } catch (ex) { title = url; } } this.setTitle(title); }, setTitle(title = this._title) { this._title = title; if (this.isViewerEmbedded) { return; } const editorIndicator = this._hasAnnotationEditors && !this.pdfRenderingQueue.printing; document.title = `${editorIndicator ? \"* \" : \"\"}${title}`; }, get _docFilename() { return this._contentDispositionFilename || (0, _pdfjsLib.getPdfFilenameFromUrl)(this.url); }, _hideViewBookmark() { const { secondaryToolbar } = this.appConfig; secondaryToolbar?.viewBookmarkButton.classList.add(\"hidden\"); if (secondaryToolbar?.presentationModeButton.classList.contains(\"hidden\")) { document.getElementById(\"viewBookmarkSeparator\")?.classList.add(\"hidden\"); } }, async close() { this._unblockDocumentLoadEvent(); this._hideViewBookmark(); if (!this.pdfLoadingTask) { return; } if (this.pdfDocument?.annotationStorage.size > 0 && this._annotationStorageModified) { try { await this.save(); } catch (reason) {} } const promises = []; promises.push(this.pdfLoadingTask.destroy()); this.pdfLoadingTask = null; if (this.pdfDocument) { this.pdfDocument = null; this.pdfThumbnailViewer?.setDocument(null); this.pdfViewer.setDocument(null); this.pdfLinkService.setDocument(null); this.pdfDocumentProperties?.setDocument(null); } this.pdfLinkService.externalLinkEnabled = true; this.store = null; this.isInitialViewSet = false; this.downloadComplete = false; this.url = \"\"; this.baseUrl = \"\"; this._downloadUrl = \"\"; this.documentInfo = null; this.metadata = null; this._contentDispositionFilename = null; this._contentLength = null; this._saveInProgress = false; this._hasAnnotationEditors = false; promises.push(this.pdfScriptingManager.destroyPromise); this.setTitle(); this.pdfSidebar?.reset(); this.pdfOutlineViewer?.reset(); this.pdfAttachmentViewer?.reset(); this.pdfLayerViewer?.reset(); this.pdfHistory?.reset(); this.findBar?.reset(); this.toolbar?.reset(); this.secondaryToolbar?.reset(); this._PDFBug?.cleanup(); await Promise.all(promises); }, async open(file, args) { if (this.pdfLoadingTask) { await this.close(); } const workerParameters = _app_options.AppOptions.getAll(_app_options.OptionKind.WORKER); for (const key in workerParameters) { _pdfjsLib.GlobalWorkerOptions[key] = workerParameters[key]; } const parameters = Object.create(null); if (typeof file === \"string\") { this.setTitleUsingUrl(file, file); parameters.url = file; } else if (file && \"byteLength\" in file) { parameters.data = file; } else if (file.url && file.originalUrl) { this.setTitleUsingUrl(file.originalUrl, file.url); parameters.url = file.url; } const apiParameters = _app_options.AppOptions.getAll(_app_options.OptionKind.API); for (const key in apiParameters) { let value = apiParameters[key]; if (key === \"docBaseUrl\" && !value) {} parameters[key] = value; } if (args) { for (const key in args) { parameters[key] = args[key]; } } const loadingTask = (0, _pdfjsLib.getDocument)(parameters); this.pdfLoadingTask = loadingTask; loadingTask.onPassword = (updateCallback, reason) => { if (this.isViewerEmbedded) { this._unblockDocumentLoadEvent(); } this.pdfLinkService.externalLinkEnabled = false; this.passwordPrompt.setUpdateCallback(updateCallback, reason); this.passwordPrompt.open(); }; loadingTask.onProgress = ({ loaded, total }) => { this.progress(loaded / total); }; return loadingTask.promise.then(pdfDocument => { this.load(pdfDocument); }, reason => { if (loadingTask !== this.pdfLoadingTask) { return undefined; } let key = \"loading_error\"; if (reason instanceof _pdfjsLib.InvalidPDFException) { key = \"invalid_file_error\"; } else if (reason instanceof _pdfjsLib.MissingPDFException) { key = \"missing_file_error\"; } else if (reason instanceof _pdfjsLib.UnexpectedResponseException) { key = \"unexpected_response_error\"; } return this.l10n.get(key).then(msg => { this._documentError(msg, { message: reason?.message }); throw reason; }); }); }, _ensureDownloadComplete() { if (this.pdfDocument && this.downloadComplete) { return; } throw new Error(\"PDF document not downloaded.\"); }, async download() { const url = this._downloadUrl, filename = this._docFilename; try { this._ensureDownloadComplete(); const data = await this.pdfDocument.getData(); const blob = new Blob([data], { type: \"application/pdf\" }); await this.downloadManager.download(blob, url, filename); } catch (reason) { await this.downloadManager.downloadUrl(url, filename); } }, async save() { if (this._saveInProgress) { return; } this._saveInProgress = true; await this.pdfScriptingManager.dispatchWillSave(); const url = this._downloadUrl, filename = this._docFilename; try { this._ensureDownloadComplete(); const data = await this.pdfDocument.saveDocument(); const blob = new Blob([data], { type: \"application/pdf\" }); await this.downloadManager.download(blob, url, filename); } catch (reason) { console.error(`Error when saving the document: ${reason.message}`); await this.download(); } finally { await this.pdfScriptingManager.dispatchDidSave(); this._saveInProgress = false; } if (this._hasAnnotationEditors) { this.externalServices.reportTelemetry({ type: \"editing\", data: { type: \"save\" } }); } }, downloadOrSave() { if (this.pdfDocument?.annotationStorage.size > 0) { this.save(); } else { this.download(); } }, _documentError(message, moreInfo = null) { this._unblockDocumentLoadEvent(); this._otherError(message, moreInfo); this.eventBus.dispatch(\"documenterror\", { source: this, message, reason: moreInfo?.message ?? null }); }, _otherError(message, moreInfo = null) { const moreInfoText = [`PDF.js v${_pdfjsLib.version || \"?\"} (build: ${_pdfjsLib.build || \"?\"})`]; if (moreInfo) { moreInfoText.push(`Message: ${moreInfo.message}`); if (moreInfo.stack) { moreInfoText.push(`Stack: ${moreInfo.stack}`); } else { if (moreInfo.filename) { moreInfoText.push(`File: ${moreInfo.filename}`); } if (moreInfo.lineNumber) { moreInfoText.push(`Line: ${moreInfo.lineNumber}`); } } } console.error(`${message}\\n\\n${moreInfoText.join(\"\\n\")}`); }, progress(level) { if (!this.loadingBar || this.downloadComplete) { return; } const percent = Math.round(level * 100); if (percent { this.loadingBar.hide(); this.disableAutoFetchLoadingBarTimeout = null; }, DISABLE_AUTO_FETCH_LOADING_BAR_TIMEOUT); }, load(pdfDocument) { this.pdfDocument = pdfDocument; pdfDocument.getDownloadInfo().then(({ length }) => { this._contentLength = length; this.downloadComplete = true; this.loadingBar?.hide(); firstPagePromise.then(() => { this.eventBus.dispatch(\"documentloaded\", { source: this }); }); }); const pageLayoutPromise = pdfDocument.getPageLayout().catch(function () {}); const pageModePromise = pdfDocument.getPageMode().catch(function () {}); const openActionPromise = pdfDocument.getOpenAction().catch(function () {}); this.toolbar?.setPagesCount(pdfDocument.numPages, false); this.secondaryToolbar?.setPagesCount(pdfDocument.numPages); let baseDocumentUrl; baseDocumentUrl = null; if (baseDocumentUrl && (0, _pdfjsLib.isDataScheme)(baseDocumentUrl)) { baseDocumentUrl = null; } this.pdfLinkService.setDocument(pdfDocument, baseDocumentUrl); this.pdfDocumentProperties?.setDocument(pdfDocument); const pdfViewer = this.pdfViewer; pdfViewer.setDocument(pdfDocument); const { firstPagePromise, onePageRendered, pagesPromise } = pdfViewer; this.pdfThumbnailViewer?.setDocument(pdfDocument); const storedPromise = (this.store = new _view_history.ViewHistory(pdfDocument.fingerprints[0])).getMultiple({ page: null, zoom: _ui_utils.DEFAULT_SCALE_VALUE, scrollLeft: \"0\", scrollTop: \"0\", rotation: null, sidebarView: _ui_utils.SidebarView.UNKNOWN, scrollMode: _ui_utils.ScrollMode.UNKNOWN, spreadMode: _ui_utils.SpreadMode.UNKNOWN }).catch(() => { return Object.create(null); }); firstPagePromise.then(pdfPage => { this.loadingBar?.setWidth(this.appConfig.viewerContainer); this._initializeAnnotationStorageCallbacks(pdfDocument); Promise.all([_ui_utils.animationStarted, storedPromise, pageLayoutPromise, pageModePromise, openActionPromise]).then(async ([timeStamp, stored, pageLayout, pageMode, openAction]) => { const viewOnLoad = _app_options.AppOptions.get(\"viewOnLoad\"); this._initializePdfHistory({ fingerprint: pdfDocument.fingerprints[0], viewOnLoad, initialDest: openAction?.dest }); const initialBookmark = this.initialBookmark; const zoom = _app_options.AppOptions.get(\"defaultZoomValue\"); let hash = zoom ? `zoom=${zoom}` : null; let rotation = null; let sidebarView = _app_options.AppOptions.get(\"sidebarViewOnLoad\"); let scrollMode = _app_options.AppOptions.get(\"scrollModeOnLoad\"); let spreadMode = _app_options.AppOptions.get(\"spreadModeOnLoad\"); if (stored.page && viewOnLoad !== ViewOnLoad.INITIAL) { hash = `page=${stored.page}&zoom=${zoom || stored.zoom},` + `${stored.scrollLeft},${stored.scrollTop}`; rotation = parseInt(stored.rotation, 10); if (sidebarView === _ui_utils.SidebarView.UNKNOWN) { sidebarView = stored.sidebarView | 0; } if (scrollMode === _ui_utils.ScrollMode.UNKNOWN) { scrollMode = stored.scrollMode | 0; } if (spreadMode === _ui_utils.SpreadMode.UNKNOWN) { spreadMode = stored.spreadMode | 0; } } if (pageMode && sidebarView === _ui_utils.SidebarView.UNKNOWN) { sidebarView = (0, _ui_utils.apiPageModeToSidebarView)(pageMode); } if (pageLayout && scrollMode === _ui_utils.ScrollMode.UNKNOWN && spreadMode === _ui_utils.SpreadMode.UNKNOWN) { const modes = (0, _ui_utils.apiPageLayoutToViewerModes)(pageLayout); spreadMode = modes.spreadMode; } this.setInitialView(hash, { rotation, sidebarView, scrollMode, spreadMode }); this.eventBus.dispatch(\"documentinit\", { source: this }); if (!this.isViewerEmbedded) { pdfViewer.focus(); } await Promise.race([pagesPromise, new Promise(resolve => { setTimeout(resolve, FORCE_PAGES_LOADED_TIMEOUT); })]); if (!initialBookmark && !hash) { return; } if (pdfViewer.hasEqualPageSizes) { return; } this.initialBookmark = initialBookmark; pdfViewer.currentScaleValue = pdfViewer.currentScaleValue; this.setInitialView(hash); }).catch(() => { this.setInitialView(); }).then(function () { pdfViewer.update(); }); }); pagesPromise.then(() => { this._unblockDocumentLoadEvent(); this._initializeAutoPrint(pdfDocument, openActionPromise); }, reason => { this.l10n.get(\"loading_error\").then(msg => { this._documentError(msg, { message: reason?.message }); }); }); onePageRendered.then(data => { this.externalServices.reportTelemetry({ type: \"pageInfo\", timestamp: data.timestamp }); pdfDocument.getOutline().then(outline => { if (pdfDocument !== this.pdfDocument) { return; } this.pdfOutlineViewer?.render({ outline, pdfDocument }); }); pdfDocument.getAttachments().then(attachments => { if (pdfDocument !== this.pdfDocument) { return; } this.pdfAttachmentViewer?.render({ attachments }); }); pdfViewer.optionalContentConfigPromise.then(optionalContentConfig => { if (pdfDocument !== this.pdfDocument) { return; } this.pdfLayerViewer?.render({ optionalContentConfig, pdfDocument }); }); }); this._initializePageLabels(pdfDocument); this._initializeMetadata(pdfDocument); }, async _scriptingDocProperties(pdfDocument) { if (!this.documentInfo) { await new Promise(resolve => { this.eventBus._on(\"metadataloaded\", resolve, { once: true }); }); if (pdfDocument !== this.pdfDocument) { return null; } } if (!this._contentLength) { await new Promise(resolve => { this.eventBus._on(\"documentloaded\", resolve, { once: true }); }); if (pdfDocument !== this.pdfDocument) { return null; } } return { ...this.documentInfo, baseURL: this.baseUrl, filesize: this._contentLength, filename: this._docFilename, metadata: this.metadata?.getRaw(), authors: this.metadata?.get(\"dc:creator\"), numPages: this.pagesCount, URL: this.url }; }, async _initializeAutoPrint(pdfDocument, openActionPromise) { const [openAction, javaScript] = await Promise.all([openActionPromise, !this.pdfViewer.enableScripting ? pdfDocument.getJavaScript() : null]); if (pdfDocument !== this.pdfDocument) { return; } let triggerAutoPrint = false; if (openAction?.action === \"Print\") { triggerAutoPrint = true; } if (javaScript) { javaScript.some(js => { if (!js) { return false; } console.warn(\"Warning: JavaScript support is not enabled\"); return true; }); if (!triggerAutoPrint) { for (const js of javaScript) { if (js && _ui_utils.AutoPrintRegExp.test(js)) { triggerAutoPrint = true; break; } } } } if (triggerAutoPrint) { this.triggerPrinting(); } }, async _initializeMetadata(pdfDocument) { const { info, metadata, contentDispositionFilename, contentLength } = await pdfDocument.getMetadata(); if (pdfDocument !== this.pdfDocument) { return; } this.documentInfo = info; this.metadata = metadata; this._contentDispositionFilename ??= contentDispositionFilename; this._contentLength ??= contentLength; console.log(`PDF ${pdfDocument.fingerprints[0]} [${info.PDFFormatVersion} ` + `${(info.Producer || \"-\").trim()} / ${(info.Creator || \"-\").trim()}] ` + `(PDF.js: ${_pdfjsLib.version || \"?\"} [${_pdfjsLib.build || \"?\"}])`); let pdfTitle = info.Title; const metadataTitle = metadata?.get(\"dc:title\"); if (metadataTitle) { if (metadataTitle !== \"Untitled\" && !/[\\uFFF0-\\uFFFF]/g.test(metadataTitle)) { pdfTitle = metadataTitle; } } if (pdfTitle) { this.setTitle(`${pdfTitle} - ${this._contentDispositionFilename || this._title}`); } else if (this._contentDispositionFilename) { this.setTitle(this._contentDispositionFilename); } if (info.IsXFAPresent && !info.IsAcroFormPresent && !pdfDocument.isPureXfa) { if (pdfDocument.loadingParams.enableXfa) { console.warn(\"Warning: XFA Foreground documents are not supported\"); } else { console.warn(\"Warning: XFA support is not enabled\"); } } else if ((info.IsAcroFormPresent || info.IsXFAPresent) && !this.pdfViewer.renderForms) { console.warn(\"Warning: Interactive form support is not enabled\"); } if (info.IsSignaturesPresent) { console.warn(\"Warning: Digital signatures validation is not supported\"); } this.eventBus.dispatch(\"metadataloaded\", { source: this }); }, async _initializePageLabels(pdfDocument) { const labels = await pdfDocument.getPageLabels(); if (pdfDocument !== this.pdfDocument) { return; } if (!labels || _app_options.AppOptions.get(\"disablePageLabels\")) { return; } const numLabels = labels.length; let standardLabels = 0, emptyLabels = 0; for (let i = 0; i < numLabels; i++) { const label = labels[i]; if (label === (i + 1).toString()) { standardLabels++; } else if (label === \"\") { emptyLabels++; } else { break; } } if (standardLabels >= numLabels || emptyLabels >= numLabels) { return; } const { pdfViewer, pdfThumbnailViewer, toolbar } = this; pdfViewer.setPageLabels(labels); pdfThumbnailViewer?.setPageLabels(labels); toolbar?.setPagesCount(numLabels, true); toolbar?.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel); }, _initializePdfHistory({ fingerprint, viewOnLoad, initialDest = null }) { if (!this.pdfHistory) { return; } this.pdfHistory.initialize({ fingerprint, resetHistory: viewOnLoad === ViewOnLoad.INITIAL, updateUrl: _app_options.AppOptions.get(\"historyUpdateUrl\") }); if (this.pdfHistory.initialBookmark) { this.initialBookmark = this.pdfHistory.initialBookmark; this.initialRotation = this.pdfHistory.initialRotation; } if (initialDest && !this.initialBookmark && viewOnLoad === ViewOnLoad.UNKNOWN) { this.initialBookmark = JSON.stringify(initialDest); this.pdfHistory.push({ explicitDest: initialDest, pageNumber: null }); } }, _initializeAnnotationStorageCallbacks(pdfDocument) { if (pdfDocument !== this.pdfDocument) { return; } const { annotationStorage } = pdfDocument; annotationStorage.onSetModified = () => { window.addEventListener(\"beforeunload\", beforeUnload); this._annotationStorageModified = true; }; annotationStorage.onResetModified = () => { window.removeEventListener(\"beforeunload\", beforeUnload); delete this._annotationStorageModified; }; annotationStorage.onAnnotationEditor = typeStr => { this._hasAnnotationEditors = !!typeStr; this.setTitle(); if (typeStr) { this.externalServices.reportTelemetry({ type: \"editing\", data: { type: typeStr } }); } }; }, setInitialView(storedHash, { rotation, sidebarView, scrollMode, spreadMode } = {}) { const setRotation = angle => { if ((0, _ui_utils.isValidRotation)(angle)) { this.pdfViewer.pagesRotation = angle; } }; const setViewerModes = (scroll, spread) => { if ((0, _ui_utils.isValidScrollMode)(scroll)) { this.pdfViewer.scrollMode = scroll; } if ((0, _ui_utils.isValidSpreadMode)(spread)) { this.pdfViewer.spreadMode = spread; } }; this.isInitialViewSet = true; this.pdfSidebar?.setInitialView(sidebarView); setViewerModes(scrollMode, spreadMode); if (this.initialBookmark) { setRotation(this.initialRotation); delete this.initialRotation; this.pdfLinkService.setHash(this.initialBookmark); this.initialBookmark = null; } else if (storedHash) { setRotation(rotation); this.pdfLinkService.setHash(storedHash); } this.toolbar?.setPageNumber(this.pdfViewer.currentPageNumber, this.pdfViewer.currentPageLabel); this.secondaryToolbar?.setPageNumber(this.pdfViewer.currentPageNumber); if (!this.pdfViewer.currentScaleValue) { this.pdfViewer.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE; } }, _cleanup() { if (!this.pdfDocument) { return; } this.pdfViewer.cleanup(); this.pdfThumbnailViewer?.cleanup(); this.pdfDocument.cleanup(this.pdfViewer.renderer === _ui_utils.RendererType.SVG); }, forceRendering() { this.pdfRenderingQueue.printing = !!this.printService; this.pdfRenderingQueue.isThumbnailViewEnabled = this.pdfSidebar?.visibleView === _ui_utils.SidebarView.THUMBS; this.pdfRenderingQueue.renderHighestPriority(); }, beforePrint() { this._printAnnotationStoragePromise = this.pdfScriptingManager.dispatchWillPrint().catch(() => {}).then(() => { return this.pdfDocument?.annotationStorage.print; }); if (this.printService) { return; } if (!this.supportsPrinting) { this.l10n.get(\"printing_not_supported\").then(msg => { this._otherError(msg); }); return; } if (!this.pdfViewer.pageViewsReady) { this.l10n.get(\"printing_not_ready\").then(msg => { window.alert(msg); }); return; } const pagesOverview = this.pdfViewer.getPagesOverview(); const printContainer = this.appConfig.printContainer; const printResolution = _app_options.AppOptions.get(\"printResolution\"); const optionalContentConfigPromise = this.pdfViewer.optionalContentConfigPromise; const printService = PDFPrintServiceFactory.instance.createPrintService(this.pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise, this._printAnnotationStoragePromise, this.l10n); this.printService = printService; this.forceRendering(); this.setTitle(); printService.layout(); if (this._hasAnnotationEditors) { this.externalServices.reportTelemetry({ type: \"editing\", data: { type: \"print\" } }); } }, afterPrint() { if (this._printAnnotationStoragePromise) { this._printAnnotationStoragePromise.then(() => { this.pdfScriptingManager.dispatchDidPrint(); }); this._printAnnotationStoragePromise = null; } if (this.printService) { this.printService.destroy(); this.printService = null; this.pdfDocument?.annotationStorage.resetModified(); } this.forceRendering(); this.setTitle(); }, rotatePages(delta) { this.pdfViewer.pagesRotation += delta; }, requestPresentationMode() { this.pdfPresentationMode?.request(); }, triggerPrinting() { if (!this.supportsPrinting) { return; } window.print(); }, bindEvents() { const { eventBus, _boundEvents } = this; _boundEvents.beforePrint = this.beforePrint.bind(this); _boundEvents.afterPrint = this.afterPrint.bind(this); eventBus._on(\"resize\", webViewerResize); eventBus._on(\"hashchange\", webViewerHashchange); eventBus._on(\"beforeprint\", _boundEvents.beforePrint); eventBus._on(\"afterprint\", _boundEvents.afterPrint); eventBus._on(\"pagerender\", webViewerPageRender); eventBus._on(\"pagerendered\", webViewerPageRendered); eventBus._on(\"updateviewarea\", webViewerUpdateViewarea); eventBus._on(\"pagechanging\", webViewerPageChanging); eventBus._on(\"scalechanging\", webViewerScaleChanging); eventBus._on(\"rotationchanging\", webViewerRotationChanging); eventBus._on(\"sidebarviewchanged\", webViewerSidebarViewChanged); eventBus._on(\"pagemode\", webViewerPageMode); eventBus._on(\"namedaction\", webViewerNamedAction); eventBus._on(\"presentationmodechanged\", webViewerPresentationModeChanged); eventBus._on(\"presentationmode\", webViewerPresentationMode); eventBus._on(\"switchannotationeditormode\", webViewerSwitchAnnotationEditorMode); eventBus._on(\"switchannotationeditorparams\", webViewerSwitchAnnotationEditorParams); eventBus._on(\"print\", webViewerPrint); eventBus._on(\"download\", webViewerDownload); eventBus._on(\"firstpage\", webViewerFirstPage); eventBus._on(\"lastpage\", webViewerLastPage); eventBus._on(\"nextpage\", webViewerNextPage); eventBus._on(\"previouspage\", webViewerPreviousPage); eventBus._on(\"zoomin\", webViewerZoomIn); eventBus._on(\"zoomout\", webViewerZoomOut); eventBus._on(\"zoomreset\", webViewerZoomReset); eventBus._on(\"pagenumberchanged\", webViewerPageNumberChanged); eventBus._on(\"scalechanged\", webViewerScaleChanged); eventBus._on(\"rotatecw\", webViewerRotateCw); eventBus._on(\"rotateccw\", webViewerRotateCcw); eventBus._on(\"optionalcontentconfig\", webViewerOptionalContentConfig); eventBus._on(\"switchscrollmode\", webViewerSwitchScrollMode); eventBus._on(\"scrollmodechanged\", webViewerScrollModeChanged); eventBus._on(\"switchspreadmode\", webViewerSwitchSpreadMode); eventBus._on(\"spreadmodechanged\", webViewerSpreadModeChanged); eventBus._on(\"documentproperties\", webViewerDocumentProperties); eventBus._on(\"findfromurlhash\", webViewerFindFromUrlHash); eventBus._on(\"updatefindmatchescount\", webViewerUpdateFindMatchesCount); eventBus._on(\"updatefindcontrolstate\", webViewerUpdateFindControlState); if (_app_options.AppOptions.get(\"pdfBug\")) { _boundEvents.reportPageStatsPDFBug = reportPageStatsPDFBug; eventBus._on(\"pagerendered\", _boundEvents.reportPageStatsPDFBug); eventBus._on(\"pagechanging\", _boundEvents.reportPageStatsPDFBug); } eventBus._on(\"fileinputchange\", webViewerFileInputChange); eventBus._on(\"openfile\", webViewerOpenFile); }, bindWindowEvents() { const { eventBus, _boundEvents } = this; function addWindowResolutionChange(evt = null) { if (evt) { webViewerResolutionChange(evt); } const mediaQueryList = window.matchMedia(`(resolution: ${window.devicePixelRatio || 1}dppx)`); mediaQueryList.addEventListener(\"change\", addWindowResolutionChange, { once: true }); _boundEvents.removeWindowResolutionChange ||= function () { mediaQueryList.removeEventListener(\"change\", addWindowResolutionChange); _boundEvents.removeWindowResolutionChange = null; }; } addWindowResolutionChange(); _boundEvents.windowResize = () => { eventBus.dispatch(\"resize\", { source: window }); }; _boundEvents.windowHashChange = () => { eventBus.dispatch(\"hashchange\", { source: window, hash: document.location.hash.substring(1) }); }; _boundEvents.windowBeforePrint = () => { eventBus.dispatch(\"beforeprint\", { source: window }); }; _boundEvents.windowAfterPrint = () => { eventBus.dispatch(\"afterprint\", { source: window }); }; _boundEvents.windowUpdateFromSandbox = event => { eventBus.dispatch(\"updatefromsandbox\", { source: window, detail: event.detail }); }; window.addEventListener(\"visibilitychange\", webViewerVisibilityChange); window.addEventListener(\"wheel\", webViewerWheel, { passive: false }); window.addEventListener(\"touchstart\", webViewerTouchStart, { passive: false }); window.addEventListener(\"click\", webViewerClick); window.addEventListener(\"keydown\", webViewerKeyDown); window.addEventListener(\"resize\", _boundEvents.windowResize); window.addEventListener(\"hashchange\", _boundEvents.windowHashChange); window.addEventListener(\"beforeprint\", _boundEvents.windowBeforePrint); window.addEventListener(\"afterprint\", _boundEvents.windowAfterPrint); window.addEventListener(\"updatefromsandbox\", _boundEvents.windowUpdateFromSandbox); }, unbindEvents() { const { eventBus, _boundEvents } = this; eventBus._off(\"resize\", webViewerResize); eventBus._off(\"hashchange\", webViewerHashchange); eventBus._off(\"beforeprint\", _boundEvents.beforePrint); eventBus._off(\"afterprint\", _boundEvents.afterPrint); eventBus._off(\"pagerender\", webViewerPageRender); eventBus._off(\"pagerendered\", webViewerPageRendered); eventBus._off(\"updateviewarea\", webViewerUpdateViewarea); eventBus._off(\"pagechanging\", webViewerPageChanging); eventBus._off(\"scalechanging\", webViewerScaleChanging); eventBus._off(\"rotationchanging\", webViewerRotationChanging); eventBus._off(\"sidebarviewchanged\", webViewerSidebarViewChanged); eventBus._off(\"pagemode\", webViewerPageMode); eventBus._off(\"namedaction\", webViewerNamedAction); eventBus._off(\"presentationmodechanged\", webViewerPresentationModeChanged); eventBus._off(\"presentationmode\", webViewerPresentationMode); eventBus._off(\"print\", webViewerPrint); eventBus._off(\"download\", webViewerDownload); eventBus._off(\"firstpage\", webViewerFirstPage); eventBus._off(\"lastpage\", webViewerLastPage); eventBus._off(\"nextpage\", webViewerNextPage); eventBus._off(\"previouspage\", webViewerPreviousPage); eventBus._off(\"zoomin\", webViewerZoomIn); eventBus._off(\"zoomout\", webViewerZoomOut); eventBus._off(\"zoomreset\", webViewerZoomReset); eventBus._off(\"pagenumberchanged\", webViewerPageNumberChanged); eventBus._off(\"scalechanged\", webViewerScaleChanged); eventBus._off(\"rotatecw\", webViewerRotateCw); eventBus._off(\"rotateccw\", webViewerRotateCcw); eventBus._off(\"optionalcontentconfig\", webViewerOptionalContentConfig); eventBus._off(\"switchscrollmode\", webViewerSwitchScrollMode); eventBus._off(\"scrollmodechanged\", webViewerScrollModeChanged); eventBus._off(\"switchspreadmode\", webViewerSwitchSpreadMode); eventBus._off(\"spreadmodechanged\", webViewerSpreadModeChanged); eventBus._off(\"documentproperties\", webViewerDocumentProperties); eventBus._off(\"findfromurlhash\", webViewerFindFromUrlHash); eventBus._off(\"updatefindmatchescount\", webViewerUpdateFindMatchesCount); eventBus._off(\"updatefindcontrolstate\", webViewerUpdateFindControlState); if (_boundEvents.reportPageStatsPDFBug) { eventBus._off(\"pagerendered\", _boundEvents.reportPageStatsPDFBug); eventBus._off(\"pagechanging\", _boundEvents.reportPageStatsPDFBug); _boundEvents.reportPageStatsPDFBug = null; } eventBus._off(\"fileinputchange\", webViewerFileInputChange); eventBus._off(\"openfile\", webViewerOpenFile); _boundEvents.beforePrint = null; _boundEvents.afterPrint = null; }, unbindWindowEvents() { const { _boundEvents } = this; window.removeEventListener(\"visibilitychange\", webViewerVisibilityChange); window.removeEventListener(\"wheel\", webViewerWheel, { passive: false }); window.removeEventListener(\"touchstart\", webViewerTouchStart, { passive: false }); window.removeEventListener(\"click\", webViewerClick); window.removeEventListener(\"keydown\", webViewerKeyDown); window.removeEventListener(\"resize\", _boundEvents.windowResize); window.removeEventListener(\"hashchange\", _boundEvents.windowHashChange); window.removeEventListener(\"beforeprint\", _boundEvents.windowBeforePrint); window.removeEventListener(\"afterprint\", _boundEvents.windowAfterPrint); window.removeEventListener(\"updatefromsandbox\", _boundEvents.windowUpdateFromSandbox); _boundEvents.removeWindowResolutionChange?.(); _boundEvents.windowResize = null; _boundEvents.windowHashChange = null; _boundEvents.windowBeforePrint = null; _boundEvents.windowAfterPrint = null; _boundEvents.windowUpdateFromSandbox = null; }, accumulateWheelTicks(ticks) { if (this._wheelUnusedTicks > 0 && ticks < 0 || this._wheelUnusedTicks < 0 && ticks > 0) { this._wheelUnusedTicks = 0; } this._wheelUnusedTicks += ticks; const wholeTicks = Math.trunc(this._wheelUnusedTicks); this._wheelUnusedTicks -= wholeTicks; return wholeTicks; }, _unblockDocumentLoadEvent() { document.blockUnblockOnload?.(false); this._unblockDocumentLoadEvent = () => {}; }, get scriptingReady() { return this.pdfScriptingManager.ready; } }; exports.PDFViewerApplication = PDFViewerApplication; { const HOSTED_VIEWER_ORIGINS = [\"null\", \"http://mozilla.github.io\", \"https://mozilla.github.io\"]; var validateFileURL = function (file) { if (!file) { return; } try { const viewerOrigin = new URL(window.location.href).origin || \"null\"; if (HOSTED_VIEWER_ORIGINS.includes(viewerOrigin)) { return; } const fileOrigin = new URL(file, window.location.href).origin; if (fileOrigin !== viewerOrigin) { throw new Error(\"file origin does not match viewer's\"); } } catch (ex) { PDFViewerApplication.l10n.get(\"loading_error\").then(msg => { PDFViewerApplication._documentError(msg, { message: ex?.message }); }); throw ex; } }; } async function loadFakeWorker() { _pdfjsLib.GlobalWorkerOptions.workerSrc ||= _app_options.AppOptions.get(\"workerSrc\"); await (0, _pdfjsLib.loadScript)(_pdfjsLib.PDFWorker.workerSrc); } async function loadPDFBug(self) { const { debuggerScriptPath } = self.appConfig; const { PDFBug } = await import(debuggerScriptPath); self._PDFBug = PDFBug; } function reportPageStatsPDFBug({ pageNumber }) { if (!globalThis.Stats?.enabled) { return; } const pageView = PDFViewerApplication.pdfViewer.getPageView(pageNumber - 1); globalThis.Stats.add(pageNumber, pageView?.pdfPage?.stats); } function webViewerInitialized() { const { appConfig, eventBus } = PDFViewerApplication; let file; const queryString = document.location.search.substring(1); const params = (0, _ui_utils.parseQueryString)(queryString); file = params.get(\"file\") ?? _app_options.AppOptions.get(\"defaultUrl\"); validateFileURL(file); const fileInput = appConfig.openFileInput; fileInput.value = null; fileInput.addEventListener(\"change\", function (evt) { const { files } = evt.target; if (!files || files.length === 0) { return; } eventBus.dispatch(\"fileinputchange\", { source: this, fileInput: evt.target }); }); appConfig.mainContainer.addEventListener(\"dragover\", function (evt) { evt.preventDefault(); evt.dataTransfer.dropEffect = evt.dataTransfer.effectAllowed === \"copy\" ? \"copy\" : \"move\"; }); appConfig.mainContainer.addEventListener(\"drop\", function (evt) { evt.preventDefault(); const { files } = evt.dataTransfer; if (!files || files.length === 0) { return; } eventBus.dispatch(\"fileinputchange\", { source: this, fileInput: evt.dataTransfer }); }); if (!PDFViewerApplication.supportsDocumentFonts) { _app_options.AppOptions.set(\"disableFontFace\", true); PDFViewerApplication.l10n.get(\"web_fonts_disabled\").then(msg => { console.warn(msg); }); } if (!PDFViewerApplication.supportsPrinting) { appConfig.toolbar?.print.classList.add(\"hidden\"); appConfig.secondaryToolbar?.printButton.classList.add(\"hidden\"); } if (!PDFViewerApplication.supportsFullscreen) { appConfig.secondaryToolbar?.presentationModeButton.classList.add(\"hidden\"); } if (PDFViewerApplication.supportsIntegratedFind) { appConfig.toolbar?.viewFind.classList.add(\"hidden\"); } appConfig.mainContainer.addEventListener(\"transitionend\", function (evt) { if (evt.target === this) { eventBus.dispatch(\"resize\", { source: this }); } }, true); try { if (file) { PDFViewerApplication.open(file); } else { PDFViewerApplication._hideViewBookmark(); } } catch (reason) { PDFViewerApplication.l10n.get(\"loading_error\").then(msg => { PDFViewerApplication._documentError(msg, reason); }); } } function webViewerPageRender({ pageNumber }) { if (pageNumber === PDFViewerApplication.page) { PDFViewerApplication.toolbar?.updateLoadingIndicatorState(true); } } function webViewerPageRendered({ pageNumber, error }) { if (pageNumber === PDFViewerApplication.page) { PDFViewerApplication.toolbar?.updateLoadingIndicatorState(false); } if (PDFViewerApplication.pdfSidebar?.visibleView === _ui_utils.SidebarView.THUMBS) { const pageView = PDFViewerApplication.pdfViewer.getPageView(pageNumber - 1); const thumbnailView = PDFViewerApplication.pdfThumbnailViewer?.getThumbnail(pageNumber - 1); if (pageView && thumbnailView) { thumbnailView.setImage(pageView); } } if (error) { PDFViewerApplication.l10n.get(\"rendering_error\").then(msg => { PDFViewerApplication._otherError(msg, error); }); } } function webViewerPageMode({ mode }) { let view; switch (mode) { case \"thumbs\": view = _ui_utils.SidebarView.THUMBS; break; case \"bookmarks\": case \"outline\": view = _ui_utils.SidebarView.OUTLINE; break; case \"attachments\": view = _ui_utils.SidebarView.ATTACHMENTS; break; case \"layers\": view = _ui_utils.SidebarView.LAYERS; break; case \"none\": view = _ui_utils.SidebarView.NONE; break; default: console.error('Invalid \"pagemode\" hash parameter: ' + mode); return; } PDFViewerApplication.pdfSidebar?.switchView(view, true); } function webViewerNamedAction(evt) { switch (evt.action) { case \"GoToPage\": PDFViewerApplication.appConfig.toolbar?.pageNumber.select(); break; case \"Find\": if (!PDFViewerApplication.supportsIntegratedFind) { PDFViewerApplication?.findBar.toggle(); } break; case \"Print\": PDFViewerApplication.triggerPrinting(); break; case \"SaveAs\": PDFViewerApplication.downloadOrSave(); break; } } function webViewerPresentationModeChanged(evt) { PDFViewerApplication.pdfViewer.presentationModeState = evt.state; } function webViewerSidebarViewChanged({ view }) { PDFViewerApplication.pdfRenderingQueue.isThumbnailViewEnabled = view === _ui_utils.SidebarView.THUMBS; if (PDFViewerApplication.isInitialViewSet) { PDFViewerApplication.store?.set(\"sidebarView\", view).catch(() => {}); } } function webViewerUpdateViewarea({ location }) { if (PDFViewerApplication.isInitialViewSet) { PDFViewerApplication.store?.setMultiple({ page: location.pageNumber, zoom: location.scale, scrollLeft: location.left, scrollTop: location.top, rotation: location.rotation }).catch(() => {}); } if (PDFViewerApplication.appConfig.secondaryToolbar) { const href = PDFViewerApplication.pdfLinkService.getAnchorUrl(location.pdfOpenParams); PDFViewerApplication.appConfig.secondaryToolbar.viewBookmarkButton.href = href; } } function webViewerScrollModeChanged(evt) { if (PDFViewerApplication.isInitialViewSet && !PDFViewerApplication.pdfViewer.isInPresentationMode) { PDFViewerApplication.store?.set(\"scrollMode\", evt.mode).catch(() => {}); } } function webViewerSpreadModeChanged(evt) { if (PDFViewerApplication.isInitialViewSet && !PDFViewerApplication.pdfViewer.isInPresentationMode) { PDFViewerApplication.store?.set(\"spreadMode\", evt.mode).catch(() => {}); } } function webViewerResize() { const { pdfDocument, pdfViewer, pdfRenderingQueue } = PDFViewerApplication; if (pdfRenderingQueue.printing && window.matchMedia(\"print\").matches) { return; } if (!pdfDocument) { return; } const currentScaleValue = pdfViewer.currentScaleValue; if (currentScaleValue === \"auto\" || currentScaleValue === \"page-fit\" || currentScaleValue === \"page-width\") { pdfViewer.currentScaleValue = currentScaleValue; } pdfViewer.update(); } function webViewerHashchange(evt) { const hash = evt.hash; if (!hash) { return; } if (!PDFViewerApplication.isInitialViewSet) { PDFViewerApplication.initialBookmark = hash; } else if (!PDFViewerApplication.pdfHistory?.popStateInProgress) { PDFViewerApplication.pdfLinkService.setHash(hash); } } { var webViewerFileInputChange = function (evt) { if (PDFViewerApplication.pdfViewer?.isInPresentationMode) { return; } const file = evt.fileInput.files[0]; let url = URL.createObjectURL(file); if (file.name) { url = { url, originalUrl: file.name }; } PDFViewerApplication.open(url); }; var webViewerOpenFile = function (evt) { const fileInput = PDFViewerApplication.appConfig.openFileInput; fileInput.click(); }; } function webViewerPresentationMode() { PDFViewerApplication.requestPresentationMode(); } function webViewerSwitchAnnotationEditorMode(evt) { PDFViewerApplication.pdfViewer.annotationEditorMode = evt.mode; } function webViewerSwitchAnnotationEditorParams(evt) { PDFViewerApplication.pdfViewer.annotationEditorParams = evt; } function webViewerPrint() { PDFViewerApplication.triggerPrinting(); } function webViewerDownload() { PDFViewerApplication.downloadOrSave(); } function webViewerFirstPage() { if (PDFViewerApplication.pdfDocument) { PDFViewerApplication.page = 1; } } function webViewerLastPage() { if (PDFViewerApplication.pdfDocument) { PDFViewerApplication.page = PDFViewerApplication.pagesCount; } } function webViewerNextPage() { PDFViewerApplication.pdfViewer.nextPage(); } function webViewerPreviousPage() { PDFViewerApplication.pdfViewer.previousPage(); } function webViewerZoomIn() { PDFViewerApplication.zoomIn(); } function webViewerZoomOut() { PDFViewerApplication.zoomOut(); } function webViewerZoomReset() { PDFViewerApplication.zoomReset(); } function webViewerPageNumberChanged(evt) { const pdfViewer = PDFViewerApplication.pdfViewer; if (evt.value !== \"\") { PDFViewerApplication.pdfLinkService.goToPage(evt.value); } if (evt.value !== pdfViewer.currentPageNumber.toString() && evt.value !== pdfViewer.currentPageLabel) { PDFViewerApplication.toolbar?.setPageNumber(pdfViewer.currentPageNumber, pdfViewer.currentPageLabel); } } function webViewerScaleChanged(evt) { PDFViewerApplication.pdfViewer.currentScaleValue = evt.value; } function webViewerRotateCw() { PDFViewerApplication.rotatePages(90); } function webViewerRotateCcw() { PDFViewerApplication.rotatePages(-90); } function webViewerOptionalContentConfig(evt) { PDFViewerApplication.pdfViewer.optionalContentConfigPromise = evt.promise; } function webViewerSwitchScrollMode(evt) { PDFViewerApplication.pdfViewer.scrollMode = evt.mode; } function webViewerSwitchSpreadMode(evt) { PDFViewerApplication.pdfViewer.spreadMode = evt.mode; } function webViewerDocumentProperties() { PDFViewerApplication.pdfDocumentProperties?.open(); } function webViewerFindFromUrlHash(evt) { PDFViewerApplication.eventBus.dispatch(\"find\", { source: evt.source, type: \"\", query: evt.query, phraseSearch: evt.phraseSearch, caseSensitive: false, entireWord: false, highlightAll: true, findPrevious: false, matchDiacritics: true }); } function webViewerUpdateFindMatchesCount({ matchesCount }) { if (PDFViewerApplication.supportsIntegratedFind) { PDFViewerApplication.externalServices.updateFindMatchesCount(matchesCount); } else { PDFViewerApplication.findBar.updateResultsCount(matchesCount); } } function webViewerUpdateFindControlState({ state, previous, matchesCount, rawQuery }) { if (PDFViewerApplication.supportsIntegratedFind) { PDFViewerApplication.externalServices.updateFindControlState({ result: state, findPrevious: previous, matchesCount, rawQuery }); } else { PDFViewerApplication.findBar?.updateUIState(state, previous, matchesCount); } } function webViewerScaleChanging(evt) { PDFViewerApplication.toolbar?.setPageScale(evt.presetValue, evt.scale); PDFViewerApplication.pdfViewer.update(); } function webViewerRotationChanging(evt) { if (PDFViewerApplication.pdfThumbnailViewer) { PDFViewerApplication.pdfThumbnailViewer.pagesRotation = evt.pagesRotation; } PDFViewerApplication.forceRendering(); PDFViewerApplication.pdfViewer.currentPageNumber = evt.pageNumber; } function webViewerPageChanging({ pageNumber, pageLabel }) { PDFViewerApplication.toolbar?.setPageNumber(pageNumber, pageLabel); PDFViewerApplication.secondaryToolbar?.setPageNumber(pageNumber); if (PDFViewerApplication.pdfSidebar?.visibleView === _ui_utils.SidebarView.THUMBS) { PDFViewerApplication.pdfThumbnailViewer?.scrollThumbnailIntoView(pageNumber); } const currentPage = PDFViewerApplication.pdfViewer.getPageView(pageNumber - 1); PDFViewerApplication.toolbar?.updateLoadingIndicatorState(currentPage?.renderingState === _ui_utils.RenderingStates.RUNNING); } function webViewerResolutionChange(evt) { PDFViewerApplication.pdfViewer.refresh(); } function webViewerVisibilityChange(evt) { if (document.visibilityState === \"visible\") { setZoomDisabledTimeout(); } } let zoomDisabledTimeout = null; function setZoomDisabledTimeout() { if (zoomDisabledTimeout) { clearTimeout(zoomDisabledTimeout); } zoomDisabledTimeout = setTimeout(function () { zoomDisabledTimeout = null; }, WHEEL_ZOOM_DISABLED_TIMEOUT); } function webViewerWheel(evt) { const { pdfViewer, supportedMouseWheelZoomModifierKeys } = PDFViewerApplication; if (pdfViewer.isInPresentationMode) { return; } if (evt.ctrlKey && supportedMouseWheelZoomModifierKeys.ctrlKey || evt.metaKey && supportedMouseWheelZoomModifierKeys.metaKey) { evt.preventDefault(); if (zoomDisabledTimeout || document.visibilityState === \"hidden\") { return; } const deltaMode = evt.deltaMode; const delta = (0, _ui_utils.normalizeWheelEventDirection)(evt); const previousScale = pdfViewer.currentScale; let ticks = 0; if (deltaMode === WheelEvent.DOM_DELTA_LINE || deltaMode === WheelEvent.DOM_DELTA_PAGE) { if (Math.abs(delta) >= 1) { ticks = Math.sign(delta); } else { ticks = PDFViewerApplication.accumulateWheelTicks(delta); } } else { const PIXELS_PER_LINE_SCALE = 30; ticks = PDFViewerApplication.accumulateWheelTicks(delta / PIXELS_PER_LINE_SCALE); } if (ticks < 0) { PDFViewerApplication.zoomOut(-ticks); } else if (ticks > 0) { PDFViewerApplication.zoomIn(ticks); } const currentScale = pdfViewer.currentScale; if (previousScale !== currentScale) { const scaleCorrectionFactor = currentScale / previousScale - 1; const [top, left] = pdfViewer.containerTopLeft; const dx = evt.clientX - left; const dy = evt.clientY - top; pdfViewer.container.scrollLeft += dx * scaleCorrectionFactor; pdfViewer.container.scrollTop += dy * scaleCorrectionFactor; } } else { setZoomDisabledTimeout(); } } function webViewerTouchStart(evt) { if (evt.touches.length > 1) { evt.preventDefault(); } } function webViewerClick(evt) { if (!PDFViewerApplication.secondaryToolbar?.isOpen) { return; } const appConfig = PDFViewerApplication.appConfig; if (PDFViewerApplication.pdfViewer.containsElement(evt.target) || appConfig.toolbar?.container.contains(evt.target) && evt.target !== appConfig.secondaryToolbar?.toggleButton) { PDFViewerApplication.secondaryToolbar.close(); } } function webViewerKeyDown(evt) { if (PDFViewerApplication.overlayManager.active) { return; } const { eventBus, pdfViewer } = PDFViewerApplication; const isViewerInPresentationMode = pdfViewer.isInPresentationMode; let handled = false, ensureViewerFocused = false; const cmd = (evt.ctrlKey ? 1 : 0) | (evt.altKey ? 2 : 0) | (evt.shiftKey ? 4 : 0) | (evt.metaKey ? 8 : 0); if (cmd === 1 || cmd === 8 || cmd === 5 || cmd === 12) { switch (evt.keyCode) { case 70: if (!PDFViewerApplication.supportsIntegratedFind && !evt.shiftKey) { PDFViewerApplication.findBar?.open(); handled = true; } break; case 71: if (!PDFViewerApplication.supportsIntegratedFind) { const { state } = PDFViewerApplication.findController; if (state) { const eventState = Object.assign(Object.create(null), state, { source: window, type: \"again\", findPrevious: cmd === 5 || cmd === 12 }); eventBus.dispatch(\"find\", eventState); } handled = true; } break; case 61: case 107: case 187: case 171: if (!isViewerInPresentationMode) { PDFViewerApplication.zoomIn(); } handled = true; break; case 173: case 109: case 189: if (!isViewerInPresentationMode) { PDFViewerApplication.zoomOut(); } handled = true; break; case 48: case 96: if (!isViewerInPresentationMode) { setTimeout(function () { PDFViewerApplication.zoomReset(); }); handled = false; } break; case 38: if (isViewerInPresentationMode || PDFViewerApplication.page > 1) { PDFViewerApplication.page = 1; handled = true; ensureViewerFocused = true; } break; case 40: if (isViewerInPresentationMode || PDFViewerApplication.page < PDFViewerApplication.pagesCount) { PDFViewerApplication.page = PDFViewerApplication.pagesCount; handled = true; ensureViewerFocused = true; } break; } } if (cmd === 1 || cmd === 8) { switch (evt.keyCode) { case 83: eventBus.dispatch(\"download\", { source: window }); handled = true; break; case 79: { eventBus.dispatch(\"openfile\", { source: window }); handled = true; } break; } } if (cmd === 3 || cmd === 10) { switch (evt.keyCode) { case 80: PDFViewerApplication.requestPresentationMode(); handled = true; PDFViewerApplication.externalServices.reportTelemetry({ type: \"buttons\", data: { id: \"presentationModeKeyboard\" } }); break; case 71: if (PDFViewerApplication.appConfig.toolbar) { PDFViewerApplication.appConfig.toolbar.pageNumber.select(); handled = true; } break; } } if (handled) { if (ensureViewerFocused && !isViewerInPresentationMode) { pdfViewer.focus(); } evt.preventDefault(); return; } const curElement = (0, _ui_utils.getActiveOrFocusedElement)(); const curElementTagName = curElement?.tagName.toUpperCase(); if (curElementTagName === \"INPUT\" || curElementTagName === \"TEXTAREA\" || curElementTagName === \"SELECT\" || curElement?.isContentEditable) { if (evt.keyCode !== 27) { return; } } if (cmd === 0) { let turnPage = 0, turnOnlyIfPageFit = false; switch (evt.keyCode) { case 38: case 33: if (pdfViewer.isVerticalScrollbarEnabled) { turnOnlyIfPageFit = true; } turnPage = -1; break; case 8: if (!isViewerInPresentationMode) { turnOnlyIfPageFit = true; } turnPage = -1; break; case 37: if (pdfViewer.isHorizontalScrollbarEnabled) { turnOnlyIfPageFit = true; } case 75: case 80: turnPage = -1; break; case 27: if (PDFViewerApplication.secondaryToolbar?.isOpen) { PDFViewerApplication.secondaryToolbar.close(); handled = true; } if (!PDFViewerApplication.supportsIntegratedFind && PDFViewerApplication.findBar?.opened) { PDFViewerApplication.findBar.close(); handled = true; } break; case 40: case 34: if (pdfViewer.isVerticalScrollbarEnabled) { turnOnlyIfPageFit = true; } turnPage = 1; break; case 13: case 32: if (!isViewerInPresentationMode) { turnOnlyIfPageFit = true; } turnPage = 1; break; case 39: if (pdfViewer.isHorizontalScrollbarEnabled) { turnOnlyIfPageFit = true; } case 74: case 78: turnPage = 1; break; case 36: if (isViewerInPresentationMode || PDFViewerApplication.page > 1) { PDFViewerApplication.page = 1; handled = true; ensureViewerFocused = true; } break; case 35: if (isViewerInPresentationMode || PDFViewerApplication.page < PDFViewerApplication.pagesCount) { PDFViewerApplication.page = PDFViewerApplication.pagesCount; handled = true; ensureViewerFocused = true; } break; case 83: PDFViewerApplication.pdfCursorTools?.switchTool(_pdf_cursor_tools.CursorTool.SELECT); break; case 72: PDFViewerApplication.pdfCursorTools?.switchTool(_pdf_cursor_tools.CursorTool.HAND); break; case 82: PDFViewerApplication.rotatePages(90); break; case 115: PDFViewerApplication.pdfSidebar?.toggle(); break; } if (turnPage !== 0 && (!turnOnlyIfPageFit || pdfViewer.currentScaleValue === \"page-fit\")) { if (turnPage > 0) { pdfViewer.nextPage(); } else { pdfViewer.previousPage(); } handled = true; } } if (cmd === 4) { switch (evt.keyCode) { case 13: case 32: if (!isViewerInPresentationMode && pdfViewer.currentScaleValue !== \"page-fit\") { break; } pdfViewer.previousPage(); handled = true; break; case 82: PDFViewerApplication.rotatePages(-90); break; } } if (!handled && !isViewerInPresentationMode) { if (evt.keyCode >= 33 && evt.keyCode { let pdfjsLib; if (typeof window !== \"undefined\" && window[\"pdfjs-dist/build/pdf\"]) { pdfjsLib = window[\"pdfjs-dist/build/pdf\"]; } else { pdfjsLib = require(\"../build/pdf.js\"); } module.exports = pdfjsLib; /***/ }), /* 6 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.WaitOnType = exports.EventBus = exports.AutomationEventBus = void 0; exports.waitOnEventOrTimeout = waitOnEventOrTimeout; const WaitOnType = { EVENT: \"event\", TIMEOUT: \"timeout\" }; exports.WaitOnType = WaitOnType; function waitOnEventOrTimeout({ target, name, delay = 0 }) { return new Promise(function (resolve, reject) { if (typeof target !== \"object\" || !(name && typeof name === \"string\") || !(Number.isInteger(delay) && delay >= 0)) { throw new Error(\"waitOnEventOrTimeout - invalid parameters.\"); } function handler(type) { if (target instanceof EventBus) { target._off(name, eventHandler); } else { target.removeEventListener(name, eventHandler); } if (timeout) { clearTimeout(timeout); } resolve(type); } const eventHandler = handler.bind(null, WaitOnType.EVENT); if (target instanceof EventBus) { target._on(name, eventHandler); } else { target.addEventListener(name, eventHandler); } const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT); const timeout = setTimeout(timeoutHandler, delay); }); } class EventBus { #listeners = Object.create(null); on(eventName, listener, options = null) { this._on(eventName, listener, { external: true, once: options?.once }); } off(eventName, listener, options = null) { this._off(eventName, listener, { external: true, once: options?.once }); } dispatch(eventName, data) { const eventListeners = this.#listeners[eventName]; if (!eventListeners || eventListeners.length === 0) { return; } let externalListeners; for (const { listener, external, once } of eventListeners.slice(0)) { if (once) { this._off(eventName, listener); } if (external) { (externalListeners ||= []).push(listener); continue; } listener(data); } if (externalListeners) { for (const listener of externalListeners) { listener(data); } externalListeners = null; } } _on(eventName, listener, options = null) { const eventListeners = this.#listeners[eventName] ||= []; eventListeners.push({ listener, external: options?.external === true, once: options?.once === true }); } _off(eventName, listener, options = null) { const eventListeners = this.#listeners[eventName]; if (!eventListeners) { return; } for (let i = 0, ii = eventListeners.length; i < ii; i++) { if (eventListeners[i].listener === listener) { eventListeners.splice(i, 1); return; } } } } exports.EventBus = EventBus; class AutomationEventBus extends EventBus { dispatch(eventName, data) { throw new Error(\"Not implemented: AutomationEventBus.dispatch\"); } } exports.AutomationEventBus = AutomationEventBus; /***/ }), /* 7 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFCursorTools = exports.CursorTool = void 0; var _pdfjsLib = __webpack_require__(5); var _grab_to_pan = __webpack_require__(8); var _ui_utils = __webpack_require__(1); const CursorTool = { SELECT: 0, HAND: 1, ZOOM: 2 }; exports.CursorTool = CursorTool; class PDFCursorTools { constructor({ container, eventBus, cursorToolOnLoad = CursorTool.SELECT }) { this.container = container; this.eventBus = eventBus; this.active = CursorTool.SELECT; this.previouslyActive = null; this.handTool = new _grab_to_pan.GrabToPan({ element: this.container }); this.#addEventListeners(); Promise.resolve().then(() => { this.switchTool(cursorToolOnLoad); }); } get activeTool() { return this.active; } switchTool(tool) { if (this.previouslyActive !== null) { return; } if (tool === this.active) { return; } const disableActiveTool = () => { switch (this.active) { case CursorTool.SELECT: break; case CursorTool.HAND: this.handTool.deactivate(); break; case CursorTool.ZOOM: } }; switch (tool) { case CursorTool.SELECT: disableActiveTool(); break; case CursorTool.HAND: disableActiveTool(); this.handTool.activate(); break; case CursorTool.ZOOM: default: console.error(`switchTool: \"${tool}\" is an unsupported value.`); return; } this.active = tool; this.#dispatchEvent(); } #dispatchEvent() { this.eventBus.dispatch(\"cursortoolchanged\", { source: this, tool: this.active }); } #addEventListeners() { this.eventBus._on(\"switchcursortool\", evt => { this.switchTool(evt.tool); }); let annotationEditorMode = _pdfjsLib.AnnotationEditorType.NONE, presentationModeState = _ui_utils.PresentationModeState.NORMAL; const disableActive = () => { const previouslyActive = this.active; this.switchTool(CursorTool.SELECT); this.previouslyActive ??= previouslyActive; }; const enableActive = () => { const previouslyActive = this.previouslyActive; if (previouslyActive !== null && annotationEditorMode === _pdfjsLib.AnnotationEditorType.NONE && presentationModeState === _ui_utils.PresentationModeState.NORMAL) { this.previouslyActive = null; this.switchTool(previouslyActive); } }; this.eventBus._on(\"secondarytoolbarreset\", evt => { if (this.previouslyActive !== null) { annotationEditorMode = _pdfjsLib.AnnotationEditorType.NONE; presentationModeState = _ui_utils.PresentationModeState.NORMAL; enableActive(); } }); this.eventBus._on(\"annotationeditormodechanged\", ({ mode }) => { annotationEditorMode = mode; if (mode === _pdfjsLib.AnnotationEditorType.NONE) { enableActive(); } else { disableActive(); } }); this.eventBus._on(\"presentationmodechanged\", ({ state }) => { presentationModeState = state; if (state === _ui_utils.PresentationModeState.NORMAL) { enableActive(); } else if (state === _ui_utils.PresentationModeState.FULLSCREEN) { disableActive(); } }); } } exports.PDFCursorTools = PDFCursorTools; /***/ }), /* 8 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.GrabToPan = void 0; const CSS_CLASS_GRAB = \"grab-to-pan-grab\"; class GrabToPan { constructor(options) { this.element = options.element; this.document = options.element.ownerDocument; if (typeof options.ignoreTarget === \"function\") { this.ignoreTarget = options.ignoreTarget; } this.onActiveChanged = options.onActiveChanged; this.activate = this.activate.bind(this); this.deactivate = this.deactivate.bind(this); this.toggle = this.toggle.bind(this); this._onMouseDown = this.#onMouseDown.bind(this); this._onMouseMove = this.#onMouseMove.bind(this); this._endPan = this.#endPan.bind(this); const overlay = this.overlay = document.createElement(\"div\"); overlay.className = \"grab-to-pan-grabbing\"; } activate() { if (!this.active) { this.active = true; this.element.addEventListener(\"mousedown\", this._onMouseDown, true); this.element.classList.add(CSS_CLASS_GRAB); this.onActiveChanged?.(true); } } deactivate() { if (this.active) { this.active = false; this.element.removeEventListener(\"mousedown\", this._onMouseDown, true); this._endPan(); this.element.classList.remove(CSS_CLASS_GRAB); this.onActiveChanged?.(false); } } toggle() { if (this.active) { this.deactivate(); } else { this.activate(); } } ignoreTarget(node) { return node.matches(\"a[href], a[href] *, input, textarea, button, button *, select, option\"); } #onMouseDown(event) { if (event.button !== 0 || this.ignoreTarget(event.target)) { return; } if (event.originalTarget) { try { event.originalTarget.tagName; } catch (e) { return; } } this.scrollLeftStart = this.element.scrollLeft; this.scrollTopStart = this.element.scrollTop; this.clientXStart = event.clientX; this.clientYStart = event.clientY; this.document.addEventListener(\"mousemove\", this._onMouseMove, true); this.document.addEventListener(\"mouseup\", this._endPan, true); this.element.addEventListener(\"scroll\", this._endPan, true); event.preventDefault(); event.stopPropagation(); const focusedElement = document.activeElement; if (focusedElement && !focusedElement.contains(event.target)) { focusedElement.blur(); } } #onMouseMove(event) { this.element.removeEventListener(\"scroll\", this._endPan, true); if (!(event.buttons & 1)) { this._endPan(); return; } const xDiff = event.clientX - this.clientXStart; const yDiff = event.clientY - this.clientYStart; const scrollTop = this.scrollTopStart - yDiff; const scrollLeft = this.scrollLeftStart - xDiff; if (this.element.scrollTo) { this.element.scrollTo({ top: scrollTop, left: scrollLeft, behavior: \"instant\" }); } else { this.element.scrollTop = scrollTop; this.element.scrollLeft = scrollLeft; } if (!this.overlay.parentNode) { document.body.append(this.overlay); } } #endPan() { this.element.removeEventListener(\"scroll\", this._endPan, true); this.document.removeEventListener(\"mousemove\", this._onMouseMove, true); this.document.removeEventListener(\"mouseup\", this._endPan, true); this.overlay.remove(); } } exports.GrabToPan = GrabToPan; /***/ }), /* 9 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.AnnotationEditorParams = void 0; var _pdfjsLib = __webpack_require__(5); class AnnotationEditorParams { constructor(options, eventBus) { this.eventBus = eventBus; this.#bindListeners(options); } #bindListeners({ editorFreeTextFontSize, editorFreeTextColor, editorInkColor, editorInkThickness, editorInkOpacity }) { editorFreeTextFontSize.addEventListener(\"input\", evt => { this.eventBus.dispatch(\"switchannotationeditorparams\", { source: this, type: _pdfjsLib.AnnotationEditorParamsType.FREETEXT_SIZE, value: editorFreeTextFontSize.valueAsNumber }); }); editorFreeTextColor.addEventListener(\"input\", evt => { this.eventBus.dispatch(\"switchannotationeditorparams\", { source: this, type: _pdfjsLib.AnnotationEditorParamsType.FREETEXT_COLOR, value: editorFreeTextColor.value }); }); editorInkColor.addEventListener(\"input\", evt => { this.eventBus.dispatch(\"switchannotationeditorparams\", { source: this, type: _pdfjsLib.AnnotationEditorParamsType.INK_COLOR, value: editorInkColor.value }); }); editorInkThickness.addEventListener(\"input\", evt => { this.eventBus.dispatch(\"switchannotationeditorparams\", { source: this, type: _pdfjsLib.AnnotationEditorParamsType.INK_THICKNESS, value: editorInkThickness.valueAsNumber }); }); editorInkOpacity.addEventListener(\"input\", evt => { this.eventBus.dispatch(\"switchannotationeditorparams\", { source: this, type: _pdfjsLib.AnnotationEditorParamsType.INK_OPACITY, value: editorInkOpacity.valueAsNumber }); }); this.eventBus._on(\"annotationeditorparamschanged\", evt => { for (const [type, value] of evt.details) { switch (type) { case _pdfjsLib.AnnotationEditorParamsType.FREETEXT_SIZE: editorFreeTextFontSize.value = value; break; case _pdfjsLib.AnnotationEditorParamsType.FREETEXT_COLOR: editorFreeTextColor.value = value; break; case _pdfjsLib.AnnotationEditorParamsType.INK_COLOR: editorInkColor.value = value; break; case _pdfjsLib.AnnotationEditorParamsType.INK_THICKNESS: editorInkThickness.value = value; break; case _pdfjsLib.AnnotationEditorParamsType.INK_OPACITY: editorInkOpacity.value = value; break; } } }); } } exports.AnnotationEditorParams = AnnotationEditorParams; /***/ }), /* 10 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.OverlayManager = void 0; class OverlayManager { #overlays = new WeakMap(); #active = null; get active() { return this.#active; } async register(dialog, canForceClose = false) { if (typeof dialog !== \"object\") { throw new Error(\"Not enough parameters.\"); } else if (this.#overlays.has(dialog)) { throw new Error(\"The overlay is already registered.\"); } this.#overlays.set(dialog, { canForceClose }); dialog.addEventListener(\"cancel\", evt => { this.#active = null; }); } async unregister(dialog) { if (!this.#overlays.has(dialog)) { throw new Error(\"The overlay does not exist.\"); } else if (this.#active === dialog) { throw new Error(\"The overlay cannot be removed while it is active.\"); } this.#overlays.delete(dialog); } async open(dialog) { if (!this.#overlays.has(dialog)) { throw new Error(\"The overlay does not exist.\"); } else if (this.#active) { if (this.#active === dialog) { throw new Error(\"The overlay is already active.\"); } else if (this.#overlays.get(dialog).canForceClose) { await this.close(); } else { throw new Error(\"Another overlay is currently active.\"); } } this.#active = dialog; dialog.showModal(); } async close(dialog = this.#active) { if (!this.#overlays.has(dialog)) { throw new Error(\"The overlay does not exist.\"); } else if (!this.#active) { throw new Error(\"The overlay is currently not active.\"); } else if (this.#active !== dialog) { throw new Error(\"Another overlay is currently active.\"); } dialog.close(); this.#active = null; } } exports.OverlayManager = OverlayManager; /***/ }), /* 11 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PasswordPrompt = void 0; var _pdfjsLib = __webpack_require__(5); class PasswordPrompt { #activeCapability = null; #updateCallback = null; #reason = null; constructor(options, overlayManager, l10n, isViewerEmbedded = false) { this.dialog = options.dialog; this.label = options.label; this.input = options.input; this.submitButton = options.submitButton; this.cancelButton = options.cancelButton; this.overlayManager = overlayManager; this.l10n = l10n; this._isViewerEmbedded = isViewerEmbedded; this.submitButton.addEventListener(\"click\", this.#verify.bind(this)); this.cancelButton.addEventListener(\"click\", this.close.bind(this)); this.input.addEventListener(\"keydown\", e => { if (e.keyCode === 13) { this.#verify(); } }); this.overlayManager.register(this.dialog, true); this.dialog.addEventListener(\"close\", this.#cancel.bind(this)); } async open() { if (this.#activeCapability) { await this.#activeCapability.promise; } this.#activeCapability = (0, _pdfjsLib.createPromiseCapability)(); try { await this.overlayManager.open(this.dialog); } catch (ex) { this.#activeCapability = null; throw ex; } const passwordIncorrect = this.#reason === _pdfjsLib.PasswordResponses.INCORRECT_PASSWORD; if (!this._isViewerEmbedded || passwordIncorrect) { this.input.focus(); } this.label.textContent = await this.l10n.get(`password_${passwordIncorrect ? \"invalid\" : \"label\"}`); } async close() { if (this.overlayManager.active === this.dialog) { this.overlayManager.close(this.dialog); } } #verify() { const password = this.input.value; if (password?.length > 0) { this.#invokeCallback(password); } } #cancel() { this.#invokeCallback(new Error(\"PasswordPrompt cancelled.\")); this.#activeCapability.resolve(); } #invokeCallback(password) { if (!this.#updateCallback) { return; } this.close(); this.input.value = \"\"; this.#updateCallback(password); this.#updateCallback = null; } async setUpdateCallback(updateCallback, reason) { if (this.#activeCapability) { await this.#activeCapability.promise; } this.#updateCallback = updateCallback; this.#reason = reason; } } exports.PasswordPrompt = PasswordPrompt; /***/ }), /* 12 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFAttachmentViewer = void 0; var _pdfjsLib = __webpack_require__(5); var _base_tree_viewer = __webpack_require__(13); var _event_utils = __webpack_require__(6); class PDFAttachmentViewer extends _base_tree_viewer.BaseTreeViewer { constructor(options) { super(options); this.downloadManager = options.downloadManager; this.eventBus._on(\"fileattachmentannotation\", this.#appendAttachment.bind(this)); } reset(keepRenderedCapability = false) { super.reset(); this._attachments = null; if (!keepRenderedCapability) { this._renderedCapability = (0, _pdfjsLib.createPromiseCapability)(); } this._pendingDispatchEvent = false; } async _dispatchEvent(attachmentsCount) { this._renderedCapability.resolve(); if (attachmentsCount === 0 && !this._pendingDispatchEvent) { this._pendingDispatchEvent = true; await (0, _event_utils.waitOnEventOrTimeout)({ target: this.eventBus, name: \"annotationlayerrendered\", delay: 1000 }); if (!this._pendingDispatchEvent) { return; } } this._pendingDispatchEvent = false; this.eventBus.dispatch(\"attachmentsloaded\", { source: this, attachmentsCount }); } _bindLink(element, { content, filename }) { element.onclick = () => { this.downloadManager.openOrDownloadData(element, content, filename); return false; }; } render({ attachments, keepRenderedCapability = false }) { if (this._attachments) { this.reset(keepRenderedCapability); } this._attachments = attachments || null; if (!attachments) { this._dispatchEvent(0); return; } const names = Object.keys(attachments).sort(function (a, b) { return a.toLowerCase().localeCompare(b.toLowerCase()); }); const fragment = document.createDocumentFragment(); let attachmentsCount = 0; for (const name of names) { const item = attachments[name]; const content = item.content, filename = (0, _pdfjsLib.getFilenameFromUrl)(item.filename, true); const div = document.createElement(\"div\"); div.className = \"treeItem\"; const element = document.createElement(\"a\"); this._bindLink(element, { content, filename }); element.textContent = this._normalizeTextContent(filename); div.append(element); fragment.append(div); attachmentsCount++; } this._finishRendering(fragment, attachmentsCount); } #appendAttachment({ filename, content }) { const renderedPromise = this._renderedCapability.promise; renderedPromise.then(() => { if (renderedPromise !== this._renderedCapability.promise) { return; } const attachments = this._attachments || Object.create(null); for (const name in attachments) { if (filename === name) { return; } } attachments[filename] = { filename, content }; this.render({ attachments, keepRenderedCapability: true }); }); } } exports.PDFAttachmentViewer = PDFAttachmentViewer; /***/ }), /* 13 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.BaseTreeViewer = void 0; var _ui_utils = __webpack_require__(1); const TREEITEM_OFFSET_TOP = -100; const TREEITEM_SELECTED_CLASS = \"selected\"; class BaseTreeViewer { constructor(options) { if (this.constructor === BaseTreeViewer) { throw new Error(\"Cannot initialize BaseTreeViewer.\"); } this.container = options.container; this.eventBus = options.eventBus; this.reset(); } reset() { this._pdfDocument = null; this._lastToggleIsShow = true; this._currentTreeItem = null; this.container.textContent = \"\"; this.container.classList.remove(\"treeWithDeepNesting\"); } _dispatchEvent(count) { throw new Error(\"Not implemented: _dispatchEvent\"); } _bindLink(element, params) { throw new Error(\"Not implemented: _bindLink\"); } _normalizeTextContent(str) { return (0, _ui_utils.removeNullCharacters)(str, true) || \"\\u2013\"; } _addToggleButton(div, hidden = false) { const toggler = document.createElement(\"div\"); toggler.className = \"treeItemToggler\"; if (hidden) { toggler.classList.add(\"treeItemsHidden\"); } toggler.onclick = evt => { evt.stopPropagation(); toggler.classList.toggle(\"treeItemsHidden\"); if (evt.shiftKey) { const shouldShowAll = !toggler.classList.contains(\"treeItemsHidden\"); this._toggleTreeItem(div, shouldShowAll); } }; div.prepend(toggler); } _toggleTreeItem(root, show = false) { this._lastToggleIsShow = show; for (const toggler of root.querySelectorAll(\".treeItemToggler\")) { toggler.classList.toggle(\"treeItemsHidden\", !show); } } _toggleAllTreeItems() { this._toggleTreeItem(this.container, !this._lastToggleIsShow); } _finishRendering(fragment, count, hasAnyNesting = false) { if (hasAnyNesting) { this.container.classList.add(\"treeWithDeepNesting\"); this._lastToggleIsShow = !fragment.querySelector(\".treeItemsHidden\"); } this.container.append(fragment); this._dispatchEvent(count); } render(params) { throw new Error(\"Not implemented: render\"); } _updateCurrentTreeItem(treeItem = null) { if (this._currentTreeItem) { this._currentTreeItem.classList.remove(TREEITEM_SELECTED_CLASS); this._currentTreeItem = null; } if (treeItem) { treeItem.classList.add(TREEITEM_SELECTED_CLASS); this._currentTreeItem = treeItem; } } _scrollToCurrentTreeItem(treeItem) { if (!treeItem) { return; } let currentNode = treeItem.parentNode; while (currentNode && currentNode !== this.container) { if (currentNode.classList.contains(\"treeItem\")) { const toggler = currentNode.firstElementChild; toggler?.classList.remove(\"treeItemsHidden\"); } currentNode = currentNode.parentNode; } this._updateCurrentTreeItem(treeItem); this.container.scrollTo(treeItem.offsetLeft, treeItem.offsetTop + TREEITEM_OFFSET_TOP); } } exports.BaseTreeViewer = BaseTreeViewer; /***/ }), /* 14 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFDocumentProperties = void 0; var _pdfjsLib = __webpack_require__(5); var _ui_utils = __webpack_require__(1); const DEFAULT_FIELD_CONTENT = \"-\"; const NON_METRIC_LOCALES = [\"en-us\", \"en-lr\", \"my\"]; const US_PAGE_NAMES = { \"8.5x11\": \"Letter\", \"8.5x14\": \"Legal\" }; const METRIC_PAGE_NAMES = { \"297x420\": \"A3\", \"210x297\": \"A4\" }; function getPageName(size, isPortrait, pageNames) { const width = isPortrait ? size.width : size.height; const height = isPortrait ? size.height : size.width; return pageNames[`${width}x${height}`]; } class PDFDocumentProperties { #fieldData = null; constructor({ dialog, fields, closeButton }, overlayManager, eventBus, l10n, fileNameLookup) { this.dialog = dialog; this.fields = fields; this.overlayManager = overlayManager; this.l10n = l10n; this._fileNameLookup = fileNameLookup; this.#reset(); closeButton.addEventListener(\"click\", this.close.bind(this)); this.overlayManager.register(this.dialog); eventBus._on(\"pagechanging\", evt => { this._currentPageNumber = evt.pageNumber; }); eventBus._on(\"rotationchanging\", evt => { this._pagesRotation = evt.pagesRotation; }); this._isNonMetricLocale = true; l10n.getLanguage().then(locale => { this._isNonMetricLocale = NON_METRIC_LOCALES.includes(locale); }); } async open() { await Promise.all([this.overlayManager.open(this.dialog), this._dataAvailableCapability.promise]); const currentPageNumber = this._currentPageNumber; const pagesRotation = this._pagesRotation; if (this.#fieldData && currentPageNumber === this.#fieldData._currentPageNumber && pagesRotation === this.#fieldData._pagesRotation) { this.#updateUI(); return; } const { info, contentLength } = await this.pdfDocument.getMetadata(); const [fileName, fileSize, creationDate, modificationDate, pageSize, isLinearized] = await Promise.all([this._fileNameLookup(), this.#parseFileSize(contentLength), this.#parseDate(info.CreationDate), this.#parseDate(info.ModDate), this.pdfDocument.getPage(currentPageNumber).then(pdfPage => { return this.#parsePageSize((0, _ui_utils.getPageSizeInches)(pdfPage), pagesRotation); }), this.#parseLinearization(info.IsLinearized)]); this.#fieldData = Object.freeze({ fileName, fileSize, title: info.Title, author: info.Author, subject: info.Subject, keywords: info.Keywords, creationDate, modificationDate, creator: info.Creator, producer: info.Producer, version: info.PDFFormatVersion, pageCount: this.pdfDocument.numPages, pageSize, linearized: isLinearized, _currentPageNumber: currentPageNumber, _pagesRotation: pagesRotation }); this.#updateUI(); const { length } = await this.pdfDocument.getDownloadInfo(); if (contentLength === length) { return; } const data = Object.assign(Object.create(null), this.#fieldData); data.fileSize = await this.#parseFileSize(length); this.#fieldData = Object.freeze(data); this.#updateUI(); } async close() { this.overlayManager.close(this.dialog); } setDocument(pdfDocument) { if (this.pdfDocument) { this.#reset(); this.#updateUI(true); } if (!pdfDocument) { return; } this.pdfDocument = pdfDocument; this._dataAvailableCapability.resolve(); } #reset() { this.pdfDocument = null; this.#fieldData = null; this._dataAvailableCapability = (0, _pdfjsLib.createPromiseCapability)(); this._currentPageNumber = 1; this._pagesRotation = 0; } #updateUI(reset = false) { if (reset || !this.#fieldData) { for (const id in this.fields) { this.fields[id].textContent = DEFAULT_FIELD_CONTENT; } return; } if (this.overlayManager.active !== this.dialog) { return; } for (const id in this.fields) { const content = this.#fieldData[id]; this.fields[id].textContent = content || content === 0 ? content : DEFAULT_FIELD_CONTENT; } } async #parseFileSize(fileSize = 0) { const kb = fileSize / 1024, mb = kb / 1024; if (!kb) { return undefined; } return this.l10n.get(`document_properties_${mb >= 1 ? \"mb\" : \"kb\"}`, { size_mb: mb >= 1 && (+mb.toPrecision(3)).toLocaleString(), size_kb: mb < 1 && (+kb.toPrecision(3)).toLocaleString(), size_b: fileSize.toLocaleString() }); } async #parsePageSize(pageSizeInches, pagesRotation) { if (!pageSizeInches) { return undefined; } if (pagesRotation % 180 !== 0) { pageSizeInches = { width: pageSizeInches.height, height: pageSizeInches.width }; } const isPortrait = (0, _ui_utils.isPortraitOrientation)(pageSizeInches); let sizeInches = { width: Math.round(pageSizeInches.width * 100) / 100, height: Math.round(pageSizeInches.height * 100) / 100 }; let sizeMillimeters = { width: Math.round(pageSizeInches.width * 25.4 * 10) / 10, height: Math.round(pageSizeInches.height * 25.4 * 10) / 10 }; let rawName = getPageName(sizeInches, isPortrait, US_PAGE_NAMES) || getPageName(sizeMillimeters, isPortrait, METRIC_PAGE_NAMES); if (!rawName && !(Number.isInteger(sizeMillimeters.width) && Number.isInteger(sizeMillimeters.height))) { const exactMillimeters = { width: pageSizeInches.width * 25.4, height: pageSizeInches.height * 25.4 }; const intMillimeters = { width: Math.round(sizeMillimeters.width), height: Math.round(sizeMillimeters.height) }; if (Math.abs(exactMillimeters.width - intMillimeters.width) < 0.1 && Math.abs(exactMillimeters.height - intMillimeters.height) < 0.1) { rawName = getPageName(intMillimeters, isPortrait, METRIC_PAGE_NAMES); if (rawName) { sizeInches = { width: Math.round(intMillimeters.width / 25.4 * 100) / 100, height: Math.round(intMillimeters.height / 25.4 * 100) / 100 }; sizeMillimeters = intMillimeters; } } } const [{ width, height }, unit, name, orientation] = await Promise.all([this._isNonMetricLocale ? sizeInches : sizeMillimeters, this.l10n.get(`document_properties_page_size_unit_${this._isNonMetricLocale ? \"inches\" : \"millimeters\"}`), rawName && this.l10n.get(`document_properties_page_size_name_${rawName.toLowerCase()}`), this.l10n.get(`document_properties_page_size_orientation_${isPortrait ? \"portrait\" : \"landscape\"}`)]); return this.l10n.get(`document_properties_page_size_dimension_${name ? \"name_\" : \"\"}string`, { width: width.toLocaleString(), height: height.toLocaleString(), unit, name, orientation }); } async #parseDate(inputDate) { const dateObject = _pdfjsLib.PDFDateString.toDateObject(inputDate); if (!dateObject) { return undefined; } return this.l10n.get(\"document_properties_date_string\", { date: dateObject.toLocaleDateString(), time: dateObject.toLocaleTimeString() }); } #parseLinearization(isLinearized) { return this.l10n.get(`document_properties_linearized_${isLinearized ? \"yes\" : \"no\"}`); } } exports.PDFDocumentProperties = PDFDocumentProperties; /***/ }), /* 15 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFFindBar = void 0; var _pdf_find_controller = __webpack_require__(16); const MATCHES_COUNT_LIMIT = 1000; class PDFFindBar { constructor(options, eventBus, l10n) { this.opened = false; this.bar = options.bar; this.toggleButton = options.toggleButton; this.findField = options.findField; this.highlightAll = options.highlightAllCheckbox; this.caseSensitive = options.caseSensitiveCheckbox; this.matchDiacritics = options.matchDiacriticsCheckbox; this.entireWord = options.entireWordCheckbox; this.findMsg = options.findMsg; this.findResultsCount = options.findResultsCount; this.findPreviousButton = options.findPreviousButton; this.findNextButton = options.findNextButton; this.eventBus = eventBus; this.l10n = l10n; this.toggleButton.addEventListener(\"click\", () => { this.toggle(); }); this.findField.addEventListener(\"input\", () => { this.dispatchEvent(\"\"); }); this.bar.addEventListener(\"keydown\", e => { switch (e.keyCode) { case 13: if (e.target === this.findField) { this.dispatchEvent(\"again\", e.shiftKey); } break; case 27: this.close(); break; } }); this.findPreviousButton.addEventListener(\"click\", () => { this.dispatchEvent(\"again\", true); }); this.findNextButton.addEventListener(\"click\", () => { this.dispatchEvent(\"again\", false); }); this.highlightAll.addEventListener(\"click\", () => { this.dispatchEvent(\"highlightallchange\"); }); this.caseSensitive.addEventListener(\"click\", () => { this.dispatchEvent(\"casesensitivitychange\"); }); this.entireWord.addEventListener(\"click\", () => { this.dispatchEvent(\"entirewordchange\"); }); this.matchDiacritics.addEventListener(\"click\", () => { this.dispatchEvent(\"diacriticmatchingchange\"); }); this.eventBus._on(\"resize\", this.#adjustWidth.bind(this)); } reset() { this.updateUIState(); } dispatchEvent(type, findPrev = false) { this.eventBus.dispatch(\"find\", { source: this, type, query: this.findField.value, phraseSearch: true, caseSensitive: this.caseSensitive.checked, entireWord: this.entireWord.checked, highlightAll: this.highlightAll.checked, findPrevious: findPrev, matchDiacritics: this.matchDiacritics.checked }); } updateUIState(state, previous, matchesCount) { let findMsg = Promise.resolve(\"\"); let status = \"\"; switch (state) { case _pdf_find_controller.FindState.FOUND: break; case _pdf_find_controller.FindState.PENDING: status = \"pending\"; break; case _pdf_find_controller.FindState.NOT_FOUND: findMsg = this.l10n.get(\"find_not_found\"); status = \"notFound\"; break; case _pdf_find_controller.FindState.WRAPPED: findMsg = this.l10n.get(`find_reached_${previous ? \"top\" : \"bottom\"}`); break; } this.findField.setAttribute(\"data-status\", status); this.findField.setAttribute(\"aria-invalid\", state === _pdf_find_controller.FindState.NOT_FOUND); findMsg.then(msg => { this.findMsg.textContent = msg; this.#adjustWidth(); }); this.updateResultsCount(matchesCount); } updateResultsCount({ current = 0, total = 0 } = {}) { const limit = MATCHES_COUNT_LIMIT; let matchCountMsg = Promise.resolve(\"\"); if (total > 0) { if (total > limit) { let key = \"find_match_count_limit\"; matchCountMsg = this.l10n.get(key, { limit }); } else { let key = \"find_match_count\"; matchCountMsg = this.l10n.get(key, { current, total }); } } matchCountMsg.then(msg => { this.findResultsCount.textContent = msg; this.#adjustWidth(); }); } open() { if (!this.opened) { this.opened = true; this.toggleButton.classList.add(\"toggled\"); this.toggleButton.setAttribute(\"aria-expanded\", \"true\"); this.bar.classList.remove(\"hidden\"); } this.findField.select(); this.findField.focus(); this.#adjustWidth(); } close() { if (!this.opened) { return; } this.opened = false; this.toggleButton.classList.remove(\"toggled\"); this.toggleButton.setAttribute(\"aria-expanded\", \"false\"); this.bar.classList.add(\"hidden\"); this.eventBus.dispatch(\"findbarclose\", { source: this }); } toggle() { if (this.opened) { this.close(); } else { this.open(); } } #adjustWidth() { if (!this.opened) { return; } this.bar.classList.remove(\"wrapContainers\"); const findbarHeight = this.bar.clientHeight; const inputContainerHeight = this.bar.firstElementChild.clientHeight; if (findbarHeight > inputContainerHeight) { this.bar.classList.add(\"wrapContainers\"); } } } exports.PDFFindBar = PDFFindBar; /***/ }), /* 16 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFFindController = exports.FindState = void 0; var _ui_utils = __webpack_require__(1); var _pdfjsLib = __webpack_require__(5); var _pdf_find_utils = __webpack_require__(17); const FindState = { FOUND: 0, NOT_FOUND: 1, WRAPPED: 2, PENDING: 3 }; exports.FindState = FindState; const FIND_TIMEOUT = 250; const MATCH_SCROLL_OFFSET_TOP = -50; const MATCH_SCROLL_OFFSET_LEFT = -400; const CHARACTERS_TO_NORMALIZE = { \"\\u2010\": \"-\", \"\\u2018\": \"'\", \"\\u2019\": \"'\", \"\\u201A\": \"'\", \"\\u201B\": \"'\", \"\\u201C\": '\"', \"\\u201D\": '\"', \"\\u201E\": '\"', \"\\u201F\": '\"', \"\\u00BC\": \"1/4\", \"\\u00BD\": \"1/2\", \"\\u00BE\": \"3/4\" }; const DIACRITICS_EXCEPTION = new Set([0x3099, 0x309a, 0x094d, 0x09cd, 0x0a4d, 0x0acd, 0x0b4d, 0x0bcd, 0x0c4d, 0x0ccd, 0x0d3b, 0x0d3c, 0x0d4d, 0x0dca, 0x0e3a, 0x0eba, 0x0f84, 0x1039, 0x103a, 0x1714, 0x1734, 0x17d2, 0x1a60, 0x1b44, 0x1baa, 0x1bab, 0x1bf2, 0x1bf3, 0x2d7f, 0xa806, 0xa82c, 0xa8c4, 0xa953, 0xa9c0, 0xaaf6, 0xabed, 0x0c56, 0x0f71, 0x0f72, 0x0f7a, 0x0f7b, 0x0f7c, 0x0f7d, 0x0f80, 0x0f74]); let DIACRITICS_EXCEPTION_STR; const DIACRITICS_REG_EXP = /\\p{M}+/gu; const SPECIAL_CHARS_REG_EXP = /([.*+?^${}()|[\\]\\\\])|(\\p{P})|(\\s+)|(\\p{M})|(\\p{L})/gu; const NOT_DIACRITIC_FROM_END_REG_EXP = /([^\\p{M}])\\p{M}*$/u; const NOT_DIACRITIC_FROM_START_REG_EXP = /^\\p{M}*([^\\p{M}])/u; const SYLLABLES_REG_EXP = /[\\uAC00-\\uD7AF\\uFA6C\\uFACF-\\uFAD1\\uFAD5-\\uFAD7]+/g; const SYLLABLES_LENGTHS = new Map(); const FIRST_CHAR_SYLLABLES_REG_EXP = \"[\\\\u1100-\\\\u1112\\\\ud7a4-\\\\ud7af\\\\ud84a\\\\ud84c\\\\ud850\\\\ud854\\\\ud857\\\\ud85f]\"; const NFKC_CHARS_TO_NORMALIZE = new Map(); let noSyllablesRegExp = null; let withSyllablesRegExp = null; function normalize(text) { const syllablePositions = []; let m; while ((m = SYLLABLES_REG_EXP.exec(text)) !== null) { let { index } = m; for (const char of m[0]) { let len = SYLLABLES_LENGTHS.get(char); if (!len) { len = char.normalize(\"NFD\").length; SYLLABLES_LENGTHS.set(char, len); } syllablePositions.push([len, index++]); } } let normalizationRegex; if (syllablePositions.length === 0 && noSyllablesRegExp) { normalizationRegex = noSyllablesRegExp; } else if (syllablePositions.length > 0 && withSyllablesRegExp) { normalizationRegex = withSyllablesRegExp; } else { const replace = Object.keys(CHARACTERS_TO_NORMALIZE).join(\"\"); const toNormalizeWithNFKC = \"\\u2460-\\u2473\" + \"\\u24b6-\\u24ff\" + \"\\u3244-\\u32bf\" + \"\\u32d0-\\u32fe\" + \"\\uff00-\\uffef\"; const CJK = \"(?:\\\\p{Ideographic}|[\\u3040-\\u30FF])\"; const regexp = `([${replace}])|([${toNormalizeWithNFKC}])|(\\\\p{M}+(?:-\\\\n)?)|(\\\\S-\\\\n)|(${CJK}\\\\n)|(\\\\n)`; if (syllablePositions.length === 0) { normalizationRegex = noSyllablesRegExp = new RegExp(regexp + \"|(\\\\u0000)\", \"gum\"); } else { normalizationRegex = withSyllablesRegExp = new RegExp(regexp + `|(${FIRST_CHAR_SYLLABLES_REG_EXP})`, \"gum\"); } } const rawDiacriticsPositions = []; while ((m = DIACRITICS_REG_EXP.exec(text)) !== null) { rawDiacriticsPositions.push([m[0].length, m.index]); } let normalized = text.normalize(\"NFD\"); const positions = [[0, 0]]; let rawDiacriticsIndex = 0; let syllableIndex = 0; let shift = 0; let shiftOrigin = 0; let eol = 0; let hasDiacritics = false; normalized = normalized.replace(normalizationRegex, (match, p1, p2, p3, p4, p5, p6, p7, i) => { i -= shiftOrigin; if (p1) { const replacement = CHARACTERS_TO_NORMALIZE[p1]; const jj = replacement.length; for (let j = 1; j < jj; j++) { positions.push([i - shift + j, shift - j]); } shift -= jj - 1; return replacement; } if (p2) { let replacement = NFKC_CHARS_TO_NORMALIZE.get(p2); if (!replacement) { replacement = p2.normalize(\"NFKC\"); NFKC_CHARS_TO_NORMALIZE.set(p2, replacement); } const jj = replacement.length; for (let j = 1; j < jj; j++) { positions.push([i - shift + j, shift - j]); } shift -= jj - 1; return replacement; } if (p3) { const hasTrailingDashEOL = p3.endsWith(\"\\n\"); const len = hasTrailingDashEOL ? p3.length - 2 : p3.length; hasDiacritics = true; let jj = len; if (i + eol === rawDiacriticsPositions[rawDiacriticsIndex]?.[1]) { jj -= rawDiacriticsPositions[rawDiacriticsIndex][0]; ++rawDiacriticsIndex; } for (let j = 1; j = start); if (diffs[i][0] > start) { --i; } let j = (0, _ui_utils.binarySearchFirstItem)(diffs, x => x[0] >= end, i); if (diffs[j][0] > end) { --j; } return [start + diffs[i][1], len + diffs[j][1] - diffs[i][1]]; } class PDFFindController { constructor({ linkService, eventBus }) { this._linkService = linkService; this._eventBus = eventBus; this.#reset(); eventBus._on(\"find\", this.#onFind.bind(this)); eventBus._on(\"findbarclose\", this.#onFindBarClose.bind(this)); } get highlightMatches() { return this._highlightMatches; } get pageMatches() { return this._pageMatches; } get pageMatchesLength() { return this._pageMatchesLength; } get selected() { return this._selected; } get state() { return this._state; } setDocument(pdfDocument) { if (this._pdfDocument) { this.#reset(); } if (!pdfDocument) { return; } this._pdfDocument = pdfDocument; this._firstPageCapability.resolve(); } #onFind(state) { if (!state) { return; } const pdfDocument = this._pdfDocument; const { type } = state; if (this._state === null || this.#shouldDirtyMatch(state)) { this._dirtyMatch = true; } this._state = state; if (type !== \"highlightallchange\") { this.#updateUIState(FindState.PENDING); } this._firstPageCapability.promise.then(() => { if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) { return; } this.#extractText(); const findbarClosed = !this._highlightMatches; const pendingTimeout = !!this._findTimeout; if (this._findTimeout) { clearTimeout(this._findTimeout); this._findTimeout = null; } if (!type) { this._findTimeout = setTimeout(() => { this.#nextMatch(); this._findTimeout = null; }, FIND_TIMEOUT); } else if (this._dirtyMatch) { this.#nextMatch(); } else if (type === \"again\") { this.#nextMatch(); if (findbarClosed && this._state.highlightAll) { this.#updateAllPages(); } } else if (type === \"highlightallchange\") { if (pendingTimeout) { this.#nextMatch(); } else { this._highlightMatches = true; } this.#updateAllPages(); } else { this.#nextMatch(); } }); } scrollMatchIntoView({ element = null, selectedLeft = 0, pageIndex = -1, matchIndex = -1 }) { if (!this._scrollMatches || !element) { return; } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) { return; } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) { return; } this._scrollMatches = false; const spot = { top: MATCH_SCROLL_OFFSET_TOP, left: selectedLeft + MATCH_SCROLL_OFFSET_LEFT }; (0, _ui_utils.scrollIntoView)(element, spot, true); } #reset() { this._highlightMatches = false; this._scrollMatches = false; this._pdfDocument = null; this._pageMatches = []; this._pageMatchesLength = []; this._state = null; this._selected = { pageIdx: -1, matchIdx: -1 }; this._offset = { pageIdx: null, matchIdx: null, wrapped: false }; this._extractTextPromises = []; this._pageContents = []; this._pageDiffs = []; this._hasDiacritics = []; this._matchesCountTotal = 0; this._pagesToSearch = null; this._pendingFindMatches = new Set(); this._resumePageIdx = null; this._dirtyMatch = false; clearTimeout(this._findTimeout); this._findTimeout = null; this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)(); } get #query() { if (this._state.query !== this._rawQuery) { this._rawQuery = this._state.query; [this._normalizedQuery] = normalize(this._state.query); } return this._normalizedQuery; } #shouldDirtyMatch(state) { if (state.query !== this._state.query) { return true; } switch (state.type) { case \"again\": const pageNumber = this._selected.pageIdx + 1; const linkService = this._linkService; if (pageNumber >= 1 && pageNumber { if (p1) { return `[ ]*\\\\${p1}[ ]*`; } if (p2) { return `[ ]*${p2}[ ]*`; } if (p3) { return \"[ ]+\"; } if (matchDiacritics) { return p4 || p5; } if (p4) { return DIACRITICS_EXCEPTION.has(p4.charCodeAt(0)) ? p4 : \"\"; } if (hasDiacritics) { isUnicode = true; return `${p5}\\\\p{M}*`; } return p5; }); const trailingSpaces = \"[ ]*\"; if (query.endsWith(trailingSpaces)) { query = query.slice(0, query.length - trailingSpaces.length); } if (matchDiacritics) { if (hasDiacritics) { DIACRITICS_EXCEPTION_STR ||= String.fromCharCode(...DIACRITICS_EXCEPTION); isUnicode = true; query = `${query}(?=[${DIACRITICS_EXCEPTION_STR}]|[^\\\\p{M}]|$)`; } } return [isUnicode, query]; } #calculateMatch(pageIndex) { let query = this.#query; if (query.length === 0) { return; } const { caseSensitive, entireWord, phraseSearch } = this._state; const pageContent = this._pageContents[pageIndex]; const hasDiacritics = this._hasDiacritics[pageIndex]; let isUnicode = false; if (phraseSearch) { [isUnicode, query] = this.#convertToRegExpString(query, hasDiacritics); } else { const match = query.match(/\\S+/g); if (match) { query = match.sort().reverse().map(q => { const [isUnicodePart, queryPart] = this.#convertToRegExpString(q, hasDiacritics); isUnicode ||= isUnicodePart; return `(${queryPart})`; }).join(\"|\"); } } const flags = `g${isUnicode ? \"u\" : \"\"}${caseSensitive ? \"\" : \"i\"}`; query = new RegExp(query, flags); this.#calculateRegExpMatch(query, entireWord, pageIndex, pageContent); if (this._state.highlightAll) { this.#updatePage(pageIndex); } if (this._resumePageIdx === pageIndex) { this._resumePageIdx = null; this.#nextPageMatch(); } const pageMatchesCount = this._pageMatches[pageIndex].length; if (pageMatchesCount > 0) { this._matchesCountTotal += pageMatchesCount; this.#updateUIResultsCount(); } } #extractText() { if (this._extractTextPromises.length > 0) { return; } let promise = Promise.resolve(); for (let i = 0, ii = this._linkService.pagesCount; i < ii; i++) { const extractTextCapability = (0, _pdfjsLib.createPromiseCapability)(); this._extractTextPromises[i] = extractTextCapability.promise; promise = promise.then(() => { return this._pdfDocument.getPage(i + 1).then(pdfPage => { return pdfPage.getTextContent(); }).then(textContent => { const strBuf = []; for (const textItem of textContent.items) { strBuf.push(textItem.str); if (textItem.hasEOL) { strBuf.push(\"\\n\"); } } [this._pageContents[i], this._pageDiffs[i], this._hasDiacritics[i]] = normalize(strBuf.join(\"\")); extractTextCapability.resolve(); }, reason => { console.error(`Unable to get text content for page ${i + 1}`, reason); this._pageContents[i] = \"\"; this._pageDiffs[i] = null; this._hasDiacritics[i] = false; extractTextCapability.resolve(); }); }); } } #updatePage(index) { if (this._scrollMatches && this._selected.pageIdx === index) { this._linkService.page = index + 1; } this._eventBus.dispatch(\"updatetextlayermatches\", { source: this, pageIndex: index }); } #updateAllPages() { this._eventBus.dispatch(\"updatetextlayermatches\", { source: this, pageIndex: -1 }); } #nextMatch() { const previous = this._state.findPrevious; const currentPageIndex = this._linkService.page - 1; const numPages = this._linkService.pagesCount; this._highlightMatches = true; if (this._dirtyMatch) { this._dirtyMatch = false; this._selected.pageIdx = this._selected.matchIdx = -1; this._offset.pageIdx = currentPageIndex; this._offset.matchIdx = null; this._offset.wrapped = false; this._resumePageIdx = null; this._pageMatches.length = 0; this._pageMatchesLength.length = 0; this._matchesCountTotal = 0; this.#updateAllPages(); for (let i = 0; i < numPages; i++) { if (this._pendingFindMatches.has(i)) { continue; } this._pendingFindMatches.add(i); this._extractTextPromises[i].then(() => { this._pendingFindMatches.delete(i); this.#calculateMatch(i); }); } } if (this.#query === \"\") { this.#updateUIState(FindState.FOUND); return; } if (this._resumePageIdx) { return; } const offset = this._offset; this._pagesToSearch = numPages; if (offset.matchIdx !== null) { const numPageMatches = this._pageMatches[offset.pageIdx].length; if (!previous && offset.matchIdx + 1 < numPageMatches || previous && offset.matchIdx > 0) { offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1; this.#updateMatch(true); return; } this.#advanceOffsetPage(previous); } this.#nextPageMatch(); } #matchesReady(matches) { const offset = this._offset; const numMatches = matches.length; const previous = this._state.findPrevious; if (numMatches) { offset.matchIdx = previous ? numMatches - 1 : 0; this.#updateMatch(true); return true; } this.#advanceOffsetPage(previous); if (offset.wrapped) { offset.matchIdx = null; if (this._pagesToSearch < 0) { this.#updateMatch(false); return true; } } return false; } #nextPageMatch() { if (this._resumePageIdx !== null) { console.error(\"There can only be one pending page.\"); } let matches = null; do { const pageIdx = this._offset.pageIdx; matches = this._pageMatches[pageIdx]; if (!matches) { this._resumePageIdx = pageIdx; break; } } while (!this.#matchesReady(matches)); } #advanceOffsetPage(previous) { const offset = this._offset; const numPages = this._linkService.pagesCount; offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1; offset.matchIdx = null; this._pagesToSearch--; if (offset.pageIdx >= numPages || offset.pageIdx < 0) { offset.pageIdx = previous ? numPages - 1 : 0; offset.wrapped = true; } } #updateMatch(found = false) { let state = FindState.NOT_FOUND; const wrapped = this._offset.wrapped; this._offset.wrapped = false; if (found) { const previousPage = this._selected.pageIdx; this._selected.pageIdx = this._offset.pageIdx; this._selected.matchIdx = this._offset.matchIdx; state = wrapped ? FindState.WRAPPED : FindState.FOUND; if (previousPage !== -1 && previousPage !== this._selected.pageIdx) { this.#updatePage(previousPage); } } this.#updateUIState(state, this._state.findPrevious); if (this._selected.pageIdx !== -1) { this._scrollMatches = true; this.#updatePage(this._selected.pageIdx); } } #onFindBarClose(evt) { const pdfDocument = this._pdfDocument; this._firstPageCapability.promise.then(() => { if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) { return; } if (this._findTimeout) { clearTimeout(this._findTimeout); this._findTimeout = null; } if (this._resumePageIdx) { this._resumePageIdx = null; this._dirtyMatch = true; } this.#updateUIState(FindState.FOUND); this._highlightMatches = false; this.#updateAllPages(); }); } #requestMatchesCount() { const { pageIdx, matchIdx } = this._selected; let current = 0, total = this._matchesCountTotal; if (matchIdx !== -1) { for (let i = 0; i < pageIdx; i++) { current += this._pageMatches[i]?.length || 0; } current += matchIdx + 1; } if (current < 1 || current > total) { current = total = 0; } return { current, total }; } #updateUIResultsCount() { this._eventBus.dispatch(\"updatefindmatchescount\", { source: this, matchesCount: this.#requestMatchesCount() }); } #updateUIState(state, previous = false) { this._eventBus.dispatch(\"updatefindcontrolstate\", { source: this, state, previous, matchesCount: this.#requestMatchesCount(), rawQuery: this._state?.query ?? null }); } } exports.PDFFindController = PDFFindController; /***/ }), /* 17 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.CharacterType = void 0; exports.getCharacterType = getCharacterType; const CharacterType = { SPACE: 0, ALPHA_LETTER: 1, PUNCT: 2, HAN_LETTER: 3, KATAKANA_LETTER: 4, HIRAGANA_LETTER: 5, HALFWIDTH_KATAKANA_LETTER: 6, THAI_LETTER: 7 }; exports.CharacterType = CharacterType; function isAlphabeticalScript(charCode) { return charCode < 0x2e80; } function isAscii(charCode) { return (charCode & 0xff80) === 0; } function isAsciiAlpha(charCode) { return charCode >= 0x61 && charCode = 0x41 && charCode = 0x30 && charCode = 0x3400 && charCode = 0xf900 && charCode = 0x30a0 && charCode = 0x3040 && charCode = 0xff60 && charCode { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFHistory = void 0; exports.isDestArraysEqual = isDestArraysEqual; exports.isDestHashesEqual = isDestHashesEqual; var _ui_utils = __webpack_require__(1); var _event_utils = __webpack_require__(6); const HASH_CHANGE_TIMEOUT = 1000; const POSITION_UPDATED_THRESHOLD = 50; const UPDATE_VIEWAREA_TIMEOUT = 1000; function getCurrentHash() { return document.location.hash; } class PDFHistory { constructor({ linkService, eventBus }) { this.linkService = linkService; this.eventBus = eventBus; this._initialized = false; this._fingerprint = \"\"; this.reset(); this._boundEvents = null; this.eventBus._on(\"pagesinit\", () => { this._isPagesLoaded = false; this.eventBus._on(\"pagesloaded\", evt => { this._isPagesLoaded = !!evt.pagesCount; }, { once: true }); }); } initialize({ fingerprint, resetHistory = false, updateUrl = false }) { if (!fingerprint || typeof fingerprint !== \"string\") { console.error('PDFHistory.initialize: The \"fingerprint\" must be a non-empty string.'); return; } if (this._initialized) { this.reset(); } const reInitialized = this._fingerprint !== \"\" && this._fingerprint !== fingerprint; this._fingerprint = fingerprint; this._updateUrl = updateUrl === true; this._initialized = true; this._bindEvents(); const state = window.history.state; this._popStateInProgress = false; this._blockHashChange = 0; this._currentHash = getCurrentHash(); this._numPositionUpdates = 0; this._uid = this._maxUid = 0; this._destination = null; this._position = null; if (!this._isValidState(state, true) || resetHistory) { const { hash, page, rotation } = this._parseCurrentHash(true); if (!hash || reInitialized || resetHistory) { this._pushOrReplaceState(null, true); return; } this._pushOrReplaceState({ hash, page, rotation }, true); return; } const destination = state.destination; this._updateInternalState(destination, state.uid, true); if (destination.rotation !== undefined) { this._initialRotation = destination.rotation; } if (destination.dest) { this._initialBookmark = JSON.stringify(destination.dest); this._destination.page = null; } else if (destination.hash) { this._initialBookmark = destination.hash; } else if (destination.page) { this._initialBookmark = `page=${destination.page}`; } } reset() { if (this._initialized) { this._pageHide(); this._initialized = false; this._unbindEvents(); } if (this._updateViewareaTimeout) { clearTimeout(this._updateViewareaTimeout); this._updateViewareaTimeout = null; } this._initialBookmark = null; this._initialRotation = null; } push({ namedDest = null, explicitDest, pageNumber }) { if (!this._initialized) { return; } if (namedDest && typeof namedDest !== \"string\") { console.error(\"PDFHistory.push: \" + `\"${namedDest}\" is not a valid namedDest parameter.`); return; } else if (!Array.isArray(explicitDest)) { console.error(\"PDFHistory.push: \" + `\"${explicitDest}\" is not a valid explicitDest parameter.`); return; } else if (!this._isValidPage(pageNumber)) { if (pageNumber !== null || this._destination) { console.error(\"PDFHistory.push: \" + `\"${pageNumber}\" is not a valid pageNumber parameter.`); return; } } const hash = namedDest || JSON.stringify(explicitDest); if (!hash) { return; } let forceReplace = false; if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) { if (this._destination.page) { return; } forceReplace = true; } if (this._popStateInProgress && !forceReplace) { return; } this._pushOrReplaceState({ dest: explicitDest, hash, page: pageNumber, rotation: this.linkService.rotation }, forceReplace); if (!this._popStateInProgress) { this._popStateInProgress = true; Promise.resolve().then(() => { this._popStateInProgress = false; }); } } pushPage(pageNumber) { if (!this._initialized) { return; } if (!this._isValidPage(pageNumber)) { console.error(`PDFHistory.pushPage: \"${pageNumber}\" is not a valid page number.`); return; } if (this._destination?.page === pageNumber) { return; } if (this._popStateInProgress) { return; } this._pushOrReplaceState({ dest: null, hash: `page=${pageNumber}`, page: pageNumber, rotation: this.linkService.rotation }); if (!this._popStateInProgress) { this._popStateInProgress = true; Promise.resolve().then(() => { this._popStateInProgress = false; }); } } pushCurrentPosition() { if (!this._initialized || this._popStateInProgress) { return; } this._tryPushCurrentPosition(); } back() { if (!this._initialized || this._popStateInProgress) { return; } const state = window.history.state; if (this._isValidState(state) && state.uid > 0) { window.history.back(); } } forward() { if (!this._initialized || this._popStateInProgress) { return; } const state = window.history.state; if (this._isValidState(state) && state.uid < this._maxUid) { window.history.forward(); } } get popStateInProgress() { return this._initialized && (this._popStateInProgress || this._blockHashChange > 0); } get initialBookmark() { return this._initialized ? this._initialBookmark : null; } get initialRotation() { return this._initialized ? this._initialRotation : null; } _pushOrReplaceState(destination, forceReplace = false) { const shouldReplace = forceReplace || !this._destination; const newState = { fingerprint: this._fingerprint, uid: shouldReplace ? this._uid : this._uid + 1, destination }; this._updateInternalState(destination, newState.uid); let newUrl; if (this._updateUrl && destination?.hash) { const baseUrl = document.location.href.split(\"#\")[0]; if (!baseUrl.startsWith(\"file://\")) { newUrl = `${baseUrl}#${destination.hash}`; } } if (shouldReplace) { window.history.replaceState(newState, \"\", newUrl); } else { window.history.pushState(newState, \"\", newUrl); } } _tryPushCurrentPosition(temporary = false) { if (!this._position) { return; } let position = this._position; if (temporary) { position = Object.assign(Object.create(null), this._position); position.temporary = true; } if (!this._destination) { this._pushOrReplaceState(position); return; } if (this._destination.temporary) { this._pushOrReplaceState(position, true); return; } if (this._destination.hash === position.hash) { return; } if (!this._destination.page && (POSITION_UPDATED_THRESHOLD 0) { this._updateViewareaTimeout = setTimeout(() => { if (!this._popStateInProgress) { this._tryPushCurrentPosition(true); } this._updateViewareaTimeout = null; }, UPDATE_VIEWAREA_TIMEOUT); } } _popState({ state }) { const newHash = getCurrentHash(), hashChanged = this._currentHash !== newHash; this._currentHash = newHash; if (!state) { this._uid++; const { hash, page, rotation } = this._parseCurrentHash(); this._pushOrReplaceState({ hash, page, rotation }, true); return; } if (!this._isValidState(state)) { return; } this._popStateInProgress = true; if (hashChanged) { this._blockHashChange++; (0, _event_utils.waitOnEventOrTimeout)({ target: window, name: \"hashchange\", delay: HASH_CHANGE_TIMEOUT }).then(() => { this._blockHashChange--; }); } const destination = state.destination; this._updateInternalState(destination, state.uid, true); if ((0, _ui_utils.isValidRotation)(destination.rotation)) { this.linkService.rotation = destination.rotation; } if (destination.dest) { this.linkService.goToDestination(destination.dest); } else if (destination.hash) { this.linkService.setHash(destination.hash); } else if (destination.page) { this.linkService.page = destination.page; } Promise.resolve().then(() => { this._popStateInProgress = false; }); } _pageHide() { if (!this._destination || this._destination.temporary) { this._tryPushCurrentPosition(); } } _bindEvents() { if (this._boundEvents) { return; } this._boundEvents = { updateViewarea: this._updateViewarea.bind(this), popState: this._popState.bind(this), pageHide: this._pageHide.bind(this) }; this.eventBus._on(\"updateviewarea\", this._boundEvents.updateViewarea); window.addEventListener(\"popstate\", this._boundEvents.popState); window.addEventListener(\"pagehide\", this._boundEvents.pageHide); } _unbindEvents() { if (!this._boundEvents) { return; } this.eventBus._off(\"updateviewarea\", this._boundEvents.updateViewarea); window.removeEventListener(\"popstate\", this._boundEvents.popState); window.removeEventListener(\"pagehide\", this._boundEvents.pageHide); this._boundEvents = null; } } exports.PDFHistory = PDFHistory; function isDestHashesEqual(destHash, pushHash) { if (typeof destHash !== \"string\" || typeof pushHash !== \"string\") { return false; } if (destHash === pushHash) { return true; } const nameddest = (0, _ui_utils.parseQueryString)(destHash).get(\"nameddest\"); if (nameddest === pushHash) { return true; } return false; } function isDestArraysEqual(firstDest, secondDest) { function isEntryEqual(first, second) { if (typeof first !== typeof second) { return false; } if (Array.isArray(first) || Array.isArray(second)) { return false; } if (first !== null && typeof first === \"object\" && second !== null) { if (Object.keys(first).length !== Object.keys(second).length) { return false; } for (const key in first) { if (!isEntryEqual(first[key], second[key])) { return false; } } return true; } return first === second || Number.isNaN(first) && Number.isNaN(second); } if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) { return false; } if (firstDest.length !== secondDest.length) { return false; } for (let i = 0, ii = firstDest.length; i < ii; i++) { if (!isEntryEqual(firstDest[i], secondDest[i])) { return false; } } return true; } /***/ }), /* 19 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFLayerViewer = void 0; var _base_tree_viewer = __webpack_require__(13); class PDFLayerViewer extends _base_tree_viewer.BaseTreeViewer { constructor(options) { super(options); this.l10n = options.l10n; this.eventBus._on(\"optionalcontentconfigchanged\", evt => { this.#updateLayers(evt.promise); }); this.eventBus._on(\"resetlayers\", () => { this.#updateLayers(); }); this.eventBus._on(\"togglelayerstree\", this._toggleAllTreeItems.bind(this)); } reset() { super.reset(); this._optionalContentConfig = null; this._optionalContentHash = null; } _dispatchEvent(layersCount) { this.eventBus.dispatch(\"layersloaded\", { source: this, layersCount }); } _bindLink(element, { groupId, input }) { const setVisibility = () => { this._optionalContentConfig.setVisibility(groupId, input.checked); this._optionalContentHash = this._optionalContentConfig.getHash(); this.eventBus.dispatch(\"optionalcontentconfig\", { source: this, promise: Promise.resolve(this._optionalContentConfig) }); }; element.onclick = evt => { if (evt.target === input) { setVisibility(); return true; } else if (evt.target !== element) { return true; } input.checked = !input.checked; setVisibility(); return false; }; } async _setNestedName(element, { name = null }) { if (typeof name === \"string\") { element.textContent = this._normalizeTextContent(name); return; } element.textContent = await this.l10n.get(\"additional_layers\"); element.style.fontStyle = \"italic\"; } _addToggleButton(div, { name = null }) { super._addToggleButton(div, name === null); } _toggleAllTreeItems() { if (!this._optionalContentConfig) { return; } super._toggleAllTreeItems(); } render({ optionalContentConfig, pdfDocument }) { if (this._optionalContentConfig) { this.reset(); } this._optionalContentConfig = optionalContentConfig || null; this._pdfDocument = pdfDocument || null; const groups = optionalContentConfig?.getOrder(); if (!groups) { this._dispatchEvent(0); return; } this._optionalContentHash = optionalContentConfig.getHash(); const fragment = document.createDocumentFragment(), queue = [{ parent: fragment, groups }]; let layersCount = 0, hasAnyNesting = false; while (queue.length > 0) { const levelData = queue.shift(); for (const groupId of levelData.groups) { const div = document.createElement(\"div\"); div.className = \"treeItem\"; const element = document.createElement(\"a\"); div.append(element); if (typeof groupId === \"object\") { hasAnyNesting = true; this._addToggleButton(div, groupId); this._setNestedName(element, groupId); const itemsDiv = document.createElement(\"div\"); itemsDiv.className = \"treeItems\"; div.append(itemsDiv); queue.push({ parent: itemsDiv, groups: groupId.order }); } else { const group = optionalContentConfig.getGroup(groupId); const input = document.createElement(\"input\"); this._bindLink(element, { groupId, input }); input.type = \"checkbox\"; input.checked = group.visible; const label = document.createElement(\"label\"); label.textContent = this._normalizeTextContent(group.name); label.append(input); element.append(label); layersCount++; } levelData.parent.append(div); } } this._finishRendering(fragment, layersCount, hasAnyNesting); } async #updateLayers(promise = null) { if (!this._optionalContentConfig) { return; } const pdfDocument = this._pdfDocument; const optionalContentConfig = await (promise || pdfDocument.getOptionalContentConfig()); if (pdfDocument !== this._pdfDocument) { return; } if (promise) { if (optionalContentConfig.getHash() === this._optionalContentHash) { return; } } else { this.eventBus.dispatch(\"optionalcontentconfig\", { source: this, promise: Promise.resolve(optionalContentConfig) }); } this.render({ optionalContentConfig, pdfDocument: this._pdfDocument }); } } exports.PDFLayerViewer = PDFLayerViewer; /***/ }), /* 20 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFOutlineViewer = void 0; var _base_tree_viewer = __webpack_require__(13); var _pdfjsLib = __webpack_require__(5); var _ui_utils = __webpack_require__(1); class PDFOutlineViewer extends _base_tree_viewer.BaseTreeViewer { constructor(options) { super(options); this.linkService = options.linkService; this.downloadManager = options.downloadManager; this.eventBus._on(\"toggleoutlinetree\", this._toggleAllTreeItems.bind(this)); this.eventBus._on(\"currentoutlineitem\", this._currentOutlineItem.bind(this)); this.eventBus._on(\"pagechanging\", evt => { this._currentPageNumber = evt.pageNumber; }); this.eventBus._on(\"pagesloaded\", evt => { this._isPagesLoaded = !!evt.pagesCount; if (this._currentOutlineItemCapability && !this._currentOutlineItemCapability.settled) { this._currentOutlineItemCapability.resolve(this._isPagesLoaded); } }); this.eventBus._on(\"sidebarviewchanged\", evt => { this._sidebarView = evt.view; }); } reset() { super.reset(); this._outline = null; this._pageNumberToDestHashCapability = null; this._currentPageNumber = 1; this._isPagesLoaded = null; if (this._currentOutlineItemCapability && !this._currentOutlineItemCapability.settled) { this._currentOutlineItemCapability.resolve(false); } this._currentOutlineItemCapability = null; } _dispatchEvent(outlineCount) { this._currentOutlineItemCapability = (0, _pdfjsLib.createPromiseCapability)(); if (outlineCount === 0 || this._pdfDocument?.loadingParams.disableAutoFetch) { this._currentOutlineItemCapability.resolve(false); } else if (this._isPagesLoaded !== null) { this._currentOutlineItemCapability.resolve(this._isPagesLoaded); } this.eventBus.dispatch(\"outlineloaded\", { source: this, outlineCount, currentOutlineItemPromise: this._currentOutlineItemCapability.promise }); } _bindLink(element, { url, newWindow, action, attachment, dest, setOCGState }) { const { linkService } = this; if (url) { linkService.addLinkAttributes(element, url, newWindow); return; } if (action) { element.href = linkService.getAnchorUrl(\"\"); element.onclick = () => { linkService.executeNamedAction(action); return false; }; return; } if (attachment) { element.href = linkService.getAnchorUrl(\"\"); element.onclick = () => { this.downloadManager.openOrDownloadData(element, attachment.content, attachment.filename); return false; }; return; } if (setOCGState) { element.href = linkService.getAnchorUrl(\"\"); element.onclick = () => { linkService.executeSetOCGState(setOCGState); return false; }; return; } element.href = linkService.getDestinationHash(dest); element.onclick = evt => { this._updateCurrentTreeItem(evt.target.parentNode); if (dest) { linkService.goToDestination(dest); } return false; }; } _setStyles(element, { bold, italic }) { if (bold) { element.style.fontWeight = \"bold\"; } if (italic) { element.style.fontStyle = \"italic\"; } } _addToggleButton(div, { count, items }) { let hidden = false; if (count < 0) { let totalCount = items.length; if (totalCount > 0) { const queue = [...items]; while (queue.length > 0) { const { count: nestedCount, items: nestedItems } = queue.shift(); if (nestedCount > 0 && nestedItems.length > 0) { totalCount += nestedItems.length; queue.push(...nestedItems); } } } if (Math.abs(count) === totalCount) { hidden = true; } } super._addToggleButton(div, hidden); } _toggleAllTreeItems() { if (!this._outline) { return; } super._toggleAllTreeItems(); } render({ outline, pdfDocument }) { if (this._outline) { this.reset(); } this._outline = outline || null; this._pdfDocument = pdfDocument || null; if (!outline) { this._dispatchEvent(0); return; } const fragment = document.createDocumentFragment(); const queue = [{ parent: fragment, items: outline }]; let outlineCount = 0, hasAnyNesting = false; while (queue.length > 0) { const levelData = queue.shift(); for (const item of levelData.items) { const div = document.createElement(\"div\"); div.className = \"treeItem\"; const element = document.createElement(\"a\"); this._bindLink(element, item); this._setStyles(element, item); element.textContent = this._normalizeTextContent(item.title); div.append(element); if (item.items.length > 0) { hasAnyNesting = true; this._addToggleButton(div, item); const itemsDiv = document.createElement(\"div\"); itemsDiv.className = \"treeItems\"; div.append(itemsDiv); queue.push({ parent: itemsDiv, items: item.items }); } levelData.parent.append(div); outlineCount++; } } this._finishRendering(fragment, outlineCount, hasAnyNesting); } async _currentOutlineItem() { if (!this._isPagesLoaded) { throw new Error(\"_currentOutlineItem: All pages have not been loaded.\"); } if (!this._outline || !this._pdfDocument) { return; } const pageNumberToDestHash = await this._getPageNumberToDestHash(this._pdfDocument); if (!pageNumberToDestHash) { return; } this._updateCurrentTreeItem(null); if (this._sidebarView !== _ui_utils.SidebarView.OUTLINE) { return; } for (let i = this._currentPageNumber; i > 0; i--) { const destHash = pageNumberToDestHash.get(i); if (!destHash) { continue; } const linkElement = this.container.querySelector(`a[href=\"${destHash}\"]`); if (!linkElement) { continue; } this._scrollToCurrentTreeItem(linkElement.parentNode); break; } } async _getPageNumberToDestHash(pdfDocument) { if (this._pageNumberToDestHashCapability) { return this._pageNumberToDestHashCapability.promise; } this._pageNumberToDestHashCapability = (0, _pdfjsLib.createPromiseCapability)(); const pageNumberToDestHash = new Map(), pageNumberNesting = new Map(); const queue = [{ nesting: 0, items: this._outline }]; while (queue.length > 0) { const levelData = queue.shift(), currentNesting = levelData.nesting; for (const { dest, items } of levelData.items) { let explicitDest, pageNumber; if (typeof dest === \"string\") { explicitDest = await pdfDocument.getDestination(dest); if (pdfDocument !== this._pdfDocument) { return null; } } else { explicitDest = dest; } if (Array.isArray(explicitDest)) { const [destRef] = explicitDest; if (typeof destRef === \"object\" && destRef !== null) { pageNumber = this.linkService._cachedPageNumber(destRef); if (!pageNumber) { try { pageNumber = (await pdfDocument.getPageIndex(destRef)) + 1; if (pdfDocument !== this._pdfDocument) { return null; } this.linkService.cachePageRef(pageNumber, destRef); } catch (ex) {} } } else if (Number.isInteger(destRef)) { pageNumber = destRef + 1; } if (Number.isInteger(pageNumber) && (!pageNumberToDestHash.has(pageNumber) || currentNesting > pageNumberNesting.get(pageNumber))) { const destHash = this.linkService.getDestinationHash(dest); pageNumberToDestHash.set(pageNumber, destHash); pageNumberNesting.set(pageNumber, currentNesting); } } if (items.length > 0) { queue.push({ nesting: currentNesting + 1, items }); } } } this._pageNumberToDestHashCapability.resolve(pageNumberToDestHash.size > 0 ? pageNumberToDestHash : null); return this._pageNumberToDestHashCapability.promise; } } exports.PDFOutlineViewer = PDFOutlineViewer; /***/ }), /* 21 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFPresentationMode = void 0; var _ui_utils = __webpack_require__(1); var _pdfjsLib = __webpack_require__(5); const DELAY_BEFORE_HIDING_CONTROLS = 3000; const ACTIVE_SELECTOR = \"pdfPresentationMode\"; const CONTROLS_SELECTOR = \"pdfPresentationModeControls\"; const MOUSE_SCROLL_COOLDOWN_TIME = 50; const PAGE_SWITCH_THRESHOLD = 0.1; const SWIPE_MIN_DISTANCE_THRESHOLD = 50; const SWIPE_ANGLE_THRESHOLD = Math.PI / 6; class PDFPresentationMode { #state = _ui_utils.PresentationModeState.UNKNOWN; #args = null; constructor({ container, pdfViewer, eventBus }) { this.container = container; this.pdfViewer = pdfViewer; this.eventBus = eventBus; this.contextMenuOpen = false; this.mouseScrollTimeStamp = 0; this.mouseScrollDelta = 0; this.touchSwipeState = null; } async request() { const { container, pdfViewer } = this; if (this.active || !pdfViewer.pagesCount || !container.requestFullscreen) { return false; } this.#addFullscreenChangeListeners(); this.#notifyStateChange(_ui_utils.PresentationModeState.CHANGING); const promise = container.requestFullscreen(); this.#args = { pageNumber: pdfViewer.currentPageNumber, scaleValue: pdfViewer.currentScaleValue, scrollMode: pdfViewer.scrollMode, spreadMode: null, annotationEditorMode: null }; if (pdfViewer.spreadMode !== _ui_utils.SpreadMode.NONE && !(pdfViewer.pageViewsReady && pdfViewer.hasEqualPageSizes)) { console.warn(\"Ignoring Spread modes when entering PresentationMode, \" + \"since the document may contain varying page sizes.\"); this.#args.spreadMode = pdfViewer.spreadMode; } if (pdfViewer.annotationEditorMode !== _pdfjsLib.AnnotationEditorType.DISABLE) { this.#args.annotationEditorMode = pdfViewer.annotationEditorMode; } try { await promise; pdfViewer.focus(); return true; } catch (reason) { this.#removeFullscreenChangeListeners(); this.#notifyStateChange(_ui_utils.PresentationModeState.NORMAL); } return false; } get active() { return this.#state === _ui_utils.PresentationModeState.CHANGING || this.#state === _ui_utils.PresentationModeState.FULLSCREEN; } #mouseWheel(evt) { if (!this.active) { return; } evt.preventDefault(); const delta = (0, _ui_utils.normalizeWheelEventDelta)(evt); const currentTime = Date.now(); const storedTime = this.mouseScrollTimeStamp; if (currentTime > storedTime && currentTime - storedTime < MOUSE_SCROLL_COOLDOWN_TIME) { return; } if (this.mouseScrollDelta > 0 && delta < 0 || this.mouseScrollDelta < 0 && delta > 0) { this.#resetMouseScrollState(); } this.mouseScrollDelta += delta; if (Math.abs(this.mouseScrollDelta) >= PAGE_SWITCH_THRESHOLD) { const totalDelta = this.mouseScrollDelta; this.#resetMouseScrollState(); const success = totalDelta > 0 ? this.pdfViewer.previousPage() : this.pdfViewer.nextPage(); if (success) { this.mouseScrollTimeStamp = currentTime; } } } #notifyStateChange(state) { this.#state = state; this.eventBus.dispatch(\"presentationmodechanged\", { source: this, state }); } #enter() { this.#notifyStateChange(_ui_utils.PresentationModeState.FULLSCREEN); this.container.classList.add(ACTIVE_SELECTOR); setTimeout(() => { this.pdfViewer.scrollMode = _ui_utils.ScrollMode.PAGE; if (this.#args.spreadMode !== null) { this.pdfViewer.spreadMode = _ui_utils.SpreadMode.NONE; } this.pdfViewer.currentPageNumber = this.#args.pageNumber; this.pdfViewer.currentScaleValue = \"page-fit\"; if (this.#args.annotationEditorMode !== null) { this.pdfViewer.annotationEditorMode = _pdfjsLib.AnnotationEditorType.NONE; } }, 0); this.#addWindowListeners(); this.#showControls(); this.contextMenuOpen = false; window.getSelection().removeAllRanges(); } #exit() { const pageNumber = this.pdfViewer.currentPageNumber; this.container.classList.remove(ACTIVE_SELECTOR); setTimeout(() => { this.#removeFullscreenChangeListeners(); this.#notifyStateChange(_ui_utils.PresentationModeState.NORMAL); this.pdfViewer.scrollMode = this.#args.scrollMode; if (this.#args.spreadMode !== null) { this.pdfViewer.spreadMode = this.#args.spreadMode; } this.pdfViewer.currentScaleValue = this.#args.scaleValue; this.pdfViewer.currentPageNumber = pageNumber; if (this.#args.annotationEditorMode !== null) { this.pdfViewer.annotationEditorMode = this.#args.annotationEditorMode; } this.#args = null; }, 0); this.#removeWindowListeners(); this.#hideControls(); this.#resetMouseScrollState(); this.contextMenuOpen = false; } #mouseDown(evt) { if (this.contextMenuOpen) { this.contextMenuOpen = false; evt.preventDefault(); return; } if (evt.button !== 0) { return; } if (evt.target.href && evt.target.parentNode?.hasAttribute(\"data-internal-link\")) { return; } evt.preventDefault(); if (evt.shiftKey) { this.pdfViewer.previousPage(); } else { this.pdfViewer.nextPage(); } } #contextMenu() { this.contextMenuOpen = true; } #showControls() { if (this.controlsTimeout) { clearTimeout(this.controlsTimeout); } else { this.container.classList.add(CONTROLS_SELECTOR); } this.controlsTimeout = setTimeout(() => { this.container.classList.remove(CONTROLS_SELECTOR); delete this.controlsTimeout; }, DELAY_BEFORE_HIDING_CONTROLS); } #hideControls() { if (!this.controlsTimeout) { return; } clearTimeout(this.controlsTimeout); this.container.classList.remove(CONTROLS_SELECTOR); delete this.controlsTimeout; } #resetMouseScrollState() { this.mouseScrollTimeStamp = 0; this.mouseScrollDelta = 0; } #touchSwipe(evt) { if (!this.active) { return; } if (evt.touches.length > 1) { this.touchSwipeState = null; return; } switch (evt.type) { case \"touchstart\": this.touchSwipeState = { startX: evt.touches[0].pageX, startY: evt.touches[0].pageY, endX: evt.touches[0].pageX, endY: evt.touches[0].pageY }; break; case \"touchmove\": if (this.touchSwipeState === null) { return; } this.touchSwipeState.endX = evt.touches[0].pageX; this.touchSwipeState.endY = evt.touches[0].pageY; evt.preventDefault(); break; case \"touchend\": if (this.touchSwipeState === null) { return; } let delta = 0; const dx = this.touchSwipeState.endX - this.touchSwipeState.startX; const dy = this.touchSwipeState.endY - this.touchSwipeState.startY; const absAngle = Math.abs(Math.atan2(dy, dx)); if (Math.abs(dx) > SWIPE_MIN_DISTANCE_THRESHOLD && (absAngle = Math.PI - SWIPE_ANGLE_THRESHOLD)) { delta = dx; } else if (Math.abs(dy) > SWIPE_MIN_DISTANCE_THRESHOLD && Math.abs(absAngle - Math.PI / 2) 0) { this.pdfViewer.previousPage(); } else if (delta < 0) { this.pdfViewer.nextPage(); } break; } } #addWindowListeners() { this.showControlsBind = this.#showControls.bind(this); this.mouseDownBind = this.#mouseDown.bind(this); this.mouseWheelBind = this.#mouseWheel.bind(this); this.resetMouseScrollStateBind = this.#resetMouseScrollState.bind(this); this.contextMenuBind = this.#contextMenu.bind(this); this.touchSwipeBind = this.#touchSwipe.bind(this); window.addEventListener(\"mousemove\", this.showControlsBind); window.addEventListener(\"mousedown\", this.mouseDownBind); window.addEventListener(\"wheel\", this.mouseWheelBind, { passive: false }); window.addEventListener(\"keydown\", this.resetMouseScrollStateBind); window.addEventListener(\"contextmenu\", this.contextMenuBind); window.addEventListener(\"touchstart\", this.touchSwipeBind); window.addEventListener(\"touchmove\", this.touchSwipeBind); window.addEventListener(\"touchend\", this.touchSwipeBind); } #removeWindowListeners() { window.removeEventListener(\"mousemove\", this.showControlsBind); window.removeEventListener(\"mousedown\", this.mouseDownBind); window.removeEventListener(\"wheel\", this.mouseWheelBind, { passive: false }); window.removeEventListener(\"keydown\", this.resetMouseScrollStateBind); window.removeEventListener(\"contextmenu\", this.contextMenuBind); window.removeEventListener(\"touchstart\", this.touchSwipeBind); window.removeEventListener(\"touchmove\", this.touchSwipeBind); window.removeEventListener(\"touchend\", this.touchSwipeBind); delete this.showControlsBind; delete this.mouseDownBind; delete this.mouseWheelBind; delete this.resetMouseScrollStateBind; delete this.contextMenuBind; delete this.touchSwipeBind; } #fullscreenChange() { if (document.fullscreenElement) { this.#enter(); } else { this.#exit(); } } #addFullscreenChangeListeners() { this.fullscreenChangeBind = this.#fullscreenChange.bind(this); window.addEventListener(\"fullscreenchange\", this.fullscreenChangeBind); } #removeFullscreenChangeListeners() { window.removeEventListener(\"fullscreenchange\", this.fullscreenChangeBind); delete this.fullscreenChangeBind; } } exports.PDFPresentationMode = PDFPresentationMode; /***/ }), /* 22 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFRenderingQueue = void 0; var _pdfjsLib = __webpack_require__(5); var _ui_utils = __webpack_require__(1); const CLEANUP_TIMEOUT = 30000; class PDFRenderingQueue { constructor() { this.pdfViewer = null; this.pdfThumbnailViewer = null; this.onIdle = null; this.highestPriorityPage = null; this.idleTimeout = null; this.printing = false; this.isThumbnailViewEnabled = false; } setViewer(pdfViewer) { this.pdfViewer = pdfViewer; } setThumbnailViewer(pdfThumbnailViewer) { this.pdfThumbnailViewer = pdfThumbnailViewer; } isHighestPriority(view) { return this.highestPriorityPage === view.renderingId; } hasViewer() { return !!this.pdfViewer; } renderHighestPriority(currentlyVisiblePages) { if (this.idleTimeout) { clearTimeout(this.idleTimeout); this.idleTimeout = null; } if (this.pdfViewer.forceRendering(currentlyVisiblePages)) { return; } if (this.isThumbnailViewEnabled && this.pdfThumbnailViewer?.forceRendering()) { return; } if (this.printing) { return; } if (this.onIdle) { this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT); } } getHighestPriority(visible, views, scrolledDown, preRenderExtra = false) { const visibleViews = visible.views, numVisible = visibleViews.length; if (numVisible === 0) { return null; } for (let i = 0; i < numVisible; i++) { const view = visibleViews[i].view; if (!this.isViewFinished(view)) { return view; } } const firstId = visible.first.id, lastId = visible.last.id; if (lastId - firstId + 1 > numVisible) { const visibleIds = visible.ids; for (let i = 1, ii = lastId - firstId; i < ii; i++) { const holeId = scrolledDown ? firstId + i : lastId - i; if (visibleIds.has(holeId)) { continue; } const holeView = views[holeId - 1]; if (!this.isViewFinished(holeView)) { return holeView; } } } let preRenderIndex = scrolledDown ? lastId : firstId - 2; let preRenderView = views[preRenderIndex]; if (preRenderView && !this.isViewFinished(preRenderView)) { return preRenderView; } if (preRenderExtra) { preRenderIndex += scrolledDown ? 1 : -1; preRenderView = views[preRenderIndex]; if (preRenderView && !this.isViewFinished(preRenderView)) { return preRenderView; } } return null; } isViewFinished(view) { return view.renderingState === _ui_utils.RenderingStates.FINISHED; } renderView(view) { switch (view.renderingState) { case _ui_utils.RenderingStates.FINISHED: return false; case _ui_utils.RenderingStates.PAUSED: this.highestPriorityPage = view.renderingId; view.resume(); break; case _ui_utils.RenderingStates.RUNNING: this.highestPriorityPage = view.renderingId; break; case _ui_utils.RenderingStates.INITIAL: this.highestPriorityPage = view.renderingId; view.draw().finally(() => { this.renderHighestPriority(); }).catch(reason => { if (reason instanceof _pdfjsLib.RenderingCancelledException) { return; } console.error(`renderView: \"${reason}\"`); }); break; } return true; } } exports.PDFRenderingQueue = PDFRenderingQueue; /***/ }), /* 23 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFScriptingManager = void 0; var _ui_utils = __webpack_require__(1); var _pdfjsLib = __webpack_require__(5); class PDFScriptingManager { constructor({ eventBus, sandboxBundleSrc = null, scriptingFactory = null, docPropertiesLookup = null }) { this._pdfDocument = null; this._pdfViewer = null; this._closeCapability = null; this._destroyCapability = null; this._scripting = null; this._ready = false; this._eventBus = eventBus; this._sandboxBundleSrc = sandboxBundleSrc; this._scriptingFactory = scriptingFactory; this._docPropertiesLookup = docPropertiesLookup; } setViewer(pdfViewer) { this._pdfViewer = pdfViewer; } async setDocument(pdfDocument) { if (this._pdfDocument) { await this._destroyScripting(); } this._pdfDocument = pdfDocument; if (!pdfDocument) { return; } const [objects, calculationOrder, docActions] = await Promise.all([pdfDocument.getFieldObjects(), pdfDocument.getCalculationOrderIds(), pdfDocument.getJSActions()]); if (!objects && !docActions) { await this._destroyScripting(); return; } if (pdfDocument !== this._pdfDocument) { return; } try { this._scripting = this._createScripting(); } catch (error) { console.error(`PDFScriptingManager.setDocument: \"${error?.message}\".`); await this._destroyScripting(); return; } this._internalEvents.set(\"updatefromsandbox\", event => { if (event?.source !== window) { return; } this._updateFromSandbox(event.detail); }); this._internalEvents.set(\"dispatcheventinsandbox\", event => { this._scripting?.dispatchEventInSandbox(event.detail); }); this._internalEvents.set(\"pagechanging\", ({ pageNumber, previous }) => { if (pageNumber === previous) { return; } this._dispatchPageClose(previous); this._dispatchPageOpen(pageNumber); }); this._internalEvents.set(\"pagerendered\", ({ pageNumber }) => { if (!this._pageOpenPending.has(pageNumber)) { return; } if (pageNumber !== this._pdfViewer.currentPageNumber) { return; } this._dispatchPageOpen(pageNumber); }); this._internalEvents.set(\"pagesdestroy\", async event => { await this._dispatchPageClose(this._pdfViewer.currentPageNumber); await this._scripting?.dispatchEventInSandbox({ id: \"doc\", name: \"WillClose\" }); this._closeCapability?.resolve(); }); for (const [name, listener] of this._internalEvents) { this._eventBus._on(name, listener); } try { const docProperties = await this._getDocProperties(); if (pdfDocument !== this._pdfDocument) { return; } await this._scripting.createSandbox({ objects, calculationOrder, appInfo: { platform: navigator.platform, language: navigator.language }, docInfo: { ...docProperties, actions: docActions } }); this._eventBus.dispatch(\"sandboxcreated\", { source: this }); } catch (error) { console.error(`PDFScriptingManager.setDocument: \"${error?.message}\".`); await this._destroyScripting(); return; } await this._scripting?.dispatchEventInSandbox({ id: \"doc\", name: \"Open\" }); await this._dispatchPageOpen(this._pdfViewer.currentPageNumber, true); Promise.resolve().then(() => { if (pdfDocument === this._pdfDocument) { this._ready = true; } }); } async dispatchWillSave(detail) { return this._scripting?.dispatchEventInSandbox({ id: \"doc\", name: \"WillSave\" }); } async dispatchDidSave(detail) { return this._scripting?.dispatchEventInSandbox({ id: \"doc\", name: \"DidSave\" }); } async dispatchWillPrint(detail) { return this._scripting?.dispatchEventInSandbox({ id: \"doc\", name: \"WillPrint\" }); } async dispatchDidPrint(detail) { return this._scripting?.dispatchEventInSandbox({ id: \"doc\", name: \"DidPrint\" }); } get destroyPromise() { return this._destroyCapability?.promise || null; } get ready() { return this._ready; } get _internalEvents() { return (0, _pdfjsLib.shadow)(this, \"_internalEvents\", new Map()); } get _pageOpenPending() { return (0, _pdfjsLib.shadow)(this, \"_pageOpenPending\", new Set()); } get _visitedPages() { return (0, _pdfjsLib.shadow)(this, \"_visitedPages\", new Map()); } async _updateFromSandbox(detail) { const isInPresentationMode = this._pdfViewer.isInPresentationMode || this._pdfViewer.isChangingPresentationMode; const { id, siblings, command, value } = detail; if (!id) { switch (command) { case \"clear\": console.clear(); break; case \"error\": console.error(value); break; case \"layout\": { if (isInPresentationMode) { return; } const modes = (0, _ui_utils.apiPageLayoutToViewerModes)(value); this._pdfViewer.spreadMode = modes.spreadMode; break; } case \"page-num\": this._pdfViewer.currentPageNumber = value + 1; break; case \"print\": await this._pdfViewer.pagesPromise; this._eventBus.dispatch(\"print\", { source: this }); break; case \"println\": console.log(value); break; case \"zoom\": if (isInPresentationMode) { return; } this._pdfViewer.currentScaleValue = value; break; case \"SaveAs\": this._eventBus.dispatch(\"download\", { source: this }); break; case \"FirstPage\": this._pdfViewer.currentPageNumber = 1; break; case \"LastPage\": this._pdfViewer.currentPageNumber = this._pdfViewer.pagesCount; break; case \"NextPage\": this._pdfViewer.nextPage(); break; case \"PrevPage\": this._pdfViewer.previousPage(); break; case \"ZoomViewIn\": if (isInPresentationMode) { return; } this._pdfViewer.increaseScale(); break; case \"ZoomViewOut\": if (isInPresentationMode) { return; } this._pdfViewer.decreaseScale(); break; } return; } if (isInPresentationMode) { if (detail.focus) { return; } } delete detail.id; delete detail.siblings; const ids = siblings ? [id, ...siblings] : [id]; for (const elementId of ids) { const element = document.querySelector(`[data-element-id=\"${elementId}\"]`); if (element) { element.dispatchEvent(new CustomEvent(\"updatefromsandbox\", { detail })); } else { this._pdfDocument?.annotationStorage.setValue(elementId, detail); } } } async _dispatchPageOpen(pageNumber, initialize = false) { const pdfDocument = this._pdfDocument, visitedPages = this._visitedPages; if (initialize) { this._closeCapability = (0, _pdfjsLib.createPromiseCapability)(); } if (!this._closeCapability) { return; } const pageView = this._pdfViewer.getPageView(pageNumber - 1); if (pageView?.renderingState !== _ui_utils.RenderingStates.FINISHED) { this._pageOpenPending.add(pageNumber); return; } this._pageOpenPending.delete(pageNumber); const actionsPromise = (async () => { const actions = await (!visitedPages.has(pageNumber) ? pageView.pdfPage?.getJSActions() : null); if (pdfDocument !== this._pdfDocument) { return; } await this._scripting?.dispatchEventInSandbox({ id: \"page\", name: \"PageOpen\", pageNumber, actions }); })(); visitedPages.set(pageNumber, actionsPromise); } async _dispatchPageClose(pageNumber) { const pdfDocument = this._pdfDocument, visitedPages = this._visitedPages; if (!this._closeCapability) { return; } if (this._pageOpenPending.has(pageNumber)) { return; } const actionsPromise = visitedPages.get(pageNumber); if (!actionsPromise) { return; } visitedPages.set(pageNumber, null); await actionsPromise; if (pdfDocument !== this._pdfDocument) { return; } await this._scripting?.dispatchEventInSandbox({ id: \"page\", name: \"PageClose\", pageNumber }); } async _getDocProperties() { if (this._docPropertiesLookup) { return this._docPropertiesLookup(this._pdfDocument); } throw new Error(\"_getDocProperties: Unable to lookup properties.\"); } _createScripting() { this._destroyCapability = (0, _pdfjsLib.createPromiseCapability)(); if (this._scripting) { throw new Error(\"_createScripting: Scripting already exists.\"); } if (this._scriptingFactory) { return this._scriptingFactory.createScripting({ sandboxBundleSrc: this._sandboxBundleSrc }); } throw new Error(\"_createScripting: Cannot create scripting.\"); } async _destroyScripting() { if (!this._scripting) { this._pdfDocument = null; this._destroyCapability?.resolve(); return; } if (this._closeCapability) { await Promise.race([this._closeCapability.promise, new Promise(resolve => { setTimeout(resolve, 1000); })]).catch(reason => {}); this._closeCapability = null; } this._pdfDocument = null; try { await this._scripting.destroySandbox(); } catch (ex) {} for (const [name, listener] of this._internalEvents) { this._eventBus._off(name, listener); } this._internalEvents.clear(); this._pageOpenPending.clear(); this._visitedPages.clear(); this._scripting = null; this._ready = false; this._destroyCapability?.resolve(); } } exports.PDFScriptingManager = PDFScriptingManager; /***/ }), /* 24 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFSidebar = void 0; var _ui_utils = __webpack_require__(1); const UI_NOTIFICATION_CLASS = \"pdfSidebarNotification\"; class PDFSidebar { constructor({ elements, pdfViewer, pdfThumbnailViewer, eventBus, l10n }) { this.isOpen = false; this.active = _ui_utils.SidebarView.THUMBS; this.isInitialViewSet = false; this.isInitialEventDispatched = false; this.onToggled = null; this.pdfViewer = pdfViewer; this.pdfThumbnailViewer = pdfThumbnailViewer; this.outerContainer = elements.outerContainer; this.sidebarContainer = elements.sidebarContainer; this.toggleButton = elements.toggleButton; this.thumbnailButton = elements.thumbnailButton; this.outlineButton = elements.outlineButton; this.attachmentsButton = elements.attachmentsButton; this.layersButton = elements.layersButton; this.thumbnailView = elements.thumbnailView; this.outlineView = elements.outlineView; this.attachmentsView = elements.attachmentsView; this.layersView = elements.layersView; this._outlineOptionsContainer = elements.outlineOptionsContainer; this._currentOutlineItemButton = elements.currentOutlineItemButton; this.eventBus = eventBus; this.l10n = l10n; this.#addEventListeners(); } reset() { this.isInitialViewSet = false; this.isInitialEventDispatched = false; this.#hideUINotification(true); this.switchView(_ui_utils.SidebarView.THUMBS); this.outlineButton.disabled = false; this.attachmentsButton.disabled = false; this.layersButton.disabled = false; this._currentOutlineItemButton.disabled = true; } get visibleView() { return this.isOpen ? this.active : _ui_utils.SidebarView.NONE; } setInitialView(view = _ui_utils.SidebarView.NONE) { if (this.isInitialViewSet) { return; } this.isInitialViewSet = true; if (view === _ui_utils.SidebarView.NONE || view === _ui_utils.SidebarView.UNKNOWN) { this.#dispatchEvent(); return; } this.switchView(view, true); if (!this.isInitialEventDispatched) { this.#dispatchEvent(); } } switchView(view, forceOpen = false) { const isViewChanged = view !== this.active; let shouldForceRendering = false; switch (view) { case _ui_utils.SidebarView.NONE: if (this.isOpen) { this.close(); } return; case _ui_utils.SidebarView.THUMBS: if (this.isOpen && isViewChanged) { shouldForceRendering = true; } break; case _ui_utils.SidebarView.OUTLINE: if (this.outlineButton.disabled) { return; } break; case _ui_utils.SidebarView.ATTACHMENTS: if (this.attachmentsButton.disabled) { return; } break; case _ui_utils.SidebarView.LAYERS: if (this.layersButton.disabled) { return; } break; default: console.error(`PDFSidebar.switchView: \"${view}\" is not a valid view.`); return; } this.active = view; const isThumbs = view === _ui_utils.SidebarView.THUMBS, isOutline = view === _ui_utils.SidebarView.OUTLINE, isAttachments = view === _ui_utils.SidebarView.ATTACHMENTS, isLayers = view === _ui_utils.SidebarView.LAYERS; this.thumbnailButton.classList.toggle(\"toggled\", isThumbs); this.outlineButton.classList.toggle(\"toggled\", isOutline); this.attachmentsButton.classList.toggle(\"toggled\", isAttachments); this.layersButton.classList.toggle(\"toggled\", isLayers); this.thumbnailButton.setAttribute(\"aria-checked\", isThumbs); this.outlineButton.setAttribute(\"aria-checked\", isOutline); this.attachmentsButton.setAttribute(\"aria-checked\", isAttachments); this.layersButton.setAttribute(\"aria-checked\", isLayers); this.thumbnailView.classList.toggle(\"hidden\", !isThumbs); this.outlineView.classList.toggle(\"hidden\", !isOutline); this.attachmentsView.classList.toggle(\"hidden\", !isAttachments); this.layersView.classList.toggle(\"hidden\", !isLayers); this._outlineOptionsContainer.classList.toggle(\"hidden\", !isOutline); if (forceOpen && !this.isOpen) { this.open(); return; } if (shouldForceRendering) { this.#updateThumbnailViewer(); this.#forceRendering(); } if (isViewChanged) { this.#dispatchEvent(); } } open() { if (this.isOpen) { return; } this.isOpen = true; this.toggleButton.classList.add(\"toggled\"); this.toggleButton.setAttribute(\"aria-expanded\", \"true\"); this.outerContainer.classList.add(\"sidebarMoving\", \"sidebarOpen\"); if (this.active === _ui_utils.SidebarView.THUMBS) { this.#updateThumbnailViewer(); } this.#forceRendering(); this.#dispatchEvent(); this.#hideUINotification(); } close() { if (!this.isOpen) { return; } this.isOpen = false; this.toggleButton.classList.remove(\"toggled\"); this.toggleButton.setAttribute(\"aria-expanded\", \"false\"); this.outerContainer.classList.add(\"sidebarMoving\"); this.outerContainer.classList.remove(\"sidebarOpen\"); this.#forceRendering(); this.#dispatchEvent(); } toggle() { if (this.isOpen) { this.close(); } else { this.open(); } } #dispatchEvent() { if (this.isInitialViewSet && !this.isInitialEventDispatched) { this.isInitialEventDispatched = true; } this.eventBus.dispatch(\"sidebarviewchanged\", { source: this, view: this.visibleView }); } #forceRendering() { if (this.onToggled) { this.onToggled(); } else { this.pdfViewer.forceRendering(); this.pdfThumbnailViewer.forceRendering(); } } #updateThumbnailViewer() { const { pdfViewer, pdfThumbnailViewer } = this; const pagesCount = pdfViewer.pagesCount; for (let pageIndex = 0; pageIndex < pagesCount; pageIndex++) { const pageView = pdfViewer.getPageView(pageIndex); if (pageView?.renderingState === _ui_utils.RenderingStates.FINISHED) { const thumbnailView = pdfThumbnailViewer.getThumbnail(pageIndex); thumbnailView.setImage(pageView); } } pdfThumbnailViewer.scrollThumbnailIntoView(pdfViewer.currentPageNumber); } #showUINotification() { this.toggleButton.setAttribute(\"data-l10n-id\", \"toggle_sidebar_notification2\"); this.l10n.translate(this.toggleButton); if (!this.isOpen) { this.toggleButton.classList.add(UI_NOTIFICATION_CLASS); } } #hideUINotification(reset = false) { if (this.isOpen || reset) { this.toggleButton.classList.remove(UI_NOTIFICATION_CLASS); } if (reset) { this.toggleButton.setAttribute(\"data-l10n-id\", \"toggle_sidebar\"); this.l10n.translate(this.toggleButton); } } #addEventListeners() { this.sidebarContainer.addEventListener(\"transitionend\", evt => { if (evt.target === this.sidebarContainer) { this.outerContainer.classList.remove(\"sidebarMoving\"); } }); this.toggleButton.addEventListener(\"click\", () => { this.toggle(); }); this.thumbnailButton.addEventListener(\"click\", () => { this.switchView(_ui_utils.SidebarView.THUMBS); }); this.outlineButton.addEventListener(\"click\", () => { this.switchView(_ui_utils.SidebarView.OUTLINE); }); this.outlineButton.addEventListener(\"dblclick\", () => { this.eventBus.dispatch(\"toggleoutlinetree\", { source: this }); }); this.attachmentsButton.addEventListener(\"click\", () => { this.switchView(_ui_utils.SidebarView.ATTACHMENTS); }); this.layersButton.addEventListener(\"click\", () => { this.switchView(_ui_utils.SidebarView.LAYERS); }); this.layersButton.addEventListener(\"dblclick\", () => { this.eventBus.dispatch(\"resetlayers\", { source: this }); }); this._currentOutlineItemButton.addEventListener(\"click\", () => { this.eventBus.dispatch(\"currentoutlineitem\", { source: this }); }); const onTreeLoaded = (count, button, view) => { button.disabled = !count; if (count) { this.#showUINotification(); } else if (this.active === view) { this.switchView(_ui_utils.SidebarView.THUMBS); } }; this.eventBus._on(\"outlineloaded\", evt => { onTreeLoaded(evt.outlineCount, this.outlineButton, _ui_utils.SidebarView.OUTLINE); evt.currentOutlineItemPromise.then(enabled => { if (!this.isInitialViewSet) { return; } this._currentOutlineItemButton.disabled = !enabled; }); }); this.eventBus._on(\"attachmentsloaded\", evt => { onTreeLoaded(evt.attachmentsCount, this.attachmentsButton, _ui_utils.SidebarView.ATTACHMENTS); }); this.eventBus._on(\"layersloaded\", evt => { onTreeLoaded(evt.layersCount, this.layersButton, _ui_utils.SidebarView.LAYERS); }); this.eventBus._on(\"presentationmodechanged\", evt => { if (evt.state === _ui_utils.PresentationModeState.NORMAL && this.visibleView === _ui_utils.SidebarView.THUMBS) { this.#updateThumbnailViewer(); } }); } } exports.PDFSidebar = PDFSidebar; /***/ }), /* 25 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFSidebarResizer = void 0; var _ui_utils = __webpack_require__(1); const SIDEBAR_WIDTH_VAR = \"--sidebar-width\"; const SIDEBAR_MIN_WIDTH = 200; const SIDEBAR_RESIZING_CLASS = \"sidebarResizing\"; class PDFSidebarResizer { constructor(options, eventBus, l10n) { this.isRTL = false; this.sidebarOpen = false; this._width = null; this._outerContainerWidth = null; this._boundEvents = Object.create(null); this.outerContainer = options.outerContainer; this.resizer = options.resizer; this.eventBus = eventBus; l10n.getDirection().then(dir => { this.isRTL = dir === \"rtl\"; }); this._addEventListeners(); } get outerContainerWidth() { return this._outerContainerWidth ||= this.outerContainer.clientWidth; } _updateWidth(width = 0) { const maxWidth = Math.floor(this.outerContainerWidth / 2); if (width > maxWidth) { width = maxWidth; } if (width < SIDEBAR_MIN_WIDTH) { width = SIDEBAR_MIN_WIDTH; } if (width === this._width) { return false; } this._width = width; _ui_utils.docStyle.setProperty(SIDEBAR_WIDTH_VAR, `${width}px`); return true; } _mouseMove(evt) { let width = evt.clientX; if (this.isRTL) { width = this.outerContainerWidth - width; } this._updateWidth(width); } _mouseUp(evt) { this.outerContainer.classList.remove(SIDEBAR_RESIZING_CLASS); this.eventBus.dispatch(\"resize\", { source: this }); const _boundEvents = this._boundEvents; window.removeEventListener(\"mousemove\", _boundEvents.mouseMove); window.removeEventListener(\"mouseup\", _boundEvents.mouseUp); } _addEventListeners() { const _boundEvents = this._boundEvents; _boundEvents.mouseMove = this._mouseMove.bind(this); _boundEvents.mouseUp = this._mouseUp.bind(this); this.resizer.addEventListener(\"mousedown\", evt => { if (evt.button !== 0) { return; } this.outerContainer.classList.add(SIDEBAR_RESIZING_CLASS); window.addEventListener(\"mousemove\", _boundEvents.mouseMove); window.addEventListener(\"mouseup\", _boundEvents.mouseUp); }); this.eventBus._on(\"sidebarviewchanged\", evt => { this.sidebarOpen = !!evt?.view; }); this.eventBus._on(\"resize\", evt => { if (evt?.source !== window) { return; } this._outerContainerWidth = null; if (!this._width) { return; } if (!this.sidebarOpen) { this._updateWidth(this._width); return; } this.outerContainer.classList.add(SIDEBAR_RESIZING_CLASS); const updated = this._updateWidth(this._width); Promise.resolve().then(() => { this.outerContainer.classList.remove(SIDEBAR_RESIZING_CLASS); if (updated) { this.eventBus.dispatch(\"resize\", { source: this }); } }); }); } } exports.PDFSidebarResizer = PDFSidebarResizer; /***/ }), /* 26 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFThumbnailViewer = void 0; var _ui_utils = __webpack_require__(1); var _pdf_thumbnail_view = __webpack_require__(27); const THUMBNAIL_SCROLL_MARGIN = -19; const THUMBNAIL_SELECTED_CLASS = \"selected\"; class PDFThumbnailViewer { constructor({ container, eventBus, linkService, renderingQueue, l10n, pageColors }) { this.container = container; this.linkService = linkService; this.renderingQueue = renderingQueue; this.l10n = l10n; this.pageColors = pageColors || null; if (this.pageColors && !(CSS.supports(\"color\", this.pageColors.background) && CSS.supports(\"color\", this.pageColors.foreground))) { if (this.pageColors.background || this.pageColors.foreground) { console.warn(\"PDFThumbnailViewer: Ignoring `pageColors`-option, since the browser doesn't support the values used.\"); } this.pageColors = null; } this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdated.bind(this)); this._resetView(); } _scrollUpdated() { this.renderingQueue.renderHighestPriority(); } getThumbnail(index) { return this._thumbnails[index]; } _getVisibleThumbs() { return (0, _ui_utils.getVisibleElements)({ scrollEl: this.container, views: this._thumbnails }); } scrollThumbnailIntoView(pageNumber) { if (!this.pdfDocument) { return; } const thumbnailView = this._thumbnails[pageNumber - 1]; if (!thumbnailView) { console.error('scrollThumbnailIntoView: Invalid \"pageNumber\" parameter.'); return; } if (pageNumber !== this._currentPageNumber) { const prevThumbnailView = this._thumbnails[this._currentPageNumber - 1]; prevThumbnailView.div.classList.remove(THUMBNAIL_SELECTED_CLASS); thumbnailView.div.classList.add(THUMBNAIL_SELECTED_CLASS); } const { first, last, views } = this._getVisibleThumbs(); if (views.length > 0) { let shouldScroll = false; if (pageNumber = last.id) { shouldScroll = true; } else { for (const { id, percent } of views) { if (id !== pageNumber) { continue; } shouldScroll = percent < 100; break; } } if (shouldScroll) { (0, _ui_utils.scrollIntoView)(thumbnailView.div, { top: THUMBNAIL_SCROLL_MARGIN }); } } this._currentPageNumber = pageNumber; } get pagesRotation() { return this._pagesRotation; } set pagesRotation(rotation) { if (!(0, _ui_utils.isValidRotation)(rotation)) { throw new Error(\"Invalid thumbnails rotation angle.\"); } if (!this.pdfDocument) { return; } if (this._pagesRotation === rotation) { return; } this._pagesRotation = rotation; const updateArgs = { rotation }; for (const thumbnail of this._thumbnails) { thumbnail.update(updateArgs); } } cleanup() { for (const thumbnail of this._thumbnails) { if (thumbnail.renderingState !== _ui_utils.RenderingStates.FINISHED) { thumbnail.reset(); } } _pdf_thumbnail_view.TempImageFactory.destroyCanvas(); } _resetView() { this._thumbnails = []; this._currentPageNumber = 1; this._pageLabels = null; this._pagesRotation = 0; this.container.textContent = \"\"; } setDocument(pdfDocument) { if (this.pdfDocument) { this._cancelRendering(); this._resetView(); } this.pdfDocument = pdfDocument; if (!pdfDocument) { return; } const firstPagePromise = pdfDocument.getPage(1); const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig(); firstPagePromise.then(firstPdfPage => { const pagesCount = pdfDocument.numPages; const viewport = firstPdfPage.getViewport({ scale: 1 }); for (let pageNum = 1; pageNum { console.error(\"Unable to initialize thumbnail viewer\", reason); }); } _cancelRendering() { for (const thumbnail of this._thumbnails) { thumbnail.cancelRendering(); } } setPageLabels(labels) { if (!this.pdfDocument) { return; } if (!labels) { this._pageLabels = null; } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) { this._pageLabels = null; console.error(\"PDFThumbnailViewer_setPageLabels: Invalid page labels.\"); } else { this._pageLabels = labels; } for (let i = 0, ii = this._thumbnails.length; i < ii; i++) { this._thumbnails[i].setPageLabel(this._pageLabels?.[i] ?? null); } } async #ensurePdfPageLoaded(thumbView) { if (thumbView.pdfPage) { return thumbView.pdfPage; } try { const pdfPage = await this.pdfDocument.getPage(thumbView.id); if (!thumbView.pdfPage) { thumbView.setPdfPage(pdfPage); } return pdfPage; } catch (reason) { console.error(\"Unable to get page for thumb view\", reason); return null; } } #getScrollAhead(visible) { if (visible.first?.id === 1) { return true; } else if (visible.last?.id === this._thumbnails.length) { return false; } return this.scroll.down; } forceRendering() { const visibleThumbs = this._getVisibleThumbs(); const scrollAhead = this.#getScrollAhead(visibleThumbs); const thumbView = this.renderingQueue.getHighestPriority(visibleThumbs, this._thumbnails, scrollAhead); if (thumbView) { this.#ensurePdfPageLoaded(thumbView).then(() => { this.renderingQueue.renderView(thumbView); }); return true; } return false; } } exports.PDFThumbnailViewer = PDFThumbnailViewer; /***/ }), /* 27 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.TempImageFactory = exports.PDFThumbnailView = void 0; var _ui_utils = __webpack_require__(1); var _pdfjsLib = __webpack_require__(5); const DRAW_UPSCALE_FACTOR = 2; const MAX_NUM_SCALING_STEPS = 3; const THUMBNAIL_CANVAS_BORDER_WIDTH = 1; const THUMBNAIL_WIDTH = 98; class TempImageFactory { static #tempCanvas = null; static getCanvas(width, height) { const tempCanvas = this.#tempCanvas ||= document.createElement(\"canvas\"); tempCanvas.width = width; tempCanvas.height = height; const ctx = tempCanvas.getContext(\"2d\", { alpha: false }); ctx.save(); ctx.fillStyle = \"rgb(255, 255, 255)\"; ctx.fillRect(0, 0, width, height); ctx.restore(); return [tempCanvas, tempCanvas.getContext(\"2d\")]; } static destroyCanvas() { const tempCanvas = this.#tempCanvas; if (tempCanvas) { tempCanvas.width = 0; tempCanvas.height = 0; } this.#tempCanvas = null; } } exports.TempImageFactory = TempImageFactory; class PDFThumbnailView { constructor({ container, id, defaultViewport, optionalContentConfigPromise, linkService, renderingQueue, l10n, pageColors }) { this.id = id; this.renderingId = \"thumbnail\" + id; this.pageLabel = null; this.pdfPage = null; this.rotation = 0; this.viewport = defaultViewport; this.pdfPageRotate = defaultViewport.rotation; this._optionalContentConfigPromise = optionalContentConfigPromise || null; this.pageColors = pageColors || null; this.linkService = linkService; this.renderingQueue = renderingQueue; this.renderTask = null; this.renderingState = _ui_utils.RenderingStates.INITIAL; this.resume = null; const pageWidth = this.viewport.width, pageHeight = this.viewport.height, pageRatio = pageWidth / pageHeight; this.canvasWidth = THUMBNAIL_WIDTH; this.canvasHeight = this.canvasWidth / pageRatio | 0; this.scale = this.canvasWidth / pageWidth; this.l10n = l10n; const anchor = document.createElement(\"a\"); anchor.href = linkService.getAnchorUrl(\"#page=\" + id); this._thumbPageTitle.then(msg => { anchor.title = msg; }); anchor.onclick = function () { linkService.goToPage(id); return false; }; this.anchor = anchor; const div = document.createElement(\"div\"); div.className = \"thumbnail\"; div.setAttribute(\"data-page-number\", this.id); this.div = div; const ring = document.createElement(\"div\"); ring.className = \"thumbnailSelectionRing\"; const borderAdjustment = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH; ring.style.width = this.canvasWidth + borderAdjustment + \"px\"; ring.style.height = this.canvasHeight + borderAdjustment + \"px\"; this.ring = ring; div.append(ring); anchor.append(div); container.append(anchor); } setPdfPage(pdfPage) { this.pdfPage = pdfPage; this.pdfPageRotate = pdfPage.rotate; const totalRotation = (this.rotation + this.pdfPageRotate) % 360; this.viewport = pdfPage.getViewport({ scale: 1, rotation: totalRotation }); this.reset(); } reset() { this.cancelRendering(); this.renderingState = _ui_utils.RenderingStates.INITIAL; const pageWidth = this.viewport.width, pageHeight = this.viewport.height, pageRatio = pageWidth / pageHeight; this.canvasHeight = this.canvasWidth / pageRatio | 0; this.scale = this.canvasWidth / pageWidth; this.div.removeAttribute(\"data-loaded\"); const ring = this.ring; ring.textContent = \"\"; const borderAdjustment = 2 * THUMBNAIL_CANVAS_BORDER_WIDTH; ring.style.width = this.canvasWidth + borderAdjustment + \"px\"; ring.style.height = this.canvasHeight + borderAdjustment + \"px\"; if (this.canvas) { this.canvas.width = 0; this.canvas.height = 0; delete this.canvas; } if (this.image) { this.image.removeAttribute(\"src\"); delete this.image; } } update({ rotation = null }) { if (typeof rotation === \"number\") { this.rotation = rotation; } const totalRotation = (this.rotation + this.pdfPageRotate) % 360; this.viewport = this.viewport.clone({ scale: 1, rotation: totalRotation }); this.reset(); } cancelRendering() { if (this.renderTask) { this.renderTask.cancel(); this.renderTask = null; } this.resume = null; } _getPageDrawContext(upscaleFactor = 1) { const canvas = document.createElement(\"canvas\"); const ctx = canvas.getContext(\"2d\", { alpha: false }); const outputScale = new _ui_utils.OutputScale(); canvas.width = upscaleFactor * this.canvasWidth * outputScale.sx | 0; canvas.height = upscaleFactor * this.canvasHeight * outputScale.sy | 0; const transform = outputScale.scaled ? [outputScale.sx, 0, 0, outputScale.sy, 0, 0] : null; return { ctx, canvas, transform }; } _convertCanvasToImage(canvas) { if (this.renderingState !== _ui_utils.RenderingStates.FINISHED) { throw new Error(\"_convertCanvasToImage: Rendering has not finished.\"); } const reducedCanvas = this._reduceImage(canvas); const image = document.createElement(\"img\"); image.className = \"thumbnailImage\"; this._thumbPageCanvas.then(msg => { image.setAttribute(\"aria-label\", msg); }); image.style.width = this.canvasWidth + \"px\"; image.style.height = this.canvasHeight + \"px\"; image.src = reducedCanvas.toDataURL(); this.image = image; this.div.setAttribute(\"data-loaded\", true); this.ring.append(image); reducedCanvas.width = 0; reducedCanvas.height = 0; } draw() { if (this.renderingState !== _ui_utils.RenderingStates.INITIAL) { console.error(\"Must be in new state before drawing\"); return Promise.resolve(); } const { pdfPage } = this; if (!pdfPage) { this.renderingState = _ui_utils.RenderingStates.FINISHED; return Promise.reject(new Error(\"pdfPage is not loaded\")); } this.renderingState = _ui_utils.RenderingStates.RUNNING; const finishRenderTask = async (error = null) => { if (renderTask === this.renderTask) { this.renderTask = null; } if (error instanceof _pdfjsLib.RenderingCancelledException) { return; } this.renderingState = _ui_utils.RenderingStates.FINISHED; this._convertCanvasToImage(canvas); if (error) { throw error; } }; const { ctx, canvas, transform } = this._getPageDrawContext(DRAW_UPSCALE_FACTOR); const drawViewport = this.viewport.clone({ scale: DRAW_UPSCALE_FACTOR * this.scale }); const renderContinueCallback = cont => { if (!this.renderingQueue.isHighestPriority(this)) { this.renderingState = _ui_utils.RenderingStates.PAUSED; this.resume = () => { this.renderingState = _ui_utils.RenderingStates.RUNNING; cont(); }; return; } cont(); }; const renderContext = { canvasContext: ctx, transform, viewport: drawViewport, optionalContentConfigPromise: this._optionalContentConfigPromise, pageColors: this.pageColors }; const renderTask = this.renderTask = pdfPage.render(renderContext); renderTask.onContinue = renderContinueCallback; const resultPromise = renderTask.promise.then(function () { return finishRenderTask(null); }, function (error) { return finishRenderTask(error); }); resultPromise.finally(() => { canvas.width = 0; canvas.height = 0; const pageCached = this.linkService.isPageCached(this.id); if (!pageCached) { this.pdfPage?.cleanup(); } }); return resultPromise; } setImage(pageView) { if (this.renderingState !== _ui_utils.RenderingStates.INITIAL) { return; } const { thumbnailCanvas: canvas, pdfPage, scale } = pageView; if (!canvas) { return; } if (!this.pdfPage) { this.setPdfPage(pdfPage); } if (scale < this.scale) { return; } this.renderingState = _ui_utils.RenderingStates.FINISHED; this._convertCanvasToImage(canvas); } _reduceImage(img) { const { ctx, canvas } = this._getPageDrawContext(); if (img.width >= 1; } reducedImageCtx.drawImage(img, 0, 0, img.width, img.height, 0, 0, reducedWidth, reducedHeight); while (reducedWidth > 2 * canvas.width) { reducedImageCtx.drawImage(reducedImage, 0, 0, reducedWidth, reducedHeight, 0, 0, reducedWidth >> 1, reducedHeight >> 1); reducedWidth >>= 1; reducedHeight >>= 1; } ctx.drawImage(reducedImage, 0, 0, reducedWidth, reducedHeight, 0, 0, canvas.width, canvas.height); return canvas; } get _thumbPageTitle() { return this.l10n.get(\"thumb_page_title\", { page: this.pageLabel ?? this.id }); } get _thumbPageCanvas() { return this.l10n.get(\"thumb_page_canvas\", { page: this.pageLabel ?? this.id }); } setPageLabel(label) { this.pageLabel = typeof label === \"string\" ? label : null; this._thumbPageTitle.then(msg => { this.anchor.title = msg; }); if (this.renderingState !== _ui_utils.RenderingStates.FINISHED) { return; } this._thumbPageCanvas.then(msg => { this.image?.setAttribute(\"aria-label\", msg); }); } } exports.PDFThumbnailView = PDFThumbnailView; /***/ }), /* 28 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PagesCountLimit = exports.PDFViewer = exports.PDFPageViewBuffer = void 0; var _pdfjsLib = __webpack_require__(5); var _ui_utils = __webpack_require__(1); var _l10n_utils = __webpack_require__(29); var _pdf_page_view = __webpack_require__(30); var _pdf_rendering_queue = __webpack_require__(22); var _pdf_link_service = __webpack_require__(3); const DEFAULT_CACHE_SIZE = 10; const ENABLE_PERMISSIONS_CLASS = \"enablePermissions\"; const PagesCountLimit = { FORCE_SCROLL_MODE_PAGE: 15000, FORCE_LAZY_PAGE_INIT: 7500, PAUSE_EAGER_PAGE_INIT: 250 }; exports.PagesCountLimit = PagesCountLimit; function isValidAnnotationEditorMode(mode) { return Object.values(_pdfjsLib.AnnotationEditorType).includes(mode) && mode !== _pdfjsLib.AnnotationEditorType.DISABLE; } class PDFPageViewBuffer { #buf = new Set(); #size = 0; constructor(size) { this.#size = size; } push(view) { const buf = this.#buf; if (buf.has(view)) { buf.delete(view); } buf.add(view); if (buf.size > this.#size) { this.#destroyFirstView(); } } resize(newSize, idsToKeep = null) { this.#size = newSize; const buf = this.#buf; if (idsToKeep) { const ii = buf.size; let i = 1; for (const view of buf) { if (idsToKeep.has(view.id)) { buf.delete(view); buf.add(view); } if (++i > ii) { break; } } } while (buf.size > this.#size) { this.#destroyFirstView(); } } has(view) { return this.#buf.has(view); } [Symbol.iterator]() { return this.#buf.keys(); } #destroyFirstView() { const firstView = this.#buf.keys().next().value; firstView?.destroy(); this.#buf.delete(firstView); } } exports.PDFPageViewBuffer = PDFPageViewBuffer; class PDFViewer { #buffer = null; #annotationEditorMode = _pdfjsLib.AnnotationEditorType.NONE; #annotationEditorUIManager = null; #annotationMode = _pdfjsLib.AnnotationMode.ENABLE_FORMS; #containerTopLeft = null; #enablePermissions = false; #previousContainerHeight = 0; #resizeObserver = new ResizeObserver(this.#resizeObserverCallback.bind(this)); #scrollModePageState = null; #onVisibilityChange = null; #scaleTimeoutId = null; constructor(options) { const viewerVersion = '3.2.146'; if (_pdfjsLib.version !== viewerVersion) { throw new Error(`The API version \"${_pdfjsLib.version}\" does not match the Viewer version \"${viewerVersion}\".`); } this.container = options.container; this.#resizeObserver.observe(this.container); this.viewer = options.viewer || options.container.firstElementChild; if (!(this.container?.tagName.toUpperCase() === \"DIV\" && this.viewer?.tagName.toUpperCase() === \"DIV\")) { throw new Error(\"Invalid `container` and/or `viewer` option.\"); } if (this.container.offsetParent && getComputedStyle(this.container).position !== \"absolute\") { throw new Error(\"The `container` must be absolutely positioned.\"); } this.eventBus = options.eventBus; this.linkService = options.linkService || new _pdf_link_service.SimpleLinkService(); this.downloadManager = options.downloadManager || null; this.findController = options.findController || null; this._scriptingManager = options.scriptingManager || null; this.removePageBorders = options.removePageBorders || false; this.textLayerMode = options.textLayerMode ?? _ui_utils.TextLayerMode.ENABLE; this.#annotationMode = options.annotationMode ?? _pdfjsLib.AnnotationMode.ENABLE_FORMS; this.#annotationEditorMode = options.annotationEditorMode ?? _pdfjsLib.AnnotationEditorType.NONE; this.imageResourcesPath = options.imageResourcesPath || \"\"; this.enablePrintAutoRotate = options.enablePrintAutoRotate || false; this.renderer = options.renderer || _ui_utils.RendererType.CANVAS; this.useOnlyCssZoom = options.useOnlyCssZoom || false; this.isOffscreenCanvasSupported = options.isOffscreenCanvasSupported ?? true; this.maxCanvasPixels = options.maxCanvasPixels; this.l10n = options.l10n || _l10n_utils.NullL10n; this.#enablePermissions = options.enablePermissions || false; this.pageColors = options.pageColors || null; if (this.pageColors && !(CSS.supports(\"color\", this.pageColors.background) && CSS.supports(\"color\", this.pageColors.foreground))) { if (this.pageColors.background || this.pageColors.foreground) { console.warn(\"PDFViewer: Ignoring `pageColors`-option, since the browser doesn't support the values used.\"); } this.pageColors = null; } this.defaultRenderingQueue = !options.renderingQueue; if (this.defaultRenderingQueue) { this.renderingQueue = new _pdf_rendering_queue.PDFRenderingQueue(); this.renderingQueue.setViewer(this); } else { this.renderingQueue = options.renderingQueue; } this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdate.bind(this)); this.presentationModeState = _ui_utils.PresentationModeState.UNKNOWN; this._onBeforeDraw = this._onAfterDraw = null; this._resetView(); if (this.removePageBorders) { this.viewer.classList.add(\"removePageBorders\"); } this.#updateContainerHeightCss(); } get pagesCount() { return this._pages.length; } getPageView(index) { return this._pages[index]; } get pageViewsReady() { if (!this._pagesCapability.settled) { return false; } return this._pages.every(function (pageView) { return pageView?.pdfPage; }); } get renderForms() { return this.#annotationMode === _pdfjsLib.AnnotationMode.ENABLE_FORMS; } get enableScripting() { return !!this._scriptingManager; } get currentPageNumber() { return this._currentPageNumber; } set currentPageNumber(val) { if (!Number.isInteger(val)) { throw new Error(\"Invalid page number.\"); } if (!this.pdfDocument) { return; } if (!this._setCurrentPageNumber(val, true)) { console.error(`currentPageNumber: \"${val}\" is not a valid page.`); } } _setCurrentPageNumber(val, resetCurrentPageView = false) { if (this._currentPageNumber === val) { if (resetCurrentPageView) { this.#resetCurrentPageView(); } return true; } if (!(0 < val && val = 0) { page = i + 1; } } if (!this._setCurrentPageNumber(page, true)) { console.error(`currentPageLabel: \"${val}\" is not a valid page.`); } } get currentScale() { return this._currentScale !== _ui_utils.UNKNOWN_SCALE ? this._currentScale : _ui_utils.DEFAULT_SCALE; } set currentScale(val) { if (isNaN(val)) { throw new Error(\"Invalid numeric scale.\"); } if (!this.pdfDocument) { return; } this._setScale(val, { noScroll: false }); } get currentScaleValue() { return this._currentScaleValue; } set currentScaleValue(val) { if (!this.pdfDocument) { return; } this._setScale(val, { noScroll: false }); } get pagesRotation() { return this._pagesRotation; } set pagesRotation(rotation) { if (!(0, _ui_utils.isValidRotation)(rotation)) { throw new Error(\"Invalid pages rotation angle.\"); } if (!this.pdfDocument) { return; } rotation %= 360; if (rotation < 0) { rotation += 360; } if (this._pagesRotation === rotation) { return; } this._pagesRotation = rotation; const pageNumber = this._currentPageNumber; this.refresh(true, { rotation }); if (this._currentScaleValue) { this._setScale(this._currentScaleValue, { noScroll: true }); } this.eventBus.dispatch(\"rotationchanging\", { source: this, pagesRotation: rotation, pageNumber }); if (this.defaultRenderingQueue) { this.update(); } } get firstPagePromise() { return this.pdfDocument ? this._firstPageCapability.promise : null; } get onePageRendered() { return this.pdfDocument ? this._onePageRenderedCapability.promise : null; } get pagesPromise() { return this.pdfDocument ? this._pagesCapability.promise : null; } #layerProperties() { const self = this; return { get annotationEditorUIManager() { return self.#annotationEditorUIManager; }, get annotationStorage() { return self.pdfDocument?.annotationStorage; }, get downloadManager() { return self.downloadManager; }, get enableScripting() { return !!self._scriptingManager; }, get fieldObjectsPromise() { return self.pdfDocument?.getFieldObjects(); }, get findController() { return self.findController; }, get hasJSActionsPromise() { return self.pdfDocument?.hasJSActions(); }, get linkService() { return self.linkService; } }; } #initializePermissions(permissions) { const params = { annotationEditorMode: this.#annotationEditorMode, annotationMode: this.#annotationMode, textLayerMode: this.textLayerMode }; if (!permissions) { return params; } if (!permissions.includes(_pdfjsLib.PermissionFlag.COPY)) { this.viewer.classList.add(ENABLE_PERMISSIONS_CLASS); } if (!permissions.includes(_pdfjsLib.PermissionFlag.MODIFY_CONTENTS)) { params.annotationEditorMode = _pdfjsLib.AnnotationEditorType.DISABLE; } if (!permissions.includes(_pdfjsLib.PermissionFlag.MODIFY_ANNOTATIONS) && !permissions.includes(_pdfjsLib.PermissionFlag.FILL_INTERACTIVE_FORMS) && this.#annotationMode === _pdfjsLib.AnnotationMode.ENABLE_FORMS) { params.annotationMode = _pdfjsLib.AnnotationMode.ENABLE; } return params; } #onePageRenderedOrForceFetch() { if (document.visibilityState === \"hidden\" || !this.container.offsetParent || this._getVisiblePages().views.length === 0) { return Promise.resolve(); } const visibilityChangePromise = new Promise(resolve => { this.#onVisibilityChange = () => { if (document.visibilityState !== \"hidden\") { return; } resolve(); document.removeEventListener(\"visibilitychange\", this.#onVisibilityChange); this.#onVisibilityChange = null; }; document.addEventListener(\"visibilitychange\", this.#onVisibilityChange); }); return Promise.race([this._onePageRenderedCapability.promise, visibilityChangePromise]); } setDocument(pdfDocument) { if (this.pdfDocument) { this.eventBus.dispatch(\"pagesdestroy\", { source: this }); this._cancelRendering(); this._resetView(); this.findController?.setDocument(null); this._scriptingManager?.setDocument(null); if (this.#annotationEditorUIManager) { this.#annotationEditorUIManager.destroy(); this.#annotationEditorUIManager = null; } } this.pdfDocument = pdfDocument; if (!pdfDocument) { return; } const pagesCount = pdfDocument.numPages; const firstPagePromise = pdfDocument.getPage(1); const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig(); const permissionsPromise = this.#enablePermissions ? pdfDocument.getPermissions() : Promise.resolve(); if (pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE) { console.warn(\"Forcing PAGE-scrolling for performance reasons, given the length of the document.\"); const mode = this._scrollMode = _ui_utils.ScrollMode.PAGE; this.eventBus.dispatch(\"scrollmodechanged\", { source: this, mode }); } this._pagesCapability.promise.then(() => { this.eventBus.dispatch(\"pagesloaded\", { source: this, pagesCount }); }, () => {}); this._onBeforeDraw = evt => { const pageView = this._pages[evt.pageNumber - 1]; if (!pageView) { return; } this.#buffer.push(pageView); }; this.eventBus._on(\"pagerender\", this._onBeforeDraw); this._onAfterDraw = evt => { if (evt.cssTransform || this._onePageRenderedCapability.settled) { return; } this._onePageRenderedCapability.resolve({ timestamp: evt.timestamp }); this.eventBus._off(\"pagerendered\", this._onAfterDraw); this._onAfterDraw = null; if (this.#onVisibilityChange) { document.removeEventListener(\"visibilitychange\", this.#onVisibilityChange); this.#onVisibilityChange = null; } }; this.eventBus._on(\"pagerendered\", this._onAfterDraw); Promise.all([firstPagePromise, permissionsPromise]).then(([firstPdfPage, permissions]) => { if (pdfDocument !== this.pdfDocument) { return; } this._firstPageCapability.resolve(firstPdfPage); this._optionalContentConfigPromise = optionalContentConfigPromise; const { annotationEditorMode, annotationMode, textLayerMode } = this.#initializePermissions(permissions); if (annotationEditorMode !== _pdfjsLib.AnnotationEditorType.DISABLE) { const mode = annotationEditorMode; if (pdfDocument.isPureXfa) { console.warn(\"Warning: XFA-editing is not implemented.\"); } else if (isValidAnnotationEditorMode(mode)) { this.#annotationEditorUIManager = new _pdfjsLib.AnnotationEditorUIManager(this.container, this.eventBus, pdfDocument?.annotationStorage); if (mode !== _pdfjsLib.AnnotationEditorType.NONE) { this.#annotationEditorUIManager.updateMode(mode); } } else { console.error(`Invalid AnnotationEditor mode: ${mode}`); } } const layerProperties = this.#layerProperties.bind(this); const viewerElement = this._scrollMode === _ui_utils.ScrollMode.PAGE ? null : this.viewer; const scale = this.currentScale; const viewport = firstPdfPage.getViewport({ scale: scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS }); _ui_utils.docStyle.setProperty(\"--scale-factor\", viewport.scale); for (let pageNum = 1; pageNum { this.findController?.setDocument(pdfDocument); this._scriptingManager?.setDocument(pdfDocument); if (this.#annotationEditorUIManager) { this.eventBus.dispatch(\"annotationeditormodechanged\", { source: this, mode: this.#annotationEditorMode }); } if (pdfDocument.loadingParams.disableAutoFetch || pagesCount > PagesCountLimit.FORCE_LAZY_PAGE_INIT) { this._pagesCapability.resolve(); return; } let getPagesLeft = pagesCount - 1; if (getPagesLeft { console.error(`Unable to get page ${pageNum} to initialize viewer`, reason); if (--getPagesLeft === 0) { this._pagesCapability.resolve(); } }); if (pageNum % PagesCountLimit.PAUSE_EAGER_PAGE_INIT === 0) { await promise; } } }); this.eventBus.dispatch(\"pagesinit\", { source: this }); pdfDocument.getMetadata().then(({ info }) => { if (pdfDocument !== this.pdfDocument) { return; } if (info.Language) { this.viewer.lang = info.Language; } }); if (this.defaultRenderingQueue) { this.update(); } }).catch(reason => { console.error(\"Unable to initialize viewer\", reason); this._pagesCapability.reject(reason); }); } setPageLabels(labels) { if (!this.pdfDocument) { return; } if (!labels) { this._pageLabels = null; } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) { this._pageLabels = null; console.error(`setPageLabels: Invalid page labels.`); } else { this._pageLabels = labels; } for (let i = 0, ii = this._pages.length; i < ii; i++) { this._pages[i].setPageLabel(this._pageLabels?.[i] ?? null); } } _resetView() { this._pages = []; this._currentPageNumber = 1; this._currentScale = _ui_utils.UNKNOWN_SCALE; this._currentScaleValue = null; this._pageLabels = null; this.#buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE); this._location = null; this._pagesRotation = 0; this._optionalContentConfigPromise = null; this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)(); this._onePageRenderedCapability = (0, _pdfjsLib.createPromiseCapability)(); this._pagesCapability = (0, _pdfjsLib.createPromiseCapability)(); this._scrollMode = _ui_utils.ScrollMode.VERTICAL; this._previousScrollMode = _ui_utils.ScrollMode.UNKNOWN; this._spreadMode = _ui_utils.SpreadMode.NONE; this.#scrollModePageState = { previousPageNumber: 1, scrollDown: true, pages: [] }; if (this._onBeforeDraw) { this.eventBus._off(\"pagerender\", this._onBeforeDraw); this._onBeforeDraw = null; } if (this._onAfterDraw) { this.eventBus._off(\"pagerendered\", this._onAfterDraw); this._onAfterDraw = null; } if (this.#onVisibilityChange) { document.removeEventListener(\"visibilitychange\", this.#onVisibilityChange); this.#onVisibilityChange = null; } this.viewer.textContent = \"\"; this._updateScrollMode(); this.viewer.removeAttribute(\"lang\"); this.viewer.classList.remove(ENABLE_PERMISSIONS_CLASS); } #ensurePageViewVisible() { if (this._scrollMode !== _ui_utils.ScrollMode.PAGE) { throw new Error(\"#ensurePageViewVisible: Invalid scrollMode value.\"); } const pageNumber = this._currentPageNumber, state = this.#scrollModePageState, viewer = this.viewer; viewer.textContent = \"\"; state.pages.length = 0; if (this._spreadMode === _ui_utils.SpreadMode.NONE && !this.isInPresentationMode) { const pageView = this._pages[pageNumber - 1]; viewer.append(pageView.div); state.pages.push(pageView); } else { const pageIndexSet = new Set(), parity = this._spreadMode - 1; if (parity === -1) { pageIndexSet.add(pageNumber - 1); } else if (pageNumber % 2 !== parity) { pageIndexSet.add(pageNumber - 1); pageIndexSet.add(pageNumber); } else { pageIndexSet.add(pageNumber - 2); pageIndexSet.add(pageNumber - 1); } const spread = document.createElement(\"div\"); spread.className = \"spread\"; if (this.isInPresentationMode) { const dummyPage = document.createElement(\"div\"); dummyPage.className = \"dummyPage\"; spread.append(dummyPage); } for (const i of pageIndexSet) { const pageView = this._pages[i]; if (!pageView) { continue; } spread.append(pageView.div); state.pages.push(pageView); } viewer.append(spread); } state.scrollDown = pageNumber >= state.previousPageNumber; state.previousPageNumber = pageNumber; } _scrollUpdate() { if (this.pagesCount === 0) { return; } this.update(); } #scrollIntoView(pageView, pageSpot = null) { const { div, id } = pageView; if (this._currentPageNumber !== id) { this._setCurrentPageNumber(id); } if (this._scrollMode === _ui_utils.ScrollMode.PAGE) { this.#ensurePageViewVisible(); this.update(); } if (!pageSpot && !this.isInPresentationMode) { const left = div.offsetLeft + div.clientLeft, right = left + div.clientWidth; const { scrollLeft, clientWidth } = this.container; if (this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL || left < scrollLeft || right > scrollLeft + clientWidth) { pageSpot = { left: 0, top: 0 }; } } (0, _ui_utils.scrollIntoView)(div, pageSpot); if (!this._currentScaleValue && this._location) { this._location = null; } } #isSameScale(newScale) { return newScale === this._currentScale || Math.abs(newScale - this._currentScale) < 1e-15; } _setScaleUpdatePages(newScale, newValue, { noScroll = false, preset = false, drawingDelay = -1 }) { this._currentScaleValue = newValue.toString(); if (this.#isSameScale(newScale)) { if (preset) { this.eventBus.dispatch(\"scalechanging\", { source: this, scale: newScale, presetValue: newValue }); } return; } _ui_utils.docStyle.setProperty(\"--scale-factor\", newScale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS); const postponeDrawing = drawingDelay >= 0 && drawingDelay < 1000; this.refresh(true, { scale: newScale, drawingDelay: postponeDrawing ? drawingDelay : -1 }); if (postponeDrawing) { this.#scaleTimeoutId = setTimeout(() => { this.#scaleTimeoutId = null; this.refresh(); }, drawingDelay); } this._currentScale = newScale; if (!noScroll) { let page = this._currentPageNumber, dest; if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode)) { page = this._location.pageNumber; dest = [null, { name: \"XYZ\" }, this._location.left, this._location.top, null]; } this.scrollPageIntoView({ pageNumber: page, destArray: dest, allowNegativeOffset: true }); } this.eventBus.dispatch(\"scalechanging\", { source: this, scale: newScale, presetValue: preset ? newValue : undefined }); if (this.defaultRenderingQueue) { this.update(); } } get _pageWidthScaleFactor() { if (this._spreadMode !== _ui_utils.SpreadMode.NONE && this._scrollMode !== _ui_utils.ScrollMode.HORIZONTAL) { return 2; } return 1; } _setScale(value, options) { let scale = parseFloat(value); if (scale > 0) { options.preset = false; this._setScaleUpdatePages(scale, value, options); } else { const currentPage = this._pages[this._currentPageNumber - 1]; if (!currentPage) { return; } let hPadding = _ui_utils.SCROLLBAR_PADDING, vPadding = _ui_utils.VERTICAL_PADDING; if (this.isInPresentationMode) { hPadding = vPadding = 4; if (this._spreadMode !== _ui_utils.SpreadMode.NONE) { hPadding *= 2; } } else if (this.removePageBorders) { hPadding = vPadding = 0; } else if (this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL) { [hPadding, vPadding] = [vPadding, hPadding]; } const pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale / this._pageWidthScaleFactor; const pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale; switch (value) { case \"page-actual\": scale = 1; break; case \"page-width\": scale = pageWidthScale; break; case \"page-height\": scale = pageHeightScale; break; case \"page-fit\": scale = Math.min(pageWidthScale, pageHeightScale); break; case \"auto\": const horizontalScale = (0, _ui_utils.isPortraitOrientation)(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale); scale = Math.min(_ui_utils.MAX_AUTO_SCALE, horizontalScale); break; default: console.error(`_setScale: \"${value}\" is an unknown zoom value.`); return; } options.preset = true; this._setScaleUpdatePages(scale, value, options); } } #resetCurrentPageView() { const pageView = this._pages[this._currentPageNumber - 1]; if (this.isInPresentationMode) { this._setScale(this._currentScaleValue, { noScroll: true }); } this.#scrollIntoView(pageView); } pageLabelToPageNumber(label) { if (!this._pageLabels) { return null; } const i = this._pageLabels.indexOf(label); if (i < 0) { return null; } return i + 1; } scrollPageIntoView({ pageNumber, destArray = null, allowNegativeOffset = false, ignoreDestinationZoom = false }) { if (!this.pdfDocument) { return; } const pageView = Number.isInteger(pageNumber) && this._pages[pageNumber - 1]; if (!pageView) { console.error(`scrollPageIntoView: \"${pageNumber}\" is not a valid pageNumber parameter.`); return; } if (this.isInPresentationMode || !destArray) { this._setCurrentPageNumber(pageNumber, true); return; } let x = 0, y = 0; let width = 0, height = 0, widthScale, heightScale; const changeOrientation = pageView.rotation % 180 !== 0; const pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS; const pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS; let scale = 0; switch (destArray[1].name) { case \"XYZ\": x = destArray[2]; y = destArray[3]; scale = destArray[4]; x = x !== null ? x : 0; y = y !== null ? y : pageHeight; break; case \"Fit\": case \"FitB\": scale = \"page-fit\"; break; case \"FitH\": case \"FitBH\": y = destArray[2]; scale = \"page-width\"; if (y === null && this._location) { x = this._location.left; y = this._location.top; } else if (typeof y !== \"number\" || y < 0) { y = pageHeight; } break; case \"FitV\": case \"FitBV\": x = destArray[2]; width = pageWidth; height = pageHeight; scale = \"page-height\"; break; case \"FitR\": x = destArray[2]; y = destArray[3]; width = destArray[4] - x; height = destArray[5] - y; const hPadding = this.removePageBorders ? 0 : _ui_utils.SCROLLBAR_PADDING; const vPadding = this.removePageBorders ? 0 : _ui_utils.VERTICAL_PADDING; widthScale = (this.container.clientWidth - hPadding) / width / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS; heightScale = (this.container.clientHeight - vPadding) / height / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS; scale = Math.min(Math.abs(widthScale), Math.abs(heightScale)); break; default: console.error(`scrollPageIntoView: \"${destArray[1].name}\" is not a valid destination type.`); return; } if (!ignoreDestinationZoom) { if (scale && scale !== this._currentScale) { this.currentScaleValue = scale; } else if (this._currentScale === _ui_utils.UNKNOWN_SCALE) { this.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE; } } if (scale === \"page-fit\" && !destArray[4]) { this.#scrollIntoView(pageView); return; } const boundingRect = [pageView.viewport.convertToViewportPoint(x, y), pageView.viewport.convertToViewportPoint(x + width, y + height)]; let left = Math.min(boundingRect[0][0], boundingRect[1][0]); let top = Math.min(boundingRect[0][1], boundingRect[1][1]); if (!allowNegativeOffset) { left = Math.max(left, 0); top = Math.max(top, 0); } this.#scrollIntoView(pageView, { left, top }); } _updateLocation(firstPage) { const currentScale = this._currentScale; const currentScaleValue = this._currentScaleValue; const normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 10000) / 100 : currentScaleValue; const pageNumber = firstPage.id; const currentPageView = this._pages[pageNumber - 1]; const container = this.container; const topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y); const intLeft = Math.round(topLeft[0]); const intTop = Math.round(topLeft[1]); let pdfOpenParams = `#page=${pageNumber}`; if (!this.isInPresentationMode) { pdfOpenParams += `&zoom=${normalizedScaleValue},${intLeft},${intTop}`; } this._location = { pageNumber, scale: normalizedScaleValue, top: intTop, left: intLeft, rotation: this._pagesRotation, pdfOpenParams }; } update() { const visible = this._getVisiblePages(); const visiblePages = visible.views, numVisiblePages = visiblePages.length; if (numVisiblePages === 0) { return; } const newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1); this.#buffer.resize(newCacheSize, visible.ids); this.renderingQueue.renderHighestPriority(visible); const isSimpleLayout = this._spreadMode === _ui_utils.SpreadMode.NONE && (this._scrollMode === _ui_utils.ScrollMode.PAGE || this._scrollMode === _ui_utils.ScrollMode.VERTICAL); const currentId = this._currentPageNumber; let stillFullyVisible = false; for (const page of visiblePages) { if (page.percent < 100) { break; } if (page.id === currentId && isSimpleLayout) { stillFullyVisible = true; break; } } this._setCurrentPageNumber(stillFullyVisible ? currentId : visiblePages[0].id); this._updateLocation(visible.first); this.eventBus.dispatch(\"updateviewarea\", { source: this, location: this._location }); } containsElement(element) { return this.container.contains(element); } focus() { this.container.focus(); } get _isContainerRtl() { return getComputedStyle(this.container).direction === \"rtl\"; } get isInPresentationMode() { return this.presentationModeState === _ui_utils.PresentationModeState.FULLSCREEN; } get isChangingPresentationMode() { return this.presentationModeState === _ui_utils.PresentationModeState.CHANGING; } get isHorizontalScrollbarEnabled() { return this.isInPresentationMode ? false : this.container.scrollWidth > this.container.clientWidth; } get isVerticalScrollbarEnabled() { return this.isInPresentationMode ? false : this.container.scrollHeight > this.container.clientHeight; } _getVisiblePages() { const views = this._scrollMode === _ui_utils.ScrollMode.PAGE ? this.#scrollModePageState.pages : this._pages, horizontal = this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL, rtl = horizontal && this._isContainerRtl; return (0, _ui_utils.getVisibleElements)({ scrollEl: this.container, views, sortByVisibility: true, horizontal, rtl }); } isPageVisible(pageNumber) { if (!this.pdfDocument) { return false; } if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber 0 && pageNumber { this.renderingQueue.renderView(pageView); }); return true; } return false; } get hasEqualPageSizes() { const firstPageView = this._pages[0]; for (let i = 1, ii = this._pages.length; i < ii; ++i) { const pageView = this._pages[i]; if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) { return false; } } return true; } getPagesOverview() { return this._pages.map(pageView => { const viewport = pageView.pdfPage.getViewport({ scale: 1 }); if (!this.enablePrintAutoRotate || (0, _ui_utils.isPortraitOrientation)(viewport)) { return { width: viewport.width, height: viewport.height, rotation: viewport.rotation }; } return { width: viewport.height, height: viewport.width, rotation: (viewport.rotation - 90) % 360 }; }); } get optionalContentConfigPromise() { if (!this.pdfDocument) { return Promise.resolve(null); } if (!this._optionalContentConfigPromise) { console.error(\"optionalContentConfigPromise: Not initialized yet.\"); return this.pdfDocument.getOptionalContentConfig(); } return this._optionalContentConfigPromise; } set optionalContentConfigPromise(promise) { if (!(promise instanceof Promise)) { throw new Error(`Invalid optionalContentConfigPromise: ${promise}`); } if (!this.pdfDocument) { return; } if (!this._optionalContentConfigPromise) { return; } this._optionalContentConfigPromise = promise; this.refresh(false, { optionalContentConfigPromise: promise }); this.eventBus.dispatch(\"optionalcontentconfigchanged\", { source: this, promise }); } get scrollMode() { return this._scrollMode; } set scrollMode(mode) { if (this._scrollMode === mode) { return; } if (!(0, _ui_utils.isValidScrollMode)(mode)) { throw new Error(`Invalid scroll mode: ${mode}`); } if (this.pagesCount > PagesCountLimit.FORCE_SCROLL_MODE_PAGE) { return; } this._previousScrollMode = this._scrollMode; this._scrollMode = mode; this.eventBus.dispatch(\"scrollmodechanged\", { source: this, mode }); this._updateScrollMode(this._currentPageNumber); } _updateScrollMode(pageNumber = null) { const scrollMode = this._scrollMode, viewer = this.viewer; viewer.classList.toggle(\"scrollHorizontal\", scrollMode === _ui_utils.ScrollMode.HORIZONTAL); viewer.classList.toggle(\"scrollWrapped\", scrollMode === _ui_utils.ScrollMode.WRAPPED); if (!this.pdfDocument || !pageNumber) { return; } if (scrollMode === _ui_utils.ScrollMode.PAGE) { this.#ensurePageViewVisible(); } else if (this._previousScrollMode === _ui_utils.ScrollMode.PAGE) { this._updateSpreadMode(); } if (this._currentScaleValue && isNaN(this._currentScaleValue)) { this._setScale(this._currentScaleValue, { noScroll: true }); } this._setCurrentPageNumber(pageNumber, true); this.update(); } get spreadMode() { return this._spreadMode; } set spreadMode(mode) { if (this._spreadMode === mode) { return; } if (!(0, _ui_utils.isValidSpreadMode)(mode)) { throw new Error(`Invalid spread mode: ${mode}`); } this._spreadMode = mode; this.eventBus.dispatch(\"spreadmodechanged\", { source: this, mode }); this._updateSpreadMode(this._currentPageNumber); } _updateSpreadMode(pageNumber = null) { if (!this.pdfDocument) { return; } const viewer = this.viewer, pages = this._pages; if (this._scrollMode === _ui_utils.ScrollMode.PAGE) { this.#ensurePageViewVisible(); } else { viewer.textContent = \"\"; if (this._spreadMode === _ui_utils.SpreadMode.NONE) { for (const pageView of this._pages) { viewer.append(pageView.div); } } else { const parity = this._spreadMode - 1; let spread = null; for (let i = 0, ii = pages.length; i < ii; ++i) { if (spread === null) { spread = document.createElement(\"div\"); spread.className = \"spread\"; viewer.append(spread); } else if (i % 2 === parity) { spread = spread.cloneNode(false); viewer.append(spread); } spread.append(pages[i].div); } } } if (!pageNumber) { return; } if (this._currentScaleValue && isNaN(this._currentScaleValue)) { this._setScale(this._currentScaleValue, { noScroll: true }); } this._setCurrentPageNumber(pageNumber, true); this.update(); } _getPageAdvance(currentPageNumber, previous = false) { switch (this._scrollMode) { case _ui_utils.ScrollMode.WRAPPED: { const { views } = this._getVisiblePages(), pageLayout = new Map(); for (const { id, y, percent, widthPercent } of views) { if (percent === 0 || widthPercent < 100) { continue; } let yArray = pageLayout.get(y); if (!yArray) { pageLayout.set(y, yArray ||= []); } yArray.push(id); } for (const yArray of pageLayout.values()) { const currentIndex = yArray.indexOf(currentPageNumber); if (currentIndex === -1) { continue; } const numPages = yArray.length; if (numPages === 1) { break; } if (previous) { for (let i = currentIndex - 1, ii = 0; i >= ii; i--) { const currentId = yArray[i], expectedId = yArray[i + 1] - 1; if (currentId < expectedId) { return currentPageNumber - expectedId; } } } else { for (let i = currentIndex + 1, ii = numPages; i < ii; i++) { const currentId = yArray[i], expectedId = yArray[i - 1] + 1; if (currentId > expectedId) { return expectedId - currentPageNumber; } } } if (previous) { const firstId = yArray[0]; if (firstId < currentPageNumber) { return currentPageNumber - firstId + 1; } } else { const lastId = yArray[numPages - 1]; if (lastId > currentPageNumber) { return lastId - currentPageNumber + 1; } } break; } break; } case _ui_utils.ScrollMode.HORIZONTAL: { break; } case _ui_utils.ScrollMode.PAGE: case _ui_utils.ScrollMode.VERTICAL: { if (this._spreadMode === _ui_utils.SpreadMode.NONE) { break; } const parity = this._spreadMode - 1; if (previous && currentPageNumber % 2 !== parity) { break; } else if (!previous && currentPageNumber % 2 === parity) { break; } const { views } = this._getVisiblePages(), expectedId = previous ? currentPageNumber - 1 : currentPageNumber + 1; for (const { id, percent, widthPercent } of views) { if (id !== expectedId) { continue; } if (percent > 0 && widthPercent === 100) { return 2; } break; } break; } } return 1; } nextPage() { const currentPageNumber = this._currentPageNumber, pagesCount = this.pagesCount; if (currentPageNumber >= pagesCount) { return false; } const advance = this._getPageAdvance(currentPageNumber, false) || 1; this.currentPageNumber = Math.min(currentPageNumber + advance, pagesCount); return true; } previousPage() { const currentPageNumber = this._currentPageNumber; if (currentPageNumber 0 && newScale < _ui_utils.MAX_SCALE); options ||= Object.create(null); options.noScroll = false; this._setScale(newScale, options); } decreaseScale(steps = 1, options = null) { let newScale = this._currentScale; do { newScale = (newScale / _ui_utils.DEFAULT_SCALE_DELTA).toFixed(2); newScale = Math.floor(newScale * 10) / 10; newScale = Math.max(_ui_utils.MIN_SCALE, newScale); } while (--steps > 0 && newScale > _ui_utils.MIN_SCALE); options ||= Object.create(null); options.noScroll = false; this._setScale(newScale, options); } #updateContainerHeightCss(height = this.container.clientHeight) { if (height !== this.#previousContainerHeight) { this.#previousContainerHeight = height; _ui_utils.docStyle.setProperty(\"--viewer-container-height\", `${height}px`); } } #resizeObserverCallback(entries) { for (const entry of entries) { if (entry.target === this.container) { this.#updateContainerHeightCss(Math.floor(entry.borderBoxSize[0].blockSize)); this.#containerTopLeft = null; break; } } } get containerTopLeft() { return this.#containerTopLeft ||= [this.container.offsetTop, this.container.offsetLeft]; } get annotationEditorMode() { return this.#annotationEditorUIManager ? this.#annotationEditorMode : _pdfjsLib.AnnotationEditorType.DISABLE; } set annotationEditorMode(mode) { if (!this.#annotationEditorUIManager) { throw new Error(`The AnnotationEditor is not enabled.`); } if (this.#annotationEditorMode === mode) { return; } if (!isValidAnnotationEditorMode(mode)) { throw new Error(`Invalid AnnotationEditor mode: ${mode}`); } if (!this.pdfDocument) { return; } this.#annotationEditorMode = mode; this.eventBus.dispatch(\"annotationeditormodechanged\", { source: this, mode }); this.#annotationEditorUIManager.updateMode(mode); } set annotationEditorParams({ type, value }) { if (!this.#annotationEditorUIManager) { throw new Error(`The AnnotationEditor is not enabled.`); } this.#annotationEditorUIManager.updateParams(type, value); } refresh(noUpdate = false, updateArgs = Object.create(null)) { if (!this.pdfDocument) { return; } for (const pageView of this._pages) { pageView.update(updateArgs); } if (this.#scaleTimeoutId !== null) { clearTimeout(this.#scaleTimeoutId); this.#scaleTimeoutId = null; } if (!noUpdate) { this.update(); } } } exports.PDFViewer = PDFViewer; /***/ }), /* 29 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.NullL10n = void 0; exports.fixupLangCode = fixupLangCode; exports.getL10nFallback = getL10nFallback; const DEFAULT_L10N_STRINGS = { of_pages: \"of \", page_of_pages: \"( of )\", document_properties_kb: \" KB ( bytes)\", document_properties_mb: \" MB ( bytes)\", document_properties_date_string: \"1688005776996, \", document_properties_page_size_unit_inches: \"in\", document_properties_page_size_unit_millimeters: \"mm\", document_properties_page_size_orientation_portrait: \"portrait\", document_properties_page_size_orientation_landscape: \"landscape\", document_properties_page_size_name_a3: \"A3\", document_properties_page_size_name_a4: \"A4\", document_properties_page_size_name_letter: \"Letter\", document_properties_page_size_name_legal: \"Legal\", document_properties_page_size_dimension_string: \" × ()\", document_properties_page_size_dimension_name_string: \" × (, )\", document_properties_linearized_yes: \"Yes\", document_properties_linearized_no: \"No\", additional_layers: \"Additional Layers\", page_landmark: \"Page \", thumb_page_title: \"Page \", thumb_page_canvas: \"Thumbnail of Page \", find_reached_top: \"Reached top of document, continued from bottom\", find_reached_bottom: \"Reached end of document, continued from top\", \"find_match_count[one]\": \" of match\", \"find_match_count[other]\": \" of matches\", \"find_match_count_limit[one]\": \"More than match\", \"find_match_count_limit[other]\": \"More than matches\", find_not_found: \"Phrase not found\", page_scale_width: \"Page Width\", page_scale_fit: \"Page Fit\", page_scale_auto: \"Automatic Zoom\", page_scale_actual: \"Actual Size\", page_scale_percent: \"%\", loading: \"Loading…\", loading_error: \"An error occurred while loading the PDF.\", invalid_file_error: \"Invalid or corrupted PDF file.\", missing_file_error: \"Missing PDF file.\", unexpected_response_error: \"Unexpected server response.\", rendering_error: \"An error occurred while rendering the page.\", printing_not_supported: \"Warning: Printing is not fully supported by this browser.\", printing_not_ready: \"Warning: The PDF is not fully loaded for printing.\", web_fonts_disabled: \"Web fonts are disabled: unable to use embedded PDF fonts.\", free_text2_default_content: \"Start typing…\", editor_free_text2_aria_label: \"Text Editor\", editor_ink2_aria_label: \"Draw Editor\", editor_ink_canvas_aria_label: \"User-created image\" }; { DEFAULT_L10N_STRINGS.print_progress_percent = \"%\"; } function getL10nFallback(key, args) { switch (key) { case \"find_match_count\": key = `find_match_count[${args.total === 1 ? \"one\" : \"other\"}]`; break; case \"find_match_count_limit\": key = `find_match_count_limit[${args.limit === 1 ? \"one\" : \"other\"}]`; break; } return DEFAULT_L10N_STRINGS[key] || \"\"; } const PARTIAL_LANG_CODES = { en: \"en-US\", es: \"es-ES\", fy: \"fy-NL\", ga: \"ga-IE\", gu: \"gu-IN\", hi: \"hi-IN\", hy: \"hy-AM\", nb: \"nb-NO\", ne: \"ne-NP\", nn: \"nn-NO\", pa: \"pa-IN\", pt: \"pt-PT\", sv: \"sv-SE\", zh: \"zh-CN\" }; function fixupLangCode(langCode) { return PARTIAL_LANG_CODES[langCode?.toLowerCase()] || langCode; } function formatL10nValue(text, args) { if (!args) { return text; } return text.replace(/\\{\\{\\s*(\\w+)\\s*\\}\\}/g, (all, name) => { return name in args ? args[name] : \" + name + \"; }); } const NullL10n = { async getLanguage() { return \"en-us\"; }, async getDirection() { return \"ltr\"; }, async get(key, args = null, fallback = getL10nFallback(key, args)) { return formatL10nValue(fallback, args); }, async translate(element) {} }; exports.NullL10n = NullL10n; /***/ }), /* 30 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFPageView = void 0; var _pdfjsLib = __webpack_require__(5); var _ui_utils = __webpack_require__(1); var _annotation_editor_layer_builder = __webpack_require__(31); var _annotation_layer_builder = __webpack_require__(32); var _app_options = __webpack_require__(2); var _l10n_utils = __webpack_require__(29); var _struct_tree_layer_builder = __webpack_require__(33); var _text_accessibility = __webpack_require__(34); var _text_highlighter = __webpack_require__(35); var _text_layer_builder = __webpack_require__(36); var _xfa_layer_builder = __webpack_require__(37); const MAX_CANVAS_PIXELS = _app_options.compatibilityParams.maxCanvasPixels || 16777216; const DEFAULT_LAYER_PROPERTIES = () => { return null; }; class PDFPageView { #annotationMode = _pdfjsLib.AnnotationMode.ENABLE_FORMS; #layerProperties = null; #previousRotation = null; #renderingState = _ui_utils.RenderingStates.INITIAL; #useThumbnailCanvas = { initialOptionalContent: true, regularAnnotations: true }; constructor(options) { const container = options.container; const defaultViewport = options.defaultViewport; this.id = options.id; this.renderingId = \"page\" + this.id; this.#layerProperties = options.layerProperties || DEFAULT_LAYER_PROPERTIES; this.pdfPage = null; this.pageLabel = null; this.rotation = 0; this.scale = options.scale || _ui_utils.DEFAULT_SCALE; this.viewport = defaultViewport; this.pdfPageRotate = defaultViewport.rotation; this._optionalContentConfigPromise = options.optionalContentConfigPromise || null; this.hasRestrictedScaling = false; this.textLayerMode = options.textLayerMode ?? _ui_utils.TextLayerMode.ENABLE; this.#annotationMode = options.annotationMode ?? _pdfjsLib.AnnotationMode.ENABLE_FORMS; this.imageResourcesPath = options.imageResourcesPath || \"\"; this.useOnlyCssZoom = options.useOnlyCssZoom || false; this.isOffscreenCanvasSupported = options.isOffscreenCanvasSupported ?? true; this.maxCanvasPixels = options.maxCanvasPixels || MAX_CANVAS_PIXELS; this.pageColors = options.pageColors || null; this.eventBus = options.eventBus; this.renderingQueue = options.renderingQueue; this.renderer = options.renderer || _ui_utils.RendererType.CANVAS; this.l10n = options.l10n || _l10n_utils.NullL10n; this.paintTask = null; this.paintedViewportMap = new WeakMap(); this.resume = null; this._renderError = null; this._isStandalone = !this.renderingQueue?.hasViewer(); this._annotationCanvasMap = null; this.annotationLayer = null; this.annotationEditorLayer = null; this.textLayer = null; this.zoomLayer = null; this.xfaLayer = null; this.structTreeLayer = null; const div = document.createElement(\"div\"); div.className = \"page\"; div.setAttribute(\"data-page-number\", this.id); div.setAttribute(\"role\", \"region\"); this.l10n.get(\"page_landmark\", { page: this.id }).then(msg => { div.setAttribute(\"aria-label\", msg); }); this.div = div; this.#setDimensions(); container?.append(div); if (this._isStandalone) { _ui_utils.docStyle.setProperty(\"--scale-factor\", this.scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS); const { optionalContentConfigPromise } = options; if (optionalContentConfigPromise) { optionalContentConfigPromise.then(optionalContentConfig => { if (optionalContentConfigPromise !== this._optionalContentConfigPromise) { return; } this.#useThumbnailCanvas.initialOptionalContent = optionalContentConfig.hasInitialVisibility; }); } } } get renderingState() { return this.#renderingState; } set renderingState(state) { this.#renderingState = state; switch (state) { case _ui_utils.RenderingStates.INITIAL: case _ui_utils.RenderingStates.PAUSED: this.loadingIconDiv?.classList.add(\"notVisible\"); break; case _ui_utils.RenderingStates.RUNNING: this.loadingIconDiv?.classList.remove(\"notVisible\"); break; case _ui_utils.RenderingStates.FINISHED: if (this.loadingIconDiv) { this.loadingIconDiv.remove(); delete this.loadingIconDiv; } break; } } #setDimensions() { const { viewport } = this; if (this.pdfPage) { if (this.#previousRotation === viewport.rotation) { return; } this.#previousRotation = viewport.rotation; } (0, _pdfjsLib.setLayerDimensions)(this.div, viewport, true, false); } setPdfPage(pdfPage) { this.pdfPage = pdfPage; this.pdfPageRotate = pdfPage.rotate; const totalRotation = (this.rotation + this.pdfPageRotate) % 360; this.viewport = pdfPage.getViewport({ scale: this.scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS, rotation: totalRotation }); this.#setDimensions(); this.reset(); } destroy() { this.reset(); this.pdfPage?.cleanup(); } get _textHighlighter() { return (0, _pdfjsLib.shadow)(this, \"_textHighlighter\", new _text_highlighter.TextHighlighter({ pageIndex: this.id - 1, eventBus: this.eventBus, findController: this.#layerProperties().findController })); } async #renderAnnotationLayer() { let error = null; try { await this.annotationLayer.render(this.viewport, \"display\"); } catch (ex) { console.error(`#renderAnnotationLayer: \"${ex}\".`); error = ex; } finally { this.eventBus.dispatch(\"annotationlayerrendered\", { source: this, pageNumber: this.id, error }); } } async #renderAnnotationEditorLayer() { let error = null; try { await this.annotationEditorLayer.render(this.viewport, \"display\"); } catch (ex) { console.error(`#renderAnnotationEditorLayer: \"${ex}\".`); error = ex; } finally { this.eventBus.dispatch(\"annotationeditorlayerrendered\", { source: this, pageNumber: this.id, error }); } } async #renderXfaLayer() { let error = null; try { const result = await this.xfaLayer.render(this.viewport, \"display\"); if (result?.textDivs && this._textHighlighter) { this.#buildXfaTextContentItems(result.textDivs); } } catch (ex) { console.error(`#renderXfaLayer: \"${ex}\".`); error = ex; } finally { this.eventBus.dispatch(\"xfalayerrendered\", { source: this, pageNumber: this.id, error }); } } async #renderTextLayer() { const { pdfPage, textLayer, viewport } = this; if (!textLayer) { return; } let error = null; try { if (!textLayer.renderingDone) { const readableStream = pdfPage.streamTextContent({ includeMarkedContent: true }); textLayer.setTextContentSource(readableStream); } await textLayer.render(viewport); } catch (ex) { if (ex instanceof _pdfjsLib.AbortException) { return; } console.error(`#renderTextLayer: \"${ex}\".`); error = ex; } this.eventBus.dispatch(\"textlayerrendered\", { source: this, pageNumber: this.id, numTextDivs: textLayer.numTextDivs, error }); this.#renderStructTreeLayer(); } async #renderStructTreeLayer() { if (!this.textLayer) { return; } this.structTreeLayer ||= new _struct_tree_layer_builder.StructTreeLayerBuilder(); const tree = await (!this.structTreeLayer.renderingDone ? this.pdfPage.getStructTree() : null); const treeDom = this.structTreeLayer?.render(tree); if (treeDom) { this.canvas?.append(treeDom); } } async #buildXfaTextContentItems(textDivs) { const text = await this.pdfPage.getTextContent(); const items = []; for (const item of text.items) { items.push(item.str); } this._textHighlighter.setTextMapping(textDivs, items); this._textHighlighter.enable(); } _resetZoomLayer(removeFromDOM = false) { if (!this.zoomLayer) { return; } const zoomLayerCanvas = this.zoomLayer.firstChild; this.paintedViewportMap.delete(zoomLayerCanvas); zoomLayerCanvas.width = 0; zoomLayerCanvas.height = 0; if (removeFromDOM) { this.zoomLayer.remove(); } this.zoomLayer = null; } reset({ keepZoomLayer = false, keepAnnotationLayer = false, keepAnnotationEditorLayer = false, keepXfaLayer = false, keepTextLayer = false } = {}) { this.cancelRendering({ keepAnnotationLayer, keepAnnotationEditorLayer, keepXfaLayer, keepTextLayer }); this.renderingState = _ui_utils.RenderingStates.INITIAL; const div = this.div; const childNodes = div.childNodes, zoomLayerNode = keepZoomLayer && this.zoomLayer || null, annotationLayerNode = keepAnnotationLayer && this.annotationLayer?.div || null, annotationEditorLayerNode = keepAnnotationEditorLayer && this.annotationEditorLayer?.div || null, xfaLayerNode = keepXfaLayer && this.xfaLayer?.div || null, textLayerNode = keepTextLayer && this.textLayer?.div || null; for (let i = childNodes.length - 1; i >= 0; i--) { const node = childNodes[i]; switch (node) { case zoomLayerNode: case annotationLayerNode: case annotationEditorLayerNode: case xfaLayerNode: case textLayerNode: case this.loadingIconDiv: continue; } node.remove(); } div.removeAttribute(\"data-loaded\"); if (annotationLayerNode) { this.annotationLayer.hide(); } if (annotationEditorLayerNode) { this.annotationEditorLayer.hide(); } if (xfaLayerNode) { this.xfaLayer.hide(); } if (textLayerNode) { this.textLayer.hide(); } if (!zoomLayerNode) { if (this.canvas) { this.paintedViewportMap.delete(this.canvas); this.canvas.width = 0; this.canvas.height = 0; delete this.canvas; } this._resetZoomLayer(); } if (this.svg) { this.paintedViewportMap.delete(this.svg); delete this.svg; } if (!this.loadingIconDiv) { this.loadingIconDiv = document.createElement(\"div\"); this.loadingIconDiv.className = \"loadingIcon notVisible\"; this.loadingIconDiv.setAttribute(\"role\", \"img\"); this.l10n.get(\"loading\").then(msg => { this.loadingIconDiv?.setAttribute(\"aria-label\", msg); }); div.append(this.loadingIconDiv); } } update({ scale = 0, rotation = null, optionalContentConfigPromise = null, drawingDelay = -1 }) { this.scale = scale || this.scale; if (typeof rotation === \"number\") { this.rotation = rotation; } if (optionalContentConfigPromise instanceof Promise) { this._optionalContentConfigPromise = optionalContentConfigPromise; optionalContentConfigPromise.then(optionalContentConfig => { if (optionalContentConfigPromise !== this._optionalContentConfigPromise) { return; } this.#useThumbnailCanvas.initialOptionalContent = optionalContentConfig.hasInitialVisibility; }); } const totalRotation = (this.rotation + this.pdfPageRotate) % 360; this.viewport = this.viewport.clone({ scale: this.scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS, rotation: totalRotation }); this.#setDimensions(); if (this._isStandalone) { _ui_utils.docStyle.setProperty(\"--scale-factor\", this.viewport.scale); } if (this.svg) { this.cssTransform({ target: this.svg, redrawAnnotationLayer: true, redrawAnnotationEditorLayer: true, redrawXfaLayer: true, redrawTextLayer: true }); this.eventBus.dispatch(\"pagerendered\", { source: this, pageNumber: this.id, cssTransform: true, timestamp: performance.now(), error: this._renderError }); return; } let isScalingRestricted = false; if (this.canvas && this.maxCanvasPixels > 0) { const outputScale = this.outputScale; if ((Math.floor(this.viewport.width) * outputScale.sx | 0) * (Math.floor(this.viewport.height) * outputScale.sy | 0) > this.maxCanvasPixels) { isScalingRestricted = true; } } const postponeDrawing = drawingDelay >= 0 && drawingDelay < 1000; if (this.canvas) { if (postponeDrawing || this.useOnlyCssZoom || this.hasRestrictedScaling && isScalingRestricted) { if (postponeDrawing && this.renderingState !== _ui_utils.RenderingStates.FINISHED) { this.cancelRendering({ keepZoomLayer: true, keepAnnotationLayer: true, keepAnnotationEditorLayer: true, keepXfaLayer: true, keepTextLayer: true, cancelExtraDelay: drawingDelay }); this.renderingState = _ui_utils.RenderingStates.FINISHED; } this.cssTransform({ target: this.canvas, redrawAnnotationLayer: true, redrawAnnotationEditorLayer: true, redrawXfaLayer: true, redrawTextLayer: !postponeDrawing, hideTextLayer: postponeDrawing }); this.eventBus.dispatch(\"pagerendered\", { source: this, pageNumber: this.id, cssTransform: true, timestamp: performance.now(), error: this._renderError }); return; } if (!this.zoomLayer && !this.canvas.hidden) { this.zoomLayer = this.canvas.parentNode; this.zoomLayer.style.position = \"absolute\"; } } if (this.zoomLayer) { this.cssTransform({ target: this.zoomLayer.firstChild }); } this.reset({ keepZoomLayer: true, keepAnnotationLayer: true, keepAnnotationEditorLayer: true, keepXfaLayer: true, keepTextLayer: true }); } cancelRendering({ keepAnnotationLayer = false, keepAnnotationEditorLayer = false, keepXfaLayer = false, keepTextLayer = false, cancelExtraDelay = 0 } = {}) { if (this.paintTask) { this.paintTask.cancel(cancelExtraDelay); this.paintTask = null; } this.resume = null; if (this.textLayer && (!keepTextLayer || !this.textLayer.div)) { this.textLayer.cancel(); this.textLayer = null; } if (this.structTreeLayer && !this.textLayer) { this.structTreeLayer = null; } if (this.annotationLayer && (!keepAnnotationLayer || !this.annotationLayer.div)) { this.annotationLayer.cancel(); this.annotationLayer = null; this._annotationCanvasMap = null; } if (this.annotationEditorLayer && (!keepAnnotationEditorLayer || !this.annotationEditorLayer.div)) { this.annotationEditorLayer.cancel(); this.annotationEditorLayer = null; } if (this.xfaLayer && (!keepXfaLayer || !this.xfaLayer.div)) { this.xfaLayer.cancel(); this.xfaLayer = null; this._textHighlighter?.disable(); } } cssTransform({ target, redrawAnnotationLayer = false, redrawAnnotationEditorLayer = false, redrawXfaLayer = false, redrawTextLayer = false, hideTextLayer = false }) { if (target instanceof HTMLCanvasElement) { if (!target.hasAttribute(\"zooming\")) { target.setAttribute(\"zooming\", true); const { style } = target; style.width = style.height = \"\"; } } else { const div = this.div; const { width, height } = this.viewport; target.style.width = target.parentNode.style.width = div.style.width = Math.floor(width) + \"px\"; target.style.height = target.parentNode.style.height = div.style.height = Math.floor(height) + \"px\"; } const originalViewport = this.paintedViewportMap.get(target); if (this.viewport !== originalViewport) { const relativeRotation = this.viewport.rotation - originalViewport.rotation; const absRotation = Math.abs(relativeRotation); let scaleX = 1, scaleY = 1; if (absRotation === 90 || absRotation === 270) { const { width, height } = this.viewport; scaleX = height / width; scaleY = width / height; } if (absRotation !== 0) { target.style.transform = `rotate(${relativeRotation}deg) scale(${scaleX}, ${scaleY})`; } } if (redrawAnnotationLayer && this.annotationLayer) { this.#renderAnnotationLayer(); } if (redrawAnnotationEditorLayer && this.annotationEditorLayer) { this.#renderAnnotationEditorLayer(); } if (redrawXfaLayer && this.xfaLayer) { this.#renderXfaLayer(); } if (this.textLayer) { if (hideTextLayer) { this.textLayer.hide(); } else if (redrawTextLayer) { this.#renderTextLayer(); } } } get width() { return this.viewport.width; } get height() { return this.viewport.height; } getPagePoint(x, y) { return this.viewport.convertToPdfPoint(x, y); } draw() { if (this.renderingState !== _ui_utils.RenderingStates.INITIAL) { console.error(\"Must be in new state before drawing\"); this.reset(); } const { div, pdfPage } = this; if (!pdfPage) { this.renderingState = _ui_utils.RenderingStates.FINISHED; return Promise.reject(new Error(\"pdfPage is not loaded\")); } this.renderingState = _ui_utils.RenderingStates.RUNNING; const canvasWrapper = document.createElement(\"div\"); canvasWrapper.classList.add(\"canvasWrapper\"); div.append(canvasWrapper); if (!this.textLayer && this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE && !pdfPage.isPureXfa) { this._accessibilityManager ||= new _text_accessibility.TextAccessibilityManager(); this.textLayer = new _text_layer_builder.TextLayerBuilder({ highlighter: this._textHighlighter, accessibilityManager: this._accessibilityManager, isOffscreenCanvasSupported: this.isOffscreenCanvasSupported }); div.append(this.textLayer.div); } if (!this.annotationLayer && this.#annotationMode !== _pdfjsLib.AnnotationMode.DISABLE) { const { annotationStorage, downloadManager, enableScripting, fieldObjectsPromise, hasJSActionsPromise, linkService } = this.#layerProperties(); this._annotationCanvasMap ||= new Map(); this.annotationLayer = new _annotation_layer_builder.AnnotationLayerBuilder({ pageDiv: div, pdfPage, annotationStorage, imageResourcesPath: this.imageResourcesPath, renderForms: this.#annotationMode === _pdfjsLib.AnnotationMode.ENABLE_FORMS, linkService, downloadManager, l10n: this.l10n, enableScripting, hasJSActionsPromise, fieldObjectsPromise, annotationCanvasMap: this._annotationCanvasMap, accessibilityManager: this._accessibilityManager }); } if (this.xfaLayer?.div) { div.append(this.xfaLayer.div); } let renderContinueCallback = null; if (this.renderingQueue) { renderContinueCallback = cont => { if (!this.renderingQueue.isHighestPriority(this)) { this.renderingState = _ui_utils.RenderingStates.PAUSED; this.resume = () => { this.renderingState = _ui_utils.RenderingStates.RUNNING; cont(); }; return; } cont(); }; } const finishPaintTask = async (error = null) => { if (paintTask === this.paintTask) { this.paintTask = null; } if (error instanceof _pdfjsLib.RenderingCancelledException) { this._renderError = null; return; } this._renderError = error; this.renderingState = _ui_utils.RenderingStates.FINISHED; this._resetZoomLayer(true); this.#useThumbnailCanvas.regularAnnotations = !paintTask.separateAnnots; this.eventBus.dispatch(\"pagerendered\", { source: this, pageNumber: this.id, cssTransform: false, timestamp: performance.now(), error: this._renderError }); if (error) { throw error; } }; const paintTask = this.renderer === _ui_utils.RendererType.SVG ? this.paintOnSvg(canvasWrapper) : this.paintOnCanvas(canvasWrapper); paintTask.onRenderContinue = renderContinueCallback; this.paintTask = paintTask; const resultPromise = paintTask.promise.then(() => { return finishPaintTask(null).then(async () => { this.#renderTextLayer(); if (this.annotationLayer) { await this.#renderAnnotationLayer(); } if (!this.annotationEditorLayer) { const { annotationEditorUIManager } = this.#layerProperties(); if (!annotationEditorUIManager) { return; } this.annotationEditorLayer = new _annotation_editor_layer_builder.AnnotationEditorLayerBuilder({ uiManager: annotationEditorUIManager, pageDiv: div, pdfPage, l10n: this.l10n, accessibilityManager: this._accessibilityManager }); } this.#renderAnnotationEditorLayer(); }); }, function (reason) { return finishPaintTask(reason); }); if (pdfPage.isPureXfa) { if (!this.xfaLayer) { const { annotationStorage, linkService } = this.#layerProperties(); this.xfaLayer = new _xfa_layer_builder.XfaLayerBuilder({ pageDiv: div, pdfPage, annotationStorage, linkService }); } this.#renderXfaLayer(); } div.setAttribute(\"data-loaded\", true); this.eventBus.dispatch(\"pagerender\", { source: this, pageNumber: this.id }); return resultPromise; } paintOnCanvas(canvasWrapper) { const renderCapability = (0, _pdfjsLib.createPromiseCapability)(); const result = { promise: renderCapability.promise, onRenderContinue(cont) { cont(); }, cancel(extraDelay = 0) { renderTask.cancel(extraDelay); }, get separateAnnots() { return renderTask.separateAnnots; } }; const viewport = this.viewport; const { width, height } = viewport; const canvas = document.createElement(\"canvas\"); canvas.setAttribute(\"role\", \"presentation\"); canvas.hidden = true; let isCanvasHidden = true; const showCanvas = function () { if (isCanvasHidden) { canvas.hidden = false; isCanvasHidden = false; } }; canvasWrapper.append(canvas); this.canvas = canvas; const ctx = canvas.getContext(\"2d\", { alpha: false }); const outputScale = this.outputScale = new _ui_utils.OutputScale(); if (this.useOnlyCssZoom) { const actualSizeViewport = viewport.clone({ scale: _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS }); outputScale.sx *= actualSizeViewport.width / width; outputScale.sy *= actualSizeViewport.height / height; } if (this.maxCanvasPixels > 0) { const pixelsInViewport = width * height; const maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport); if (outputScale.sx > maxScale || outputScale.sy > maxScale) { outputScale.sx = maxScale; outputScale.sy = maxScale; this.hasRestrictedScaling = true; } else { this.hasRestrictedScaling = false; } } const sfx = (0, _ui_utils.approximateFraction)(outputScale.sx); const sfy = (0, _ui_utils.approximateFraction)(outputScale.sy); canvas.width = (0, _ui_utils.roundToDivide)(viewport.width * outputScale.sx, sfx[0]); canvas.height = (0, _ui_utils.roundToDivide)(viewport.height * outputScale.sy, sfy[0]); const { style } = canvas; style.width = (0, _ui_utils.roundToDivide)(viewport.width, sfx[1]) + \"px\"; style.height = (0, _ui_utils.roundToDivide)(viewport.height, sfy[1]) + \"px\"; this.paintedViewportMap.set(canvas, viewport); const transform = outputScale.scaled ? [outputScale.sx, 0, 0, outputScale.sy, 0, 0] : null; const renderContext = { canvasContext: ctx, transform, viewport, annotationMode: this.#annotationMode, optionalContentConfigPromise: this._optionalContentConfigPromise, annotationCanvasMap: this._annotationCanvasMap, pageColors: this.pageColors }; const renderTask = this.pdfPage.render(renderContext); renderTask.onContinue = function (cont) { showCanvas(); if (result.onRenderContinue) { result.onRenderContinue(cont); } else { cont(); } }; renderTask.promise.then(function () { showCanvas(); renderCapability.resolve(); }, function (error) { showCanvas(); renderCapability.reject(error); }); return result; } paintOnSvg(wrapper) { let cancelled = false; const ensureNotCancelled = () => { if (cancelled) { throw new _pdfjsLib.RenderingCancelledException(`Rendering cancelled, page ${this.id}`, \"svg\"); } }; const pdfPage = this.pdfPage; const actualSizeViewport = this.viewport.clone({ scale: _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS }); const promise = pdfPage.getOperatorList({ annotationMode: this.#annotationMode }).then(opList => { ensureNotCancelled(); const svgGfx = new _pdfjsLib.SVGGraphics(pdfPage.commonObjs, pdfPage.objs); return svgGfx.getSVG(opList, actualSizeViewport).then(svg => { ensureNotCancelled(); this.svg = svg; this.paintedViewportMap.set(svg, actualSizeViewport); svg.style.width = wrapper.style.width; svg.style.height = wrapper.style.height; this.renderingState = _ui_utils.RenderingStates.FINISHED; wrapper.append(svg); }); }); return { promise, onRenderContinue(cont) { cont(); }, cancel() { cancelled = true; }, get separateAnnots() { return false; } }; } setPageLabel(label) { this.pageLabel = typeof label === \"string\" ? label : null; if (this.pageLabel !== null) { this.div.setAttribute(\"data-page-label\", this.pageLabel); } else { this.div.removeAttribute(\"data-page-label\"); } } get thumbnailCanvas() { const { initialOptionalContent, regularAnnotations } = this.#useThumbnailCanvas; return initialOptionalContent && regularAnnotations ? this.canvas : null; } } exports.PDFPageView = PDFPageView; /***/ }), /* 31 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.AnnotationEditorLayerBuilder = void 0; var _pdfjsLib = __webpack_require__(5); var _l10n_utils = __webpack_require__(29); class AnnotationEditorLayerBuilder { #uiManager; constructor(options) { this.pageDiv = options.pageDiv; this.pdfPage = options.pdfPage; this.accessibilityManager = options.accessibilityManager; this.l10n = options.l10n || _l10n_utils.NullL10n; this.annotationEditorLayer = null; this.div = null; this._cancelled = false; this.#uiManager = options.uiManager; } async render(viewport, intent = \"display\") { if (intent !== \"display\") { return; } if (this._cancelled) { return; } const clonedViewport = viewport.clone({ dontFlip: true }); if (this.div) { this.annotationEditorLayer.update({ viewport: clonedViewport }); this.show(); return; } const div = this.div = document.createElement(\"div\"); div.className = \"annotationEditorLayer\"; div.tabIndex = 0; this.pageDiv.append(div); this.annotationEditorLayer = new _pdfjsLib.AnnotationEditorLayer({ uiManager: this.#uiManager, div, accessibilityManager: this.accessibilityManager, pageIndex: this.pdfPage.pageNumber - 1, l10n: this.l10n, viewport: clonedViewport }); const parameters = { viewport: clonedViewport, div, annotations: null, intent }; this.annotationEditorLayer.render(parameters); } cancel() { this._cancelled = true; if (!this.div) { return; } this.pageDiv = null; this.annotationEditorLayer.destroy(); this.div.remove(); } hide() { if (!this.div) { return; } this.div.hidden = true; } show() { if (!this.div) { return; } this.div.hidden = false; } } exports.AnnotationEditorLayerBuilder = AnnotationEditorLayerBuilder; /***/ }), /* 32 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.AnnotationLayerBuilder = void 0; var _pdfjsLib = __webpack_require__(5); var _l10n_utils = __webpack_require__(29); var _ui_utils = __webpack_require__(1); class AnnotationLayerBuilder { #numAnnotations = 0; #onPresentationModeChanged = null; constructor({ pageDiv, pdfPage, linkService, downloadManager, annotationStorage = null, imageResourcesPath = \"\", renderForms = true, l10n = _l10n_utils.NullL10n, enableScripting = false, hasJSActionsPromise = null, fieldObjectsPromise = null, annotationCanvasMap = null, accessibilityManager = null }) { this.pageDiv = pageDiv; this.pdfPage = pdfPage; this.linkService = linkService; this.downloadManager = downloadManager; this.imageResourcesPath = imageResourcesPath; this.renderForms = renderForms; this.l10n = l10n; this.annotationStorage = annotationStorage; this.enableScripting = enableScripting; this._hasJSActionsPromise = hasJSActionsPromise || Promise.resolve(false); this._fieldObjectsPromise = fieldObjectsPromise || Promise.resolve(null); this._annotationCanvasMap = annotationCanvasMap; this._accessibilityManager = accessibilityManager; this.div = null; this._cancelled = false; this._eventBus = linkService.eventBus; } async render(viewport, intent = \"display\") { if (this.div) { if (this._cancelled || this.#numAnnotations === 0) { return; } _pdfjsLib.AnnotationLayer.update({ viewport: viewport.clone({ dontFlip: true }), div: this.div, annotationCanvasMap: this._annotationCanvasMap }); return; } const [annotations, hasJSActions, fieldObjects] = await Promise.all([this.pdfPage.getAnnotations({ intent }), this._hasJSActionsPromise, this._fieldObjectsPromise]); if (this._cancelled) { return; } this.#numAnnotations = annotations.length; this.div = document.createElement(\"div\"); this.div.className = \"annotationLayer\"; this.pageDiv.append(this.div); if (this.#numAnnotations === 0) { this.hide(); return; } _pdfjsLib.AnnotationLayer.render({ viewport: viewport.clone({ dontFlip: true }), div: this.div, annotations, page: this.pdfPage, imageResourcesPath: this.imageResourcesPath, renderForms: this.renderForms, linkService: this.linkService, downloadManager: this.downloadManager, annotationStorage: this.annotationStorage, enableScripting: this.enableScripting, hasJSActions, fieldObjects, annotationCanvasMap: this._annotationCanvasMap, accessibilityManager: this._accessibilityManager }); this.l10n.translate(this.div); if (this.linkService.isInPresentationMode) { this.#updatePresentationModeState(_ui_utils.PresentationModeState.FULLSCREEN); } if (!this.#onPresentationModeChanged) { this.#onPresentationModeChanged = evt => { this.#updatePresentationModeState(evt.state); }; this._eventBus?._on(\"presentationmodechanged\", this.#onPresentationModeChanged); } } cancel() { this._cancelled = true; if (this.#onPresentationModeChanged) { this._eventBus?._off(\"presentationmodechanged\", this.#onPresentationModeChanged); this.#onPresentationModeChanged = null; } } hide() { if (!this.div) { return; } this.div.hidden = true; } #updatePresentationModeState(state) { if (!this.div) { return; } let disableFormElements = false; switch (state) { case _ui_utils.PresentationModeState.FULLSCREEN: disableFormElements = true; break; case _ui_utils.PresentationModeState.NORMAL: break; default: return; } for (const section of this.div.childNodes) { if (section.hasAttribute(\"data-internal-link\")) { continue; } section.inert = disableFormElements; } } } exports.AnnotationLayerBuilder = AnnotationLayerBuilder; /***/ }), /* 33 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.StructTreeLayerBuilder = void 0; const PDF_ROLE_TO_HTML_ROLE = { Document: null, DocumentFragment: null, Part: \"group\", Sect: \"group\", Div: \"group\", Aside: \"note\", NonStruct: \"none\", P: null, H: \"heading\", Title: null, FENote: \"note\", Sub: \"group\", Lbl: null, Span: null, Em: null, Strong: null, Link: \"link\", Annot: \"note\", Form: \"form\", Ruby: null, RB: null, RT: null, RP: null, Warichu: null, WT: null, WP: null, L: \"list\", LI: \"listitem\", LBody: null, Table: \"table\", TR: \"row\", TH: \"columnheader\", TD: \"cell\", THead: \"columnheader\", TBody: null, TFoot: null, Caption: null, Figure: \"figure\", Formula: null, Artifact: null }; const HEADING_PATTERN = /^H(\\d+)$/; class StructTreeLayerBuilder { #treeDom = undefined; get renderingDone() { return this.#treeDom !== undefined; } render(structTree) { if (this.#treeDom !== undefined) { return this.#treeDom; } const treeDom = this.#walk(structTree); treeDom?.classList.add(\"structTree\"); return this.#treeDom = treeDom; } #setAttributes(structElement, htmlElement) { if (structElement.alt !== undefined) { htmlElement.setAttribute(\"aria-label\", structElement.alt); } if (structElement.id !== undefined) { htmlElement.setAttribute(\"aria-owns\", structElement.id); } if (structElement.lang !== undefined) { htmlElement.setAttribute(\"lang\", structElement.lang); } } #walk(node) { if (!node) { return null; } const element = document.createElement(\"span\"); if (\"role\" in node) { const { role } = node; const match = role.match(HEADING_PATTERN); if (match) { element.setAttribute(\"role\", \"heading\"); element.setAttribute(\"aria-level\", match[1]); } else if (PDF_ROLE_TO_HTML_ROLE[role]) { element.setAttribute(\"role\", PDF_ROLE_TO_HTML_ROLE[role]); } } this.#setAttributes(node, element); if (node.children) { if (node.children.length === 1 && \"id\" in node.children[0]) { this.#setAttributes(node.children[0], element); } else { for (const kid of node.children) { element.append(this.#walk(kid)); } } } return element; } } exports.StructTreeLayerBuilder = StructTreeLayerBuilder; /***/ }), /* 34 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.TextAccessibilityManager = void 0; var _ui_utils = __webpack_require__(1); class TextAccessibilityManager { #enabled = false; #textChildren = null; #textNodes = new Map(); #waitingElements = new Map(); setTextMapping(textDivs) { this.#textChildren = textDivs; } static #compareElementPositions(e1, e2) { const rect1 = e1.getBoundingClientRect(); const rect2 = e2.getBoundingClientRect(); if (rect1.width === 0 && rect1.height === 0) { return +1; } if (rect2.width === 0 && rect2.height === 0) { return -1; } const top1 = rect1.y; const bot1 = rect1.y + rect1.height; const mid1 = rect1.y + rect1.height / 2; const top2 = rect2.y; const bot2 = rect2.y + rect2.height; const mid2 = rect2.y + rect2.height / 2; if (mid1 = bot1) { return -1; } if (mid2 = bot2) { return +1; } const centerX1 = rect1.x + rect1.width / 2; const centerX2 = rect2.x + rect2.width / 2; return centerX1 - centerX2; } enable() { if (this.#enabled) { throw new Error(\"TextAccessibilityManager is already enabled.\"); } if (!this.#textChildren) { throw new Error(\"Text divs and strings have not been set.\"); } this.#enabled = true; this.#textChildren = this.#textChildren.slice(); this.#textChildren.sort(TextAccessibilityManager.#compareElementPositions); if (this.#textNodes.size > 0) { const textChildren = this.#textChildren; for (const [id, nodeIndex] of this.#textNodes) { const element = document.getElementById(id); if (!element) { this.#textNodes.delete(id); continue; } this.#addIdToAriaOwns(id, textChildren[nodeIndex]); } } for (const [element, isRemovable] of this.#waitingElements) { this.addPointerInTextLayer(element, isRemovable); } this.#waitingElements.clear(); } disable() { if (!this.#enabled) { return; } this.#waitingElements.clear(); this.#textChildren = null; this.#enabled = false; } removePointerInTextLayer(element) { if (!this.#enabled) { this.#waitingElements.delete(element); return; } const children = this.#textChildren; if (!children || children.length === 0) { return; } const { id } = element; const nodeIndex = this.#textNodes.get(id); if (nodeIndex === undefined) { return; } const node = children[nodeIndex]; this.#textNodes.delete(id); let owns = node.getAttribute(\"aria-owns\"); if (owns?.includes(id)) { owns = owns.split(\" \").filter(x => x !== id).join(\" \"); if (owns) { node.setAttribute(\"aria-owns\", owns); } else { node.removeAttribute(\"aria-owns\"); node.setAttribute(\"role\", \"presentation\"); } } } #addIdToAriaOwns(id, node) { const owns = node.getAttribute(\"aria-owns\"); if (!owns?.includes(id)) { node.setAttribute(\"aria-owns\", owns ? `${owns} ${id}` : id); } node.removeAttribute(\"role\"); } addPointerInTextLayer(element, isRemovable) { const { id } = element; if (!id) { return; } if (!this.#enabled) { this.#waitingElements.set(element, isRemovable); return; } if (isRemovable) { this.removePointerInTextLayer(element); } const children = this.#textChildren; if (!children || children.length === 0) { return; } const index = (0, _ui_utils.binarySearchFirstItem)(children, node => TextAccessibilityManager.#compareElementPositions(element, node) < 0); const nodeIndex = Math.max(0, index - 1); this.#addIdToAriaOwns(id, children[nodeIndex]); this.#textNodes.set(id, nodeIndex); } moveElementInDOM(container, element, contentElement, isRemovable) { this.addPointerInTextLayer(contentElement, isRemovable); if (!container.hasChildNodes()) { container.append(element); return; } const children = Array.from(container.childNodes).filter(node => node !== element); if (children.length === 0) { return; } const elementToCompare = contentElement || element; const index = (0, _ui_utils.binarySearchFirstItem)(children, node => TextAccessibilityManager.#compareElementPositions(elementToCompare, node) < 0); if (index === 0) { children[0].before(element); } else { children[index - 1].after(element); } } } exports.TextAccessibilityManager = TextAccessibilityManager; /***/ }), /* 35 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.TextHighlighter = void 0; class TextHighlighter { constructor({ findController, eventBus, pageIndex }) { this.findController = findController; this.matches = []; this.eventBus = eventBus; this.pageIdx = pageIndex; this._onUpdateTextLayerMatches = null; this.textDivs = null; this.textContentItemsStr = null; this.enabled = false; } setTextMapping(divs, texts) { this.textDivs = divs; this.textContentItemsStr = texts; } enable() { if (!this.textDivs || !this.textContentItemsStr) { throw new Error(\"Text divs and strings have not been set.\"); } if (this.enabled) { throw new Error(\"TextHighlighter is already enabled.\"); } this.enabled = true; if (!this._onUpdateTextLayerMatches) { this._onUpdateTextLayerMatches = evt => { if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) { this._updateMatches(); } }; this.eventBus._on(\"updatetextlayermatches\", this._onUpdateTextLayerMatches); } this._updateMatches(); } disable() { if (!this.enabled) { return; } this.enabled = false; if (this._onUpdateTextLayerMatches) { this.eventBus._off(\"updatetextlayermatches\", this._onUpdateTextLayerMatches); this._onUpdateTextLayerMatches = null; } this._updateMatches(true); } _convertMatches(matches, matchesLength) { if (!matches) { return []; } const { textContentItemsStr } = this; let i = 0, iIndex = 0; const end = textContentItemsStr.length - 1; const result = []; for (let m = 0, mm = matches.length; m < mm; m++) { let matchIdx = matches[m]; while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) { iIndex += textContentItemsStr[i].length; i++; } if (i === textContentItemsStr.length) { console.error(\"Could not find a matching mapping\"); } const match = { begin: { divIdx: i, offset: matchIdx - iIndex } }; matchIdx += matchesLength[m]; while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) { iIndex += textContentItemsStr[i].length; i++; } match.end = { divIdx: i, offset: matchIdx - iIndex }; result.push(match); } return result; } _renderMatches(matches) { if (matches.length === 0) { return; } const { findController, pageIdx } = this; const { textContentItemsStr, textDivs } = this; const isSelectedPage = pageIdx === findController.selected.pageIdx; const selectedMatchIdx = findController.selected.matchIdx; const highlightAll = findController.state.highlightAll; let prevEnd = null; const infinity = { divIdx: -1, offset: undefined }; function beginText(begin, className) { const divIdx = begin.divIdx; textDivs[divIdx].textContent = \"\"; return appendTextToDiv(divIdx, 0, begin.offset, className); } function appendTextToDiv(divIdx, fromOffset, toOffset, className) { let div = textDivs[divIdx]; if (div.nodeType === Node.TEXT_NODE) { const span = document.createElement(\"span\"); div.before(span); span.append(div); textDivs[divIdx] = span; div = span; } const content = textContentItemsStr[divIdx].substring(fromOffset, toOffset); const node = document.createTextNode(content); if (className) { const span = document.createElement(\"span\"); span.className = `${className} appended`; span.append(node); div.append(span); return className.includes(\"selected\") ? span.offsetLeft : 0; } div.append(node); return 0; } let i0 = selectedMatchIdx, i1 = i0 + 1; if (highlightAll) { i0 = 0; i1 = matches.length; } else if (!isSelectedPage) { return; } for (let i = i0; i < i1; i++) { const match = matches[i]; const begin = match.begin; const end = match.end; const isSelected = isSelectedPage && i === selectedMatchIdx; const highlightSuffix = isSelected ? \" selected\" : \"\"; let selectedLeft = 0; if (!prevEnd || begin.divIdx !== prevEnd.divIdx) { if (prevEnd !== null) { appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset); } beginText(begin); } else { appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset); } if (begin.divIdx === end.divIdx) { selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, end.offset, \"highlight\" + highlightSuffix); } else { selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, \"highlight begin\" + highlightSuffix); for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) { textDivs[n0].className = \"highlight middle\" + highlightSuffix; } beginText(end, \"highlight end\" + highlightSuffix); } prevEnd = end; if (isSelected) { findController.scrollMatchIntoView({ element: textDivs[begin.divIdx], selectedLeft, pageIndex: pageIdx, matchIndex: selectedMatchIdx }); } } if (prevEnd) { appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset); } } _updateMatches(reset = false) { if (!this.enabled && !reset) { return; } const { findController, matches, pageIdx } = this; const { textContentItemsStr, textDivs } = this; let clearedUntilDivIdx = -1; for (const match of matches) { const begin = Math.max(clearedUntilDivIdx, match.begin.divIdx); for (let n = begin, end = match.end.divIdx; n { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.TextLayerBuilder = void 0; var _pdfjsLib = __webpack_require__(5); class TextLayerBuilder { #rotation = 0; #scale = 0; #textContentSource = null; constructor({ highlighter = null, accessibilityManager = null, isOffscreenCanvasSupported = true }) { this.textContentItemsStr = []; this.renderingDone = false; this.textDivs = []; this.textDivProperties = new WeakMap(); this.textLayerRenderTask = null; this.highlighter = highlighter; this.accessibilityManager = accessibilityManager; this.isOffscreenCanvasSupported = isOffscreenCanvasSupported; this.div = document.createElement(\"div\"); this.div.className = \"textLayer\"; this.hide(); } #finishRendering() { this.renderingDone = true; const endOfContent = document.createElement(\"div\"); endOfContent.className = \"endOfContent\"; this.div.append(endOfContent); this.#bindMouse(); } get numTextDivs() { return this.textDivs.length; } async render(viewport) { if (!this.#textContentSource) { throw new Error('No \"textContentSource\" parameter specified.'); } const scale = viewport.scale * (globalThis.devicePixelRatio || 1); const { rotation } = viewport; if (this.renderingDone) { const mustRotate = rotation !== this.#rotation; const mustRescale = scale !== this.#scale; if (mustRotate || mustRescale) { this.hide(); (0, _pdfjsLib.updateTextLayer)({ container: this.div, viewport, textDivs: this.textDivs, textDivProperties: this.textDivProperties, isOffscreenCanvasSupported: this.isOffscreenCanvasSupported, mustRescale, mustRotate }); this.#scale = scale; this.#rotation = rotation; } this.show(); return; } this.cancel(); this.highlighter?.setTextMapping(this.textDivs, this.textContentItemsStr); this.accessibilityManager?.setTextMapping(this.textDivs); this.textLayerRenderTask = (0, _pdfjsLib.renderTextLayer)({ textContentSource: this.#textContentSource, container: this.div, viewport, textDivs: this.textDivs, textDivProperties: this.textDivProperties, textContentItemsStr: this.textContentItemsStr, isOffscreenCanvasSupported: this.isOffscreenCanvasSupported }); await this.textLayerRenderTask.promise; this.#finishRendering(); this.#scale = scale; this.#rotation = rotation; this.show(); this.accessibilityManager?.enable(); } hide() { if (!this.div.hidden) { this.highlighter?.disable(); this.div.hidden = true; } } show() { if (this.div.hidden && this.renderingDone) { this.div.hidden = false; this.highlighter?.enable(); } } cancel() { if (this.textLayerRenderTask) { this.textLayerRenderTask.cancel(); this.textLayerRenderTask = null; } this.highlighter?.disable(); this.accessibilityManager?.disable(); this.textContentItemsStr.length = 0; this.textDivs.length = 0; this.textDivProperties = new WeakMap(); } setTextContentSource(source) { this.cancel(); this.#textContentSource = source; } #bindMouse() { const { div } = this; div.addEventListener(\"mousedown\", evt => { const end = div.querySelector(\".endOfContent\"); if (!end) { return; } let adjustTop = evt.target !== div; adjustTop &&= getComputedStyle(end).getPropertyValue(\"-moz-user-select\") !== \"none\"; if (adjustTop) { const divBounds = div.getBoundingClientRect(); const r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height); end.style.top = (r * 100).toFixed(2) + \"%\"; } end.classList.add(\"active\"); }); div.addEventListener(\"mouseup\", () => { const end = div.querySelector(\".endOfContent\"); if (!end) { return; } end.style.top = \"\"; end.classList.remove(\"active\"); }); } } exports.TextLayerBuilder = TextLayerBuilder; /***/ }), /* 37 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.XfaLayerBuilder = void 0; var _pdfjsLib = __webpack_require__(5); class XfaLayerBuilder { constructor({ pageDiv, pdfPage, annotationStorage = null, linkService, xfaHtml = null }) { this.pageDiv = pageDiv; this.pdfPage = pdfPage; this.annotationStorage = annotationStorage; this.linkService = linkService; this.xfaHtml = xfaHtml; this.div = null; this._cancelled = false; } async render(viewport, intent = \"display\") { if (intent === \"print\") { const parameters = { viewport: viewport.clone({ dontFlip: true }), div: this.div, xfaHtml: this.xfaHtml, annotationStorage: this.annotationStorage, linkService: this.linkService, intent }; const div = document.createElement(\"div\"); this.pageDiv.append(div); parameters.div = div; return _pdfjsLib.XfaLayer.render(parameters); } const xfaHtml = await this.pdfPage.getXfa(); if (this._cancelled || !xfaHtml) { return { textDivs: [] }; } const parameters = { viewport: viewport.clone({ dontFlip: true }), div: this.div, xfaHtml, annotationStorage: this.annotationStorage, linkService: this.linkService, intent }; if (this.div) { return _pdfjsLib.XfaLayer.update(parameters); } this.div = document.createElement(\"div\"); this.pageDiv.append(this.div); parameters.div = this.div; return _pdfjsLib.XfaLayer.render(parameters); } cancel() { this._cancelled = true; } hide() { if (!this.div) { return; } this.div.hidden = true; } } exports.XfaLayerBuilder = XfaLayerBuilder; /***/ }), /* 38 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.SecondaryToolbar = void 0; var _ui_utils = __webpack_require__(1); var _pdf_cursor_tools = __webpack_require__(7); var _pdf_viewer = __webpack_require__(28); class SecondaryToolbar { constructor(options, eventBus, externalServices) { this.toolbar = options.toolbar; this.toggleButton = options.toggleButton; this.buttons = [{ element: options.presentationModeButton, eventName: \"presentationmode\", close: true }, { element: options.printButton, eventName: \"print\", close: true }, { element: options.downloadButton, eventName: \"download\", close: true }, { element: options.viewBookmarkButton, eventName: null, close: true }, { element: options.firstPageButton, eventName: \"firstpage\", close: true }, { element: options.lastPageButton, eventName: \"lastpage\", close: true }, { element: options.pageRotateCwButton, eventName: \"rotatecw\", close: false }, { element: options.pageRotateCcwButton, eventName: \"rotateccw\", close: false }, { element: options.cursorSelectToolButton, eventName: \"switchcursortool\", eventDetails: { tool: _pdf_cursor_tools.CursorTool.SELECT }, close: true }, { element: options.cursorHandToolButton, eventName: \"switchcursortool\", eventDetails: { tool: _pdf_cursor_tools.CursorTool.HAND }, close: true }, { element: options.scrollPageButton, eventName: \"switchscrollmode\", eventDetails: { mode: _ui_utils.ScrollMode.PAGE }, close: true }, { element: options.scrollVerticalButton, eventName: \"switchscrollmode\", eventDetails: { mode: _ui_utils.ScrollMode.VERTICAL }, close: true }, { element: options.scrollHorizontalButton, eventName: \"switchscrollmode\", eventDetails: { mode: _ui_utils.ScrollMode.HORIZONTAL }, close: true }, { element: options.scrollWrappedButton, eventName: \"switchscrollmode\", eventDetails: { mode: _ui_utils.ScrollMode.WRAPPED }, close: true }, { element: options.spreadNoneButton, eventName: \"switchspreadmode\", eventDetails: { mode: _ui_utils.SpreadMode.NONE }, close: true }, { element: options.spreadOddButton, eventName: \"switchspreadmode\", eventDetails: { mode: _ui_utils.SpreadMode.ODD }, close: true }, { element: options.spreadEvenButton, eventName: \"switchspreadmode\", eventDetails: { mode: _ui_utils.SpreadMode.EVEN }, close: true }, { element: options.documentPropertiesButton, eventName: \"documentproperties\", close: true }]; this.buttons.push({ element: options.openFileButton, eventName: \"openfile\", close: true }); this.items = { firstPage: options.firstPageButton, lastPage: options.lastPageButton, pageRotateCw: options.pageRotateCwButton, pageRotateCcw: options.pageRotateCcwButton }; this.eventBus = eventBus; this.externalServices = externalServices; this.opened = false; this.#bindClickListeners(); this.#bindCursorToolsListener(options); this.#bindScrollModeListener(options); this.#bindSpreadModeListener(options); this.reset(); } get isOpen() { return this.opened; } setPageNumber(pageNumber) { this.pageNumber = pageNumber; this.#updateUIState(); } setPagesCount(pagesCount) { this.pagesCount = pagesCount; this.#updateUIState(); } reset() { this.pageNumber = 0; this.pagesCount = 0; this.#updateUIState(); this.eventBus.dispatch(\"secondarytoolbarreset\", { source: this }); } #updateUIState() { this.items.firstPage.disabled = this.pageNumber = this.pagesCount; this.items.pageRotateCw.disabled = this.pagesCount === 0; this.items.pageRotateCcw.disabled = this.pagesCount === 0; } #bindClickListeners() { this.toggleButton.addEventListener(\"click\", this.toggle.bind(this)); for (const { element, eventName, close, eventDetails } of this.buttons) { element.addEventListener(\"click\", evt => { if (eventName !== null) { const details = { source: this }; for (const property in eventDetails) { details[property] = eventDetails[property]; } this.eventBus.dispatch(eventName, details); } if (close) { this.close(); } this.externalServices.reportTelemetry({ type: \"buttons\", data: { id: element.id } }); }); } } #bindCursorToolsListener({ cursorSelectToolButton, cursorHandToolButton }) { this.eventBus._on(\"cursortoolchanged\", function ({ tool }) { const isSelect = tool === _pdf_cursor_tools.CursorTool.SELECT, isHand = tool === _pdf_cursor_tools.CursorTool.HAND; cursorSelectToolButton.classList.toggle(\"toggled\", isSelect); cursorHandToolButton.classList.toggle(\"toggled\", isHand); cursorSelectToolButton.setAttribute(\"aria-checked\", isSelect); cursorHandToolButton.setAttribute(\"aria-checked\", isHand); }); } #bindScrollModeListener({ scrollPageButton, scrollVerticalButton, scrollHorizontalButton, scrollWrappedButton, spreadNoneButton, spreadOddButton, spreadEvenButton }) { const scrollModeChanged = ({ mode }) => { const isPage = mode === _ui_utils.ScrollMode.PAGE, isVertical = mode === _ui_utils.ScrollMode.VERTICAL, isHorizontal = mode === _ui_utils.ScrollMode.HORIZONTAL, isWrapped = mode === _ui_utils.ScrollMode.WRAPPED; scrollPageButton.classList.toggle(\"toggled\", isPage); scrollVerticalButton.classList.toggle(\"toggled\", isVertical); scrollHorizontalButton.classList.toggle(\"toggled\", isHorizontal); scrollWrappedButton.classList.toggle(\"toggled\", isWrapped); scrollPageButton.setAttribute(\"aria-checked\", isPage); scrollVerticalButton.setAttribute(\"aria-checked\", isVertical); scrollHorizontalButton.setAttribute(\"aria-checked\", isHorizontal); scrollWrappedButton.setAttribute(\"aria-checked\", isWrapped); const forceScrollModePage = this.pagesCount > _pdf_viewer.PagesCountLimit.FORCE_SCROLL_MODE_PAGE; scrollPageButton.disabled = forceScrollModePage; scrollVerticalButton.disabled = forceScrollModePage; scrollHorizontalButton.disabled = forceScrollModePage; scrollWrappedButton.disabled = forceScrollModePage; spreadNoneButton.disabled = isHorizontal; spreadOddButton.disabled = isHorizontal; spreadEvenButton.disabled = isHorizontal; }; this.eventBus._on(\"scrollmodechanged\", scrollModeChanged); this.eventBus._on(\"secondarytoolbarreset\", evt => { if (evt.source === this) { scrollModeChanged({ mode: _ui_utils.ScrollMode.VERTICAL }); } }); } #bindSpreadModeListener({ spreadNoneButton, spreadOddButton, spreadEvenButton }) { function spreadModeChanged({ mode }) { const isNone = mode === _ui_utils.SpreadMode.NONE, isOdd = mode === _ui_utils.SpreadMode.ODD, isEven = mode === _ui_utils.SpreadMode.EVEN; spreadNoneButton.classList.toggle(\"toggled\", isNone); spreadOddButton.classList.toggle(\"toggled\", isOdd); spreadEvenButton.classList.toggle(\"toggled\", isEven); spreadNoneButton.setAttribute(\"aria-checked\", isNone); spreadOddButton.setAttribute(\"aria-checked\", isOdd); spreadEvenButton.setAttribute(\"aria-checked\", isEven); } this.eventBus._on(\"spreadmodechanged\", spreadModeChanged); this.eventBus._on(\"secondarytoolbarreset\", evt => { if (evt.source === this) { spreadModeChanged({ mode: _ui_utils.SpreadMode.NONE }); } }); } open() { if (this.opened) { return; } this.opened = true; this.toggleButton.classList.add(\"toggled\"); this.toggleButton.setAttribute(\"aria-expanded\", \"true\"); this.toolbar.classList.remove(\"hidden\"); } close() { if (!this.opened) { return; } this.opened = false; this.toolbar.classList.add(\"hidden\"); this.toggleButton.classList.remove(\"toggled\"); this.toggleButton.setAttribute(\"aria-expanded\", \"false\"); } toggle() { if (this.opened) { this.close(); } else { this.open(); } } } exports.SecondaryToolbar = SecondaryToolbar; /***/ }), /* 39 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.Toolbar = void 0; var _ui_utils = __webpack_require__(1); var _pdfjsLib = __webpack_require__(5); const PAGE_NUMBER_LOADING_INDICATOR = \"visiblePageIsLoading\"; class Toolbar { #wasLocalized = false; constructor(options, eventBus, l10n) { this.toolbar = options.container; this.eventBus = eventBus; this.l10n = l10n; this.buttons = [{ element: options.previous, eventName: \"previouspage\" }, { element: options.next, eventName: \"nextpage\" }, { element: options.zoomIn, eventName: \"zoomin\" }, { element: options.zoomOut, eventName: \"zoomout\" }, { element: options.print, eventName: \"print\" }, { element: options.download, eventName: \"download\" }, { element: options.editorFreeTextButton, eventName: \"switchannotationeditormode\", eventDetails: { get mode() { const { classList } = options.editorFreeTextButton; return classList.contains(\"toggled\") ? _pdfjsLib.AnnotationEditorType.NONE : _pdfjsLib.AnnotationEditorType.FREETEXT; } } }, { element: options.editorInkButton, eventName: \"switchannotationeditormode\", eventDetails: { get mode() { const { classList } = options.editorInkButton; return classList.contains(\"toggled\") ? _pdfjsLib.AnnotationEditorType.NONE : _pdfjsLib.AnnotationEditorType.INK; } } }]; this.buttons.push({ element: options.openFile, eventName: \"openfile\" }); this.items = { numPages: options.numPages, pageNumber: options.pageNumber, scaleSelect: options.scaleSelect, customScaleOption: options.customScaleOption, previous: options.previous, next: options.next, zoomIn: options.zoomIn, zoomOut: options.zoomOut }; this.#bindListeners(options); this.reset(); } setPageNumber(pageNumber, pageLabel) { this.pageNumber = pageNumber; this.pageLabel = pageLabel; this.#updateUIState(false); } setPagesCount(pagesCount, hasPageLabels) { this.pagesCount = pagesCount; this.hasPageLabels = hasPageLabels; this.#updateUIState(true); } setPageScale(pageScaleValue, pageScale) { this.pageScaleValue = (pageScaleValue || pageScale).toString(); this.pageScale = pageScale; this.#updateUIState(false); } reset() { this.pageNumber = 0; this.pageLabel = null; this.hasPageLabels = false; this.pagesCount = 0; this.pageScaleValue = _ui_utils.DEFAULT_SCALE_VALUE; this.pageScale = _ui_utils.DEFAULT_SCALE; this.#updateUIState(true); this.updateLoadingIndicatorState(); this.eventBus.dispatch(\"toolbarreset\", { source: this }); } #bindListeners(options) { const { pageNumber, scaleSelect } = this.items; const self = this; for (const { element, eventName, eventDetails } of this.buttons) { element.addEventListener(\"click\", evt => { if (eventName !== null) { const details = { source: this }; if (eventDetails) { for (const property in eventDetails) { details[property] = eventDetails[property]; } } this.eventBus.dispatch(eventName, details); } }); } pageNumber.addEventListener(\"click\", function () { this.select(); }); pageNumber.addEventListener(\"change\", function () { self.eventBus.dispatch(\"pagenumberchanged\", { source: self, value: this.value }); }); scaleSelect.addEventListener(\"change\", function () { if (this.value === \"custom\") { return; } self.eventBus.dispatch(\"scalechanged\", { source: self, value: this.value }); }); scaleSelect.addEventListener(\"click\", function (evt) { const target = evt.target; if (this.value === self.pageScaleValue && target.tagName.toUpperCase() === \"OPTION\") { this.blur(); } }); scaleSelect.oncontextmenu = _ui_utils.noContextMenuHandler; this.eventBus._on(\"localized\", () => { this.#wasLocalized = true; this.#adjustScaleWidth(); this.#updateUIState(true); }); this.#bindEditorToolsListener(options); } #bindEditorToolsListener({ editorFreeTextButton, editorFreeTextParamsToolbar, editorInkButton, editorInkParamsToolbar }) { const editorModeChanged = (evt, disableButtons = false) => { const editorButtons = [{ mode: _pdfjsLib.AnnotationEditorType.FREETEXT, button: editorFreeTextButton, toolbar: editorFreeTextParamsToolbar }, { mode: _pdfjsLib.AnnotationEditorType.INK, button: editorInkButton, toolbar: editorInkParamsToolbar }]; for (const { mode, button, toolbar } of editorButtons) { const checked = mode === evt.mode; button.classList.toggle(\"toggled\", checked); button.setAttribute(\"aria-checked\", checked); button.disabled = disableButtons; toolbar?.classList.toggle(\"hidden\", !checked); } }; this.eventBus._on(\"annotationeditormodechanged\", editorModeChanged); this.eventBus._on(\"toolbarreset\", evt => { if (evt.source === this) { editorModeChanged({ mode: _pdfjsLib.AnnotationEditorType.NONE }, true); } }); } #updateUIState(resetNumPages = false) { if (!this.#wasLocalized) { return; } const { pageNumber, pagesCount, pageScaleValue, pageScale, items } = this; if (resetNumPages) { if (this.hasPageLabels) { items.pageNumber.type = \"text\"; } else { items.pageNumber.type = \"number\"; this.l10n.get(\"of_pages\", { pagesCount }).then(msg => { items.numPages.textContent = msg; }); } items.pageNumber.max = pagesCount; } if (this.hasPageLabels) { items.pageNumber.value = this.pageLabel; this.l10n.get(\"page_of_pages\", { pageNumber, pagesCount }).then(msg => { items.numPages.textContent = msg; }); } else { items.pageNumber.value = pageNumber; } items.previous.disabled = pageNumber = pagesCount; items.zoomOut.disabled = pageScale = _ui_utils.MAX_SCALE; this.l10n.get(\"page_scale_percent\", { scale: Math.round(pageScale * 10000) / 100 }).then(msg => { let predefinedValueFound = false; for (const option of items.scaleSelect.options) { if (option.value !== pageScaleValue) { option.selected = false; continue; } option.selected = true; predefinedValueFound = true; } if (!predefinedValueFound) { items.customScaleOption.textContent = msg; items.customScaleOption.selected = true; } }); } updateLoadingIndicatorState(loading = false) { const { pageNumber } = this.items; pageNumber.classList.toggle(PAGE_NUMBER_LOADING_INDICATOR, loading); } async #adjustScaleWidth() { const { items, l10n } = this; const predefinedValuesPromise = Promise.all([l10n.get(\"page_scale_auto\"), l10n.get(\"page_scale_actual\"), l10n.get(\"page_scale_fit\"), l10n.get(\"page_scale_width\")]); await _ui_utils.animationStarted; const style = getComputedStyle(items.scaleSelect); const scaleSelectWidth = parseFloat(style.getPropertyValue(\"--scale-select-width\")); const canvas = document.createElement(\"canvas\"); const ctx = canvas.getContext(\"2d\", { alpha: false }); ctx.font = `${style.fontSize} ${style.fontFamily}`; let maxWidth = 0; for (const predefinedValue of await predefinedValuesPromise) { const { width } = ctx.measureText(predefinedValue); if (width > maxWidth) { maxWidth = width; } } maxWidth += 0.3 * scaleSelectWidth; if (maxWidth > scaleSelectWidth) { _ui_utils.docStyle.setProperty(\"--scale-select-width\", `${maxWidth}px`); } canvas.width = 0; canvas.height = 0; } } exports.Toolbar = Toolbar; /***/ }), /* 40 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.ViewHistory = void 0; const DEFAULT_VIEW_HISTORY_CACHE_SIZE = 20; class ViewHistory { constructor(fingerprint, cacheSize = DEFAULT_VIEW_HISTORY_CACHE_SIZE) { this.fingerprint = fingerprint; this.cacheSize = cacheSize; this._initializedPromise = this._readFromStorage().then(databaseStr => { const database = JSON.parse(databaseStr || \"{}\"); let index = -1; if (!Array.isArray(database.files)) { database.files = []; } else { while (database.files.length >= this.cacheSize) { database.files.shift(); } for (let i = 0, ii = database.files.length; i < ii; i++) { const branch = database.files[i]; if (branch.fingerprint === this.fingerprint) { index = i; break; } } } if (index === -1) { index = database.files.push({ fingerprint: this.fingerprint }) - 1; } this.file = database.files[index]; this.database = database; }); } async _writeToStorage() { const databaseStr = JSON.stringify(this.database); localStorage.setItem(\"pdfjs.history\", databaseStr); } async _readFromStorage() { return localStorage.getItem(\"pdfjs.history\"); } async set(name, val) { await this._initializedPromise; this.file[name] = val; return this._writeToStorage(); } async setMultiple(properties) { await this._initializedPromise; for (const name in properties) { this.file[name] = properties[name]; } return this._writeToStorage(); } async get(name, defaultValue) { await this._initializedPromise; const val = this.file[name]; return val !== undefined ? val : defaultValue; } async getMultiple(properties) { await this._initializedPromise; const values = Object.create(null); for (const name in properties) { const val = this.file[name]; values[name] = val !== undefined ? val : properties[name]; } return values; } } exports.ViewHistory = ViewHistory; /***/ }), /* 41 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.GenericCom = void 0; var _app = __webpack_require__(4); var _preferences = __webpack_require__(42); var _download_manager = __webpack_require__(43); var _genericl10n = __webpack_require__(44); var _generic_scripting = __webpack_require__(46); ; const GenericCom = {}; exports.GenericCom = GenericCom; class GenericPreferences extends _preferences.BasePreferences { async _writeToStorage(prefObj) { localStorage.setItem(\"pdfjs.preferences\", JSON.stringify(prefObj)); } async _readFromStorage(prefObj) { return JSON.parse(localStorage.getItem(\"pdfjs.preferences\")); } } class GenericExternalServices extends _app.DefaultExternalServices { static createDownloadManager() { return new _download_manager.DownloadManager(); } static createPreferences() { return new GenericPreferences(); } static createL10n({ locale = \"en-US\" }) { return new _genericl10n.GenericL10n(locale); } static createScripting({ sandboxBundleSrc }) { return new _generic_scripting.GenericScripting(sandboxBundleSrc); } } _app.PDFViewerApplication.externalServices = GenericExternalServices; /***/ }), /* 42 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.BasePreferences = void 0; var _app_options = __webpack_require__(2); class BasePreferences { #defaults = Object.freeze({ \"annotationEditorMode\": 0, \"annotationMode\": 2, \"cursorToolOnLoad\": 0, \"defaultZoomDelay\": -1, \"defaultZoomValue\": \"\", \"disablePageLabels\": false, \"enablePermissions\": false, \"enablePrintAutoRotate\": true, \"enableScripting\": true, \"externalLinkTarget\": 0, \"historyUpdateUrl\": false, \"ignoreDestinationZoom\": false, \"forcePageColors\": false, \"pageColorsBackground\": \"Canvas\", \"pageColorsForeground\": \"CanvasText\", \"pdfBugEnabled\": false, \"sidebarViewOnLoad\": -1, \"scrollModeOnLoad\": -1, \"spreadModeOnLoad\": -1, \"textLayerMode\": 1, \"useOnlyCssZoom\": false, \"viewerCssTheme\": 0, \"viewOnLoad\": 0, \"disableAutoFetch\": false, \"disableFontFace\": false, \"disableRange\": false, \"disableStream\": false, \"enableXfa\": true, \"renderer\": \"canvas\" }); #prefs = Object.create(null); #initializedPromise = null; constructor() { if (this.constructor === BasePreferences) { throw new Error(\"Cannot initialize BasePreferences.\"); } this.#initializedPromise = this._readFromStorage(this.#defaults).then(prefs => { for (const name in this.#defaults) { const prefValue = prefs?.[name]; if (typeof prefValue === typeof this.#defaults[name]) { this.#prefs[name] = prefValue; } } }); } async _writeToStorage(prefObj) { throw new Error(\"Not implemented: _writeToStorage\"); } async _readFromStorage(prefObj) { throw new Error(\"Not implemented: _readFromStorage\"); } async reset() { await this.#initializedPromise; const prefs = this.#prefs; this.#prefs = Object.create(null); return this._writeToStorage(this.#defaults).catch(reason => { this.#prefs = prefs; throw reason; }); } async set(name, value) { await this.#initializedPromise; const defaultValue = this.#defaults[name], prefs = this.#prefs; if (defaultValue === undefined) { throw new Error(`Set preference: \"${name}\" is undefined.`); } else if (value === undefined) { throw new Error(\"Set preference: no value is specified.\"); } const valueType = typeof value, defaultType = typeof defaultValue; if (valueType !== defaultType) { if (valueType === \"number\" && defaultType === \"string\") { value = value.toString(); } else { throw new Error(`Set preference: \"${value}\" is a ${valueType}, expected a ${defaultType}.`); } } else { if (valueType === \"number\" && !Number.isInteger(value)) { throw new Error(`Set preference: \"${value}\" must be an integer.`); } } this.#prefs[name] = value; return this._writeToStorage(this.#prefs).catch(reason => { this.#prefs = prefs; throw reason; }); } async get(name) { await this.#initializedPromise; const defaultValue = this.#defaults[name]; if (defaultValue === undefined) { throw new Error(`Get preference: \"${name}\" is undefined.`); } return this.#prefs[name] ?? defaultValue; } async getAll() { await this.#initializedPromise; const obj = Object.create(null); for (const name in this.#defaults) { obj[name] = this.#prefs[name] ?? this.#defaults[name]; } return obj; } } exports.BasePreferences = BasePreferences; /***/ }), /* 43 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.DownloadManager = void 0; var _pdfjsLib = __webpack_require__(5); ; function download(blobUrl, filename) { const a = document.createElement(\"a\"); if (!a.click) { throw new Error('DownloadManager: \"a.click()\" is not supported.'); } a.href = blobUrl; a.target = \"_parent\"; if (\"download\" in a) { a.download = filename; } (document.body || document.documentElement).append(a); a.click(); a.remove(); } class DownloadManager { #openBlobUrls = new WeakMap(); downloadUrl(url, filename) { if (!(0, _pdfjsLib.createValidAbsoluteUrl)(url, \"http://example.com\")) { console.error(`downloadUrl - not a valid URL: ${url}`); return; } download(url + \"#pdfjs.action=download\", filename); } downloadData(data, filename, contentType) { const blobUrl = URL.createObjectURL(new Blob([data], { type: contentType })); download(blobUrl, filename); } openOrDownloadData(element, data, filename) { const isPdfData = (0, _pdfjsLib.isPdfFile)(filename); const contentType = isPdfData ? \"application/pdf\" : \"\"; if (isPdfData) { let blobUrl = this.#openBlobUrls.get(element); if (!blobUrl) { blobUrl = URL.createObjectURL(new Blob([data], { type: contentType })); this.#openBlobUrls.set(element, blobUrl); } let viewerUrl; viewerUrl = \"?file=\" + encodeURIComponent(blobUrl + \"#\" + filename); try { window.open(viewerUrl); return true; } catch (ex) { console.error(`openOrDownloadData: ${ex}`); URL.revokeObjectURL(blobUrl); this.#openBlobUrls.delete(element); } } this.downloadData(data, filename, contentType); return false; } download(blob, url, filename) { const blobUrl = URL.createObjectURL(blob); download(blobUrl, filename); } } exports.DownloadManager = DownloadManager; /***/ }), /* 44 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.GenericL10n = void 0; __webpack_require__(45); var _l10n_utils = __webpack_require__(29); const webL10n = document.webL10n; class GenericL10n { constructor(lang) { this._lang = lang; this._ready = new Promise((resolve, reject) => { webL10n.setLanguage((0, _l10n_utils.fixupLangCode)(lang), () => { resolve(webL10n); }); }); } async getLanguage() { const l10n = await this._ready; return l10n.getLanguage(); } async getDirection() { const l10n = await this._ready; return l10n.getDirection(); } async get(key, args = null, fallback = (0, _l10n_utils.getL10nFallback)(key, args)) { const l10n = await this._ready; return l10n.get(key, args, fallback); } async translate(element) { const l10n = await this._ready; return l10n.translate(element); } } exports.GenericL10n = GenericL10n; /***/ }), /* 45 */ /***/ (() => { document.webL10n = function (window, document, undefined) { var gL10nData = {}; var gTextData = ''; var gTextProp = 'textContent'; var gLanguage = ''; var gMacros = {}; var gReadyState = 'loading'; var gAsyncResourceLoading = true; function getL10nResourceLinks() { return document.querySelectorAll('link[type=\"application/l10n\"]'); } function getL10nDictionary() { var script = document.querySelector('script[type=\"application/l10n\"]'); return script ? JSON.parse(script.innerHTML) : null; } function getTranslatableChildren(element) { return element ? element.querySelectorAll('*[data-l10n-id]') : []; } function getL10nAttributes(element) { if (!element) return {}; var l10nId = element.getAttribute('data-l10n-id'); var l10nArgs = element.getAttribute('data-l10n-args'); var args = {}; if (l10nArgs) { try { args = JSON.parse(l10nArgs); } catch (e) { console.warn('could not parse arguments for #' + l10nId); } } return { id: l10nId, args: args }; } function xhrLoadText(url, onSuccess, onFailure) { onSuccess = onSuccess || function _onSuccess(data) {}; onFailure = onFailure || function _onFailure() {}; var xhr = new XMLHttpRequest(); xhr.open('GET', url, gAsyncResourceLoading); if (xhr.overrideMimeType) { xhr.overrideMimeType('text/plain; charset=utf-8'); } xhr.onreadystatechange = function () { if (xhr.readyState == 4) { if (xhr.status == 200 || xhr.status === 0) { onSuccess(xhr.responseText); } else { onFailure(); } } }; xhr.onerror = onFailure; xhr.ontimeout = onFailure; try { xhr.send(null); } catch (e) { onFailure(); } } function parseResource(href, lang, successCallback, failureCallback) { var baseURL = href.replace(/[^\\/]*$/, '') || './'; function evalString(text) { if (text.lastIndexOf('\\\\') < 0) return text; return text.replace(/\\\\\\\\/g, '\\\\').replace(/\\\\n/g, '\\n').replace(/\\\\r/g, '\\r').replace(/\\\\t/g, '\\t').replace(/\\\\b/g, '\\b').replace(/\\\\f/g, '\\f').replace(/\\\\{/g, '{').replace(/\\\\}/g, '}').replace(/\\\\\"/g, '\"').replace(/\\\\'/g, \"'\"); } function parseProperties(text, parsedPropertiesCallback) { var dictionary = {}; var reBlank = /^\\s*|\\s*$/; var reComment = /^\\s*#|^\\s*$/; var reSection = /^\\s*\\[(.*)\\]\\s*$/; var reImport = /^\\s*@import\\s+url\\((.*)\\)\\s*$/i; var reSplit = /^([^=\\s]*)\\s*=\\s*(.+)$/; function parseRawLines(rawText, extendedSyntax, parsedRawLinesCallback) { var entries = rawText.replace(reBlank, '').split(/[\\r\\n]+/); var currentLang = '*'; var genericLang = lang.split('-', 1)[0]; var skipLang = false; var match = ''; function nextEntry() { while (true) { if (!entries.length) { parsedRawLinesCallback(); return; } var line = entries.shift(); if (reComment.test(line)) continue; if (extendedSyntax) { match = reSection.exec(line); if (match) { currentLang = match[1].toLowerCase(); skipLang = currentLang !== '*' && currentLang !== lang && currentLang !== genericLang; continue; } else if (skipLang) { continue; } match = reImport.exec(line); if (match) { loadImport(baseURL + match[1], nextEntry); return; } } var tmp = line.match(reSplit); if (tmp && tmp.length == 3) { dictionary[tmp[1]] = evalString(tmp[2]); } } } nextEntry(); } function loadImport(url, callback) { xhrLoadText(url, function (content) { parseRawLines(content, false, callback); }, function () { console.warn(url + ' not found.'); callback(); }); } parseRawLines(text, true, function () { parsedPropertiesCallback(dictionary); }); } xhrLoadText(href, function (response) { gTextData += response; parseProperties(response, function (data) { for (var key in data) { var id, prop, index = key.lastIndexOf('.'); if (index > 0) { id = key.substring(0, index); prop = key.substring(index + 1); } else { id = key; prop = gTextProp; } if (!gL10nData[id]) { gL10nData[id] = {}; } gL10nData[id][prop] = data[key]; } if (successCallback) { successCallback(); } }); }, failureCallback); } function loadLocale(lang, callback) { if (lang) { lang = lang.toLowerCase(); } callback = callback || function _callback() {}; clear(); gLanguage = lang; var langLinks = getL10nResourceLinks(); var langCount = langLinks.length; if (langCount === 0) { var dict = getL10nDictionary(); if (dict && dict.locales && dict.default_locale) { console.log('using the embedded JSON directory, early way out'); gL10nData = dict.locales[lang]; if (!gL10nData) { var defaultLocale = dict.default_locale.toLowerCase(); for (var anyCaseLang in dict.locales) { anyCaseLang = anyCaseLang.toLowerCase(); if (anyCaseLang === lang) { gL10nData = dict.locales[lang]; break; } else if (anyCaseLang === defaultLocale) { gL10nData = dict.locales[defaultLocale]; } } } callback(); } else { console.log('no resource to load, early way out'); } gReadyState = 'complete'; return; } var onResourceLoaded = null; var gResourceCount = 0; onResourceLoaded = function () { gResourceCount++; if (gResourceCount >= langCount) { callback(); gReadyState = 'complete'; } }; function L10nResourceLink(link) { var href = link.href; this.load = function (lang, callback) { parseResource(href, lang, callback, function () { console.warn(href + ' not found.'); console.warn('\"' + lang + '\" resource not found'); gLanguage = ''; callback(); }); }; } for (var i = 0; i < langCount; i++) { var resource = new L10nResourceLink(langLinks[i]); resource.load(lang, onResourceLoaded); } } function clear() { gL10nData = {}; gTextData = ''; gLanguage = ''; } function getPluralRules(lang) { var locales2rules = { 'af': 3, 'ak': 4, 'am': 4, 'ar': 1, 'asa': 3, 'az': 0, 'be': 11, 'bem': 3, 'bez': 3, 'bg': 3, 'bh': 4, 'bm': 0, 'bn': 3, 'bo': 0, 'br': 20, 'brx': 3, 'bs': 11, 'ca': 3, 'cgg': 3, 'chr': 3, 'cs': 12, 'cy': 17, 'da': 3, 'de': 3, 'dv': 3, 'dz': 0, 'ee': 3, 'el': 3, 'en': 3, 'eo': 3, 'es': 3, 'et': 3, 'eu': 3, 'fa': 0, 'ff': 5, 'fi': 3, 'fil': 4, 'fo': 3, 'fr': 5, 'fur': 3, 'fy': 3, 'ga': 8, 'gd': 24, 'gl': 3, 'gsw': 3, 'gu': 3, 'guw': 4, 'gv': 23, 'ha': 3, 'haw': 3, 'he': 2, 'hi': 4, 'hr': 11, 'hu': 0, 'id': 0, 'ig': 0, 'ii': 0, 'is': 3, 'it': 3, 'iu': 7, 'ja': 0, 'jmc': 3, 'jv': 0, 'ka': 0, 'kab': 5, 'kaj': 3, 'kcg': 3, 'kde': 0, 'kea': 0, 'kk': 3, 'kl': 3, 'km': 0, 'kn': 0, 'ko': 0, 'ksb': 3, 'ksh': 21, 'ku': 3, 'kw': 7, 'lag': 18, 'lb': 3, 'lg': 3, 'ln': 4, 'lo': 0, 'lt': 10, 'lv': 6, 'mas': 3, 'mg': 4, 'mk': 16, 'ml': 3, 'mn': 3, 'mo': 9, 'mr': 3, 'ms': 0, 'mt': 15, 'my': 0, 'nah': 3, 'naq': 7, 'nb': 3, 'nd': 3, 'ne': 3, 'nl': 3, 'nn': 3, 'no': 3, 'nr': 3, 'nso': 4, 'ny': 3, 'nyn': 3, 'om': 3, 'or': 3, 'pa': 3, 'pap': 3, 'pl': 13, 'ps': 3, 'pt': 3, 'rm': 3, 'ro': 9, 'rof': 3, 'ru': 11, 'rwk': 3, 'sah': 0, 'saq': 3, 'se': 7, 'seh': 3, 'ses': 0, 'sg': 0, 'sh': 11, 'shi': 19, 'sk': 12, 'sl': 14, 'sma': 7, 'smi': 7, 'smj': 7, 'smn': 7, 'sms': 7, 'sn': 3, 'so': 3, 'sq': 3, 'sr': 11, 'ss': 3, 'ssy': 3, 'st': 3, 'sv': 3, 'sw': 3, 'syr': 3, 'ta': 3, 'te': 3, 'teo': 3, 'th': 0, 'ti': 4, 'tig': 3, 'tk': 3, 'tl': 4, 'tn': 3, 'to': 0, 'tr': 0, 'ts': 3, 'tzm': 22, 'uk': 11, 'ur': 3, 've': 3, 'vi': 0, 'vun': 3, 'wa': 4, 'wae': 3, 'wo': 0, 'xh': 3, 'xog': 3, 'yo': 0, 'zh': 0, 'zu': 3 }; function isIn(n, list) { return list.indexOf(n) !== -1; } function isBetween(n, start, end) { return start sandbox.dispatchEvent(event), 0); } async destroySandbox() { const sandbox = await this._ready; sandbox.nukeSandbox(); } } exports.GenericScripting = GenericScripting; /***/ }), /* 47 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PDFPrintService = PDFPrintService; var _pdfjsLib = __webpack_require__(5); var _app = __webpack_require__(4); var _print_utils = __webpack_require__(48); let activeService = null; let dialog = null; let overlayManager = null; function renderPage(activeServiceOnEntry, pdfDocument, pageNumber, size, printResolution, optionalContentConfigPromise, printAnnotationStoragePromise) { const scratchCanvas = activeService.scratchCanvas; const PRINT_UNITS = printResolution / _pdfjsLib.PixelsPerInch.PDF; scratchCanvas.width = Math.floor(size.width * PRINT_UNITS); scratchCanvas.height = Math.floor(size.height * PRINT_UNITS); const ctx = scratchCanvas.getContext(\"2d\"); ctx.save(); ctx.fillStyle = \"rgb(255, 255, 255)\"; ctx.fillRect(0, 0, scratchCanvas.width, scratchCanvas.height); ctx.restore(); return Promise.all([pdfDocument.getPage(pageNumber), printAnnotationStoragePromise]).then(function ([pdfPage, printAnnotationStorage]) { const renderContext = { canvasContext: ctx, transform: [PRINT_UNITS, 0, 0, PRINT_UNITS, 0, 0], viewport: pdfPage.getViewport({ scale: 1, rotation: size.rotation }), intent: \"print\", annotationMode: _pdfjsLib.AnnotationMode.ENABLE_STORAGE, optionalContentConfigPromise, printAnnotationStorage }; return pdfPage.render(renderContext).promise; }); } function PDFPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise = null, printAnnotationStoragePromise = null, l10n) { this.pdfDocument = pdfDocument; this.pagesOverview = pagesOverview; this.printContainer = printContainer; this._printResolution = printResolution || 150; this._optionalContentConfigPromise = optionalContentConfigPromise || pdfDocument.getOptionalContentConfig(); this._printAnnotationStoragePromise = printAnnotationStoragePromise || Promise.resolve(); this.l10n = l10n; this.currentPage = -1; this.scratchCanvas = document.createElement(\"canvas\"); } PDFPrintService.prototype = { layout() { this.throwIfInactive(); const body = document.querySelector(\"body\"); body.setAttribute(\"data-pdfjsprinting\", true); const hasEqualPageSizes = this.pagesOverview.every(function (size) { return size.width === this.pagesOverview[0].width && size.height === this.pagesOverview[0].height; }, this); if (!hasEqualPageSizes) { console.warn(\"Not all pages have the same size. The printed \" + \"result may be incorrect!\"); } this.pageStyleSheet = document.createElement(\"style\"); const pageSize = this.pagesOverview[0]; this.pageStyleSheet.textContent = \"@page { size: \" + pageSize.width + \"pt \" + pageSize.height + \"pt;}\"; body.append(this.pageStyleSheet); }, destroy() { if (activeService !== this) { return; } this.printContainer.textContent = \"\"; const body = document.querySelector(\"body\"); body.removeAttribute(\"data-pdfjsprinting\"); if (this.pageStyleSheet) { this.pageStyleSheet.remove(); this.pageStyleSheet = null; } this.scratchCanvas.width = this.scratchCanvas.height = 0; this.scratchCanvas = null; activeService = null; ensureOverlay().then(function () { if (overlayManager.active === dialog) { overlayManager.close(dialog); } }); }, renderPages() { if (this.pdfDocument.isPureXfa) { (0, _print_utils.getXfaHtmlForPrinting)(this.printContainer, this.pdfDocument); return Promise.resolve(); } const pageCount = this.pagesOverview.length; const renderNextPage = (resolve, reject) => { this.throwIfInactive(); if (++this.currentPage >= pageCount) { renderProgress(pageCount, pageCount, this.l10n); resolve(); return; } const index = this.currentPage; renderProgress(index, pageCount, this.l10n); renderPage(this, this.pdfDocument, index + 1, this.pagesOverview[index], this._printResolution, this._optionalContentConfigPromise, this._printAnnotationStoragePromise).then(this.useRenderedPage.bind(this)).then(function () { renderNextPage(resolve, reject); }, reject); }; return new Promise(renderNextPage); }, useRenderedPage() { this.throwIfInactive(); const img = document.createElement(\"img\"); const scratchCanvas = this.scratchCanvas; if (\"toBlob\" in scratchCanvas) { scratchCanvas.toBlob(function (blob) { img.src = URL.createObjectURL(blob); }); } else { img.src = scratchCanvas.toDataURL(); } const wrapper = document.createElement(\"div\"); wrapper.className = \"printedPage\"; wrapper.append(img); this.printContainer.append(wrapper); return new Promise(function (resolve, reject) { img.onload = resolve; img.onerror = reject; }); }, performPrint() { this.throwIfInactive(); return new Promise(resolve => { setTimeout(() => { if (!this.active) { resolve(); return; } print.call(window); setTimeout(resolve, 20); }, 0); }); }, get active() { return this === activeService; }, throwIfInactive() { if (!this.active) { throw new Error(\"This print request was cancelled or completed.\"); } } }; const print = window.print; window.print = function () { if (activeService) { console.warn(\"Ignored window.print() because of a pending print job.\"); return; } ensureOverlay().then(function () { if (activeService) { overlayManager.open(dialog); } }); try { dispatchEvent(\"beforeprint\"); } finally { if (!activeService) { console.error(\"Expected print service to be initialized.\"); ensureOverlay().then(function () { if (overlayManager.active === dialog) { overlayManager.close(dialog); } }); return; } const activeServiceOnEntry = activeService; activeService.renderPages().then(function () { return activeServiceOnEntry.performPrint(); }).catch(function () {}).then(function () { if (activeServiceOnEntry.active) { abort(); } }); } }; function dispatchEvent(eventType) { const event = document.createEvent(\"CustomEvent\"); event.initCustomEvent(eventType, false, false, \"custom\"); window.dispatchEvent(event); } function abort() { if (activeService) { activeService.destroy(); dispatchEvent(\"afterprint\"); } } function renderProgress(index, total, l10n) { dialog ||= document.getElementById(\"printServiceDialog\"); const progress = Math.round(100 * index / total); const progressBar = dialog.querySelector(\"progress\"); const progressPerc = dialog.querySelector(\".relative-progress\"); progressBar.value = progress; l10n.get(\"print_progress_percent\", { progress }).then(msg => { progressPerc.textContent = msg; }); } window.addEventListener(\"keydown\", function (event) { if (event.keyCode === 80 && (event.ctrlKey || event.metaKey) && !event.altKey && (!event.shiftKey || window.chrome || window.opera)) { window.print(); event.preventDefault(); event.stopImmediatePropagation(); } }, true); if (\"onbeforeprint\" in window) { const stopPropagationIfNeeded = function (event) { if (event.detail !== \"custom\") { event.stopImmediatePropagation(); } }; window.addEventListener(\"beforeprint\", stopPropagationIfNeeded); window.addEventListener(\"afterprint\", stopPropagationIfNeeded); } let overlayPromise; function ensureOverlay() { if (!overlayPromise) { overlayManager = _app.PDFViewerApplication.overlayManager; if (!overlayManager) { throw new Error(\"The overlay manager has not yet been initialized.\"); } dialog ||= document.getElementById(\"printServiceDialog\"); overlayPromise = overlayManager.register(dialog, true); document.getElementById(\"printCancel\").onclick = abort; dialog.addEventListener(\"close\", abort); } return overlayPromise; } _app.PDFPrintServiceFactory.instance = { supportsPrinting: true, createPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise, printAnnotationStoragePromise, l10n) { if (activeService) { throw new Error(\"The print service is created and active.\"); } activeService = new PDFPrintService(pdfDocument, pagesOverview, printContainer, printResolution, optionalContentConfigPromise, printAnnotationStoragePromise, l10n); return activeService; } }; /***/ }), /* 48 */ /***/ ((__unused_webpack_module, exports, __webpack_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.getXfaHtmlForPrinting = getXfaHtmlForPrinting; var _pdfjsLib = __webpack_require__(5); var _pdf_link_service = __webpack_require__(3); var _xfa_layer_builder = __webpack_require__(37); function getXfaHtmlForPrinting(printContainer, pdfDocument) { const xfaHtml = pdfDocument.allXfaHtml; const linkService = new _pdf_link_service.SimpleLinkService(); const scale = Math.round(_pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS * 100) / 100; for (const xfaPage of xfaHtml.children) { const page = document.createElement(\"div\"); page.className = \"xfaPrintedPage\"; printContainer.append(page); const builder = new _xfa_layer_builder.XfaLayerBuilder({ pageDiv: page, pdfPage: null, annotationStorage: pdfDocument.annotationStorage, linkService, xfaHtml: xfaPage }); const viewport = (0, _pdfjsLib.getXfaPageViewport)(xfaPage, { scale }); builder.render(viewport, \"print\"); } } /***/ }) /******/ ]); /************************************************************************/ /******/ // The module cache /******/ var __webpack_module_cache__ = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ // Check if module is in cache /******/ var cachedModule = __webpack_module_cache__[moduleId]; /******/ if (cachedModule !== undefined) { /******/ return cachedModule.exports; /******/ } /******/ // Create a new module (and put it into the cache) /******/ var module = __webpack_module_cache__[moduleId] = { /******/ // no module.id needed /******/ // no module.loaded needed /******/ exports: {} /******/ }; /******/ /******/ // Execute the module function /******/ __webpack_modules__[moduleId](module, module.exports, __webpack_require__); /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /************************************************************************/ var __webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk. (() => { var exports = __webpack_exports__; Object.defineProperty(exports, \"__esModule\", ({ value: true })); Object.defineProperty(exports, \"PDFViewerApplication\", ({ enumerable: true, get: function () { return _app.PDFViewerApplication; } })); exports.PDFViewerApplicationConstants = void 0; Object.defineProperty(exports, \"PDFViewerApplicationOptions\", ({ enumerable: true, get: function () { return _app_options.AppOptions; } })); var _ui_utils = __webpack_require__(1); var _app_options = __webpack_require__(2); var _pdf_link_service = __webpack_require__(3); var _app = __webpack_require__(4); const pdfjsVersion = '3.2.146'; const pdfjsBuild = '3fd2a3548'; const AppConstants = { LinkTarget: _pdf_link_service.LinkTarget, RenderingStates: _ui_utils.RenderingStates, ScrollMode: _ui_utils.ScrollMode, SpreadMode: _ui_utils.SpreadMode }; exports.PDFViewerApplicationConstants = AppConstants; window.PDFViewerApplication = _app.PDFViewerApplication; window.PDFViewerApplicationConstants = AppConstants; window.PDFViewerApplicationOptions = _app_options.AppOptions; ; ; { __webpack_require__(41); } ; { __webpack_require__(47); } function getViewerConfiguration() { return { appContainer: document.body, mainContainer: document.getElementById(\"viewerContainer\"), viewerContainer: document.getElementById(\"viewer\"), toolbar: { container: document.getElementById(\"toolbarViewer\"), numPages: document.getElementById(\"numPages\"), pageNumber: document.getElementById(\"pageNumber\"), scaleSelect: document.getElementById(\"scaleSelect\"), customScaleOption: document.getElementById(\"customScaleOption\"), previous: document.getElementById(\"previous\"), next: document.getElementById(\"next\"), zoomIn: document.getElementById(\"zoomIn\"), zoomOut: document.getElementById(\"zoomOut\"), viewFind: document.getElementById(\"viewFind\"), openFile: document.getElementById(\"openFile\"), print: document.getElementById(\"print\"), editorFreeTextButton: document.getElementById(\"editorFreeText\"), editorFreeTextParamsToolbar: document.getElementById(\"editorFreeTextParamsToolbar\"), editorInkButton: document.getElementById(\"editorInk\"), editorInkParamsToolbar: document.getElementById(\"editorInkParamsToolbar\"), download: document.getElementById(\"download\") }, secondaryToolbar: { toolbar: document.getElementById(\"secondaryToolbar\"), toggleButton: document.getElementById(\"secondaryToolbarToggle\"), presentationModeButton: document.getElementById(\"presentationMode\"), openFileButton: document.getElementById(\"secondaryOpenFile\"), printButton: document.getElementById(\"secondaryPrint\"), downloadButton: document.getElementById(\"secondaryDownload\"), viewBookmarkButton: document.getElementById(\"viewBookmark\"), firstPageButton: document.getElementById(\"firstPage\"), lastPageButton: document.getElementById(\"lastPage\"), pageRotateCwButton: document.getElementById(\"pageRotateCw\"), pageRotateCcwButton: document.getElementById(\"pageRotateCcw\"), cursorSelectToolButton: document.getElementById(\"cursorSelectTool\"), cursorHandToolButton: document.getElementById(\"cursorHandTool\"), scrollPageButton: document.getElementById(\"scrollPage\"), scrollVerticalButton: document.getElementById(\"scrollVertical\"), scrollHorizontalButton: document.getElementById(\"scrollHorizontal\"), scrollWrappedButton: document.getElementById(\"scrollWrapped\"), spreadNoneButton: document.getElementById(\"spreadNone\"), spreadOddButton: document.getElementById(\"spreadOdd\"), spreadEvenButton: document.getElementById(\"spreadEven\"), documentPropertiesButton: document.getElementById(\"documentProperties\") }, sidebar: { outerContainer: document.getElementById(\"outerContainer\"), sidebarContainer: document.getElementById(\"sidebarContainer\"), toggleButton: document.getElementById(\"sidebarToggle\"), thumbnailButton: document.getElementById(\"viewThumbnail\"), outlineButton: document.getElementById(\"viewOutline\"), attachmentsButton: document.getElementById(\"viewAttachments\"), layersButton: document.getElementById(\"viewLayers\"), thumbnailView: document.getElementById(\"thumbnailView\"), outlineView: document.getElementById(\"outlineView\"), attachmentsView: document.getElementById(\"attachmentsView\"), layersView: document.getElementById(\"layersView\"), outlineOptionsContainer: document.getElementById(\"outlineOptionsContainer\"), currentOutlineItemButton: document.getElementById(\"currentOutlineItem\") }, sidebarResizer: { outerContainer: document.getElementById(\"outerContainer\"), resizer: document.getElementById(\"sidebarResizer\") }, findBar: { bar: document.getElementById(\"findbar\"), toggleButton: document.getElementById(\"viewFind\"), findField: document.getElementById(\"findInput\"), highlightAllCheckbox: document.getElementById(\"findHighlightAll\"), caseSensitiveCheckbox: document.getElementById(\"findMatchCase\"), matchDiacriticsCheckbox: document.getElementById(\"findMatchDiacritics\"), entireWordCheckbox: document.getElementById(\"findEntireWord\"), findMsg: document.getElementById(\"findMsg\"), findResultsCount: document.getElementById(\"findResultsCount\"), findPreviousButton: document.getElementById(\"findPrevious\"), findNextButton: document.getElementById(\"findNext\") }, passwordOverlay: { dialog: document.getElementById(\"passwordDialog\"), label: document.getElementById(\"passwordText\"), input: document.getElementById(\"password\"), submitButton: document.getElementById(\"passwordSubmit\"), cancelButton: document.getElementById(\"passwordCancel\") }, documentProperties: { dialog: document.getElementById(\"documentPropertiesDialog\"), closeButton: document.getElementById(\"documentPropertiesClose\"), fields: { fileName: document.getElementById(\"fileNameField\"), fileSize: document.getElementById(\"fileSizeField\"), title: document.getElementById(\"titleField\"), author: document.getElementById(\"authorField\"), subject: document.getElementById(\"subjectField\"), keywords: document.getElementById(\"keywordsField\"), creationDate: document.getElementById(\"creationDateField\"), modificationDate: document.getElementById(\"modificationDateField\"), creator: document.getElementById(\"creatorField\"), producer: document.getElementById(\"producerField\"), version: document.getElementById(\"versionField\"), pageCount: document.getElementById(\"pageCountField\"), pageSize: document.getElementById(\"pageSizeField\"), linearized: document.getElementById(\"linearizedField\") } }, annotationEditorParams: { editorFreeTextFontSize: document.getElementById(\"editorFreeTextFontSize\"), editorFreeTextColor: document.getElementById(\"editorFreeTextColor\"), editorInkColor: document.getElementById(\"editorInkColor\"), editorInkThickness: document.getElementById(\"editorInkThickness\"), editorInkOpacity: document.getElementById(\"editorInkOpacity\") }, printContainer: document.getElementById(\"printContainer\"), openFileInput: document.getElementById(\"fileInput\"), debuggerScriptPath: \"./debugger.js\" }; } function webViewerLoad() { const config = getViewerConfiguration(); const event = document.createEvent(\"CustomEvent\"); event.initCustomEvent(\"webviewerloaded\", true, true, { source: window }); try { parent.document.dispatchEvent(event); } catch (ex) { console.error(`webviewerloaded: ${ex}`); document.dispatchEvent(event); } _app.PDFViewerApplication.run(config); } document.blockUnblockOnload?.(true); if (document.readyState === \"interactive\" || document.readyState === \"complete\") { webViewerLoad(); } else { document.addEventListener(\"DOMContentLoaded\", webViewerLoad, true); } })(); /******/ })() ; //# sourceMappingURL=viewer.js.map","link":"/js/pdfjs/web/viewer.js"},{"title":"","text":"/** * @licstart The following is the entire license notice for the * JavaScript code in this page * * Copyright 2022 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * * @licend The above is the entire license notice for the * JavaScript code in this page */ (function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' && define.amd) define(\"pdfjs-dist/build/pdf.worker\", [], factory); else if(typeof exports === 'object') exports[\"pdfjs-dist/build/pdf.worker\"] = factory(); else root[\"pdfjs-dist/build/pdf.worker\"] = root.pdfjsWorker = factory(); })(globalThis, () => { return /******/ (() => { // webpackBootstrap /******/ \"use strict\"; /******/ var __webpack_modules__ = ([ /* 0 */, /* 1 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.WorkerTask = exports.WorkerMessageHandler = void 0; var _util = __w_pdfjs_require__(2); var _primitives = __w_pdfjs_require__(3); var _core_utils = __w_pdfjs_require__(4); var _pdf_manager = __w_pdfjs_require__(6); var _cleanup_helper = __w_pdfjs_require__(69); var _writer = __w_pdfjs_require__(63); var _is_node = __w_pdfjs_require__(100); var _message_handler = __w_pdfjs_require__(101); var _worker_stream = __w_pdfjs_require__(102); class WorkerTask { constructor(name) { this.name = name; this.terminated = false; this._capability = (0, _util.createPromiseCapability)(); } get finished() { return this._capability.promise; } finish() { this._capability.resolve(); } terminate() { this.terminated = true; } ensureNotTerminated() { if (this.terminated) { throw new Error(\"Worker task was terminated\"); } } } exports.WorkerTask = WorkerTask; class WorkerMessageHandler { static setup(handler, port) { let testMessageProcessed = false; handler.on(\"test\", function (data) { if (testMessageProcessed) { return; } testMessageProcessed = true; handler.send(\"test\", data instanceof Uint8Array); }); handler.on(\"configure\", function (data) { (0, _util.setVerbosityLevel)(data.verbosity); }); handler.on(\"GetDocRequest\", function (data) { return WorkerMessageHandler.createDocumentHandler(data, port); }); } static createDocumentHandler(docParams, port) { let pdfManager; let terminated = false; let cancelXHRs = null; const WorkerTasks = []; const verbosity = (0, _util.getVerbosityLevel)(); const { docId, apiVersion } = docParams; const workerVersion = '3.2.146'; if (apiVersion !== workerVersion) { throw new Error(`The API version \"${apiVersion}\" does not match ` + `the Worker version \"${workerVersion}\".`); } const enumerableProperties = []; for (const property in []) { enumerableProperties.push(property); } if (enumerableProperties.length) { throw new Error(\"The `Array.prototype` contains unexpected enumerable properties: \" + enumerableProperties.join(\", \") + \"; thus breaking e.g. `for...in` iteration of `Array`s.\"); } if (typeof ReadableStream === \"undefined\") { const partialMsg = \"The browser/environment lacks native support for critical \" + \"functionality used by the PDF.js library (e.g. `ReadableStream`); \"; if (_is_node.isNodeJS) { throw new Error(partialMsg + \"please use a `legacy`-build instead.\"); } throw new Error(partialMsg + \"please update to a supported browser.\"); } const workerHandlerName = docId + \"_worker\"; let handler = new _message_handler.MessageHandler(workerHandlerName, docId, port); function ensureNotTerminated() { if (terminated) { throw new Error(\"Worker was terminated\"); } } function startWorkerTask(task) { WorkerTasks.push(task); } function finishWorkerTask(task) { task.finish(); const i = WorkerTasks.indexOf(task); WorkerTasks.splice(i, 1); } async function loadDocument(recoveryMode) { await pdfManager.ensureDoc(\"checkHeader\"); await pdfManager.ensureDoc(\"parseStartXRef\"); await pdfManager.ensureDoc(\"parse\", [recoveryMode]); await pdfManager.ensureDoc(\"checkFirstPage\", [recoveryMode]); await pdfManager.ensureDoc(\"checkLastPage\", [recoveryMode]); const isPureXfa = await pdfManager.ensureDoc(\"isPureXfa\"); if (isPureXfa) { const task = new WorkerTask(\"loadXfaFonts\"); startWorkerTask(task); await Promise.all([pdfManager.loadXfaFonts(handler, task).catch(reason => {}).then(() => finishWorkerTask(task)), pdfManager.loadXfaImages()]); } const [numPages, fingerprints] = await Promise.all([pdfManager.ensureDoc(\"numPages\"), pdfManager.ensureDoc(\"fingerprints\")]); const htmlForXfa = isPureXfa ? await pdfManager.ensureDoc(\"htmlForXfa\") : null; return { numPages, fingerprints, htmlForXfa }; } function getPdfManager({ data, password, disableAutoFetch, rangeChunkSize, length, docBaseUrl, enableXfa, evaluatorOptions }) { const pdfManagerCapability = (0, _util.createPromiseCapability)(); let newPdfManager; if (data) { try { newPdfManager = new _pdf_manager.LocalPdfManager(docId, data, password, handler, evaluatorOptions, enableXfa, docBaseUrl); pdfManagerCapability.resolve(newPdfManager); } catch (ex) { pdfManagerCapability.reject(ex); } return pdfManagerCapability.promise; } let pdfStream, cachedChunks = []; try { pdfStream = new _worker_stream.PDFWorkerStream(handler); } catch (ex) { pdfManagerCapability.reject(ex); return pdfManagerCapability.promise; } const fullRequest = pdfStream.getFullReader(); fullRequest.headersReady.then(function () { if (!fullRequest.isRangeSupported) { return; } disableAutoFetch = disableAutoFetch || fullRequest.isStreamingSupported; newPdfManager = new _pdf_manager.NetworkPdfManager(docId, pdfStream, { msgHandler: handler, password, length: fullRequest.contentLength, disableAutoFetch, rangeChunkSize }, evaluatorOptions, enableXfa, docBaseUrl); for (const chunk of cachedChunks) { newPdfManager.sendProgressiveData(chunk); } cachedChunks = []; pdfManagerCapability.resolve(newPdfManager); cancelXHRs = null; }).catch(function (reason) { pdfManagerCapability.reject(reason); cancelXHRs = null; }); let loaded = 0; const flushChunks = function () { const pdfFile = (0, _util.arraysToBytes)(cachedChunks); if (length && pdfFile.length !== length) { (0, _util.warn)(\"reported HTTP length is different from actual\"); } try { newPdfManager = new _pdf_manager.LocalPdfManager(docId, pdfFile, password, handler, evaluatorOptions, enableXfa, docBaseUrl); pdfManagerCapability.resolve(newPdfManager); } catch (ex) { pdfManagerCapability.reject(ex); } cachedChunks = []; }; new Promise(function (resolve, reject) { const readChunk = function ({ value, done }) { try { ensureNotTerminated(); if (done) { if (!newPdfManager) { flushChunks(); } cancelXHRs = null; return; } loaded += (0, _util.arrayByteLength)(value); if (!fullRequest.isStreamingSupported) { handler.send(\"DocProgress\", { loaded, total: Math.max(loaded, fullRequest.contentLength || 0) }); } if (newPdfManager) { newPdfManager.sendProgressiveData(value); } else { cachedChunks.push(value); } fullRequest.read().then(readChunk, reject); } catch (e) { reject(e); } }; fullRequest.read().then(readChunk, reject); }).catch(function (e) { pdfManagerCapability.reject(e); cancelXHRs = null; }); cancelXHRs = function (reason) { pdfStream.cancelAllRequests(reason); }; return pdfManagerCapability.promise; } function setupDoc(data) { function onSuccess(doc) { ensureNotTerminated(); handler.send(\"GetDoc\", { pdfInfo: doc }); } function onFailure(ex) { ensureNotTerminated(); if (ex instanceof _util.PasswordException) { const task = new WorkerTask(`PasswordException: response ${ex.code}`); startWorkerTask(task); handler.sendWithPromise(\"PasswordRequest\", ex).then(function ({ password }) { finishWorkerTask(task); pdfManager.updatePassword(password); pdfManagerReady(); }).catch(function () { finishWorkerTask(task); handler.send(\"DocException\", ex); }); } else if (ex instanceof _util.InvalidPDFException || ex instanceof _util.MissingPDFException || ex instanceof _util.UnexpectedResponseException || ex instanceof _util.UnknownErrorException) { handler.send(\"DocException\", ex); } else { handler.send(\"DocException\", new _util.UnknownErrorException(ex.message, ex.toString())); } } function pdfManagerReady() { ensureNotTerminated(); loadDocument(false).then(onSuccess, function (reason) { ensureNotTerminated(); if (!(reason instanceof _core_utils.XRefParseException)) { onFailure(reason); return; } pdfManager.requestLoadedStream().then(function () { ensureNotTerminated(); loadDocument(true).then(onSuccess, onFailure); }); }); } ensureNotTerminated(); getPdfManager(data).then(function (newPdfManager) { if (terminated) { newPdfManager.terminate(new _util.AbortException(\"Worker was terminated.\")); throw new Error(\"Worker was terminated\"); } pdfManager = newPdfManager; pdfManager.requestLoadedStream(true).then(stream => { handler.send(\"DataLoaded\", { length: stream.bytes.byteLength }); }); }).then(pdfManagerReady, onFailure); } handler.on(\"GetPage\", function (data) { return pdfManager.getPage(data.pageIndex).then(function (page) { return Promise.all([pdfManager.ensure(page, \"rotate\"), pdfManager.ensure(page, \"ref\"), pdfManager.ensure(page, \"userUnit\"), pdfManager.ensure(page, \"view\")]).then(function ([rotate, ref, userUnit, view]) { return { rotate, ref, userUnit, view }; }); }); }); handler.on(\"GetPageIndex\", function (data) { const pageRef = _primitives.Ref.get(data.num, data.gen); return pdfManager.ensureCatalog(\"getPageIndex\", [pageRef]); }); handler.on(\"GetDestinations\", function (data) { return pdfManager.ensureCatalog(\"destinations\"); }); handler.on(\"GetDestination\", function (data) { return pdfManager.ensureCatalog(\"getDestination\", [data.id]); }); handler.on(\"GetPageLabels\", function (data) { return pdfManager.ensureCatalog(\"pageLabels\"); }); handler.on(\"GetPageLayout\", function (data) { return pdfManager.ensureCatalog(\"pageLayout\"); }); handler.on(\"GetPageMode\", function (data) { return pdfManager.ensureCatalog(\"pageMode\"); }); handler.on(\"GetViewerPreferences\", function (data) { return pdfManager.ensureCatalog(\"viewerPreferences\"); }); handler.on(\"GetOpenAction\", function (data) { return pdfManager.ensureCatalog(\"openAction\"); }); handler.on(\"GetAttachments\", function (data) { return pdfManager.ensureCatalog(\"attachments\"); }); handler.on(\"GetJavaScript\", function (data) { return pdfManager.ensureCatalog(\"javaScript\"); }); handler.on(\"GetDocJSActions\", function (data) { return pdfManager.ensureCatalog(\"jsActions\"); }); handler.on(\"GetPageJSActions\", function ({ pageIndex }) { return pdfManager.getPage(pageIndex).then(function (page) { return pdfManager.ensure(page, \"jsActions\"); }); }); handler.on(\"GetOutline\", function (data) { return pdfManager.ensureCatalog(\"documentOutline\"); }); handler.on(\"GetOptionalContentConfig\", function (data) { return pdfManager.ensureCatalog(\"optionalContentConfig\"); }); handler.on(\"GetPermissions\", function (data) { return pdfManager.ensureCatalog(\"permissions\"); }); handler.on(\"GetMetadata\", function (data) { return Promise.all([pdfManager.ensureDoc(\"documentInfo\"), pdfManager.ensureCatalog(\"metadata\")]); }); handler.on(\"GetMarkInfo\", function (data) { return pdfManager.ensureCatalog(\"markInfo\"); }); handler.on(\"GetData\", function (data) { return pdfManager.requestLoadedStream().then(function (stream) { return stream.bytes; }); }); handler.on(\"GetAnnotations\", function ({ pageIndex, intent }) { return pdfManager.getPage(pageIndex).then(function (page) { const task = new WorkerTask(`GetAnnotations: page ${pageIndex}`); startWorkerTask(task); return page.getAnnotationsData(handler, task, intent).then(data => { finishWorkerTask(task); return data; }, reason => { finishWorkerTask(task); }); }); }); handler.on(\"GetFieldObjects\", function (data) { return pdfManager.ensureDoc(\"fieldObjects\"); }); handler.on(\"HasJSActions\", function (data) { return pdfManager.ensureDoc(\"hasJSActions\"); }); handler.on(\"GetCalculationOrderIds\", function (data) { return pdfManager.ensureDoc(\"calculationOrderIds\"); }); handler.on(\"SaveDocument\", function ({ isPureXfa, numPages, annotationStorage, filename }) { const promises = [pdfManager.requestLoadedStream(), pdfManager.ensureCatalog(\"acroForm\"), pdfManager.ensureCatalog(\"acroFormRef\"), pdfManager.ensureDoc(\"xref\"), pdfManager.ensureDoc(\"startXRef\")]; const newAnnotationsByPage = !isPureXfa ? (0, _core_utils.getNewAnnotationsMap)(annotationStorage) : null; if (newAnnotationsByPage) { for (const [pageIndex, annotations] of newAnnotationsByPage) { promises.push(pdfManager.getPage(pageIndex).then(page => { const task = new WorkerTask(`Save (editor): page ${pageIndex}`); return page.saveNewAnnotations(handler, task, annotations).finally(function () { finishWorkerTask(task); }); })); } } if (isPureXfa) { promises.push(pdfManager.serializeXfaData(annotationStorage)); } else { for (let pageIndex = 0; pageIndex < numPages; pageIndex++) { promises.push(pdfManager.getPage(pageIndex).then(function (page) { const task = new WorkerTask(`Save: page ${pageIndex}`); return page.save(handler, task, annotationStorage).finally(function () { finishWorkerTask(task); }); })); } } return Promise.all(promises).then(function ([stream, acroForm, acroFormRef, xref, startXRef, ...refs]) { let newRefs = []; let xfaData = null; if (isPureXfa) { xfaData = refs[0]; if (!xfaData) { return stream.bytes; } } else { newRefs = refs.flat(2); if (newRefs.length === 0) { return stream.bytes; } } const needAppearances = acroFormRef && acroForm instanceof _primitives.Dict && newRefs.some(ref => ref.needAppearances); const xfa = acroForm instanceof _primitives.Dict && acroForm.get(\"XFA\") || null; let xfaDatasetsRef = null; let hasXfaDatasetsEntry = false; if (Array.isArray(xfa)) { for (let i = 0, ii = xfa.length; i < ii; i += 2) { if (xfa[i] === \"datasets\") { xfaDatasetsRef = xfa[i + 1]; hasXfaDatasetsEntry = true; } } if (xfaDatasetsRef === null) { xfaDatasetsRef = xref.getNewTemporaryRef(); } } else if (xfa) { (0, _util.warn)(\"Unsupported XFA type.\"); } let newXrefInfo = Object.create(null); if (xref.trailer) { const infoObj = Object.create(null); const xrefInfo = xref.trailer.get(\"Info\") || null; if (xrefInfo instanceof _primitives.Dict) { xrefInfo.forEach((key, value) => { if (typeof value === \"string\") { infoObj[key] = (0, _util.stringToPDFString)(value); } }); } newXrefInfo = { rootRef: xref.trailer.getRaw(\"Root\") || null, encryptRef: xref.trailer.getRaw(\"Encrypt\") || null, newRef: xref.getNewTemporaryRef(), infoRef: xref.trailer.getRaw(\"Info\") || null, info: infoObj, fileIds: xref.trailer.get(\"ID\") || null, startXRef, filename }; } try { return (0, _writer.incrementalUpdate)({ originalData: stream.bytes, xrefInfo: newXrefInfo, newRefs, xref, hasXfa: !!xfa, xfaDatasetsRef, hasXfaDatasetsEntry, needAppearances, acroFormRef, acroForm, xfaData }); } finally { xref.resetNewTemporaryRef(); } }); }); handler.on(\"GetOperatorList\", function (data, sink) { const pageIndex = data.pageIndex; pdfManager.getPage(pageIndex).then(function (page) { const task = new WorkerTask(`GetOperatorList: page ${pageIndex}`); startWorkerTask(task); const start = verbosity >= _util.VerbosityLevel.INFOS ? Date.now() : 0; page.getOperatorList({ handler, sink, task, intent: data.intent, cacheKey: data.cacheKey, annotationStorage: data.annotationStorage }).then(function (operatorListInfo) { finishWorkerTask(task); if (start) { (0, _util.info)(`page=${pageIndex + 1} - getOperatorList: time=` + `${Date.now() - start}ms, len=${operatorListInfo.length}`); } sink.close(); }, function (reason) { finishWorkerTask(task); if (task.terminated) { return; } sink.error(reason); }); }); }); handler.on(\"GetTextContent\", function (data, sink) { const pageIndex = data.pageIndex; pdfManager.getPage(pageIndex).then(function (page) { const task = new WorkerTask(\"GetTextContent: page \" + pageIndex); startWorkerTask(task); const start = verbosity >= _util.VerbosityLevel.INFOS ? Date.now() : 0; page.extractTextContent({ handler, task, sink, includeMarkedContent: data.includeMarkedContent, combineTextItems: data.combineTextItems }).then(function () { finishWorkerTask(task); if (start) { (0, _util.info)(`page=${pageIndex + 1} - getTextContent: time=` + `${Date.now() - start}ms`); } sink.close(); }, function (reason) { finishWorkerTask(task); if (task.terminated) { return; } sink.error(reason); }); }); }); handler.on(\"GetStructTree\", function (data) { return pdfManager.getPage(data.pageIndex).then(function (page) { return pdfManager.ensure(page, \"getStructTree\"); }); }); handler.on(\"FontFallback\", function (data) { return pdfManager.fontFallback(data.id, handler); }); handler.on(\"Cleanup\", function (data) { return pdfManager.cleanup(true); }); handler.on(\"Terminate\", function (data) { terminated = true; const waitOn = []; if (pdfManager) { pdfManager.terminate(new _util.AbortException(\"Worker was terminated.\")); const cleanupPromise = pdfManager.cleanup(); waitOn.push(cleanupPromise); pdfManager = null; } else { (0, _cleanup_helper.clearGlobalCaches)(); } if (cancelXHRs) { cancelXHRs(new _util.AbortException(\"Worker was terminated.\")); } for (const task of WorkerTasks) { waitOn.push(task.finished); task.terminate(); } return Promise.all(waitOn).then(function () { handler.destroy(); handler = null; }); }); handler.on(\"Ready\", function (data) { setupDoc(docParams); docParams = null; }); return workerHandlerName; } static initializeFromPort(port) { const handler = new _message_handler.MessageHandler(\"worker\", \"main\", port); WorkerMessageHandler.setup(handler, port); handler.send(\"ready\", null); } } exports.WorkerMessageHandler = WorkerMessageHandler; function isMessagePort(maybePort) { return typeof maybePort.postMessage === \"function\" && \"onmessage\" in maybePort; } if (typeof window === \"undefined\" && !_is_node.isNodeJS && typeof self !== \"undefined\" && isMessagePort(self)) { WorkerMessageHandler.initializeFromPort(self); } /***/ }), /* 2 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.UNSUPPORTED_FEATURES = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.LINE_FACTOR = exports.LINE_DESCENT_FACTOR = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.BASELINE_FACTOR = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationEditorType = exports.AnnotationEditorPrefix = exports.AnnotationEditorParamsType = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0; exports.arrayByteLength = arrayByteLength; exports.arraysToBytes = arraysToBytes; exports.assert = assert; exports.bytesToString = bytesToString; exports.createPromiseCapability = createPromiseCapability; exports.createValidAbsoluteUrl = createValidAbsoluteUrl; exports.getModificationDate = getModificationDate; exports.getVerbosityLevel = getVerbosityLevel; exports.info = info; exports.isArrayBuffer = isArrayBuffer; exports.isArrayEqual = isArrayEqual; exports.objectFromMap = objectFromMap; exports.objectSize = objectSize; exports.setVerbosityLevel = setVerbosityLevel; exports.shadow = shadow; exports.string32 = string32; exports.stringToBytes = stringToBytes; exports.stringToPDFString = stringToPDFString; exports.stringToUTF8String = stringToUTF8String; exports.unreachable = unreachable; exports.utf8StringToString = utf8StringToString; exports.warn = warn; ; const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0]; exports.IDENTITY_MATRIX = IDENTITY_MATRIX; const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0]; exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX; const LINE_FACTOR = 1.35; exports.LINE_FACTOR = LINE_FACTOR; const LINE_DESCENT_FACTOR = 0.35; exports.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR; const BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR; exports.BASELINE_FACTOR = BASELINE_FACTOR; const RenderingIntentFlag = { ANY: 0x01, DISPLAY: 0x02, PRINT: 0x04, SAVE: 0x08, ANNOTATIONS_FORMS: 0x10, ANNOTATIONS_STORAGE: 0x20, ANNOTATIONS_DISABLE: 0x40, OPLIST: 0x100 }; exports.RenderingIntentFlag = RenderingIntentFlag; const AnnotationMode = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 }; exports.AnnotationMode = AnnotationMode; const AnnotationEditorPrefix = \"pdfjs_internal_editor_\"; exports.AnnotationEditorPrefix = AnnotationEditorPrefix; const AnnotationEditorType = { DISABLE: -1, NONE: 0, FREETEXT: 3, INK: 15 }; exports.AnnotationEditorType = AnnotationEditorType; const AnnotationEditorParamsType = { FREETEXT_SIZE: 1, FREETEXT_COLOR: 2, FREETEXT_OPACITY: 3, INK_COLOR: 11, INK_THICKNESS: 12, INK_OPACITY: 13 }; exports.AnnotationEditorParamsType = AnnotationEditorParamsType; const PermissionFlag = { PRINT: 0x04, MODIFY_CONTENTS: 0x08, COPY: 0x10, MODIFY_ANNOTATIONS: 0x20, FILL_INTERACTIVE_FORMS: 0x100, COPY_FOR_ACCESSIBILITY: 0x200, ASSEMBLE: 0x400, PRINT_HIGH_QUALITY: 0x800 }; exports.PermissionFlag = PermissionFlag; const TextRenderingMode = { FILL: 0, STROKE: 1, FILL_STROKE: 2, INVISIBLE: 3, FILL_ADD_TO_PATH: 4, STROKE_ADD_TO_PATH: 5, FILL_STROKE_ADD_TO_PATH: 6, ADD_TO_PATH: 7, FILL_STROKE_MASK: 3, ADD_TO_PATH_FLAG: 4 }; exports.TextRenderingMode = TextRenderingMode; const ImageKind = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }; exports.ImageKind = ImageKind; const AnnotationType = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 }; exports.AnnotationType = AnnotationType; const AnnotationStateModelType = { MARKED: \"Marked\", REVIEW: \"Review\" }; exports.AnnotationStateModelType = AnnotationStateModelType; const AnnotationMarkedState = { MARKED: \"Marked\", UNMARKED: \"Unmarked\" }; exports.AnnotationMarkedState = AnnotationMarkedState; const AnnotationReviewState = { ACCEPTED: \"Accepted\", REJECTED: \"Rejected\", CANCELLED: \"Cancelled\", COMPLETED: \"Completed\", NONE: \"None\" }; exports.AnnotationReviewState = AnnotationReviewState; const AnnotationReplyType = { GROUP: \"Group\", REPLY: \"R\" }; exports.AnnotationReplyType = AnnotationReplyType; const AnnotationFlag = { INVISIBLE: 0x01, HIDDEN: 0x02, PRINT: 0x04, NOZOOM: 0x08, NOROTATE: 0x10, NOVIEW: 0x20, READONLY: 0x40, LOCKED: 0x80, TOGGLENOVIEW: 0x100, LOCKEDCONTENTS: 0x200 }; exports.AnnotationFlag = AnnotationFlag; const AnnotationFieldFlag = { READONLY: 0x0000001, REQUIRED: 0x0000002, NOEXPORT: 0x0000004, MULTILINE: 0x0001000, PASSWORD: 0x0002000, NOTOGGLETOOFF: 0x0004000, RADIO: 0x0008000, PUSHBUTTON: 0x0010000, COMBO: 0x0020000, EDIT: 0x0040000, SORT: 0x0080000, FILESELECT: 0x0100000, MULTISELECT: 0x0200000, DONOTSPELLCHECK: 0x0400000, DONOTSCROLL: 0x0800000, COMB: 0x1000000, RICHTEXT: 0x2000000, RADIOSINUNISON: 0x2000000, COMMITONSELCHANGE: 0x4000000 }; exports.AnnotationFieldFlag = AnnotationFieldFlag; const AnnotationBorderStyleType = { SOLID: 1, DASHED: 2, BEVELED: 3, INSET: 4, UNDERLINE: 5 }; exports.AnnotationBorderStyleType = AnnotationBorderStyleType; const AnnotationActionEventType = { E: \"Mouse Enter\", X: \"Mouse Exit\", D: \"Mouse Down\", U: \"Mouse Up\", Fo: \"Focus\", Bl: \"Blur\", PO: \"PageOpen\", PC: \"PageClose\", PV: \"PageVisible\", PI: \"PageInvisible\", K: \"Keystroke\", F: \"Format\", V: \"Validate\", C: \"Calculate\" }; exports.AnnotationActionEventType = AnnotationActionEventType; const DocumentActionEventType = { WC: \"WillClose\", WS: \"WillSave\", DS: \"DidSave\", WP: \"WillPrint\", DP: \"DidPrint\" }; exports.DocumentActionEventType = DocumentActionEventType; const PageActionEventType = { O: \"PageOpen\", C: \"PageClose\" }; exports.PageActionEventType = PageActionEventType; const StreamType = { UNKNOWN: \"UNKNOWN\", FLATE: \"FLATE\", LZW: \"LZW\", DCT: \"DCT\", JPX: \"JPX\", JBIG: \"JBIG\", A85: \"A85\", AHX: \"AHX\", CCF: \"CCF\", RLX: \"RLX\" }; exports.StreamType = StreamType; const FontType = { UNKNOWN: \"UNKNOWN\", TYPE1: \"TYPE1\", TYPE1STANDARD: \"TYPE1STANDARD\", TYPE1C: \"TYPE1C\", CIDFONTTYPE0: \"CIDFONTTYPE0\", CIDFONTTYPE0C: \"CIDFONTTYPE0C\", TRUETYPE: \"TRUETYPE\", CIDFONTTYPE2: \"CIDFONTTYPE2\", TYPE3: \"TYPE3\", OPENTYPE: \"OPENTYPE\", TYPE0: \"TYPE0\", MMTYPE1: \"MMTYPE1\" }; exports.FontType = FontType; const VerbosityLevel = { ERRORS: 0, WARNINGS: 1, INFOS: 5 }; exports.VerbosityLevel = VerbosityLevel; const CMapCompressionType = { NONE: 0, BINARY: 1 }; exports.CMapCompressionType = CMapCompressionType; const OPS = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotation: 80, endAnnotation: 81, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91 }; exports.OPS = OPS; const UNSUPPORTED_FEATURES = { forms: \"forms\", javaScript: \"javaScript\", signatures: \"signatures\", smask: \"smask\", shadingPattern: \"shadingPattern\", errorTilingPattern: \"errorTilingPattern\", errorExtGState: \"errorExtGState\", errorXObject: \"errorXObject\", errorFontLoadType3: \"errorFontLoadType3\", errorFontState: \"errorFontState\", errorFontMissing: \"errorFontMissing\", errorFontTranslate: \"errorFontTranslate\", errorColorSpace: \"errorColorSpace\", errorOperatorList: \"errorOperatorList\", errorFontToUnicode: \"errorFontToUnicode\", errorFontLoadNative: \"errorFontLoadNative\", errorFontBuildPath: \"errorFontBuildPath\", errorFontGetPath: \"errorFontGetPath\", errorMarkedContent: \"errorMarkedContent\", errorContentSubStream: \"errorContentSubStream\" }; exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES; const PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 }; exports.PasswordResponses = PasswordResponses; let verbosity = VerbosityLevel.WARNINGS; function setVerbosityLevel(level) { if (Number.isInteger(level)) { verbosity = level; } } function getVerbosityLevel() { return verbosity; } function info(msg) { if (verbosity >= VerbosityLevel.INFOS) { console.log(`Info: ${msg}`); } } function warn(msg) { if (verbosity >= VerbosityLevel.WARNINGS) { console.log(`Warning: ${msg}`); } } function unreachable(msg) { throw new Error(msg); } function assert(cond, msg) { if (!cond) { unreachable(msg); } } function _isValidProtocol(url) { if (!url) { return false; } switch (url.protocol) { case \"http:\": case \"https:\": case \"ftp:\": case \"mailto:\": case \"tel:\": return true; default: return false; } } function createValidAbsoluteUrl(url, baseUrl = null, options = null) { if (!url) { return null; } try { if (options && typeof url === \"string\") { if (options.addDefaultProtocol && url.startsWith(\"www.\")) { const dots = url.match(/\\./g); if (dots && dots.length >= 2) { url = `http://${url}`; } } if (options.tryConvertEncoding) { try { url = stringToUTF8String(url); } catch (ex) {} } } const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url); if (_isValidProtocol(absoluteUrl)) { return absoluteUrl; } } catch (ex) {} return null; } function shadow(obj, prop, value, nonSerializable = false) { Object.defineProperty(obj, prop, { value, enumerable: !nonSerializable, configurable: true, writable: false }); return value; } const BaseException = function BaseExceptionClosure() { function BaseException(message, name) { if (this.constructor === BaseException) { unreachable(\"Cannot initialize BaseException.\"); } this.message = message; this.name = name; } BaseException.prototype = new Error(); BaseException.constructor = BaseException; return BaseException; }(); exports.BaseException = BaseException; class PasswordException extends BaseException { constructor(msg, code) { super(msg, \"PasswordException\"); this.code = code; } } exports.PasswordException = PasswordException; class UnknownErrorException extends BaseException { constructor(msg, details) { super(msg, \"UnknownErrorException\"); this.details = details; } } exports.UnknownErrorException = UnknownErrorException; class InvalidPDFException extends BaseException { constructor(msg) { super(msg, \"InvalidPDFException\"); } } exports.InvalidPDFException = InvalidPDFException; class MissingPDFException extends BaseException { constructor(msg) { super(msg, \"MissingPDFException\"); } } exports.MissingPDFException = MissingPDFException; class UnexpectedResponseException extends BaseException { constructor(msg, status) { super(msg, \"UnexpectedResponseException\"); this.status = status; } } exports.UnexpectedResponseException = UnexpectedResponseException; class FormatError extends BaseException { constructor(msg) { super(msg, \"FormatError\"); } } exports.FormatError = FormatError; class AbortException extends BaseException { constructor(msg) { super(msg, \"AbortException\"); } } exports.AbortException = AbortException; function bytesToString(bytes) { if (typeof bytes !== \"object\" || bytes === null || bytes.length === undefined) { unreachable(\"Invalid argument for bytesToString\"); } const length = bytes.length; const MAX_ARGUMENT_COUNT = 8192; if (length < MAX_ARGUMENT_COUNT) { return String.fromCharCode.apply(null, bytes); } const strBuf = []; for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) { const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length); const chunk = bytes.subarray(i, chunkEnd); strBuf.push(String.fromCharCode.apply(null, chunk)); } return strBuf.join(\"\"); } function stringToBytes(str) { if (typeof str !== \"string\") { unreachable(\"Invalid argument for stringToBytes\"); } const length = str.length; const bytes = new Uint8Array(length); for (let i = 0; i < length; ++i) { bytes[i] = str.charCodeAt(i) & 0xff; } return bytes; } function arrayByteLength(arr) { if (arr.length !== undefined) { return arr.length; } if (arr.byteLength !== undefined) { return arr.byteLength; } unreachable(\"Invalid argument for arrayByteLength\"); } function arraysToBytes(arr) { const length = arr.length; if (length === 1 && arr[0] instanceof Uint8Array) { return arr[0]; } let resultLength = 0; for (let i = 0; i < length; i++) { resultLength += arrayByteLength(arr[i]); } let pos = 0; const data = new Uint8Array(resultLength); for (let i = 0; i < length; i++) { let item = arr[i]; if (!(item instanceof Uint8Array)) { if (typeof item === \"string\") { item = stringToBytes(item); } else { item = new Uint8Array(item); } } const itemLength = item.byteLength; data.set(item, pos); pos += itemLength; } return data; } function string32(value) { return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff); } function objectSize(obj) { return Object.keys(obj).length; } function objectFromMap(map) { const obj = Object.create(null); for (const [key, value] of map) { obj[key] = value; } return obj; } function isLittleEndian() { const buffer8 = new Uint8Array(4); buffer8[0] = 1; const view32 = new Uint32Array(buffer8.buffer, 0, 1); return view32[0] === 1; } function isEvalSupported() { try { new Function(\"\"); return true; } catch (e) { return false; } } class FeatureTest { static get isLittleEndian() { return shadow(this, \"isLittleEndian\", isLittleEndian()); } static get isEvalSupported() { return shadow(this, \"isEvalSupported\", isEvalSupported()); } static get isOffscreenCanvasSupported() { return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\"); } static get platform() { if (typeof navigator === \"undefined\") { return shadow(this, \"platform\", { isWin: false, isMac: false }); } return shadow(this, \"platform\", { isWin: navigator.platform.includes(\"Win\"), isMac: navigator.platform.includes(\"Mac\") }); } } exports.FeatureTest = FeatureTest; const hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, \"0\")); class Util { static makeHexColor(r, g, b) { return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`; } static scaleMinMax(transform, minMax) { let temp; if (transform[0]) { if (transform[0] < 0) { temp = minMax[0]; minMax[0] = minMax[1]; minMax[1] = temp; } minMax[0] *= transform[0]; minMax[1] *= transform[0]; if (transform[3] < 0) { temp = minMax[2]; minMax[2] = minMax[3]; minMax[3] = temp; } minMax[2] *= transform[3]; minMax[3] *= transform[3]; } else { temp = minMax[0]; minMax[0] = minMax[2]; minMax[2] = temp; temp = minMax[1]; minMax[1] = minMax[3]; minMax[3] = temp; if (transform[1] < 0) { temp = minMax[2]; minMax[2] = minMax[3]; minMax[3] = temp; } minMax[2] *= transform[1]; minMax[3] *= transform[1]; if (transform[2] < 0) { temp = minMax[0]; minMax[0] = minMax[1]; minMax[1] = temp; } minMax[0] *= transform[2]; minMax[1] *= transform[2]; } minMax[0] += transform[4]; minMax[1] += transform[4]; minMax[2] += transform[5]; minMax[3] += transform[5]; } static transform(m1, m2) { return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]]; } static applyTransform(p, m) { const xt = p[0] * m[0] + p[1] * m[2] + m[4]; const yt = p[0] * m[1] + p[1] * m[3] + m[5]; return [xt, yt]; } static applyInverseTransform(p, m) { const d = m[0] * m[3] - m[1] * m[2]; const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d; const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d; return [xt, yt]; } static getAxialAlignedBoundingBox(r, m) { const p1 = Util.applyTransform(r, m); const p2 = Util.applyTransform(r.slice(2, 4), m); const p3 = Util.applyTransform([r[0], r[3]], m); const p4 = Util.applyTransform([r[2], r[1]], m); return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])]; } static inverseTransform(m) { const d = m[0] * m[3] - m[1] * m[2]; return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d]; } static singularValueDecompose2dScale(m) { const transpose = [m[0], m[2], m[1], m[3]]; const a = m[0] * transpose[0] + m[1] * transpose[2]; const b = m[0] * transpose[1] + m[1] * transpose[3]; const c = m[2] * transpose[0] + m[3] * transpose[2]; const d = m[2] * transpose[1] + m[3] * transpose[3]; const first = (a + d) / 2; const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2; const sx = first + second || 1; const sy = first - second || 1; return [Math.sqrt(sx), Math.sqrt(sy)]; } static normalizeRect(rect) { const r = rect.slice(0); if (rect[0] > rect[2]) { r[0] = rect[2]; r[2] = rect[0]; } if (rect[1] > rect[3]) { r[1] = rect[3]; r[3] = rect[1]; } return r; } static intersect(rect1, rect2) { const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2])); const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2])); if (xLow > xHigh) { return null; } const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3])); const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3])); if (yLow > yHigh) { return null; } return [xLow, yLow, xHigh, yHigh]; } static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) { const tvalues = [], bounds = [[], []]; let a, b, c, t, t1, t2, b2ac, sqrtb2ac; for (let i = 0; i < 2; ++i) { if (i === 0) { b = 6 * x0 - 12 * x1 + 6 * x2; a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3; c = 3 * x1 - 3 * x0; } else { b = 6 * y0 - 12 * y1 + 6 * y2; a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3; c = 3 * y1 - 3 * y0; } if (Math.abs(a) < 1e-12) { if (Math.abs(b) < 1e-12) { continue; } t = -c / b; if (0 < t && t < 1) { tvalues.push(t); } continue; } b2ac = b * b - 4 * c * a; sqrtb2ac = Math.sqrt(b2ac); if (b2ac < 0) { continue; } t1 = (-b + sqrtb2ac) / (2 * a); if (0 < t1 && t1 < 1) { tvalues.push(t1); } t2 = (-b - sqrtb2ac) / (2 * a); if (0 < t2 && t2 < 1) { tvalues.push(t2); } } let j = tvalues.length, mt; const jlen = j; while (j--) { t = tvalues[j]; mt = 1 - t; bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3; bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3; } bounds[0][jlen] = x0; bounds[1][jlen] = y0; bounds[0][jlen + 1] = x3; bounds[1][jlen + 1] = y3; bounds[0].length = bounds[1].length = jlen + 2; return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])]; } } exports.Util = Util; const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac]; function stringToPDFString(str) { if (str[0] >= \"\\xEF\") { let encoding; if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") { encoding = \"utf-16be\"; } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") { encoding = \"utf-16le\"; } else if (str[0] === \"\\xEF\" && str[1] === \"\\xBB\" && str[2] === \"\\xBF\") { encoding = \"utf-8\"; } if (encoding) { try { const decoder = new TextDecoder(encoding, { fatal: true }); const buffer = stringToBytes(str); return decoder.decode(buffer); } catch (ex) { warn(`stringToPDFString: \"${ex}\".`); } } } const strBuf = []; for (let i = 0, ii = str.length; i < ii; i++) { const code = PDFStringTranslateTable[str.charCodeAt(i)]; strBuf.push(code ? String.fromCharCode(code) : str.charAt(i)); } return strBuf.join(\"\"); } function stringToUTF8String(str) { return decodeURIComponent(escape(str)); } function utf8StringToString(str) { return unescape(encodeURIComponent(str)); } function isArrayBuffer(v) { return typeof v === \"object\" && v !== null && v.byteLength !== undefined; } function isArrayEqual(arr1, arr2) { if (arr1.length !== arr2.length) { return false; } for (let i = 0, ii = arr1.length; i < ii; i++) { if (arr1[i] !== arr2[i]) { return false; } } return true; } function getModificationDate(date = new Date()) { const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")]; return buffer.join(\"\"); } function createPromiseCapability() { const capability = Object.create(null); let isSettled = false; Object.defineProperty(capability, \"settled\", { get() { return isSettled; } }); capability.promise = new Promise(function (resolve, reject) { capability.resolve = function (data) { isSettled = true; resolve(data); }; capability.reject = function (reason) { isSettled = true; reject(reason); }; }); return capability; } /***/ }), /* 3 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.RefSetCache = exports.RefSet = exports.Ref = exports.Name = exports.EOF = exports.Dict = exports.Cmd = exports.CIRCULAR_REF = void 0; exports.clearPrimitiveCaches = clearPrimitiveCaches; exports.isCmd = isCmd; exports.isDict = isDict; exports.isName = isName; exports.isRefsEqual = isRefsEqual; var _util = __w_pdfjs_require__(2); const CIRCULAR_REF = Symbol(\"CIRCULAR_REF\"); exports.CIRCULAR_REF = CIRCULAR_REF; const EOF = Symbol(\"EOF\"); exports.EOF = EOF; const Name = function NameClosure() { let nameCache = Object.create(null); class Name { constructor(name) { this.name = name; } static get(name) { return nameCache[name] || (nameCache[name] = new Name(name)); } static _clearCache() { nameCache = Object.create(null); } } return Name; }(); exports.Name = Name; const Cmd = function CmdClosure() { let cmdCache = Object.create(null); class Cmd { constructor(cmd) { this.cmd = cmd; } static get(cmd) { return cmdCache[cmd] || (cmdCache[cmd] = new Cmd(cmd)); } static _clearCache() { cmdCache = Object.create(null); } } return Cmd; }(); exports.Cmd = Cmd; const nonSerializable = function nonSerializableClosure() { return nonSerializable; }; class Dict { constructor(xref = null) { this._map = Object.create(null); this.xref = xref; this.objId = null; this.suppressEncryption = false; this.__nonSerializable__ = nonSerializable; } assignXref(newXref) { this.xref = newXref; } get size() { return Object.keys(this._map).length; } get(key1, key2, key3) { let value = this._map[key1]; if (value === undefined && key2 !== undefined) { value = this._map[key2]; if (value === undefined && key3 !== undefined) { value = this._map[key3]; } } if (value instanceof Ref && this.xref) { return this.xref.fetch(value, this.suppressEncryption); } return value; } async getAsync(key1, key2, key3) { let value = this._map[key1]; if (value === undefined && key2 !== undefined) { value = this._map[key2]; if (value === undefined && key3 !== undefined) { value = this._map[key3]; } } if (value instanceof Ref && this.xref) { return this.xref.fetchAsync(value, this.suppressEncryption); } return value; } getArray(key1, key2, key3) { let value = this._map[key1]; if (value === undefined && key2 !== undefined) { value = this._map[key2]; if (value === undefined && key3 !== undefined) { value = this._map[key3]; } } if (value instanceof Ref && this.xref) { value = this.xref.fetch(value, this.suppressEncryption); } if (Array.isArray(value)) { value = value.slice(); for (let i = 0, ii = value.length; i < ii; i++) { if (value[i] instanceof Ref && this.xref) { value[i] = this.xref.fetch(value[i], this.suppressEncryption); } } } return value; } getRaw(key) { return this._map[key]; } getKeys() { return Object.keys(this._map); } getRawValues() { return Object.values(this._map); } set(key, value) { this._map[key] = value; } has(key) { return this._map[key] !== undefined; } forEach(callback) { for (const key in this._map) { callback(key, this.get(key)); } } static get empty() { const emptyDict = new Dict(null); emptyDict.set = (key, value) => { (0, _util.unreachable)(\"Should not call `set` on the empty dictionary.\"); }; return (0, _util.shadow)(this, \"empty\", emptyDict); } static merge({ xref, dictArray, mergeSubDicts = false }) { const mergedDict = new Dict(xref), properties = new Map(); for (const dict of dictArray) { if (!(dict instanceof Dict)) { continue; } for (const [key, value] of Object.entries(dict._map)) { let property = properties.get(key); if (property === undefined) { property = []; properties.set(key, property); } else if (!mergeSubDicts || !(value instanceof Dict)) { continue; } property.push(value); } } for (const [name, values] of properties) { if (values.length === 1 || !(values[0] instanceof Dict)) { mergedDict._map[name] = values[0]; continue; } const subDict = new Dict(xref); for (const dict of values) { for (const [key, value] of Object.entries(dict._map)) { if (subDict._map[key] === undefined) { subDict._map[key] = value; } } } if (subDict.size > 0) { mergedDict._map[name] = subDict; } } properties.clear(); return mergedDict.size > 0 ? mergedDict : Dict.empty; } } exports.Dict = Dict; const Ref = function RefClosure() { let refCache = Object.create(null); class Ref { constructor(num, gen) { this.num = num; this.gen = gen; } toString() { if (this.gen === 0) { return `${this.num}R`; } return `${this.num}R${this.gen}`; } static get(num, gen) { const key = gen === 0 ? `${num}R` : `${num}R${gen}`; return refCache[key] || (refCache[key] = new Ref(num, gen)); } static _clearCache() { refCache = Object.create(null); } } return Ref; }(); exports.Ref = Ref; class RefSet { constructor(parent = null) { this._set = new Set(parent && parent._set); } has(ref) { return this._set.has(ref.toString()); } put(ref) { this._set.add(ref.toString()); } remove(ref) { this._set.delete(ref.toString()); } [Symbol.iterator]() { return this._set.values(); } clear() { this._set.clear(); } } exports.RefSet = RefSet; class RefSetCache { constructor() { this._map = new Map(); } get size() { return this._map.size; } get(ref) { return this._map.get(ref.toString()); } has(ref) { return this._map.has(ref.toString()); } put(ref, obj) { this._map.set(ref.toString(), obj); } putAlias(ref, aliasRef) { this._map.set(ref.toString(), this.get(aliasRef)); } [Symbol.iterator]() { return this._map.values(); } clear() { this._map.clear(); } } exports.RefSetCache = RefSetCache; function isName(v, name) { return v instanceof Name && (name === undefined || v.name === name); } function isCmd(v, cmd) { return v instanceof Cmd && (cmd === undefined || v.cmd === cmd); } function isDict(v, type) { return v instanceof Dict && (type === undefined || isName(v.get(\"Type\"), type)); } function isRefsEqual(v1, v2) { return v1.num === v2.num && v1.gen === v2.gen; } function clearPrimitiveCaches() { Cmd._clearCache(); Name._clearCache(); Ref._clearCache(); } /***/ }), /* 4 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.XRefParseException = exports.XRefEntryException = exports.ParserEOFException = exports.PDF_VERSION_REGEXP = exports.MissingDataException = exports.DocStats = void 0; exports.collectActions = collectActions; exports.encodeToXmlString = encodeToXmlString; exports.escapePDFName = escapePDFName; exports.escapeString = escapeString; exports.getArrayLookupTableFactory = getArrayLookupTableFactory; exports.getInheritableProperty = getInheritableProperty; exports.getLookupTableFactory = getLookupTableFactory; exports.getNewAnnotationsMap = getNewAnnotationsMap; exports.getRotationMatrix = getRotationMatrix; exports.isAscii = isAscii; exports.isWhiteSpace = isWhiteSpace; exports.log2 = log2; exports.numberToString = numberToString; exports.parseXFAPath = parseXFAPath; exports.readInt8 = readInt8; exports.readUint16 = readUint16; exports.readUint32 = readUint32; exports.recoverJsURL = recoverJsURL; exports.stringToUTF16HexString = stringToUTF16HexString; exports.stringToUTF16String = stringToUTF16String; exports.toRomanNumerals = toRomanNumerals; exports.validateCSSFont = validateCSSFont; var _util = __w_pdfjs_require__(2); var _primitives = __w_pdfjs_require__(3); var _base_stream = __w_pdfjs_require__(5); const PDF_VERSION_REGEXP = /^[1-9]\\.\\d$/; exports.PDF_VERSION_REGEXP = PDF_VERSION_REGEXP; function getLookupTableFactory(initializer) { let lookup; return function () { if (initializer) { lookup = Object.create(null); initializer(lookup); initializer = null; } return lookup; }; } function getArrayLookupTableFactory(initializer) { let lookup; return function () { if (initializer) { let arr = initializer(); initializer = null; lookup = Object.create(null); for (let i = 0, ii = arr.length; i < ii; i += 2) { lookup[arr[i]] = arr[i + 1]; } arr = null; } return lookup; }; } class MissingDataException extends _util.BaseException { constructor(begin, end) { super(`Missing data [${begin}, ${end})`, \"MissingDataException\"); this.begin = begin; this.end = end; } } exports.MissingDataException = MissingDataException; class ParserEOFException extends _util.BaseException { constructor(msg) { super(msg, \"ParserEOFException\"); } } exports.ParserEOFException = ParserEOFException; class XRefEntryException extends _util.BaseException { constructor(msg) { super(msg, \"XRefEntryException\"); } } exports.XRefEntryException = XRefEntryException; class XRefParseException extends _util.BaseException { constructor(msg) { super(msg, \"XRefParseException\"); } } exports.XRefParseException = XRefParseException; class DocStats { constructor(handler) { this._handler = handler; this._streamTypes = new Set(); this._fontTypes = new Set(); } _send() { const streamTypes = Object.create(null), fontTypes = Object.create(null); for (const type of this._streamTypes) { streamTypes[type] = true; } for (const type of this._fontTypes) { fontTypes[type] = true; } this._handler.send(\"DocStats\", { streamTypes, fontTypes }); } addStreamType(type) { if (this._streamTypes.has(type)) { return; } this._streamTypes.add(type); this._send(); } addFontType(type) { if (this._fontTypes.has(type)) { return; } this._fontTypes.add(type); this._send(); } } exports.DocStats = DocStats; function getInheritableProperty({ dict, key, getArray = false, stopWhenFound = true }) { let values; const visited = new _primitives.RefSet(); while (dict instanceof _primitives.Dict && !(dict.objId && visited.has(dict.objId))) { if (dict.objId) { visited.put(dict.objId); } const value = getArray ? dict.getArray(key) : dict.get(key); if (value !== undefined) { if (stopWhenFound) { return value; } if (!values) { values = []; } values.push(value); } dict = dict.get(\"Parent\"); } return values; } const ROMAN_NUMBER_MAP = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", \"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\", \"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]; function toRomanNumerals(number, lowerCase = false) { (0, _util.assert)(Number.isInteger(number) && number > 0, \"The number should be a positive integer.\"); const romanBuf = []; let pos; while (number >= 1000) { number -= 1000; romanBuf.push(\"M\"); } pos = number / 100 | 0; number %= 100; romanBuf.push(ROMAN_NUMBER_MAP[pos]); pos = number / 10 | 0; number %= 10; romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]); romanBuf.push(ROMAN_NUMBER_MAP[20 + number]); const romanStr = romanBuf.join(\"\"); return lowerCase ? romanStr.toLowerCase() : romanStr; } function log2(x) { if (x 0 && box[3] - box[1] > 0) { return box; } (0, _util.warn)(`Empty, or invalid, /${name} entry.`); } return null; } get mediaBox() { return (0, _util.shadow)(this, \"mediaBox\", this._getBoundingBox(\"MediaBox\") || LETTER_SIZE_MEDIABOX); } get cropBox() { return (0, _util.shadow)(this, \"cropBox\", this._getBoundingBox(\"CropBox\") || this.mediaBox); } get userUnit() { let obj = this.pageDict.get(\"UserUnit\"); if (typeof obj !== \"number\" || obj 0 && box[3] - box[1] > 0) { return (0, _util.shadow)(this, \"view\", box); } (0, _util.warn)(\"Empty /CropBox and /MediaBox intersection.\"); } return (0, _util.shadow)(this, \"view\", mediaBox); } get rotate() { let rotate = this._getInheritableProperty(\"Rotate\") || 0; if (rotate % 90 !== 0) { rotate = 0; } else if (rotate >= 360) { rotate %= 360; } else if (rotate < 0) { rotate = (rotate % 360 + 360) % 360; } return (0, _util.shadow)(this, \"rotate\", rotate); } _onSubStreamError(handler, reason, objId) { if (this.evaluatorOptions.ignoreErrors) { handler.send(\"UnsupportedFeature\", { featureId: _util.UNSUPPORTED_FEATURES.errorContentSubStream }); (0, _util.warn)(`getContentStream - ignoring sub-stream (${objId}): \"${reason}\".`); return; } throw reason; } getContentStream(handler) { return this.pdfManager.ensure(this, \"content\").then(content => { if (content instanceof _base_stream.BaseStream) { return content; } if (Array.isArray(content)) { return new _decode_stream.StreamsSequenceStream(content, this._onSubStreamError.bind(this, handler)); } return new _stream.NullStream(); }); } get xfaData() { return (0, _util.shadow)(this, \"xfaData\", this.xfaFactory ? { bbox: this.xfaFactory.getBoundingBox(this.pageIndex) } : null); } async saveNewAnnotations(handler, task, annotations) { if (this.xfaFactory) { throw new Error(\"XFA: Cannot save new annotations.\"); } const partialEvaluator = new _evaluator.PartialEvaluator({ xref: this.xref, handler, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, options: this.evaluatorOptions }); const pageDict = this.pageDict; const annotationsArray = this.annotations.slice(); const newData = await _annotation.AnnotationFactory.saveNewAnnotations(partialEvaluator, task, annotations); for (const { ref } of newData.annotations) { annotationsArray.push(ref); } const savedDict = pageDict.get(\"Annots\"); pageDict.set(\"Annots\", annotationsArray); const buffer = []; let transform = null; if (this.xref.encrypt) { transform = this.xref.encrypt.createCipherTransform(this.ref.num, this.ref.gen); } (0, _writer.writeObject)(this.ref, pageDict, buffer, transform); if (savedDict) { pageDict.set(\"Annots\", savedDict); } const objects = newData.dependencies; objects.push({ ref: this.ref, data: buffer.join(\"\") }, ...newData.annotations); return objects; } save(handler, task, annotationStorage) { const partialEvaluator = new _evaluator.PartialEvaluator({ xref: this.xref, handler, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, options: this.evaluatorOptions }); return this._parsedAnnotations.then(function (annotations) { const newRefsPromises = []; for (const annotation of annotations) { if (!annotation.mustBePrinted(annotationStorage)) { continue; } newRefsPromises.push(annotation.save(partialEvaluator, task, annotationStorage).catch(function (reason) { (0, _util.warn)(\"save - ignoring annotation data during \" + `\"${task.name}\" task: \"${reason}\".`); return null; })); } return Promise.all(newRefsPromises).then(function (newRefs) { return newRefs.filter(newRef => !!newRef); }); }); } loadResources(keys) { if (!this.resourcesPromise) { this.resourcesPromise = this.pdfManager.ensure(this, \"resources\"); } return this.resourcesPromise.then(() => { const objectLoader = new _object_loader.ObjectLoader(this.resources, keys, this.xref); return objectLoader.load(); }); } getOperatorList({ handler, sink, task, intent, cacheKey, annotationStorage = null }) { const contentStreamPromise = this.getContentStream(handler); const resourcesPromise = this.loadResources([\"ColorSpace\", \"ExtGState\", \"Font\", \"Pattern\", \"Properties\", \"Shading\", \"XObject\"]); const partialEvaluator = new _evaluator.PartialEvaluator({ xref: this.xref, handler, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, options: this.evaluatorOptions }); const newAnnotationsByPage = !this.xfaFactory ? (0, _core_utils.getNewAnnotationsMap)(annotationStorage) : null; let newAnnotationsPromise = Promise.resolve(null); if (newAnnotationsByPage) { const newAnnotations = newAnnotationsByPage.get(this.pageIndex); if (newAnnotations) { newAnnotationsPromise = _annotation.AnnotationFactory.printNewAnnotations(partialEvaluator, task, newAnnotations); } } const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]); const pageListPromise = dataPromises.then(([contentStream]) => { const opList = new _operator_list.OperatorList(intent, sink); handler.send(\"StartRenderPage\", { transparency: partialEvaluator.hasBlendModes(this.resources, this.nonBlendModesSet), pageIndex: this.pageIndex, cacheKey }); return partialEvaluator.getOperatorList({ stream: contentStream, task, resources: this.resources, operatorList: opList }).then(function () { return opList; }); }); return Promise.all([pageListPromise, this._parsedAnnotations, newAnnotationsPromise]).then(function ([pageOpList, annotations, newAnnotations]) { if (newAnnotations) { annotations = annotations.concat(newAnnotations); } if (annotations.length === 0 || intent & _util.RenderingIntentFlag.ANNOTATIONS_DISABLE) { pageOpList.flush(true); return { length: pageOpList.totalLength }; } const renderForms = !!(intent & _util.RenderingIntentFlag.ANNOTATIONS_FORMS), intentAny = !!(intent & _util.RenderingIntentFlag.ANY), intentDisplay = !!(intent & _util.RenderingIntentFlag.DISPLAY), intentPrint = !!(intent & _util.RenderingIntentFlag.PRINT); const opListPromises = []; for (const annotation of annotations) { if (intentAny || intentDisplay && annotation.mustBeViewed(annotationStorage) || intentPrint && annotation.mustBePrinted(annotationStorage)) { opListPromises.push(annotation.getOperatorList(partialEvaluator, task, intent, renderForms, annotationStorage).catch(function (reason) { (0, _util.warn)(\"getOperatorList - ignoring annotation data during \" + `\"${task.name}\" task: \"${reason}\".`); return { opList: null, separateForm: false, separateCanvas: false }; })); } } return Promise.all(opListPromises).then(function (opLists) { let form = false, canvas = false; for (const { opList, separateForm, separateCanvas } of opLists) { pageOpList.addOpList(opList); if (separateForm) { form = separateForm; } if (separateCanvas) { canvas = separateCanvas; } } pageOpList.flush(true, { form, canvas }); return { length: pageOpList.totalLength }; }); }); } extractTextContent({ handler, task, includeMarkedContent, sink, combineTextItems }) { const contentStreamPromise = this.getContentStream(handler); const resourcesPromise = this.loadResources([\"ExtGState\", \"Font\", \"Properties\", \"XObject\"]); const dataPromises = Promise.all([contentStreamPromise, resourcesPromise]); return dataPromises.then(([contentStream]) => { const partialEvaluator = new _evaluator.PartialEvaluator({ xref: this.xref, handler, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, options: this.evaluatorOptions }); return partialEvaluator.getTextContent({ stream: contentStream, task, resources: this.resources, includeMarkedContent, combineTextItems, sink, viewBox: this.view }); }); } async getStructTree() { const structTreeRoot = await this.pdfManager.ensureCatalog(\"structTreeRoot\"); if (!structTreeRoot) { return null; } const structTree = await this.pdfManager.ensure(this, \"_parseStructTree\", [structTreeRoot]); return structTree.serializable; } _parseStructTree(structTreeRoot) { const tree = new _struct_tree.StructTreePage(structTreeRoot, this.pageDict); tree.parse(); return tree; } async getAnnotationsData(handler, task, intent) { const annotations = await this._parsedAnnotations; if (annotations.length === 0) { return []; } const textContentPromises = []; const annotationsData = []; let partialEvaluator; const intentAny = !!(intent & _util.RenderingIntentFlag.ANY), intentDisplay = !!(intent & _util.RenderingIntentFlag.DISPLAY), intentPrint = !!(intent & _util.RenderingIntentFlag.PRINT); for (const annotation of annotations) { const isVisible = intentAny || intentDisplay && annotation.viewable; if (isVisible || intentPrint && annotation.printable) { annotationsData.push(annotation.data); } if (annotation.hasTextContent && isVisible) { if (!partialEvaluator) { partialEvaluator = new _evaluator.PartialEvaluator({ xref: this.xref, handler, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, options: this.evaluatorOptions }); } textContentPromises.push(annotation.extractTextContent(partialEvaluator, task, this.view).catch(function (reason) { (0, _util.warn)(`getAnnotationsData - ignoring textContent during \"${task.name}\" task: \"${reason}\".`); })); } } await Promise.all(textContentPromises); return annotationsData; } get annotations() { const annots = this._getInheritableProperty(\"Annots\"); return (0, _util.shadow)(this, \"annotations\", Array.isArray(annots) ? annots : []); } get _parsedAnnotations() { const parsedAnnotations = this.pdfManager.ensure(this, \"annotations\").then(() => { const annotationPromises = []; for (const annotationRef of this.annotations) { annotationPromises.push(_annotation.AnnotationFactory.create(this.xref, annotationRef, this.pdfManager, this._localIdFactory, false).catch(function (reason) { (0, _util.warn)(`_parsedAnnotations: \"${reason}\".`); return null; })); } return Promise.all(annotationPromises).then(function (annotations) { if (annotations.length === 0) { return annotations; } const sortedAnnotations = []; let popupAnnotations; for (const annotation of annotations) { if (!annotation) { continue; } if (annotation instanceof _annotation.PopupAnnotation) { if (!popupAnnotations) { popupAnnotations = []; } popupAnnotations.push(annotation); continue; } sortedAnnotations.push(annotation); } if (popupAnnotations) { sortedAnnotations.push(...popupAnnotations); } return sortedAnnotations; }); }); return (0, _util.shadow)(this, \"_parsedAnnotations\", parsedAnnotations); } get jsActions() { const actions = (0, _core_utils.collectActions)(this.xref, this.pageDict, _util.PageActionEventType); return (0, _util.shadow)(this, \"jsActions\", actions); } } exports.Page = Page; const PDF_HEADER_SIGNATURE = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d]); const STARTXREF_SIGNATURE = new Uint8Array([0x73, 0x74, 0x61, 0x72, 0x74, 0x78, 0x72, 0x65, 0x66]); const ENDOBJ_SIGNATURE = new Uint8Array([0x65, 0x6e, 0x64, 0x6f, 0x62, 0x6a]); const FINGERPRINT_FIRST_BYTES = 1024; const EMPTY_FINGERPRINT = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"; function find(stream, signature, limit = 1024, backwards = false) { const signatureLength = signature.length; const scanBytes = stream.peekBytes(limit); const scanLength = scanBytes.length - signatureLength; if (scanLength = signatureEnd) { let j = 0; while (j < signatureLength && scanBytes[pos - j] === signature[signatureEnd - j]) { j++; } if (j >= signatureLength) { stream.pos += pos - signatureEnd; return true; } pos--; } } else { let pos = 0; while (pos RECURSION_LIMIT) { (0, _util.warn)(\"_hasOnlyDocumentSignatures: maximum recursion depth reached\"); return false; } return this._hasOnlyDocumentSignatures(field.get(\"Kids\"), recursionDepth); } const isSignature = (0, _primitives.isName)(field.get(\"FT\"), \"Sig\"); const rectangle = field.get(\"Rect\"); const isInvisible = Array.isArray(rectangle) && rectangle.every(value => value === 0); return isSignature && isInvisible; }); } get _xfaStreams() { const acroForm = this.catalog.acroForm; if (!acroForm) { return null; } const xfa = acroForm.get(\"XFA\"); const entries = { \"xdp:xdp\": \"\", template: \"\", datasets: \"\", config: \"\", connectionSet: \"\", localeSet: \"\", stylesheet: \"\", \"/xdp:xdp\": \"\" }; if (xfa instanceof _base_stream.BaseStream && !xfa.isEmpty) { entries[\"xdp:xdp\"] = xfa; return entries; } if (!Array.isArray(xfa) || xfa.length === 0) { return null; } for (let i = 0, ii = xfa.length; i < ii; i += 2) { let name; if (i === 0) { name = \"xdp:xdp\"; } else if (i === ii - 2) { name = \"/xdp:xdp\"; } else { name = xfa[i]; } if (!entries.hasOwnProperty(name)) { continue; } const data = this.xref.fetchIfRef(xfa[i + 1]); if (!(data instanceof _base_stream.BaseStream) || data.isEmpty) { continue; } entries[name] = data; } return entries; } get xfaDatasets() { const streams = this._xfaStreams; if (!streams) { return (0, _util.shadow)(this, \"xfaDatasets\", null); } for (const key of [\"datasets\", \"xdp:xdp\"]) { const stream = streams[key]; if (!stream) { continue; } try { const str = (0, _util.stringToUTF8String)(stream.getString()); const data = { [key]: str }; return (0, _util.shadow)(this, \"xfaDatasets\", new _dataset_reader.DatasetReader(data)); } catch (_) { (0, _util.warn)(\"XFA - Invalid utf-8 string.\"); break; } } return (0, _util.shadow)(this, \"xfaDatasets\", null); } get xfaData() { const streams = this._xfaStreams; if (!streams) { return null; } const data = Object.create(null); for (const [key, stream] of Object.entries(streams)) { if (!stream) { continue; } try { data[key] = (0, _util.stringToUTF8String)(stream.getString()); } catch (_) { (0, _util.warn)(\"XFA - Invalid utf-8 string.\"); return null; } } return data; } get xfaFactory() { let data; if (this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm) { data = this.xfaData; } return (0, _util.shadow)(this, \"xfaFactory\", data ? new _factory.XFAFactory(data) : null); } get isPureXfa() { return this.xfaFactory ? this.xfaFactory.isValid() : false; } get htmlForXfa() { return this.xfaFactory ? this.xfaFactory.getPages() : null; } async loadXfaImages() { const xfaImagesDict = await this.pdfManager.ensureCatalog(\"xfaImages\"); if (!xfaImagesDict) { return; } const keys = xfaImagesDict.getKeys(); const objectLoader = new _object_loader.ObjectLoader(xfaImagesDict, keys, this.xref); await objectLoader.load(); const xfaImages = new Map(); for (const key of keys) { const stream = xfaImagesDict.get(key); if (stream instanceof _base_stream.BaseStream) { xfaImages.set(key, stream.getBytes()); } } this.xfaFactory.setImages(xfaImages); } async loadXfaFonts(handler, task) { const acroForm = await this.pdfManager.ensureCatalog(\"acroForm\"); if (!acroForm) { return; } const resources = await acroForm.getAsync(\"DR\"); if (!(resources instanceof _primitives.Dict)) { return; } const objectLoader = new _object_loader.ObjectLoader(resources, [\"Font\"], this.xref); await objectLoader.load(); const fontRes = resources.get(\"Font\"); if (!(fontRes instanceof _primitives.Dict)) { return; } const options = Object.assign(Object.create(null), this.pdfManager.evaluatorOptions); options.useSystemFonts = false; const partialEvaluator = new _evaluator.PartialEvaluator({ xref: this.xref, handler, pageIndex: -1, idFactory: this._globalIdFactory, fontCache: this.catalog.fontCache, builtInCMapCache: this.catalog.builtInCMapCache, standardFontDataCache: this.catalog.standardFontDataCache, options }); const operatorList = new _operator_list.OperatorList(); const pdfFonts = []; const initialState = { get font() { return pdfFonts.at(-1); }, set font(font) { pdfFonts.push(font); }, clone() { return this; } }; const fonts = new Map(); fontRes.forEach((fontName, font) => { fonts.set(fontName, font); }); const promises = []; for (const [fontName, font] of fonts) { const descriptor = font.get(\"FontDescriptor\"); if (!(descriptor instanceof _primitives.Dict)) { continue; } let fontFamily = descriptor.get(\"FontFamily\"); fontFamily = fontFamily.replace(/[ ]+(\\d)/g, \"$1\"); const fontWeight = descriptor.get(\"FontWeight\"); const italicAngle = -descriptor.get(\"ItalicAngle\"); const cssFontInfo = { fontFamily, fontWeight, italicAngle }; if (!(0, _core_utils.validateCSSFont)(cssFontInfo)) { continue; } promises.push(partialEvaluator.handleSetFont(resources, [_primitives.Name.get(fontName), 1], null, operatorList, task, initialState, null, cssFontInfo).catch(function (reason) { (0, _util.warn)(`loadXfaFonts: \"${reason}\".`); return null; })); } await Promise.all(promises); const missingFonts = this.xfaFactory.setFonts(pdfFonts); if (!missingFonts) { return; } options.ignoreErrors = true; promises.length = 0; pdfFonts.length = 0; const reallyMissingFonts = new Set(); for (const missing of missingFonts) { if (!(0, _xfa_fonts.getXfaFontName)(`${missing}-Regular`)) { reallyMissingFonts.add(missing); } } if (reallyMissingFonts.size) { missingFonts.push(\"PdfJS-Fallback\"); } for (const missing of missingFonts) { if (reallyMissingFonts.has(missing)) { continue; } for (const fontInfo of [{ name: \"Regular\", fontWeight: 400, italicAngle: 0 }, { name: \"Bold\", fontWeight: 700, italicAngle: 0 }, { name: \"Italic\", fontWeight: 400, italicAngle: 12 }, { name: \"BoldItalic\", fontWeight: 700, italicAngle: 12 }]) { const name = `${missing}-${fontInfo.name}`; const dict = (0, _xfa_fonts.getXfaFontDict)(name); promises.push(partialEvaluator.handleSetFont(resources, [_primitives.Name.get(name), 1], null, operatorList, task, initialState, dict, { fontFamily: missing, fontWeight: fontInfo.fontWeight, italicAngle: fontInfo.italicAngle }).catch(function (reason) { (0, _util.warn)(`loadXfaFonts: \"${reason}\".`); return null; })); } } await Promise.all(promises); this.xfaFactory.appendFonts(pdfFonts, reallyMissingFonts); } async serializeXfaData(annotationStorage) { return this.xfaFactory ? this.xfaFactory.serializeData(annotationStorage) : null; } get version() { return this.catalog.version || this._version; } get formInfo() { const formInfo = { hasFields: false, hasAcroForm: false, hasXfa: false, hasSignatures: false }; const acroForm = this.catalog.acroForm; if (!acroForm) { return (0, _util.shadow)(this, \"formInfo\", formInfo); } try { const fields = acroForm.get(\"Fields\"); const hasFields = Array.isArray(fields) && fields.length > 0; formInfo.hasFields = hasFields; const xfa = acroForm.get(\"XFA\"); formInfo.hasXfa = Array.isArray(xfa) && xfa.length > 0 || xfa instanceof _base_stream.BaseStream && !xfa.isEmpty; const sigFlags = acroForm.get(\"SigFlags\"); const hasSignatures = !!(sigFlags & 0x1); const hasOnlyDocumentSignatures = hasSignatures && this._hasOnlyDocumentSignatures(fields); formInfo.hasAcroForm = hasFields && !hasOnlyDocumentSignatures; formInfo.hasSignatures = hasSignatures; } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(`Cannot fetch form information: \"${ex}\".`); } return (0, _util.shadow)(this, \"formInfo\", formInfo); } get documentInfo() { const docInfo = { PDFFormatVersion: this.version, Language: this.catalog.lang, EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null, IsLinearized: !!this.linearization, IsAcroFormPresent: this.formInfo.hasAcroForm, IsXFAPresent: this.formInfo.hasXfa, IsCollectionPresent: !!this.catalog.collection, IsSignaturesPresent: this.formInfo.hasSignatures }; let infoDict; try { infoDict = this.xref.trailer.get(\"Info\"); } catch (err) { if (err instanceof _core_utils.MissingDataException) { throw err; } (0, _util.info)(\"The document information dictionary is invalid.\"); } if (!(infoDict instanceof _primitives.Dict)) { return (0, _util.shadow)(this, \"documentInfo\", docInfo); } for (const key of infoDict.getKeys()) { const value = infoDict.get(key); switch (key) { case \"Title\": case \"Author\": case \"Subject\": case \"Keywords\": case \"Creator\": case \"Producer\": case \"CreationDate\": case \"ModDate\": if (typeof value === \"string\") { docInfo[key] = (0, _util.stringToPDFString)(value); continue; } break; case \"Trapped\": if (value instanceof _primitives.Name) { docInfo[key] = value; continue; } break; default: let customValue; switch (typeof value) { case \"string\": customValue = (0, _util.stringToPDFString)(value); break; case \"number\": case \"boolean\": customValue = value; break; default: if (value instanceof _primitives.Name) { customValue = value; } break; } if (customValue === undefined) { (0, _util.warn)(`Bad value, for custom key \"${key}\", in Info: ${value}.`); continue; } if (!docInfo.Custom) { docInfo.Custom = Object.create(null); } docInfo.Custom[key] = customValue; continue; } (0, _util.warn)(`Bad value, for key \"${key}\", in Info: ${value}.`); } return (0, _util.shadow)(this, \"documentInfo\", docInfo); } get fingerprints() { function validate(data) { return typeof data === \"string\" && data.length > 0 && data !== EMPTY_FINGERPRINT; } function hexString(hash) { const buf = []; for (const num of hash) { const hex = num.toString(16); buf.push(hex.padStart(2, \"0\")); } return buf.join(\"\"); } const idArray = this.xref.trailer.get(\"ID\"); let hashOriginal, hashModified; if (Array.isArray(idArray) && validate(idArray[0])) { hashOriginal = (0, _util.stringToBytes)(idArray[0]); if (idArray[1] !== idArray[0] && validate(idArray[1])) { hashModified = (0, _util.stringToBytes)(idArray[1]); } } else { hashOriginal = (0, _crypto.calculateMD5)(this.stream.getByteRange(0, FINGERPRINT_FIRST_BYTES), 0, FINGERPRINT_FIRST_BYTES); } return (0, _util.shadow)(this, \"fingerprints\", [hexString(hashOriginal), hashModified ? hexString(hashModified) : null]); } async _getLinearizationPage(pageIndex) { const { catalog, linearization, xref } = this; const ref = _primitives.Ref.get(linearization.objectNumberFirst, 0); try { const obj = await xref.fetchAsync(ref); if (obj instanceof _primitives.Dict) { let type = obj.getRaw(\"Type\"); if (type instanceof _primitives.Ref) { type = await xref.fetchAsync(type); } if ((0, _primitives.isName)(type, \"Page\") || !obj.has(\"Type\") && !obj.has(\"Kids\")) { if (!catalog.pageKidsCountCache.has(ref)) { catalog.pageKidsCountCache.put(ref, 1); } if (!catalog.pageIndexCache.has(ref)) { catalog.pageIndexCache.put(ref, 0); } return [obj, ref]; } } throw new _util.FormatError(\"The Linearization dictionary doesn't point to a valid Page dictionary.\"); } catch (reason) { (0, _util.warn)(`_getLinearizationPage: \"${reason.message}\".`); return catalog.getPageDict(pageIndex); } } getPage(pageIndex) { const cachedPromise = this._pagePromises.get(pageIndex); if (cachedPromise) { return cachedPromise; } const { catalog, linearization, xfaFactory } = this; let promise; if (xfaFactory) { promise = Promise.resolve([_primitives.Dict.empty, null]); } else if (linearization && linearization.pageFirst === pageIndex) { promise = this._getLinearizationPage(pageIndex); } else { promise = catalog.getPageDict(pageIndex); } promise = promise.then(([pageDict, ref]) => { return new Page({ pdfManager: this.pdfManager, xref: this.xref, pageIndex, pageDict, ref, globalIdFactory: this._globalIdFactory, fontCache: catalog.fontCache, builtInCMapCache: catalog.builtInCMapCache, standardFontDataCache: catalog.standardFontDataCache, globalImageCache: catalog.globalImageCache, nonBlendModesSet: catalog.nonBlendModesSet, xfaFactory }); }); this._pagePromises.set(pageIndex, promise); return promise; } async checkFirstPage(recoveryMode = false) { if (recoveryMode) { return; } try { await this.getPage(0); } catch (reason) { if (reason instanceof _core_utils.XRefEntryException) { this._pagePromises.delete(0); await this.cleanup(); throw new _core_utils.XRefParseException(); } } } async checkLastPage(recoveryMode = false) { const { catalog, pdfManager } = this; catalog.setActualNumPages(); let numPages; try { await Promise.all([pdfManager.ensureDoc(\"xfaFactory\"), pdfManager.ensureDoc(\"linearization\"), pdfManager.ensureCatalog(\"numPages\")]); if (this.xfaFactory) { return; } else if (this.linearization) { numPages = this.linearization.numPages; } else { numPages = catalog.numPages; } if (!Number.isInteger(numPages)) { throw new _util.FormatError(\"Page count is not an integer.\"); } else if (numPages {}); } else { promise = Promise.resolve(new Page({ pdfManager, xref: this.xref, pageIndex, pageDict, ref, globalIdFactory: this._globalIdFactory, fontCache: catalog.fontCache, builtInCMapCache: catalog.builtInCMapCache, standardFontDataCache: catalog.standardFontDataCache, globalImageCache: catalog.globalImageCache, nonBlendModesSet: catalog.nonBlendModesSet, xfaFactory: null })); } this._pagePromises.set(pageIndex, promise); } catalog.setActualNumPages(pagesTree.size); } } fontFallback(id, handler) { return this.catalog.fontFallback(id, handler); } async cleanup(manuallyTriggered = false) { return this.catalog ? this.catalog.cleanup(manuallyTriggered) : (0, _cleanup_helper.clearGlobalCaches)(); } _collectFieldObjects(name, fieldRef, promises) { const field = this.xref.fetchIfRef(fieldRef); if (field.has(\"T\")) { const partName = (0, _util.stringToPDFString)(field.get(\"T\")); if (name === \"\") { name = partName; } else { name = `${name}.${partName}`; } } if (!promises.has(name)) { promises.set(name, []); } promises.get(name).push(_annotation.AnnotationFactory.create(this.xref, fieldRef, this.pdfManager, this._localIdFactory, true).then(annotation => annotation && annotation.getFieldObject()).catch(function (reason) { (0, _util.warn)(`_collectFieldObjects: \"${reason}\".`); return null; })); if (field.has(\"Kids\")) { const kids = field.get(\"Kids\"); for (const kid of kids) { this._collectFieldObjects(name, kid, promises); } } } get fieldObjects() { if (!this.formInfo.hasFields) { return (0, _util.shadow)(this, \"fieldObjects\", Promise.resolve(null)); } const allFields = Object.create(null); const fieldPromises = new Map(); for (const fieldRef of this.catalog.acroForm.get(\"Fields\")) { this._collectFieldObjects(\"\", fieldRef, fieldPromises); } const allPromises = []; for (const [name, promises] of fieldPromises) { allPromises.push(Promise.all(promises).then(fields => { fields = fields.filter(field => !!field); if (fields.length > 0) { allFields[name] = fields; } })); } return (0, _util.shadow)(this, \"fieldObjects\", Promise.all(allPromises).then(() => allFields)); } get hasJSActions() { const promise = this.pdfManager.ensureDoc(\"_parseHasJSActions\"); return (0, _util.shadow)(this, \"hasJSActions\", promise); } async _parseHasJSActions() { const [catalogJsActions, fieldObjects] = await Promise.all([this.pdfManager.ensureCatalog(\"jsActions\"), this.pdfManager.ensureDoc(\"fieldObjects\")]); if (catalogJsActions) { return true; } if (fieldObjects) { return Object.values(fieldObjects).some(fieldObject => fieldObject.some(object => object.actions !== null)); } return false; } get calculationOrderIds() { const acroForm = this.catalog.acroForm; if (!acroForm || !acroForm.has(\"CO\")) { return (0, _util.shadow)(this, \"calculationOrderIds\", null); } const calculationOrder = acroForm.get(\"CO\"); if (!Array.isArray(calculationOrder) || calculationOrder.length === 0) { return (0, _util.shadow)(this, \"calculationOrderIds\", null); } const ids = []; for (const id of calculationOrder) { if (id instanceof _primitives.Ref) { ids.push(id.toString()); } } if (ids.length === 0) { return (0, _util.shadow)(this, \"calculationOrderIds\", null); } return (0, _util.shadow)(this, \"calculationOrderIds\", ids); } } exports.PDFDocument = PDFDocument; /***/ }), /* 10 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.PopupAnnotation = exports.MarkupAnnotation = exports.AnnotationFactory = exports.AnnotationBorderStyle = exports.Annotation = void 0; exports.getQuadPoints = getQuadPoints; var _util = __w_pdfjs_require__(2); var _core_utils = __w_pdfjs_require__(4); var _default_appearance = __w_pdfjs_require__(11); var _primitives = __w_pdfjs_require__(3); var _writer = __w_pdfjs_require__(63); var _base_stream = __w_pdfjs_require__(5); var _bidi = __w_pdfjs_require__(58); var _catalog = __w_pdfjs_require__(67); var _colorspace = __w_pdfjs_require__(12); var _file_spec = __w_pdfjs_require__(70); var _object_loader = __w_pdfjs_require__(73); var _operator_list = __w_pdfjs_require__(60); var _stream = __w_pdfjs_require__(8); var _factory = __w_pdfjs_require__(74); class AnnotationFactory { static create(xref, ref, pdfManager, idFactory, collectFields) { return Promise.all([pdfManager.ensureCatalog(\"acroForm\"), pdfManager.ensureCatalog(\"baseUrl\"), pdfManager.ensureCatalog(\"attachments\"), pdfManager.ensureDoc(\"xfaDatasets\"), collectFields ? this._getPageIndex(xref, ref, pdfManager) : -1]).then(([acroForm, baseUrl, attachments, xfaDatasets, pageIndex]) => pdfManager.ensure(this, \"_create\", [xref, ref, pdfManager, idFactory, acroForm, attachments, xfaDatasets, collectFields, pageIndex])); } static _create(xref, ref, pdfManager, idFactory, acroForm, attachments = null, xfaDatasets, collectFields, pageIndex = -1) { const dict = xref.fetchIfRef(ref); if (!(dict instanceof _primitives.Dict)) { return undefined; } const id = ref instanceof _primitives.Ref ? ref.toString() : `annot_${idFactory.createObjId()}`; let subtype = dict.get(\"Subtype\"); subtype = subtype instanceof _primitives.Name ? subtype.name : null; const acroFormDict = acroForm instanceof _primitives.Dict ? acroForm : _primitives.Dict.empty; const parameters = { xref, ref, dict, subtype, id, pdfManager, acroForm: acroFormDict, attachments, xfaDatasets, collectFields, needAppearances: !collectFields && acroFormDict.get(\"NeedAppearances\") === true, pageIndex, isOffscreenCanvasSupported: _util.FeatureTest.isOffscreenCanvasSupported && pdfManager.evaluatorOptions.isOffscreenCanvasSupported }; switch (subtype) { case \"Link\": return new LinkAnnotation(parameters); case \"Text\": return new TextAnnotation(parameters); case \"Widget\": let fieldType = (0, _core_utils.getInheritableProperty)({ dict, key: \"FT\" }); fieldType = fieldType instanceof _primitives.Name ? fieldType.name : null; switch (fieldType) { case \"Tx\": return new TextWidgetAnnotation(parameters); case \"Btn\": return new ButtonWidgetAnnotation(parameters); case \"Ch\": return new ChoiceWidgetAnnotation(parameters); case \"Sig\": return new SignatureWidgetAnnotation(parameters); } (0, _util.warn)(`Unimplemented widget field type \"${fieldType}\", ` + \"falling back to base field type.\"); return new WidgetAnnotation(parameters); case \"Popup\": return new PopupAnnotation(parameters); case \"FreeText\": return new FreeTextAnnotation(parameters); case \"Line\": return new LineAnnotation(parameters); case \"Square\": return new SquareAnnotation(parameters); case \"Circle\": return new CircleAnnotation(parameters); case \"PolyLine\": return new PolylineAnnotation(parameters); case \"Polygon\": return new PolygonAnnotation(parameters); case \"Caret\": return new CaretAnnotation(parameters); case \"Ink\": return new InkAnnotation(parameters); case \"Highlight\": return new HighlightAnnotation(parameters); case \"Underline\": return new UnderlineAnnotation(parameters); case \"Squiggly\": return new SquigglyAnnotation(parameters); case \"StrikeOut\": return new StrikeOutAnnotation(parameters); case \"Stamp\": return new StampAnnotation(parameters); case \"FileAttachment\": return new FileAttachmentAnnotation(parameters); default: if (!collectFields) { if (!subtype) { (0, _util.warn)(\"Annotation is missing the required /Subtype.\"); } else { (0, _util.warn)(`Unimplemented annotation type \"${subtype}\", ` + \"falling back to base annotation.\"); } } return new Annotation(parameters); } } static async _getPageIndex(xref, ref, pdfManager) { try { const annotDict = await xref.fetchIfRefAsync(ref); if (!(annotDict instanceof _primitives.Dict)) { return -1; } const pageRef = annotDict.getRaw(\"P\"); if (!(pageRef instanceof _primitives.Ref)) { return -1; } const pageIndex = await pdfManager.ensureCatalog(\"getPageIndex\", [pageRef]); return pageIndex; } catch (ex) { (0, _util.warn)(`_getPageIndex: \"${ex}\".`); return -1; } } static async saveNewAnnotations(evaluator, task, annotations) { const xref = evaluator.xref; let baseFontRef; const dependencies = []; const promises = []; for (const annotation of annotations) { switch (annotation.annotationType) { case _util.AnnotationEditorType.FREETEXT: if (!baseFontRef) { const baseFont = new _primitives.Dict(xref); baseFont.set(\"BaseFont\", _primitives.Name.get(\"Helvetica\")); baseFont.set(\"Type\", _primitives.Name.get(\"Font\")); baseFont.set(\"Subtype\", _primitives.Name.get(\"Type1\")); baseFont.set(\"Encoding\", _primitives.Name.get(\"WinAnsiEncoding\")); const buffer = []; baseFontRef = xref.getNewTemporaryRef(); (0, _writer.writeObject)(baseFontRef, baseFont, buffer, null); dependencies.push({ ref: baseFontRef, data: buffer.join(\"\") }); } promises.push(FreeTextAnnotation.createNewAnnotation(xref, annotation, dependencies, { evaluator, task, baseFontRef })); break; case _util.AnnotationEditorType.INK: promises.push(InkAnnotation.createNewAnnotation(xref, annotation, dependencies)); } } return { annotations: await Promise.all(promises), dependencies }; } static async printNewAnnotations(evaluator, task, annotations) { if (!annotations) { return null; } const xref = evaluator.xref; const promises = []; const isOffscreenCanvasSupported = _util.FeatureTest.isOffscreenCanvasSupported && evaluator.options.isOffscreenCanvasSupported; for (const annotation of annotations) { switch (annotation.annotationType) { case _util.AnnotationEditorType.FREETEXT: promises.push(FreeTextAnnotation.createNewPrintAnnotation(xref, annotation, { evaluator, task, isOffscreenCanvasSupported })); break; case _util.AnnotationEditorType.INK: promises.push(InkAnnotation.createNewPrintAnnotation(xref, annotation, { isOffscreenCanvasSupported })); break; } } return Promise.all(promises); } } exports.AnnotationFactory = AnnotationFactory; function getRgbColor(color, defaultColor = new Uint8ClampedArray(3)) { if (!Array.isArray(color)) { return defaultColor; } const rgbColor = defaultColor || new Uint8ClampedArray(3); switch (color.length) { case 0: return null; case 1: _colorspace.ColorSpace.singletons.gray.getRgbItem(color, 0, rgbColor, 0); return rgbColor; case 3: _colorspace.ColorSpace.singletons.rgb.getRgbItem(color, 0, rgbColor, 0); return rgbColor; case 4: _colorspace.ColorSpace.singletons.cmyk.getRgbItem(color, 0, rgbColor, 0); return rgbColor; default: return defaultColor; } } function getPdfColorArray(color) { return Array.from(color, c => c / 255); } function getQuadPoints(dict, rect) { const quadPoints = dict.getArray(\"QuadPoints\"); if (!Array.isArray(quadPoints) || quadPoints.length === 0 || quadPoints.length % 8 > 0) { return null; } const quadPointsLists = []; for (let i = 0, ii = quadPoints.length / 8; i < ii; i++) { let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity; for (let j = i * 8, jj = i * 8 + 8; j < jj; j += 2) { const x = quadPoints[j]; const y = quadPoints[j + 1]; minX = Math.min(x, minX); maxX = Math.max(x, maxX); minY = Math.min(y, minY); maxY = Math.max(y, maxY); } if (rect !== null && (minX < rect[0] || maxX > rect[2] || minY < rect[1] || maxY > rect[3])) { return null; } quadPointsLists.push([{ x: minX, y: maxY }, { x: maxX, y: maxY }, { x: minX, y: minY }, { x: maxX, y: minY }]); } return quadPointsLists; } function getTransformMatrix(rect, bbox, matrix) { const [minX, minY, maxX, maxY] = _util.Util.getAxialAlignedBoundingBox(bbox, matrix); if (minX === maxX || minY === maxY) { return [1, 0, 0, 1, rect[0], rect[1]]; } const xRatio = (rect[2] - rect[0]) / (maxX - minX); const yRatio = (rect[3] - rect[1]) / (maxY - minY); return [xRatio, 0, 0, yRatio, rect[0] - minX * xRatio, rect[1] - minY * yRatio]; } class Annotation { constructor(params) { const { dict, xref } = params; this.setTitle(dict.get(\"T\")); this.setContents(dict.get(\"Contents\")); this.setModificationDate(dict.get(\"M\")); this.setFlags(dict.get(\"F\")); this.setRectangle(dict.getArray(\"Rect\")); this.setColor(dict.getArray(\"C\")); this.setBorderStyle(dict); this.setAppearance(dict); this.setOptionalContent(dict); const MK = dict.get(\"MK\"); this.setBorderAndBackgroundColors(MK); this.setRotation(MK); this._streams = []; if (this.appearance) { this._streams.push(this.appearance); } this.data = { annotationFlags: this.flags, borderStyle: this.borderStyle, color: this.color, backgroundColor: this.backgroundColor, borderColor: this.borderColor, rotation: this.rotation, contentsObj: this._contents, hasAppearance: !!this.appearance, id: params.id, modificationDate: this.modificationDate, rect: this.rectangle, subtype: params.subtype, hasOwnCanvas: false }; if (params.collectFields) { const kids = dict.get(\"Kids\"); if (Array.isArray(kids)) { const kidIds = []; for (const kid of kids) { if (kid instanceof _primitives.Ref) { kidIds.push(kid.toString()); } } if (kidIds.length !== 0) { this.data.kidIds = kidIds; } } this.data.actions = (0, _core_utils.collectActions)(xref, dict, _util.AnnotationActionEventType); this.data.fieldName = this._constructFieldName(dict); this.data.pageIndex = params.pageIndex; } this._isOffscreenCanvasSupported = params.isOffscreenCanvasSupported; this._fallbackFontDict = null; this._needAppearances = false; } _hasFlag(flags, flag) { return !!(flags & flag); } _isViewable(flags) { return !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE) && !this._hasFlag(flags, _util.AnnotationFlag.NOVIEW); } _isPrintable(flags) { return this._hasFlag(flags, _util.AnnotationFlag.PRINT) && !this._hasFlag(flags, _util.AnnotationFlag.INVISIBLE); } mustBeViewed(annotationStorage) { const storageEntry = annotationStorage && annotationStorage.get(this.data.id); if (storageEntry && storageEntry.hidden !== undefined) { return !storageEntry.hidden; } return this.viewable && !this._hasFlag(this.flags, _util.AnnotationFlag.HIDDEN); } mustBePrinted(annotationStorage) { const storageEntry = annotationStorage && annotationStorage.get(this.data.id); if (storageEntry && storageEntry.print !== undefined) { return storageEntry.print; } return this.printable; } get viewable() { if (this.data.quadPoints === null) { return false; } if (this.flags === 0) { return true; } return this._isViewable(this.flags); } get printable() { if (this.data.quadPoints === null) { return false; } if (this.flags === 0) { return false; } return this._isPrintable(this.flags); } _parseStringHelper(data) { const str = typeof data === \"string\" ? (0, _util.stringToPDFString)(data) : \"\"; const dir = str && (0, _bidi.bidi)(str).dir === \"rtl\" ? \"rtl\" : \"ltr\"; return { str, dir }; } setDefaultAppearance(params) { const defaultAppearance = (0, _core_utils.getInheritableProperty)({ dict: params.dict, key: \"DA\" }) || params.acroForm.get(\"DA\"); this._defaultAppearance = typeof defaultAppearance === \"string\" ? defaultAppearance : \"\"; this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance); } setTitle(title) { this._title = this._parseStringHelper(title); } setContents(contents) { this._contents = this._parseStringHelper(contents); } setModificationDate(modificationDate) { this.modificationDate = typeof modificationDate === \"string\" ? modificationDate : null; } setFlags(flags) { this.flags = Number.isInteger(flags) && flags > 0 ? flags : 0; } hasFlag(flag) { return this._hasFlag(this.flags, flag); } setRectangle(rectangle) { if (Array.isArray(rectangle) && rectangle.length === 4) { this.rectangle = _util.Util.normalizeRect(rectangle); } else { this.rectangle = [0, 0, 0, 0]; } } setColor(color) { this.color = getRgbColor(color); } setLineEndings(lineEndings) { this.lineEndings = [\"None\", \"None\"]; if (Array.isArray(lineEndings) && lineEndings.length === 2) { for (let i = 0; i < 2; i++) { const obj = lineEndings[i]; if (obj instanceof _primitives.Name) { switch (obj.name) { case \"None\": continue; case \"Square\": case \"Circle\": case \"Diamond\": case \"OpenArrow\": case \"ClosedArrow\": case \"Butt\": case \"ROpenArrow\": case \"RClosedArrow\": case \"Slash\": this.lineEndings[i] = obj.name; continue; } } (0, _util.warn)(`Ignoring invalid lineEnding: ${obj}`); } } } setRotation(mk) { this.rotation = 0; if (mk instanceof _primitives.Dict) { let angle = mk.get(\"R\") || 0; if (Number.isInteger(angle) && angle !== 0) { angle %= 360; if (angle < 0) { angle += 360; } if (angle % 90 === 0) { this.rotation = angle; } } } } setBorderAndBackgroundColors(mk) { if (mk instanceof _primitives.Dict) { this.borderColor = getRgbColor(mk.getArray(\"BC\"), null); this.backgroundColor = getRgbColor(mk.getArray(\"BG\"), null); } else { this.borderColor = this.backgroundColor = null; } } setBorderStyle(borderStyle) { this.borderStyle = new AnnotationBorderStyle(); if (!(borderStyle instanceof _primitives.Dict)) { return; } if (borderStyle.has(\"BS\")) { const dict = borderStyle.get(\"BS\"); const dictType = dict.get(\"Type\"); if (!dictType || (0, _primitives.isName)(dictType, \"Border\")) { this.borderStyle.setWidth(dict.get(\"W\"), this.rectangle); this.borderStyle.setStyle(dict.get(\"S\")); this.borderStyle.setDashArray(dict.getArray(\"D\")); } } else if (borderStyle.has(\"Border\")) { const array = borderStyle.getArray(\"Border\"); if (Array.isArray(array) && array.length >= 3) { this.borderStyle.setHorizontalCornerRadius(array[0]); this.borderStyle.setVerticalCornerRadius(array[1]); this.borderStyle.setWidth(array[2], this.rectangle); if (array.length === 4) { this.borderStyle.setDashArray(array[3], true); } } } else { this.borderStyle.setWidth(0); } } setAppearance(dict) { this.appearance = null; const appearanceStates = dict.get(\"AP\"); if (!(appearanceStates instanceof _primitives.Dict)) { return; } const normalAppearanceState = appearanceStates.get(\"N\"); if (normalAppearanceState instanceof _base_stream.BaseStream) { this.appearance = normalAppearanceState; return; } if (!(normalAppearanceState instanceof _primitives.Dict)) { return; } const as = dict.get(\"AS\"); if (!(as instanceof _primitives.Name) || !normalAppearanceState.has(as.name)) { return; } this.appearance = normalAppearanceState.get(as.name); } setOptionalContent(dict) { this.oc = null; const oc = dict.get(\"OC\"); if (oc instanceof _primitives.Name) { (0, _util.warn)(\"setOptionalContent: Support for /Name-entry is not implemented.\"); } else if (oc instanceof _primitives.Dict) { this.oc = oc; } } loadResources(keys, appearance) { return appearance.dict.getAsync(\"Resources\").then(resources => { if (!resources) { return undefined; } const objectLoader = new _object_loader.ObjectLoader(resources, keys, resources.xref); return objectLoader.load().then(function () { return resources; }); }); } async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) { const data = this.data; let appearance = this.appearance; const isUsingOwnCanvas = !!(this.data.hasOwnCanvas && intent & _util.RenderingIntentFlag.DISPLAY); if (!appearance) { if (!isUsingOwnCanvas) { return { opList: new _operator_list.OperatorList(), separateForm: false, separateCanvas: false }; } appearance = new _stream.StringStream(\"\"); appearance.dict = new _primitives.Dict(); } const appearanceDict = appearance.dict; const resources = await this.loadResources([\"ExtGState\", \"ColorSpace\", \"Pattern\", \"Shading\", \"XObject\", \"Font\"], appearance); const bbox = appearanceDict.getArray(\"BBox\") || [0, 0, 1, 1]; const matrix = appearanceDict.getArray(\"Matrix\") || [1, 0, 0, 1, 0, 0]; const transform = getTransformMatrix(data.rect, bbox, matrix); const opList = new _operator_list.OperatorList(); let optionalContent; if (this.oc) { optionalContent = await evaluator.parseMarkedContentProps(this.oc, null); } if (optionalContent !== undefined) { opList.addOp(_util.OPS.beginMarkedContentProps, [\"OC\", optionalContent]); } opList.addOp(_util.OPS.beginAnnotation, [data.id, data.rect, transform, matrix, isUsingOwnCanvas]); await evaluator.getOperatorList({ stream: appearance, task, resources, operatorList: opList, fallbackFontDict: this._fallbackFontDict }); opList.addOp(_util.OPS.endAnnotation, []); if (optionalContent !== undefined) { opList.addOp(_util.OPS.endMarkedContent, []); } this.reset(); return { opList, separateForm: false, separateCanvas: isUsingOwnCanvas }; } async save(evaluator, task, annotationStorage) { return null; } get hasTextContent() { return false; } async extractTextContent(evaluator, task, viewBox) { if (!this.appearance) { return; } const resources = await this.loadResources([\"ExtGState\", \"Font\", \"Properties\", \"XObject\"], this.appearance); const text = []; const buffer = []; const sink = { desiredSize: Math.Infinity, ready: true, enqueue(chunk, size) { for (const item of chunk.items) { buffer.push(item.str); if (item.hasEOL) { text.push(buffer.join(\"\")); buffer.length = 0; } } } }; await evaluator.getTextContent({ stream: this.appearance, task, resources, includeMarkedContent: true, combineTextItems: true, sink, viewBox }); this.reset(); if (buffer.length) { text.push(buffer.join(\"\")); } if (text.length > 0) { this.data.textContent = text; } } getFieldObject() { if (this.data.kidIds) { return { id: this.data.id, actions: this.data.actions, name: this.data.fieldName, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, type: \"\", kidIds: this.data.kidIds, page: this.data.pageIndex, rotation: this.rotation }; } return null; } reset() { for (const stream of this._streams) { stream.reset(); } } _constructFieldName(dict) { if (!dict.has(\"T\") && !dict.has(\"Parent\")) { (0, _util.warn)(\"Unknown field name, falling back to empty field name.\"); return \"\"; } if (!dict.has(\"Parent\")) { return (0, _util.stringToPDFString)(dict.get(\"T\")); } const fieldName = []; if (dict.has(\"T\")) { fieldName.unshift((0, _util.stringToPDFString)(dict.get(\"T\"))); } let loopDict = dict; const visited = new _primitives.RefSet(); if (dict.objId) { visited.put(dict.objId); } while (loopDict.has(\"Parent\")) { loopDict = loopDict.get(\"Parent\"); if (!(loopDict instanceof _primitives.Dict) || loopDict.objId && visited.has(loopDict.objId)) { break; } if (loopDict.objId) { visited.put(loopDict.objId); } if (loopDict.has(\"T\")) { fieldName.unshift((0, _util.stringToPDFString)(loopDict.get(\"T\"))); } } return fieldName.join(\".\"); } } exports.Annotation = Annotation; class AnnotationBorderStyle { constructor() { this.width = 1; this.style = _util.AnnotationBorderStyleType.SOLID; this.dashArray = [3]; this.horizontalCornerRadius = 0; this.verticalCornerRadius = 0; } setWidth(width, rect = [0, 0, 0, 0]) { if (width instanceof _primitives.Name) { this.width = 0; return; } if (typeof width === \"number\") { if (width > 0) { const maxWidth = (rect[2] - rect[0]) / 2; const maxHeight = (rect[3] - rect[1]) / 2; if (maxWidth > 0 && maxHeight > 0 && (width > maxWidth || width > maxHeight)) { (0, _util.warn)(`AnnotationBorderStyle.setWidth - ignoring width: ${width}`); width = 1; } } this.width = width; } } setStyle(style) { if (!(style instanceof _primitives.Name)) { return; } switch (style.name) { case \"S\": this.style = _util.AnnotationBorderStyleType.SOLID; break; case \"D\": this.style = _util.AnnotationBorderStyleType.DASHED; break; case \"B\": this.style = _util.AnnotationBorderStyleType.BEVELED; break; case \"I\": this.style = _util.AnnotationBorderStyleType.INSET; break; case \"U\": this.style = _util.AnnotationBorderStyleType.UNDERLINE; break; default: break; } } setDashArray(dashArray, forceStyle = false) { if (Array.isArray(dashArray) && dashArray.length > 0) { let isValid = true; let allZeros = true; for (const element of dashArray) { const validNumber = +element >= 0; if (!validNumber) { isValid = false; break; } else if (element > 0) { allZeros = false; } } if (isValid && !allZeros) { this.dashArray = dashArray; if (forceStyle) { this.setStyle(_primitives.Name.get(\"D\")); } } else { this.width = 0; } } else if (dashArray) { this.width = 0; } } setHorizontalCornerRadius(radius) { if (Number.isInteger(radius)) { this.horizontalCornerRadius = radius; } } setVerticalCornerRadius(radius) { if (Number.isInteger(radius)) { this.verticalCornerRadius = radius; } } } exports.AnnotationBorderStyle = AnnotationBorderStyle; class MarkupAnnotation extends Annotation { constructor(params) { super(params); const { dict } = params; if (dict.has(\"IRT\")) { const rawIRT = dict.getRaw(\"IRT\"); this.data.inReplyTo = rawIRT instanceof _primitives.Ref ? rawIRT.toString() : null; const rt = dict.get(\"RT\"); this.data.replyType = rt instanceof _primitives.Name ? rt.name : _util.AnnotationReplyType.REPLY; } if (this.data.replyType === _util.AnnotationReplyType.GROUP) { const parent = dict.get(\"IRT\"); this.setTitle(parent.get(\"T\")); this.data.titleObj = this._title; this.setContents(parent.get(\"Contents\")); this.data.contentsObj = this._contents; if (!parent.has(\"CreationDate\")) { this.data.creationDate = null; } else { this.setCreationDate(parent.get(\"CreationDate\")); this.data.creationDate = this.creationDate; } if (!parent.has(\"M\")) { this.data.modificationDate = null; } else { this.setModificationDate(parent.get(\"M\")); this.data.modificationDate = this.modificationDate; } this.data.hasPopup = parent.has(\"Popup\"); if (!parent.has(\"C\")) { this.data.color = null; } else { this.setColor(parent.getArray(\"C\")); this.data.color = this.color; } } else { this.data.titleObj = this._title; this.setCreationDate(dict.get(\"CreationDate\")); this.data.creationDate = this.creationDate; this.data.hasPopup = dict.has(\"Popup\"); if (!dict.has(\"C\")) { this.data.color = null; } } if (dict.has(\"RC\")) { this.data.richText = _factory.XFAFactory.getRichTextAsHtml(dict.get(\"RC\")); } } setCreationDate(creationDate) { this.creationDate = typeof creationDate === \"string\" ? creationDate : null; } _setDefaultAppearance({ xref, extra, strokeColor, fillColor, blendMode, strokeAlpha, fillAlpha, pointsCallback }) { let minX = Number.MAX_VALUE; let minY = Number.MAX_VALUE; let maxX = Number.MIN_VALUE; let maxY = Number.MIN_VALUE; const buffer = [\"q\"]; if (extra) { buffer.push(extra); } if (strokeColor) { buffer.push(`${strokeColor[0]} ${strokeColor[1]} ${strokeColor[2]} RG`); } if (fillColor) { buffer.push(`${fillColor[0]} ${fillColor[1]} ${fillColor[2]} rg`); } let pointsArray = this.data.quadPoints; if (!pointsArray) { pointsArray = [[{ x: this.rectangle[0], y: this.rectangle[3] }, { x: this.rectangle[2], y: this.rectangle[3] }, { x: this.rectangle[0], y: this.rectangle[1] }, { x: this.rectangle[2], y: this.rectangle[1] }]]; } for (const points of pointsArray) { const [mX, MX, mY, MY] = pointsCallback(buffer, points); minX = Math.min(minX, mX); maxX = Math.max(maxX, MX); minY = Math.min(minY, mY); maxY = Math.max(maxY, MY); } buffer.push(\"Q\"); const formDict = new _primitives.Dict(xref); const appearanceStreamDict = new _primitives.Dict(xref); appearanceStreamDict.set(\"Subtype\", _primitives.Name.get(\"Form\")); const appearanceStream = new _stream.StringStream(buffer.join(\" \")); appearanceStream.dict = appearanceStreamDict; formDict.set(\"Fm0\", appearanceStream); const gsDict = new _primitives.Dict(xref); if (blendMode) { gsDict.set(\"BM\", _primitives.Name.get(blendMode)); } if (typeof strokeAlpha === \"number\") { gsDict.set(\"CA\", strokeAlpha); } if (typeof fillAlpha === \"number\") { gsDict.set(\"ca\", fillAlpha); } const stateDict = new _primitives.Dict(xref); stateDict.set(\"GS0\", gsDict); const resources = new _primitives.Dict(xref); resources.set(\"ExtGState\", stateDict); resources.set(\"XObject\", formDict); const appearanceDict = new _primitives.Dict(xref); appearanceDict.set(\"Resources\", resources); const bbox = this.data.rect = [minX, minY, maxX, maxY]; appearanceDict.set(\"BBox\", bbox); this.appearance = new _stream.StringStream(\"/GS0 gs /Fm0 Do\"); this.appearance.dict = appearanceDict; this._streams.push(this.appearance, appearanceStream); } static async createNewAnnotation(xref, annotation, dependencies, params) { const annotationRef = xref.getNewTemporaryRef(); const ap = await this.createNewAppearanceStream(annotation, xref, params); const buffer = []; let annotationDict; if (ap) { const apRef = xref.getNewTemporaryRef(); annotationDict = this.createNewDict(annotation, xref, { apRef }); const transform = xref.encrypt ? xref.encrypt.createCipherTransform(apRef.num, apRef.gen) : null; (0, _writer.writeObject)(apRef, ap, buffer, transform); dependencies.push({ ref: apRef, data: buffer.join(\"\") }); } else { annotationDict = this.createNewDict(annotation, xref, {}); } buffer.length = 0; const transform = xref.encrypt ? xref.encrypt.createCipherTransform(annotationRef.num, annotationRef.gen) : null; (0, _writer.writeObject)(annotationRef, annotationDict, buffer, transform); return { ref: annotationRef, data: buffer.join(\"\") }; } static async createNewPrintAnnotation(xref, annotation, params) { const ap = await this.createNewAppearanceStream(annotation, xref, params); const annotationDict = this.createNewDict(annotation, xref, { ap }); return new this.prototype.constructor({ dict: annotationDict, xref, isOffscreenCanvasSupported: params.isOffscreenCanvasSupported }); } } exports.MarkupAnnotation = MarkupAnnotation; class WidgetAnnotation extends Annotation { constructor(params) { super(params); const { dict, xref } = params; const data = this.data; this.ref = params.ref; this._needAppearances = params.needAppearances; data.annotationType = _util.AnnotationType.WIDGET; if (data.fieldName === undefined) { data.fieldName = this._constructFieldName(dict); } if (data.actions === undefined) { data.actions = (0, _core_utils.collectActions)(xref, dict, _util.AnnotationActionEventType); } let fieldValue = (0, _core_utils.getInheritableProperty)({ dict, key: \"V\", getArray: true }); data.fieldValue = this._decodeFormValue(fieldValue); const defaultFieldValue = (0, _core_utils.getInheritableProperty)({ dict, key: \"DV\", getArray: true }); data.defaultFieldValue = this._decodeFormValue(defaultFieldValue); if (fieldValue === undefined && params.xfaDatasets) { const path = this._title.str; if (path) { this._hasValueFromXFA = true; data.fieldValue = fieldValue = params.xfaDatasets.getValue(path); } } if (fieldValue === undefined && data.defaultFieldValue !== null) { data.fieldValue = data.defaultFieldValue; } data.alternativeText = (0, _util.stringToPDFString)(dict.get(\"TU\") || \"\"); this.setDefaultAppearance(params); data.hasAppearance = this._needAppearances && data.fieldValue !== undefined && data.fieldValue !== null || data.hasAppearance; const fieldType = (0, _core_utils.getInheritableProperty)({ dict, key: \"FT\" }); data.fieldType = fieldType instanceof _primitives.Name ? fieldType.name : null; const localResources = (0, _core_utils.getInheritableProperty)({ dict, key: \"DR\" }); const acroFormResources = params.acroForm.get(\"DR\"); const appearanceResources = this.appearance && this.appearance.dict.get(\"Resources\"); this._fieldResources = { localResources, acroFormResources, appearanceResources, mergedResources: _primitives.Dict.merge({ xref, dictArray: [localResources, appearanceResources, acroFormResources], mergeSubDicts: true }) }; data.fieldFlags = (0, _core_utils.getInheritableProperty)({ dict, key: \"Ff\" }); if (!Number.isInteger(data.fieldFlags) || data.fieldFlags < 0) { data.fieldFlags = 0; } data.readOnly = this.hasFieldFlag(_util.AnnotationFieldFlag.READONLY); data.required = this.hasFieldFlag(_util.AnnotationFieldFlag.REQUIRED); data.hidden = this._hasFlag(data.annotationFlags, _util.AnnotationFlag.HIDDEN); } _decodeFormValue(formValue) { if (Array.isArray(formValue)) { return formValue.filter(item => typeof item === \"string\").map(item => (0, _util.stringToPDFString)(item)); } else if (formValue instanceof _primitives.Name) { return (0, _util.stringToPDFString)(formValue.name); } else if (typeof formValue === \"string\") { return (0, _util.stringToPDFString)(formValue); } return null; } hasFieldFlag(flag) { return !!(this.data.fieldFlags & flag); } getRotationMatrix(annotationStorage) { const storageEntry = annotationStorage ? annotationStorage.get(this.data.id) : undefined; let rotation = storageEntry && storageEntry.rotation; if (rotation === undefined) { rotation = this.rotation; } if (rotation === 0) { return _util.IDENTITY_MATRIX; } const width = this.data.rect[2] - this.data.rect[0]; const height = this.data.rect[3] - this.data.rect[1]; return (0, _core_utils.getRotationMatrix)(rotation, width, height); } getBorderAndBackgroundAppearances(annotationStorage) { const storageEntry = annotationStorage ? annotationStorage.get(this.data.id) : undefined; let rotation = storageEntry && storageEntry.rotation; if (rotation === undefined) { rotation = this.rotation; } if (!this.backgroundColor && !this.borderColor) { return \"\"; } const width = this.data.rect[2] - this.data.rect[0]; const height = this.data.rect[3] - this.data.rect[1]; const rect = rotation === 0 || rotation === 180 ? `0 0 ${width} ${height} re` : `0 0 ${height} ${width} re`; let str = \"\"; if (this.backgroundColor) { str = `${(0, _default_appearance.getPdfColor)(this.backgroundColor, true)} ${rect} f `; } if (this.borderColor) { const borderWidth = this.borderStyle.width || 1; str += `${borderWidth} w ${(0, _default_appearance.getPdfColor)(this.borderColor, false)} ${rect} S `; } return str; } async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) { if (renderForms && !(this instanceof SignatureWidgetAnnotation)) { return { opList: new _operator_list.OperatorList(), separateForm: true, separateCanvas: false }; } if (!this._hasText) { return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage); } const content = await this._getAppearance(evaluator, task, intent, annotationStorage); if (this.appearance && content === null) { return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage); } const opList = new _operator_list.OperatorList(); if (!this._defaultAppearance || content === null) { return { opList, separateForm: false, separateCanvas: false }; } const matrix = [1, 0, 0, 1, 0, 0]; const bbox = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]; const transform = getTransformMatrix(this.data.rect, bbox, matrix); let optionalContent; if (this.oc) { optionalContent = await evaluator.parseMarkedContentProps(this.oc, null); } if (optionalContent !== undefined) { opList.addOp(_util.OPS.beginMarkedContentProps, [\"OC\", optionalContent]); } opList.addOp(_util.OPS.beginAnnotation, [this.data.id, this.data.rect, transform, this.getRotationMatrix(annotationStorage), false]); const stream = new _stream.StringStream(content); await evaluator.getOperatorList({ stream, task, resources: this._fieldResources.mergedResources, operatorList: opList }); opList.addOp(_util.OPS.endAnnotation, []); if (optionalContent !== undefined) { opList.addOp(_util.OPS.endMarkedContent, []); } return { opList, separateForm: false, separateCanvas: false }; } _getMKDict(rotation) { const mk = new _primitives.Dict(null); if (rotation) { mk.set(\"R\", rotation); } if (this.borderColor) { mk.set(\"BC\", getPdfColorArray(this.borderColor)); } if (this.backgroundColor) { mk.set(\"BG\", getPdfColorArray(this.backgroundColor)); } return mk.size > 0 ? mk : null; } async save(evaluator, task, annotationStorage) { const storageEntry = annotationStorage ? annotationStorage.get(this.data.id) : undefined; let value = storageEntry && storageEntry.value; let rotation = storageEntry && storageEntry.rotation; if (value === this.data.fieldValue || value === undefined) { if (!this._hasValueFromXFA && rotation === undefined) { return null; } value = value || this.data.fieldValue; } if (rotation === undefined && !this._hasValueFromXFA && Array.isArray(value) && Array.isArray(this.data.fieldValue) && value.length === this.data.fieldValue.length && value.every((x, i) => x === this.data.fieldValue[i])) { return null; } if (rotation === undefined) { rotation = this.rotation; } let appearance = null; if (!this._needAppearances) { appearance = await this._getAppearance(evaluator, task, _util.RenderingIntentFlag.SAVE, annotationStorage); if (appearance === null) { return null; } } else {} let needAppearances = false; if (appearance && appearance.needAppearances) { needAppearances = true; appearance = null; } const { xref } = evaluator; const originalDict = xref.fetchIfRef(this.ref); if (!(originalDict instanceof _primitives.Dict)) { return null; } const dict = new _primitives.Dict(xref); for (const key of originalDict.getKeys()) { if (key !== \"AP\") { dict.set(key, originalDict.getRaw(key)); } } const xfa = { path: (0, _util.stringToPDFString)(dict.get(\"T\") || \"\"), value }; const encoder = val => { return (0, _core_utils.isAscii)(val) ? val : (0, _core_utils.stringToUTF16String)(val, true); }; dict.set(\"V\", Array.isArray(value) ? value.map(encoder) : encoder(value)); const maybeMK = this._getMKDict(rotation); if (maybeMK) { dict.set(\"MK\", maybeMK); } const encrypt = xref.encrypt; const originalTransform = encrypt ? encrypt.createCipherTransform(this.ref.num, this.ref.gen) : null; const buffer = []; const changes = [{ ref: this.ref, data: \"\", xfa, needAppearances }]; if (appearance !== null) { const newRef = xref.getNewTemporaryRef(); const AP = new _primitives.Dict(xref); dict.set(\"AP\", AP); AP.set(\"N\", newRef); let newTransform = null; if (encrypt) { newTransform = encrypt.createCipherTransform(newRef.num, newRef.gen); appearance = newTransform.encryptString(appearance); } const resources = this._getSaveFieldResources(xref); const appearanceStream = new _stream.StringStream(appearance); const appearanceDict = appearanceStream.dict = new _primitives.Dict(xref); appearanceDict.set(\"Length\", appearance.length); appearanceDict.set(\"Subtype\", _primitives.Name.get(\"Form\")); appearanceDict.set(\"Resources\", resources); appearanceDict.set(\"BBox\", [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]); const rotationMatrix = this.getRotationMatrix(annotationStorage); if (rotationMatrix !== _util.IDENTITY_MATRIX) { appearanceDict.set(\"Matrix\", rotationMatrix); } (0, _writer.writeObject)(newRef, appearanceStream, buffer, newTransform); changes.push({ ref: newRef, data: buffer.join(\"\"), xfa: null, needAppearances: false }); buffer.length = 0; } dict.set(\"M\", `D:${(0, _util.getModificationDate)()}`); (0, _writer.writeObject)(this.ref, dict, buffer, originalTransform); changes[0].data = buffer.join(\"\"); return changes; } async _getAppearance(evaluator, task, intent, annotationStorage) { const isPassword = this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD); if (isPassword) { return null; } const storageEntry = annotationStorage ? annotationStorage.get(this.data.id) : undefined; let value, rotation; if (storageEntry) { value = storageEntry.formattedValue || storageEntry.value; rotation = storageEntry.rotation; } if (rotation === undefined && value === undefined && !this._needAppearances) { if (!this._hasValueFromXFA || this.appearance) { return null; } } const colors = this.getBorderAndBackgroundAppearances(annotationStorage); if (value === undefined) { value = this.data.fieldValue; if (!value) { return `/Tx BMC q ${colors}Q EMC`; } } if (Array.isArray(value) && value.length === 1) { value = value[0]; } (0, _util.assert)(typeof value === \"string\", \"Expected `value` to be a string.\"); if (!this.data.combo) { value = value.trim(); } else { const option = this.data.options.find(({ exportValue }) => value === exportValue) || this.data.options[0]; value = option && option.displayValue || \"\"; } if (value === \"\") { return `/Tx BMC q ${colors}Q EMC`; } if (rotation === undefined) { rotation = this.rotation; } let lineCount = -1; let lines; if (this.data.multiLine) { lines = value.split(/\\r\\n?|\\n/).map(line => line.normalize(\"NFC\")); lineCount = lines.length; } else { lines = [value.replace(/\\r\\n?|\\n/, \"\").normalize(\"NFC\")]; } const defaultPadding = 1; const defaultHPadding = 2; let totalHeight = this.data.rect[3] - this.data.rect[1]; let totalWidth = this.data.rect[2] - this.data.rect[0]; if (rotation === 90 || rotation === 270) { [totalWidth, totalHeight] = [totalHeight, totalWidth]; } if (!this._defaultAppearance) { this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance = \"/Helvetica 0 Tf 0 g\"); } let font = await WidgetAnnotation._getFontData(evaluator, task, this.data.defaultAppearanceData, this._fieldResources.mergedResources); let defaultAppearance, fontSize, lineHeight; const encodedLines = []; let encodingError = false; for (const line of lines) { const encodedString = font.encodeString(line); if (encodedString.length > 1) { encodingError = true; } encodedLines.push(encodedString.join(\"\")); } if (encodingError && intent & _util.RenderingIntentFlag.SAVE) { return { needAppearances: true }; } if (encodingError && this._isOffscreenCanvasSupported) { const fontFamily = this.data.comb ? \"monospace\" : \"sans-serif\"; const fakeUnicodeFont = new _default_appearance.FakeUnicodeFont(evaluator.xref, fontFamily); const resources = fakeUnicodeFont.createFontResources(lines.join(\"\")); const newFont = resources.getRaw(\"Font\"); if (this._fieldResources.mergedResources.has(\"Font\")) { const oldFont = this._fieldResources.mergedResources.get(\"Font\"); for (const key of newFont.getKeys()) { oldFont.set(key, newFont.getRaw(key)); } } else { this._fieldResources.mergedResources.set(\"Font\", newFont); } const fontName = fakeUnicodeFont.fontName.name; font = await WidgetAnnotation._getFontData(evaluator, task, { fontName, fontSize: 0 }, resources); for (let i = 0, ii = encodedLines.length; i < ii; i++) { encodedLines[i] = (0, _core_utils.stringToUTF16String)(lines[i]); } const savedDefaultAppearance = Object.assign(Object.create(null), this.data.defaultAppearanceData); this.data.defaultAppearanceData.fontSize = 0; this.data.defaultAppearanceData.fontName = fontName; [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(totalHeight - 2 * defaultPadding, totalWidth - 2 * defaultHPadding, value, font, lineCount); this.data.defaultAppearanceData = savedDefaultAppearance; } else { if (!this._isOffscreenCanvasSupported) { (0, _util.warn)(\"_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly.\"); } [defaultAppearance, fontSize, lineHeight] = this._computeFontSize(totalHeight - 2 * defaultPadding, totalWidth - 2 * defaultHPadding, value, font, lineCount); } let descent = font.descent; if (isNaN(descent)) { descent = _util.BASELINE_FACTOR * lineHeight; } else { descent = Math.max(_util.BASELINE_FACTOR * lineHeight, Math.abs(descent) * fontSize); } const defaultVPadding = Math.min(Math.floor((totalHeight - fontSize) / 2), defaultPadding); const alignment = this.data.textAlignment; if (this.data.multiLine) { return this._getMultilineAppearance(defaultAppearance, encodedLines, font, fontSize, totalWidth, totalHeight, alignment, defaultHPadding, defaultVPadding, descent, lineHeight, annotationStorage); } if (this.data.comb) { return this._getCombAppearance(defaultAppearance, font, encodedLines[0], fontSize, totalWidth, totalHeight, defaultHPadding, defaultVPadding, descent, lineHeight, annotationStorage); } const bottomPadding = defaultVPadding + descent; if (alignment === 0 || alignment > 2) { return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 ${(0, _core_utils.numberToString)(defaultHPadding)} ${(0, _core_utils.numberToString)(bottomPadding)} Tm (${(0, _core_utils.escapeString)(encodedLines[0])}) Tj` + \" ET Q EMC\"; } const prevInfo = { shift: 0 }; const renderedText = this._renderText(encodedLines[0], font, fontSize, totalWidth, alignment, prevInfo, defaultHPadding, bottomPadding); return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 0 0 Tm ${renderedText}` + \" ET Q EMC\"; } static async _getFontData(evaluator, task, appearanceData, resources) { const operatorList = new _operator_list.OperatorList(); const initialState = { font: null, clone() { return this; } }; const { fontName, fontSize } = appearanceData; await evaluator.handleSetFont(resources, [fontName && _primitives.Name.get(fontName), fontSize], null, operatorList, task, initialState, null); return initialState.font; } _getTextWidth(text, font) { return font.charsToGlyphs(text).reduce((width, glyph) => width + glyph.width, 0) / 1000; } _computeFontSize(height, width, text, font, lineCount) { let { fontSize } = this.data.defaultAppearanceData; let lineHeight = (fontSize || 12) * _util.LINE_FACTOR, numberOfLines = Math.round(height / lineHeight); if (!fontSize) { const roundWithTwoDigits = x => Math.floor(x * 100) / 100; if (lineCount === -1) { const textWidth = this._getTextWidth(text, font); fontSize = roundWithTwoDigits(Math.min(height / _util.LINE_FACTOR, textWidth > width ? width / textWidth : Infinity)); numberOfLines = 1; } else { const lines = text.split(/\\r\\n?|\\n/); const cachedLines = []; for (const line of lines) { const encoded = font.encodeString(line).join(\"\"); const glyphs = font.charsToGlyphs(encoded); const positions = font.getCharPositions(encoded); cachedLines.push({ line: encoded, glyphs, positions }); } const isTooBig = fsize => { let totalHeight = 0; for (const cache of cachedLines) { const chunks = this._splitLine(null, font, fsize, width, cache); totalHeight += chunks.length * fsize; if (totalHeight > height) { return true; } } return false; }; numberOfLines = Math.max(numberOfLines, lineCount); while (true) { lineHeight = height / numberOfLines; fontSize = roundWithTwoDigits(lineHeight / _util.LINE_FACTOR); if (isTooBig(fontSize)) { numberOfLines++; continue; } break; } } const { fontName, fontColor } = this.data.defaultAppearanceData; this._defaultAppearance = (0, _default_appearance.createDefaultAppearance)({ fontSize, fontName, fontColor }); } return [this._defaultAppearance, fontSize, height / numberOfLines]; } _renderText(text, font, fontSize, totalWidth, alignment, prevInfo, hPadding, vPadding) { let shift; if (alignment === 1) { const width = this._getTextWidth(text, font) * fontSize; shift = (totalWidth - width) / 2; } else if (alignment === 2) { const width = this._getTextWidth(text, font) * fontSize; shift = totalWidth - width - hPadding; } else { shift = hPadding; } const shiftStr = (0, _core_utils.numberToString)(shift - prevInfo.shift); prevInfo.shift = shift; vPadding = (0, _core_utils.numberToString)(vPadding); return `${shiftStr} ${vPadding} Td (${(0, _core_utils.escapeString)(text)}) Tj`; } _getSaveFieldResources(xref) { const { localResources, appearanceResources, acroFormResources } = this._fieldResources; const fontName = this.data.defaultAppearanceData && this.data.defaultAppearanceData.fontName; if (!fontName) { return localResources || _primitives.Dict.empty; } for (const resources of [localResources, appearanceResources]) { if (resources instanceof _primitives.Dict) { const localFont = resources.get(\"Font\"); if (localFont instanceof _primitives.Dict && localFont.has(fontName)) { return resources; } } } if (acroFormResources instanceof _primitives.Dict) { const acroFormFont = acroFormResources.get(\"Font\"); if (acroFormFont instanceof _primitives.Dict && acroFormFont.has(fontName)) { const subFontDict = new _primitives.Dict(xref); subFontDict.set(fontName, acroFormFont.getRaw(fontName)); const subResourcesDict = new _primitives.Dict(xref); subResourcesDict.set(\"Font\", subFontDict); return _primitives.Dict.merge({ xref, dictArray: [subResourcesDict, localResources], mergeSubDicts: true }); } } return localResources || _primitives.Dict.empty; } getFieldObject() { return null; } } class TextWidgetAnnotation extends WidgetAnnotation { constructor(params) { super(params); this._hasText = true; const dict = params.dict; if (typeof this.data.fieldValue !== \"string\") { this.data.fieldValue = \"\"; } let alignment = (0, _core_utils.getInheritableProperty)({ dict, key: \"Q\" }); if (!Number.isInteger(alignment) || alignment < 0 || alignment > 2) { alignment = null; } this.data.textAlignment = alignment; let maximumLength = (0, _core_utils.getInheritableProperty)({ dict, key: \"MaxLen\" }); if (!Number.isInteger(maximumLength) || maximumLength < 0) { maximumLength = 0; } this.data.maxLen = maximumLength; this.data.multiLine = this.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE); this.data.comb = this.hasFieldFlag(_util.AnnotationFieldFlag.COMB) && !this.hasFieldFlag(_util.AnnotationFieldFlag.MULTILINE) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD) && !this.hasFieldFlag(_util.AnnotationFieldFlag.FILESELECT) && this.data.maxLen !== 0; this.data.doNotScroll = this.hasFieldFlag(_util.AnnotationFieldFlag.DONOTSCROLL); } _getCombAppearance(defaultAppearance, font, text, fontSize, width, height, hPadding, vPadding, descent, lineHeight, annotationStorage) { const combWidth = width / this.data.maxLen; const colors = this.getBorderAndBackgroundAppearances(annotationStorage); const buf = []; const positions = font.getCharPositions(text); for (const [start, end] of positions) { buf.push(`(${(0, _core_utils.escapeString)(text.substring(start, end))}) Tj`); } const renderedComb = buf.join(` ${(0, _core_utils.numberToString)(combWidth)} 0 Td `); return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 ${(0, _core_utils.numberToString)(hPadding)} ${(0, _core_utils.numberToString)(vPadding + descent)} Tm ${renderedComb}` + \" ET Q EMC\"; } _getMultilineAppearance(defaultAppearance, lines, font, fontSize, width, height, alignment, hPadding, vPadding, descent, lineHeight, annotationStorage) { const buf = []; const totalWidth = width - 2 * hPadding; const prevInfo = { shift: 0 }; for (let i = 0, ii = lines.length; i < ii; i++) { const line = lines[i]; const chunks = this._splitLine(line, font, fontSize, totalWidth); for (let j = 0, jj = chunks.length; j < jj; j++) { const chunk = chunks[j]; const vShift = i === 0 && j === 0 ? -vPadding - (lineHeight - descent) : -lineHeight; buf.push(this._renderText(chunk, font, fontSize, width, alignment, prevInfo, hPadding, vShift)); } } const colors = this.getBorderAndBackgroundAppearances(annotationStorage); const renderedText = buf.join(\"\\n\"); return `/Tx BMC q ${colors}BT ` + defaultAppearance + ` 1 0 0 1 0 ${(0, _core_utils.numberToString)(height)} Tm ${renderedText}` + \" ET Q EMC\"; } _splitLine(line, font, fontSize, width, cache = {}) { line = cache.line || line; const glyphs = cache.glyphs || font.charsToGlyphs(line); if (glyphs.length width) { if (lastSpacePosInStringStart !== -1) { chunks.push(line.substring(startChunk, lastSpacePosInStringEnd)); startChunk = lastSpacePosInStringEnd; i = lastSpacePos + 1; lastSpacePosInStringStart = -1; currentWidth = 0; } else { chunks.push(line.substring(startChunk, start)); startChunk = start; currentWidth = glyphWidth; } } else { currentWidth += glyphWidth; } } } if (startChunk < line.length) { chunks.push(line.substring(startChunk, line.length)); } return chunks; } getFieldObject() { return { id: this.data.id, value: this.data.fieldValue, defaultValue: this.data.defaultFieldValue || \"\", multiline: this.data.multiLine, password: this.hasFieldFlag(_util.AnnotationFieldFlag.PASSWORD), charLimit: this.data.maxLen, comb: this.data.comb, editable: !this.data.readOnly, hidden: this.data.hidden, name: this.data.fieldName, rect: this.data.rect, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: \"text\" }; } } class ButtonWidgetAnnotation extends WidgetAnnotation { constructor(params) { super(params); this.checkedAppearance = null; this.uncheckedAppearance = null; this.data.checkBox = !this.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON); this.data.radioButton = this.hasFieldFlag(_util.AnnotationFieldFlag.RADIO) && !this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON); this.data.pushButton = this.hasFieldFlag(_util.AnnotationFieldFlag.PUSHBUTTON); this.data.isTooltipOnly = false; if (this.data.checkBox) { this._processCheckBox(params); } else if (this.data.radioButton) { this._processRadioButton(params); } else if (this.data.pushButton) { this.data.hasOwnCanvas = true; this._processPushButton(params); } else { (0, _util.warn)(\"Invalid field flags for button widget annotation\"); } } async getOperatorList(evaluator, task, intent, renderForms, annotationStorage) { if (this.data.pushButton) { return super.getOperatorList(evaluator, task, intent, false, annotationStorage); } let value = null; let rotation = null; if (annotationStorage) { const storageEntry = annotationStorage.get(this.data.id); value = storageEntry ? storageEntry.value : null; rotation = storageEntry ? storageEntry.rotation : null; } if (value === null && this.appearance) { return super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage); } if (value === null || value === undefined) { if (this.data.checkBox) { value = this.data.fieldValue === this.data.exportValue; } else { value = this.data.fieldValue === this.data.buttonValue; } } const appearance = value ? this.checkedAppearance : this.uncheckedAppearance; if (appearance) { const savedAppearance = this.appearance; const savedMatrix = appearance.dict.getArray(\"Matrix\") || _util.IDENTITY_MATRIX; if (rotation) { appearance.dict.set(\"Matrix\", this.getRotationMatrix(annotationStorage)); } this.appearance = appearance; const operatorList = super.getOperatorList(evaluator, task, intent, renderForms, annotationStorage); this.appearance = savedAppearance; appearance.dict.set(\"Matrix\", savedMatrix); return operatorList; } return { opList: new _operator_list.OperatorList(), separateForm: false, separateCanvas: false }; } async save(evaluator, task, annotationStorage) { if (this.data.checkBox) { return this._saveCheckbox(evaluator, task, annotationStorage); } if (this.data.radioButton) { return this._saveRadioButton(evaluator, task, annotationStorage); } return null; } async _saveCheckbox(evaluator, task, annotationStorage) { if (!annotationStorage) { return null; } const storageEntry = annotationStorage.get(this.data.id); let rotation = storageEntry && storageEntry.rotation; let value = storageEntry && storageEntry.value; if (rotation === undefined) { if (value === undefined) { return null; } const defaultValue = this.data.fieldValue === this.data.exportValue; if (defaultValue === value) { return null; } } const dict = evaluator.xref.fetchIfRef(this.ref); if (!(dict instanceof _primitives.Dict)) { return null; } if (rotation === undefined) { rotation = this.rotation; } if (value === undefined) { value = this.data.fieldValue === this.data.exportValue; } const xfa = { path: (0, _util.stringToPDFString)(dict.get(\"T\") || \"\"), value: value ? this.data.exportValue : \"\" }; const name = _primitives.Name.get(value ? this.data.exportValue : \"Off\"); dict.set(\"V\", name); dict.set(\"AS\", name); dict.set(\"M\", `D:${(0, _util.getModificationDate)()}`); const maybeMK = this._getMKDict(rotation); if (maybeMK) { dict.set(\"MK\", maybeMK); } const encrypt = evaluator.xref.encrypt; let originalTransform = null; if (encrypt) { originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen); } const buffer = [`${this.ref.num} ${this.ref.gen} obj\\n`]; (0, _writer.writeDict)(dict, buffer, originalTransform); buffer.push(\"\\nendobj\\n\"); return [{ ref: this.ref, data: buffer.join(\"\"), xfa }]; } async _saveRadioButton(evaluator, task, annotationStorage) { if (!annotationStorage) { return null; } const storageEntry = annotationStorage.get(this.data.id); let rotation = storageEntry && storageEntry.rotation; let value = storageEntry && storageEntry.value; if (rotation === undefined) { if (value === undefined) { return null; } const defaultValue = this.data.fieldValue === this.data.buttonValue; if (defaultValue === value) { return null; } } const dict = evaluator.xref.fetchIfRef(this.ref); if (!(dict instanceof _primitives.Dict)) { return null; } if (value === undefined) { value = this.data.fieldValue === this.data.buttonValue; } if (rotation === undefined) { rotation = this.rotation; } const xfa = { path: (0, _util.stringToPDFString)(dict.get(\"T\") || \"\"), value: value ? this.data.buttonValue : \"\" }; const name = _primitives.Name.get(value ? this.data.buttonValue : \"Off\"); let parentBuffer = null; const encrypt = evaluator.xref.encrypt; if (value) { if (this.parent instanceof _primitives.Ref) { const parent = evaluator.xref.fetch(this.parent); let parentTransform = null; if (encrypt) { parentTransform = encrypt.createCipherTransform(this.parent.num, this.parent.gen); } parent.set(\"V\", name); parentBuffer = [`${this.parent.num} ${this.parent.gen} obj\\n`]; (0, _writer.writeDict)(parent, parentBuffer, parentTransform); parentBuffer.push(\"\\nendobj\\n\"); } else if (this.parent instanceof _primitives.Dict) { this.parent.set(\"V\", name); } } dict.set(\"AS\", name); dict.set(\"M\", `D:${(0, _util.getModificationDate)()}`); const maybeMK = this._getMKDict(rotation); if (maybeMK) { dict.set(\"MK\", maybeMK); } let originalTransform = null; if (encrypt) { originalTransform = encrypt.createCipherTransform(this.ref.num, this.ref.gen); } const buffer = [`${this.ref.num} ${this.ref.gen} obj\\n`]; (0, _writer.writeDict)(dict, buffer, originalTransform); buffer.push(\"\\nendobj\\n\"); const newRefs = [{ ref: this.ref, data: buffer.join(\"\"), xfa }]; if (parentBuffer !== null) { newRefs.push({ ref: this.parent, data: parentBuffer.join(\"\"), xfa: null }); } return newRefs; } _getDefaultCheckedAppearance(params, type) { const width = this.data.rect[2] - this.data.rect[0]; const height = this.data.rect[3] - this.data.rect[1]; const bbox = [0, 0, width, height]; const FONT_RATIO = 0.8; const fontSize = Math.min(width, height) * FONT_RATIO; let metrics, char; if (type === \"check\") { metrics = { width: 0.755 * fontSize, height: 0.705 * fontSize }; char = \"\\x33\"; } else if (type === \"disc\") { metrics = { width: 0.791 * fontSize, height: 0.705 * fontSize }; char = \"\\x6C\"; } else { (0, _util.unreachable)(`_getDefaultCheckedAppearance - unsupported type: ${type}`); } const xShift = (0, _core_utils.numberToString)((width - metrics.width) / 2); const yShift = (0, _core_utils.numberToString)((height - metrics.height) / 2); const appearance = `q BT /PdfJsZaDb ${fontSize} Tf 0 g ${xShift} ${yShift} Td (${char}) Tj ET Q`; const appearanceStreamDict = new _primitives.Dict(params.xref); appearanceStreamDict.set(\"FormType\", 1); appearanceStreamDict.set(\"Subtype\", _primitives.Name.get(\"Form\")); appearanceStreamDict.set(\"Type\", _primitives.Name.get(\"XObject\")); appearanceStreamDict.set(\"BBox\", bbox); appearanceStreamDict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]); appearanceStreamDict.set(\"Length\", appearance.length); const resources = new _primitives.Dict(params.xref); const font = new _primitives.Dict(params.xref); font.set(\"PdfJsZaDb\", this.fallbackFontDict); resources.set(\"Font\", font); appearanceStreamDict.set(\"Resources\", resources); this.checkedAppearance = new _stream.StringStream(appearance); this.checkedAppearance.dict = appearanceStreamDict; this._streams.push(this.checkedAppearance); } _processCheckBox(params) { const customAppearance = params.dict.get(\"AP\"); if (!(customAppearance instanceof _primitives.Dict)) { return; } const normalAppearance = customAppearance.get(\"N\"); if (!(normalAppearance instanceof _primitives.Dict)) { return; } const asValue = this._decodeFormValue(params.dict.get(\"AS\")); if (typeof asValue === \"string\") { this.data.fieldValue = asValue; } const yes = this.data.fieldValue !== null && this.data.fieldValue !== \"Off\" ? this.data.fieldValue : \"Yes\"; const exportValues = normalAppearance.getKeys(); if (exportValues.length === 0) { exportValues.push(\"Off\", yes); } else if (exportValues.length === 1) { if (exportValues[0] === \"Off\") { exportValues.push(yes); } else { exportValues.unshift(\"Off\"); } } else if (exportValues.includes(yes)) { exportValues.length = 0; exportValues.push(\"Off\", yes); } else { const otherYes = exportValues.find(v => v !== \"Off\"); exportValues.length = 0; exportValues.push(\"Off\", otherYes); } if (!exportValues.includes(this.data.fieldValue)) { this.data.fieldValue = \"Off\"; } this.data.exportValue = exportValues[1]; this.checkedAppearance = normalAppearance.get(this.data.exportValue) || null; this.uncheckedAppearance = normalAppearance.get(\"Off\") || null; if (this.checkedAppearance) { this._streams.push(this.checkedAppearance); } else { this._getDefaultCheckedAppearance(params, \"check\"); } if (this.uncheckedAppearance) { this._streams.push(this.uncheckedAppearance); } this._fallbackFontDict = this.fallbackFontDict; } _processRadioButton(params) { this.data.fieldValue = this.data.buttonValue = null; const fieldParent = params.dict.get(\"Parent\"); if (fieldParent instanceof _primitives.Dict) { this.parent = params.dict.getRaw(\"Parent\"); const fieldParentValue = fieldParent.get(\"V\"); if (fieldParentValue instanceof _primitives.Name) { this.data.fieldValue = this._decodeFormValue(fieldParentValue); } } const appearanceStates = params.dict.get(\"AP\"); if (!(appearanceStates instanceof _primitives.Dict)) { return; } const normalAppearance = appearanceStates.get(\"N\"); if (!(normalAppearance instanceof _primitives.Dict)) { return; } for (const key of normalAppearance.getKeys()) { if (key !== \"Off\") { this.data.buttonValue = this._decodeFormValue(key); break; } } this.checkedAppearance = normalAppearance.get(this.data.buttonValue) || null; this.uncheckedAppearance = normalAppearance.get(\"Off\") || null; if (this.checkedAppearance) { this._streams.push(this.checkedAppearance); } else { this._getDefaultCheckedAppearance(params, \"disc\"); } if (this.uncheckedAppearance) { this._streams.push(this.uncheckedAppearance); } this._fallbackFontDict = this.fallbackFontDict; } _processPushButton(params) { if (!params.dict.has(\"A\") && !params.dict.has(\"AA\") && !this.data.alternativeText) { (0, _util.warn)(\"Push buttons without action dictionaries are not supported\"); return; } this.data.isTooltipOnly = !params.dict.has(\"A\") && !params.dict.has(\"AA\"); _catalog.Catalog.parseDestDictionary({ destDict: params.dict, resultObj: this.data, docBaseUrl: params.pdfManager.docBaseUrl, docAttachments: params.attachments }); } getFieldObject() { let type = \"button\"; let exportValues; if (this.data.checkBox) { type = \"checkbox\"; exportValues = this.data.exportValue; } else if (this.data.radioButton) { type = \"radiobutton\"; exportValues = this.data.buttonValue; } return { id: this.data.id, value: this.data.fieldValue || \"Off\", defaultValue: this.data.defaultFieldValue, exportValues, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, hidden: this.data.hidden, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type }; } get fallbackFontDict() { const dict = new _primitives.Dict(); dict.set(\"BaseFont\", _primitives.Name.get(\"ZapfDingbats\")); dict.set(\"Type\", _primitives.Name.get(\"FallbackType\")); dict.set(\"Subtype\", _primitives.Name.get(\"FallbackType\")); dict.set(\"Encoding\", _primitives.Name.get(\"ZapfDingbatsEncoding\")); return (0, _util.shadow)(this, \"fallbackFontDict\", dict); } } class ChoiceWidgetAnnotation extends WidgetAnnotation { constructor(params) { super(params); const { dict, xref } = params; this.data.options = []; const options = (0, _core_utils.getInheritableProperty)({ dict, key: \"Opt\" }); if (Array.isArray(options)) { for (let i = 0, ii = options.length; i < ii; i++) { const option = xref.fetchIfRef(options[i]); const isOptionArray = Array.isArray(option); this.data.options[i] = { exportValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[0]) : option), displayValue: this._decodeFormValue(isOptionArray ? xref.fetchIfRef(option[1]) : option) }; } } if (typeof this.data.fieldValue === \"string\") { this.data.fieldValue = [this.data.fieldValue]; } else if (!this.data.fieldValue) { this.data.fieldValue = []; } this.data.combo = this.hasFieldFlag(_util.AnnotationFieldFlag.COMBO); this.data.multiSelect = this.hasFieldFlag(_util.AnnotationFieldFlag.MULTISELECT); this._hasText = true; } getFieldObject() { const type = this.data.combo ? \"combobox\" : \"listbox\"; const value = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null; return { id: this.data.id, value, defaultValue: this.data.defaultFieldValue, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, numItems: this.data.fieldValue.length, multipleSelection: this.data.multiSelect, hidden: this.data.hidden, actions: this.data.actions, items: this.data.options, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type }; } async _getAppearance(evaluator, task, intent, annotationStorage) { if (this.data.combo) { return super._getAppearance(evaluator, task, intent, annotationStorage); } let exportedValue, rotation; const storageEntry = annotationStorage ? annotationStorage.get(this.data.id) : undefined; if (storageEntry) { rotation = storageEntry.rotation; exportedValue = storageEntry.value; } if (rotation === undefined && exportedValue === undefined && !this._needAppearances) { return null; } if (exportedValue === undefined) { exportedValue = this.data.fieldValue; } else if (!Array.isArray(exportedValue)) { exportedValue = [exportedValue]; } const defaultPadding = 1; const defaultHPadding = 2; let totalHeight = this.data.rect[3] - this.data.rect[1]; let totalWidth = this.data.rect[2] - this.data.rect[0]; if (rotation === 90 || rotation === 270) { [totalWidth, totalHeight] = [totalHeight, totalWidth]; } const lineCount = this.data.options.length; const valueIndices = []; for (let i = 0; i < lineCount; i++) { const { exportValue } = this.data.options[i]; if (exportedValue.includes(exportValue)) { valueIndices.push(i); } } if (!this._defaultAppearance) { this.data.defaultAppearanceData = (0, _default_appearance.parseDefaultAppearance)(this._defaultAppearance = \"/Helvetica 0 Tf 0 g\"); } const font = await WidgetAnnotation._getFontData(evaluator, task, this.data.defaultAppearanceData, this._fieldResources.mergedResources); let defaultAppearance; let { fontSize } = this.data.defaultAppearanceData; if (!fontSize) { const lineHeight = (totalHeight - defaultPadding) / lineCount; let lineWidth = -1; let value; for (const { displayValue } of this.data.options) { const width = this._getTextWidth(displayValue, font); if (width > lineWidth) { lineWidth = width; value = displayValue; } } [defaultAppearance, fontSize] = this._computeFontSize(lineHeight, totalWidth - 2 * defaultHPadding, value, font, -1); } else { defaultAppearance = this._defaultAppearance; } const lineHeight = fontSize * _util.LINE_FACTOR; const vPadding = (lineHeight - fontSize) / 2; const numberOfVisibleLines = Math.floor(totalHeight / lineHeight); let firstIndex; if (valueIndices.length === 1) { const valuePosition = valueIndices[0]; const indexInPage = valuePosition % numberOfVisibleLines; firstIndex = valuePosition - indexInPage; } else { firstIndex = valueIndices.length ? valueIndices[0] : 0; } const end = Math.min(firstIndex + numberOfVisibleLines + 1, lineCount); const buf = [\"/Tx BMC q\", `1 1 ${totalWidth} ${totalHeight} re W n`]; if (valueIndices.length) { buf.push(\"0.600006 0.756866 0.854904 rg\"); for (const index of valueIndices) { if (firstIndex h) { vscale = h / totalHeight; } const fscale = Math.min(hscale, vscale); const newFontSize = fontSize * fscale; const buffer = [\"q\", `0 0 ${(0, _core_utils.numberToString)(w)} ${(0, _core_utils.numberToString)(h)} re W n`, `BT`, `1 0 0 1 0 ${(0, _core_utils.numberToString)(h + lineDescent)} Tm 0 Tc ${(0, _default_appearance.getPdfColor)(color, true)}`, `/Helv ${(0, _core_utils.numberToString)(newFontSize)} Tf`]; const vShift = (0, _core_utils.numberToString)(lineHeight); for (const line of encodedLines) { buffer.push(`0 -${vShift} Td (${(0, _core_utils.escapeString)(line)}) Tj`); } buffer.push(\"ET\", \"Q\"); const appearance = buffer.join(\"\\n\"); const appearanceStreamDict = new _primitives.Dict(xref); appearanceStreamDict.set(\"FormType\", 1); appearanceStreamDict.set(\"Subtype\", _primitives.Name.get(\"Form\")); appearanceStreamDict.set(\"Type\", _primitives.Name.get(\"XObject\")); appearanceStreamDict.set(\"BBox\", [0, 0, w, h]); appearanceStreamDict.set(\"Length\", appearance.length); appearanceStreamDict.set(\"Resources\", resources); if (rotation) { const matrix = (0, _core_utils.getRotationMatrix)(rotation, w, h); appearanceStreamDict.set(\"Matrix\", matrix); } const ap = new _stream.StringStream(appearance); ap.dict = appearanceStreamDict; return ap; } } class LineAnnotation extends MarkupAnnotation { constructor(params) { super(params); const { dict, xref } = params; this.data.annotationType = _util.AnnotationType.LINE; const lineCoordinates = dict.getArray(\"L\"); this.data.lineCoordinates = _util.Util.normalizeRect(lineCoordinates); this.setLineEndings(dict.getArray(\"LE\")); this.data.lineEndings = this.lineEndings; if (!this.appearance) { const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0]; const strokeAlpha = dict.get(\"CA\"); const interiorColor = getRgbColor(dict.getArray(\"IC\"), null); const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null; const fillAlpha = fillColor ? strokeAlpha : null; const borderWidth = this.borderStyle.width || 1, borderAdjust = 2 * borderWidth; const bbox = [this.data.lineCoordinates[0] - borderAdjust, this.data.lineCoordinates[1] - borderAdjust, this.data.lineCoordinates[2] + borderAdjust, this.data.lineCoordinates[3] + borderAdjust]; if (!_util.Util.intersect(this.rectangle, bbox)) { this.rectangle = bbox; } this._setDefaultAppearance({ xref, extra: `${borderWidth} w`, strokeColor, fillColor, strokeAlpha, fillAlpha, pointsCallback: (buffer, points) => { buffer.push(`${lineCoordinates[0]} ${lineCoordinates[1]} m`, `${lineCoordinates[2]} ${lineCoordinates[3]} l`, \"S\"); return [points[0].x - borderWidth, points[1].x + borderWidth, points[3].y - borderWidth, points[1].y + borderWidth]; } }); } } } class SquareAnnotation extends MarkupAnnotation { constructor(params) { super(params); const { dict, xref } = params; this.data.annotationType = _util.AnnotationType.SQUARE; if (!this.appearance) { const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0]; const strokeAlpha = dict.get(\"CA\"); const interiorColor = getRgbColor(dict.getArray(\"IC\"), null); const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null; const fillAlpha = fillColor ? strokeAlpha : null; if (this.borderStyle.width === 0 && !fillColor) { return; } this._setDefaultAppearance({ xref, extra: `${this.borderStyle.width} w`, strokeColor, fillColor, strokeAlpha, fillAlpha, pointsCallback: (buffer, points) => { const x = points[2].x + this.borderStyle.width / 2; const y = points[2].y + this.borderStyle.width / 2; const width = points[3].x - points[2].x - this.borderStyle.width; const height = points[1].y - points[3].y - this.borderStyle.width; buffer.push(`${x} ${y} ${width} ${height} re`); if (fillColor) { buffer.push(\"B\"); } else { buffer.push(\"S\"); } return [points[0].x, points[1].x, points[3].y, points[1].y]; } }); } } } class CircleAnnotation extends MarkupAnnotation { constructor(params) { super(params); const { dict, xref } = params; this.data.annotationType = _util.AnnotationType.CIRCLE; if (!this.appearance) { const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0]; const strokeAlpha = dict.get(\"CA\"); const interiorColor = getRgbColor(dict.getArray(\"IC\"), null); const fillColor = interiorColor ? getPdfColorArray(interiorColor) : null; const fillAlpha = fillColor ? strokeAlpha : null; if (this.borderStyle.width === 0 && !fillColor) { return; } const controlPointsDistance = 4 / 3 * Math.tan(Math.PI / (2 * 4)); this._setDefaultAppearance({ xref, extra: `${this.borderStyle.width} w`, strokeColor, fillColor, strokeAlpha, fillAlpha, pointsCallback: (buffer, points) => { const x0 = points[0].x + this.borderStyle.width / 2; const y0 = points[0].y - this.borderStyle.width / 2; const x1 = points[3].x - this.borderStyle.width / 2; const y1 = points[3].y + this.borderStyle.width / 2; const xMid = x0 + (x1 - x0) / 2; const yMid = y0 + (y1 - y0) / 2; const xOffset = (x1 - x0) / 2 * controlPointsDistance; const yOffset = (y1 - y0) / 2 * controlPointsDistance; buffer.push(`${xMid} ${y1} m`, `${xMid + xOffset} ${y1} ${x1} ${yMid + yOffset} ${x1} ${yMid} c`, `${x1} ${yMid - yOffset} ${xMid + xOffset} ${y0} ${xMid} ${y0} c`, `${xMid - xOffset} ${y0} ${x0} ${yMid - yOffset} ${x0} ${yMid} c`, `${x0} ${yMid + yOffset} ${xMid - xOffset} ${y1} ${xMid} ${y1} c`, \"h\"); if (fillColor) { buffer.push(\"B\"); } else { buffer.push(\"S\"); } return [points[0].x, points[1].x, points[3].y, points[1].y]; } }); } } } class PolylineAnnotation extends MarkupAnnotation { constructor(params) { super(params); const { dict, xref } = params; this.data.annotationType = _util.AnnotationType.POLYLINE; this.data.vertices = []; if (!(this instanceof PolygonAnnotation)) { this.setLineEndings(dict.getArray(\"LE\")); this.data.lineEndings = this.lineEndings; } const rawVertices = dict.getArray(\"Vertices\"); if (!Array.isArray(rawVertices)) { return; } for (let i = 0, ii = rawVertices.length; i < ii; i += 2) { this.data.vertices.push({ x: rawVertices[i], y: rawVertices[i + 1] }); } if (!this.appearance) { const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0]; const strokeAlpha = dict.get(\"CA\"); const borderWidth = this.borderStyle.width || 1, borderAdjust = 2 * borderWidth; const bbox = [Infinity, Infinity, -Infinity, -Infinity]; for (const vertex of this.data.vertices) { bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust); bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust); bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust); bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust); } if (!_util.Util.intersect(this.rectangle, bbox)) { this.rectangle = bbox; } this._setDefaultAppearance({ xref, extra: `${borderWidth} w`, strokeColor, strokeAlpha, pointsCallback: (buffer, points) => { const vertices = this.data.vertices; for (let i = 0, ii = vertices.length; i < ii; i++) { buffer.push(`${vertices[i].x} ${vertices[i].y} ${i === 0 ? \"m\" : \"l\"}`); } buffer.push(\"S\"); return [points[0].x, points[1].x, points[3].y, points[1].y]; } }); } } } class PolygonAnnotation extends PolylineAnnotation { constructor(params) { super(params); this.data.annotationType = _util.AnnotationType.POLYGON; } } class CaretAnnotation extends MarkupAnnotation { constructor(params) { super(params); this.data.annotationType = _util.AnnotationType.CARET; } } class InkAnnotation extends MarkupAnnotation { constructor(params) { super(params); const { dict, xref } = params; this.data.annotationType = _util.AnnotationType.INK; this.data.inkLists = []; const rawInkLists = dict.getArray(\"InkList\"); if (!Array.isArray(rawInkLists)) { return; } for (let i = 0, ii = rawInkLists.length; i < ii; ++i) { this.data.inkLists.push([]); for (let j = 0, jj = rawInkLists[i].length; j < jj; j += 2) { this.data.inkLists[i].push({ x: xref.fetchIfRef(rawInkLists[i][j]), y: xref.fetchIfRef(rawInkLists[i][j + 1]) }); } } if (!this.appearance) { const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0]; const strokeAlpha = dict.get(\"CA\"); const borderWidth = this.borderStyle.width || 1, borderAdjust = 2 * borderWidth; const bbox = [Infinity, Infinity, -Infinity, -Infinity]; for (const inkLists of this.data.inkLists) { for (const vertex of inkLists) { bbox[0] = Math.min(bbox[0], vertex.x - borderAdjust); bbox[1] = Math.min(bbox[1], vertex.y - borderAdjust); bbox[2] = Math.max(bbox[2], vertex.x + borderAdjust); bbox[3] = Math.max(bbox[3], vertex.y + borderAdjust); } } if (!_util.Util.intersect(this.rectangle, bbox)) { this.rectangle = bbox; } this._setDefaultAppearance({ xref, extra: `${borderWidth} w`, strokeColor, strokeAlpha, pointsCallback: (buffer, points) => { for (const inkList of this.data.inkLists) { for (let i = 0, ii = inkList.length; i < ii; i++) { buffer.push(`${inkList[i].x} ${inkList[i].y} ${i === 0 ? \"m\" : \"l\"}`); } buffer.push(\"S\"); } return [points[0].x, points[1].x, points[3].y, points[1].y]; } }); } } static createNewDict(annotation, xref, { apRef, ap }) { const { paths, rect, rotation } = annotation; const ink = new _primitives.Dict(xref); ink.set(\"Type\", _primitives.Name.get(\"Annot\")); ink.set(\"Subtype\", _primitives.Name.get(\"Ink\")); ink.set(\"CreationDate\", `D:${(0, _util.getModificationDate)()}`); ink.set(\"Rect\", rect); ink.set(\"InkList\", paths.map(p => p.points)); ink.set(\"F\", 4); ink.set(\"Border\", [0, 0, 0]); ink.set(\"Rotate\", rotation); const n = new _primitives.Dict(xref); ink.set(\"AP\", n); if (apRef) { n.set(\"N\", apRef); } else { n.set(\"N\", ap); } return ink; } static async createNewAppearanceStream(annotation, xref, params) { const { color, rect, rotation, paths, thickness, opacity } = annotation; const [x1, y1, x2, y2] = rect; let w = x2 - x1; let h = y2 - y1; if (rotation % 180 !== 0) { [w, h] = [h, w]; } const appearanceBuffer = [`${thickness} w 1 J 1 j`, `${(0, _default_appearance.getPdfColor)(color, false)}`]; if (opacity !== 1) { appearanceBuffer.push(\"/R0 gs\"); } const buffer = []; for (const { bezier } of paths) { buffer.length = 0; buffer.push(`${(0, _core_utils.numberToString)(bezier[0])} ${(0, _core_utils.numberToString)(bezier[1])} m`); for (let i = 2, ii = bezier.length; i < ii; i += 6) { const curve = bezier.slice(i, i + 6).map(_core_utils.numberToString).join(\" \"); buffer.push(`${curve} c`); } buffer.push(\"S\"); appearanceBuffer.push(buffer.join(\"\\n\")); } const appearance = appearanceBuffer.join(\"\\n\"); const appearanceStreamDict = new _primitives.Dict(xref); appearanceStreamDict.set(\"FormType\", 1); appearanceStreamDict.set(\"Subtype\", _primitives.Name.get(\"Form\")); appearanceStreamDict.set(\"Type\", _primitives.Name.get(\"XObject\")); appearanceStreamDict.set(\"BBox\", [0, 0, w, h]); appearanceStreamDict.set(\"Length\", appearance.length); if (rotation) { const matrix = (0, _core_utils.getRotationMatrix)(rotation, w, h); appearanceStreamDict.set(\"Matrix\", matrix); } if (opacity !== 1) { const resources = new _primitives.Dict(xref); const extGState = new _primitives.Dict(xref); const r0 = new _primitives.Dict(xref); r0.set(\"CA\", opacity); r0.set(\"Type\", _primitives.Name.get(\"ExtGState\")); extGState.set(\"R0\", r0); resources.set(\"ExtGState\", extGState); appearanceStreamDict.set(\"Resources\", resources); } const ap = new _stream.StringStream(appearance); ap.dict = appearanceStreamDict; return ap; } } class HighlightAnnotation extends MarkupAnnotation { constructor(params) { super(params); const { dict, xref } = params; this.data.annotationType = _util.AnnotationType.HIGHLIGHT; const quadPoints = this.data.quadPoints = getQuadPoints(dict, null); if (quadPoints) { const resources = this.appearance && this.appearance.dict.get(\"Resources\"); if (!this.appearance || !(resources && resources.has(\"ExtGState\"))) { if (this.appearance) { (0, _util.warn)(\"HighlightAnnotation - ignoring built-in appearance stream.\"); } const fillColor = this.color ? getPdfColorArray(this.color) : [1, 1, 0]; const fillAlpha = dict.get(\"CA\"); this._setDefaultAppearance({ xref, fillColor, blendMode: \"Multiply\", fillAlpha, pointsCallback: (buffer, points) => { buffer.push(`${points[0].x} ${points[0].y} m`, `${points[1].x} ${points[1].y} l`, `${points[3].x} ${points[3].y} l`, `${points[2].x} ${points[2].y} l`, \"f\"); return [points[0].x, points[1].x, points[3].y, points[1].y]; } }); } } else { this.data.hasPopup = false; } } } class UnderlineAnnotation extends MarkupAnnotation { constructor(params) { super(params); const { dict, xref } = params; this.data.annotationType = _util.AnnotationType.UNDERLINE; const quadPoints = this.data.quadPoints = getQuadPoints(dict, null); if (quadPoints) { if (!this.appearance) { const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0]; const strokeAlpha = dict.get(\"CA\"); this._setDefaultAppearance({ xref, extra: \"[] 0 d 1 w\", strokeColor, strokeAlpha, pointsCallback: (buffer, points) => { buffer.push(`${points[2].x} ${points[2].y} m`, `${points[3].x} ${points[3].y} l`, \"S\"); return [points[0].x, points[1].x, points[3].y, points[1].y]; } }); } } else { this.data.hasPopup = false; } } } class SquigglyAnnotation extends MarkupAnnotation { constructor(params) { super(params); const { dict, xref } = params; this.data.annotationType = _util.AnnotationType.SQUIGGLY; const quadPoints = this.data.quadPoints = getQuadPoints(dict, null); if (quadPoints) { if (!this.appearance) { const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0]; const strokeAlpha = dict.get(\"CA\"); this._setDefaultAppearance({ xref, extra: \"[] 0 d 1 w\", strokeColor, strokeAlpha, pointsCallback: (buffer, points) => { const dy = (points[0].y - points[2].y) / 6; let shift = dy; let x = points[2].x; const y = points[2].y; const xEnd = points[3].x; buffer.push(`${x} ${y + shift} m`); do { x += 2; shift = shift === 0 ? dy : 0; buffer.push(`${x} ${y + shift} l`); } while (x < xEnd); buffer.push(\"S\"); return [points[2].x, xEnd, y - 2 * dy, y + 2 * dy]; } }); } } else { this.data.hasPopup = false; } } } class StrikeOutAnnotation extends MarkupAnnotation { constructor(params) { super(params); const { dict, xref } = params; this.data.annotationType = _util.AnnotationType.STRIKEOUT; const quadPoints = this.data.quadPoints = getQuadPoints(dict, null); if (quadPoints) { if (!this.appearance) { const strokeColor = this.color ? getPdfColorArray(this.color) : [0, 0, 0]; const strokeAlpha = dict.get(\"CA\"); this._setDefaultAppearance({ xref, extra: \"[] 0 d 1 w\", strokeColor, strokeAlpha, pointsCallback: (buffer, points) => { buffer.push(`${(points[0].x + points[2].x) / 2} ` + `${(points[0].y + points[2].y) / 2} m`, `${(points[1].x + points[3].x) / 2} ` + `${(points[1].y + points[3].y) / 2} l`, \"S\"); return [points[0].x, points[1].x, points[3].y, points[1].y]; } }); } } else { this.data.hasPopup = false; } } } class StampAnnotation extends MarkupAnnotation { constructor(params) { super(params); this.data.annotationType = _util.AnnotationType.STAMP; } } class FileAttachmentAnnotation extends MarkupAnnotation { constructor(params) { super(params); const { dict, xref } = params; const file = new _file_spec.FileSpec(dict.get(\"FS\"), xref); this.data.annotationType = _util.AnnotationType.FILEATTACHMENT; this.data.file = file.serializable; const name = dict.get(\"Name\"); this.data.name = name instanceof _primitives.Name ? (0, _util.stringToPDFString)(name.name) : \"PushPin\"; } } /***/ }), /* 11 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.FakeUnicodeFont = void 0; exports.createDefaultAppearance = createDefaultAppearance; exports.getPdfColor = getPdfColor; exports.parseDefaultAppearance = parseDefaultAppearance; var _primitives = __w_pdfjs_require__(3); var _core_utils = __w_pdfjs_require__(4); var _util = __w_pdfjs_require__(2); var _colorspace = __w_pdfjs_require__(12); var _evaluator = __w_pdfjs_require__(13); var _stream = __w_pdfjs_require__(8); class DefaultAppearanceEvaluator extends _evaluator.EvaluatorPreprocessor { constructor(str) { super(new _stream.StringStream(str)); } parse() { const operation = { fn: 0, args: [] }; const result = { fontSize: 0, fontName: \"\", fontColor: new Uint8ClampedArray(3) }; try { while (true) { operation.args.length = 0; if (!this.read(operation)) { break; } if (this.savedStatesDepth !== 0) { continue; } const { fn, args } = operation; switch (fn | 0) { case _util.OPS.setFont: const [fontName, fontSize] = args; if (fontName instanceof _primitives.Name) { result.fontName = fontName.name; } if (typeof fontSize === \"number\" && fontSize > 0) { result.fontSize = fontSize; } break; case _util.OPS.setFillRGBColor: _colorspace.ColorSpace.singletons.rgb.getRgbItem(args, 0, result.fontColor, 0); break; case _util.OPS.setFillGray: _colorspace.ColorSpace.singletons.gray.getRgbItem(args, 0, result.fontColor, 0); break; case _util.OPS.setFillColorSpace: _colorspace.ColorSpace.singletons.cmyk.getRgbItem(args, 0, result.fontColor, 0); break; } } } catch (reason) { (0, _util.warn)(`parseDefaultAppearance - ignoring errors: \"${reason}\".`); } return result; } } function parseDefaultAppearance(str) { return new DefaultAppearanceEvaluator(str).parse(); } function getPdfColor(color, isFill) { if (color[0] === color[1] && color[1] === color[2]) { const gray = color[0] / 255; return `${(0, _core_utils.numberToString)(gray)} ${isFill ? \"g\" : \"G\"}`; } return Array.from(color, c => (0, _core_utils.numberToString)(c / 255)).join(\" \") + ` ${isFill ? \"rg\" : \"RG\"}`; } function createDefaultAppearance({ fontSize, fontName, fontColor }) { return `/${(0, _core_utils.escapePDFName)(fontName)} ${fontSize} Tf ${getPdfColor(fontColor, true)}`; } class FakeUnicodeFont { constructor(xref, fontFamily) { this.xref = xref; this.widths = null; this.firstChar = Infinity; this.lastChar = -Infinity; this.fontFamily = fontFamily; const canvas = new OffscreenCanvas(1, 1); this.ctxMeasure = canvas.getContext(\"2d\"); if (!FakeUnicodeFont._fontNameId) { FakeUnicodeFont._fontNameId = 1; } this.fontName = _primitives.Name.get(`InvalidPDFjsFont_${fontFamily}_${FakeUnicodeFont._fontNameId++}`); } get toUnicodeRef() { if (!FakeUnicodeFont._toUnicodeRef) { const toUnicode = `/CIDInit /ProcSet findresource begin 12 dict begin begincmap /CIDSystemInfo < /Registry (Adobe) /Ordering (UCS) /Supplement 0 >> def /CMapName /Adobe-Identity-UCS def /CMapType 2 def 1 begincodespacerange w) { hscale = w / maxWidth; } let vscale = 1; const lineHeight = _util.LINE_FACTOR * fontSize; const lineDescent = _util.LINE_DESCENT_FACTOR * fontSize; const maxHeight = lineHeight * lines.length; if (maxHeight > h) { vscale = h / maxHeight; } const fscale = Math.min(hscale, vscale); const newFontSize = fontSize * fscale; const buffer = [\"q\", `0 0 ${(0, _core_utils.numberToString)(w)} ${(0, _core_utils.numberToString)(h)} re W n`, `BT`, `1 0 0 1 0 ${(0, _core_utils.numberToString)(h + lineDescent)} Tm 0 Tc ${getPdfColor(bgColor, true)}`, `/${this.fontName.name} ${(0, _core_utils.numberToString)(newFontSize)} Tf`]; const vShift = (0, _core_utils.numberToString)(lineHeight); for (const line of lines) { buffer.push(`0 -${vShift} Td Tj`); } buffer.push(\"ET\", \"Q\"); const appearance = buffer.join(\"\\n\"); const appearanceStreamDict = new _primitives.Dict(this.xref); appearanceStreamDict.set(\"Subtype\", _primitives.Name.get(\"Form\")); appearanceStreamDict.set(\"Type\", _primitives.Name.get(\"XObject\")); appearanceStreamDict.set(\"BBox\", [0, 0, w, h]); appearanceStreamDict.set(\"Length\", appearance.length); appearanceStreamDict.set(\"Resources\", this.resources); if (rotation) { const matrix = (0, _core_utils.getRotationMatrix)(rotation, w, h); appearanceStreamDict.set(\"Matrix\", matrix); } const ap = new _stream.StringStream(appearance); ap.dict = appearanceStreamDict; return ap; } } exports.FakeUnicodeFont = FakeUnicodeFont; /***/ }), /* 12 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.ColorSpace = void 0; var _util = __w_pdfjs_require__(2); var _primitives = __w_pdfjs_require__(3); var _base_stream = __w_pdfjs_require__(5); var _core_utils = __w_pdfjs_require__(4); function resizeRgbImage(src, dest, w1, h1, w2, h2, alpha01) { const COMPONENTS = 3; alpha01 = alpha01 !== 1 ? 0 : alpha01; const xRatio = w1 / w2; const yRatio = h1 / h2; let newIndex = 0, oldIndex; const xScaled = new Uint16Array(w2); const w1Scanline = w1 * COMPONENTS; for (let i = 0; i < w2; i++) { xScaled[i] = Math.floor(i * xRatio) * COMPONENTS; } for (let i = 0; i < h2; i++) { const py = Math.floor(i * yRatio) * w1Scanline; for (let j = 0; j < w2; j++) { oldIndex = py + xScaled[j]; dest[newIndex++] = src[oldIndex++]; dest[newIndex++] = src[oldIndex++]; dest[newIndex++] = src[oldIndex++]; newIndex += alpha01; } } } class ColorSpace { constructor(name, numComps) { if (this.constructor === ColorSpace) { (0, _util.unreachable)(\"Cannot initialize ColorSpace.\"); } this.name = name; this.numComps = numComps; } getRgb(src, srcOffset) { const rgb = new Uint8ClampedArray(3); this.getRgbItem(src, srcOffset, rgb, 0); return rgb; } getRgbItem(src, srcOffset, dest, destOffset) { (0, _util.unreachable)(\"Should not call ColorSpace.getRgbItem\"); } getRgbBuffer(src, srcOffset, count, dest, destOffset, bits, alpha01) { (0, _util.unreachable)(\"Should not call ColorSpace.getRgbBuffer\"); } getOutputLength(inputLength, alpha01) { (0, _util.unreachable)(\"Should not call ColorSpace.getOutputLength\"); } isPassthrough(bits) { return false; } isDefaultDecode(decodeMap, bpc) { return ColorSpace.isDefaultDecode(decodeMap, this.numComps); } fillRgb(dest, originalWidth, originalHeight, width, height, actualHeight, bpc, comps, alpha01) { const count = originalWidth * originalHeight; let rgbBuf = null; const numComponentColors = 1 < bpc; const needsResizing = originalHeight !== height || originalWidth !== width; if (this.isPassthrough(bpc)) { rgbBuf = comps; } else if (this.numComps === 1 && count > numComponentColors && this.name !== \"DeviceGray\" && this.name !== \"DeviceRGB\") { const allColors = bpc n >= 0 && n n >= 0 }); } } class Trace extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, \"trace\", true); this.area = new _xfa_object.XFAObjectArray(); } } class Transform extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, \"transform\", true); this.groupParent = null; this.ifEmpty = null; this.nameAttr = null; this.picture = null; this.presence = null; this.rename = null; this.whitespace = null; } } class Type extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, \"type\", [\"none\", \"ascii85\", \"asciiHex\", \"ccittfax\", \"flate\", \"lzw\", \"runLength\", \"native\", \"xdp\", \"mergedXDP\"]); } } class Uri extends _xfa_object.StringObject { constructor(attributes) { super(CONFIG_NS_ID, \"uri\"); } } class Validate extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, \"validate\", [\"preSubmit\", \"prePrint\", \"preExecute\", \"preSave\"]); } } class ValidateApprovalSignatures extends _xfa_object.ContentObject { constructor(attributes) { super(CONFIG_NS_ID, \"validateApprovalSignatures\"); } [_xfa_object.$finalize]() { this[_xfa_object.$content] = this[_xfa_object.$content].trim().split(/\\s+/).filter(x => [\"docReady\", \"postSign\"].includes(x)); } } class ValidationMessaging extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, \"validationMessaging\", [\"allMessagesIndividually\", \"allMessagesTogether\", \"firstMessageOnly\", \"noMessages\"]); } } class Version extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, \"version\", [\"1.7\", \"1.6\", \"1.5\", \"1.4\", \"1.3\", \"1.2\"]); } } class VersionControl extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, \"VersionControl\"); this.outputBelow = (0, _utils.getStringOption)(attributes.outputBelow, [\"warn\", \"error\", \"update\"]); this.sourceAbove = (0, _utils.getStringOption)(attributes.sourceAbove, [\"warn\", \"error\"]); this.sourceBelow = (0, _utils.getStringOption)(attributes.sourceBelow, [\"update\", \"maintain\"]); } } class ViewerPreferences extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, \"viewerPreferences\", true); this.ADBE_JSConsole = null; this.ADBE_JSDebugger = null; this.addViewerPreferences = null; this.duplexOption = null; this.enforce = null; this.numberOfCopies = null; this.pageRange = null; this.pickTrayByPDFSize = null; this.printScaling = null; } } class WebClient extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, \"webClient\", true); this.name = attributes.name ? attributes.name.trim() : \"\"; this.fontInfo = null; this.xdc = null; } } class Whitespace extends _xfa_object.OptionObject { constructor(attributes) { super(CONFIG_NS_ID, \"whitespace\", [\"preserve\", \"ltrim\", \"normalize\", \"rtrim\", \"trim\"]); } } class Window extends _xfa_object.ContentObject { constructor(attributes) { super(CONFIG_NS_ID, \"window\"); } [_xfa_object.$finalize]() { const pair = this[_xfa_object.$content].trim().split(/\\s*,\\s*/, 2).map(x => parseInt(x, 10)); if (pair.some(x => isNaN(x))) { this[_xfa_object.$content] = [0, 0]; return; } if (pair.length === 1) { pair.push(pair[0]); } this[_xfa_object.$content] = pair; } } class Xdc extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, \"xdc\", true); this.uri = new _xfa_object.XFAObjectArray(); this.xsl = new _xfa_object.XFAObjectArray(); } } class Xdp extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, \"xdp\", true); this.packets = null; } } class Xsl extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, \"xsl\", true); this.debug = null; this.uri = null; } } class Zpl extends _xfa_object.XFAObject { constructor(attributes) { super(CONFIG_NS_ID, \"zpl\", true); this.name = attributes.name ? attributes.name.trim() : \"\"; this.batchOutput = null; this.flipLabel = null; this.fontInfo = null; this.xdc = null; } } class ConfigNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (ConfigNamespace.hasOwnProperty(name)) { return ConfigNamespace[name](attributes); } return undefined; } static acrobat(attrs) { return new Acrobat(attrs); } static acrobat7(attrs) { return new Acrobat7(attrs); } static ADBE_JSConsole(attrs) { return new ADBE_JSConsole(attrs); } static ADBE_JSDebugger(attrs) { return new ADBE_JSDebugger(attrs); } static addSilentPrint(attrs) { return new AddSilentPrint(attrs); } static addViewerPreferences(attrs) { return new AddViewerPreferences(attrs); } static adjustData(attrs) { return new AdjustData(attrs); } static adobeExtensionLevel(attrs) { return new AdobeExtensionLevel(attrs); } static agent(attrs) { return new Agent(attrs); } static alwaysEmbed(attrs) { return new AlwaysEmbed(attrs); } static amd(attrs) { return new Amd(attrs); } static area(attrs) { return new Area(attrs); } static attributes(attrs) { return new Attributes(attrs); } static autoSave(attrs) { return new AutoSave(attrs); } static base(attrs) { return new Base(attrs); } static batchOutput(attrs) { return new BatchOutput(attrs); } static behaviorOverride(attrs) { return new BehaviorOverride(attrs); } static cache(attrs) { return new Cache(attrs); } static change(attrs) { return new Change(attrs); } static common(attrs) { return new Common(attrs); } static compress(attrs) { return new Compress(attrs); } static compressLogicalStructure(attrs) { return new CompressLogicalStructure(attrs); } static compressObjectStream(attrs) { return new CompressObjectStream(attrs); } static compression(attrs) { return new Compression(attrs); } static config(attrs) { return new Config(attrs); } static conformance(attrs) { return new Conformance(attrs); } static contentCopy(attrs) { return new ContentCopy(attrs); } static copies(attrs) { return new Copies(attrs); } static creator(attrs) { return new Creator(attrs); } static currentPage(attrs) { return new CurrentPage(attrs); } static data(attrs) { return new Data(attrs); } static debug(attrs) { return new Debug(attrs); } static defaultTypeface(attrs) { return new DefaultTypeface(attrs); } static destination(attrs) { return new Destination(attrs); } static documentAssembly(attrs) { return new DocumentAssembly(attrs); } static driver(attrs) { return new Driver(attrs); } static duplexOption(attrs) { return new DuplexOption(attrs); } static dynamicRender(attrs) { return new DynamicRender(attrs); } static embed(attrs) { return new Embed(attrs); } static encrypt(attrs) { return new Encrypt(attrs); } static encryption(attrs) { return new Encryption(attrs); } static encryptionLevel(attrs) { return new EncryptionLevel(attrs); } static enforce(attrs) { return new Enforce(attrs); } static equate(attrs) { return new Equate(attrs); } static equateRange(attrs) { return new EquateRange(attrs); } static exclude(attrs) { return new Exclude(attrs); } static excludeNS(attrs) { return new ExcludeNS(attrs); } static flipLabel(attrs) { return new FlipLabel(attrs); } static fontInfo(attrs) { return new FontInfo(attrs); } static formFieldFilling(attrs) { return new FormFieldFilling(attrs); } static groupParent(attrs) { return new GroupParent(attrs); } static ifEmpty(attrs) { return new IfEmpty(attrs); } static includeXDPContent(attrs) { return new IncludeXDPContent(attrs); } static incrementalLoad(attrs) { return new IncrementalLoad(attrs); } static incrementalMerge(attrs) { return new IncrementalMerge(attrs); } static interactive(attrs) { return new Interactive(attrs); } static jog(attrs) { return new Jog(attrs); } static labelPrinter(attrs) { return new LabelPrinter(attrs); } static layout(attrs) { return new Layout(attrs); } static level(attrs) { return new Level(attrs); } static linearized(attrs) { return new Linearized(attrs); } static locale(attrs) { return new Locale(attrs); } static localeSet(attrs) { return new LocaleSet(attrs); } static log(attrs) { return new Log(attrs); } static map(attrs) { return new MapElement(attrs); } static mediumInfo(attrs) { return new MediumInfo(attrs); } static message(attrs) { return new Message(attrs); } static messaging(attrs) { return new Messaging(attrs); } static mode(attrs) { return new Mode(attrs); } static modifyAnnots(attrs) { return new ModifyAnnots(attrs); } static msgId(attrs) { return new MsgId(attrs); } static nameAttr(attrs) { return new NameAttr(attrs); } static neverEmbed(attrs) { return new NeverEmbed(attrs); } static numberOfCopies(attrs) { return new NumberOfCopies(attrs); } static openAction(attrs) { return new OpenAction(attrs); } static output(attrs) { return new Output(attrs); } static outputBin(attrs) { return new OutputBin(attrs); } static outputXSL(attrs) { return new OutputXSL(attrs); } static overprint(attrs) { return new Overprint(attrs); } static packets(attrs) { return new Packets(attrs); } static pageOffset(attrs) { return new PageOffset(attrs); } static pageRange(attrs) { return new PageRange(attrs); } static pagination(attrs) { return new Pagination(attrs); } static paginationOverride(attrs) { return new PaginationOverride(attrs); } static part(attrs) { return new Part(attrs); } static pcl(attrs) { return new Pcl(attrs); } static pdf(attrs) { return new Pdf(attrs); } static pdfa(attrs) { return new Pdfa(attrs); } static permissions(attrs) { return new Permissions(attrs); } static pickTrayByPDFSize(attrs) { return new PickTrayByPDFSize(attrs); } static picture(attrs) { return new Picture(attrs); } static plaintextMetadata(attrs) { return new PlaintextMetadata(attrs); } static presence(attrs) { return new Presence(attrs); } static present(attrs) { return new Present(attrs); } static print(attrs) { return new Print(attrs); } static printHighQuality(attrs) { return new PrintHighQuality(attrs); } static printScaling(attrs) { return new PrintScaling(attrs); } static printerName(attrs) { return new PrinterName(attrs); } static producer(attrs) { return new Producer(attrs); } static ps(attrs) { return new Ps(attrs); } static range(attrs) { return new Range(attrs); } static record(attrs) { return new Record(attrs); } static relevant(attrs) { return new Relevant(attrs); } static rename(attrs) { return new Rename(attrs); } static renderPolicy(attrs) { return new RenderPolicy(attrs); } static runScripts(attrs) { return new RunScripts(attrs); } static script(attrs) { return new Script(attrs); } static scriptModel(attrs) { return new ScriptModel(attrs); } static severity(attrs) { return new Severity(attrs); } static silentPrint(attrs) { return new SilentPrint(attrs); } static staple(attrs) { return new Staple(attrs); } static startNode(attrs) { return new StartNode(attrs); } static startPage(attrs) { return new StartPage(attrs); } static submitFormat(attrs) { return new SubmitFormat(attrs); } static submitUrl(attrs) { return new SubmitUrl(attrs); } static subsetBelow(attrs) { return new SubsetBelow(attrs); } static suppressBanner(attrs) { return new SuppressBanner(attrs); } static tagged(attrs) { return new Tagged(attrs); } static template(attrs) { return new Template(attrs); } static templateCache(attrs) { return new TemplateCache(attrs); } static threshold(attrs) { return new Threshold(attrs); } static to(attrs) { return new To(attrs); } static trace(attrs) { return new Trace(attrs); } static transform(attrs) { return new Transform(attrs); } static type(attrs) { return new Type(attrs); } static uri(attrs) { return new Uri(attrs); } static validate(attrs) { return new Validate(attrs); } static validateApprovalSignatures(attrs) { return new ValidateApprovalSignatures(attrs); } static validationMessaging(attrs) { return new ValidationMessaging(attrs); } static version(attrs) { return new Version(attrs); } static versionControl(attrs) { return new VersionControl(attrs); } static viewerPreferences(attrs) { return new ViewerPreferences(attrs); } static webClient(attrs) { return new WebClient(attrs); } static whitespace(attrs) { return new Whitespace(attrs); } static window(attrs) { return new Window(attrs); } static xdc(attrs) { return new Xdc(attrs); } static xdp(attrs) { return new Xdp(attrs); } static xsl(attrs) { return new Xsl(attrs); } static zpl(attrs) { return new Zpl(attrs); } } exports.ConfigNamespace = ConfigNamespace; /***/ }), /* 90 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.ConnectionSetNamespace = void 0; var _namespaces = __w_pdfjs_require__(77); var _xfa_object = __w_pdfjs_require__(75); const CONNECTION_SET_NS_ID = _namespaces.NamespaceIds.connectionSet.id; class ConnectionSet extends _xfa_object.XFAObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, \"connectionSet\", true); this.wsdlConnection = new _xfa_object.XFAObjectArray(); this.xmlConnection = new _xfa_object.XFAObjectArray(); this.xsdConnection = new _xfa_object.XFAObjectArray(); } } class EffectiveInputPolicy extends _xfa_object.XFAObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, \"effectiveInputPolicy\"); this.id = attributes.id || \"\"; this.name = attributes.name || \"\"; this.use = attributes.use || \"\"; this.usehref = attributes.usehref || \"\"; } } class EffectiveOutputPolicy extends _xfa_object.XFAObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, \"effectiveOutputPolicy\"); this.id = attributes.id || \"\"; this.name = attributes.name || \"\"; this.use = attributes.use || \"\"; this.usehref = attributes.usehref || \"\"; } } class Operation extends _xfa_object.StringObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, \"operation\"); this.id = attributes.id || \"\"; this.input = attributes.input || \"\"; this.name = attributes.name || \"\"; this.output = attributes.output || \"\"; this.use = attributes.use || \"\"; this.usehref = attributes.usehref || \"\"; } } class RootElement extends _xfa_object.StringObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, \"rootElement\"); this.id = attributes.id || \"\"; this.name = attributes.name || \"\"; this.use = attributes.use || \"\"; this.usehref = attributes.usehref || \"\"; } } class SoapAction extends _xfa_object.StringObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, \"soapAction\"); this.id = attributes.id || \"\"; this.name = attributes.name || \"\"; this.use = attributes.use || \"\"; this.usehref = attributes.usehref || \"\"; } } class SoapAddress extends _xfa_object.StringObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, \"soapAddress\"); this.id = attributes.id || \"\"; this.name = attributes.name || \"\"; this.use = attributes.use || \"\"; this.usehref = attributes.usehref || \"\"; } } class Uri extends _xfa_object.StringObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, \"uri\"); this.id = attributes.id || \"\"; this.name = attributes.name || \"\"; this.use = attributes.use || \"\"; this.usehref = attributes.usehref || \"\"; } } class WsdlAddress extends _xfa_object.StringObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, \"wsdlAddress\"); this.id = attributes.id || \"\"; this.name = attributes.name || \"\"; this.use = attributes.use || \"\"; this.usehref = attributes.usehref || \"\"; } } class WsdlConnection extends _xfa_object.XFAObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, \"wsdlConnection\", true); this.dataDescription = attributes.dataDescription || \"\"; this.name = attributes.name || \"\"; this.effectiveInputPolicy = null; this.effectiveOutputPolicy = null; this.operation = null; this.soapAction = null; this.soapAddress = null; this.wsdlAddress = null; } } class XmlConnection extends _xfa_object.XFAObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, \"xmlConnection\", true); this.dataDescription = attributes.dataDescription || \"\"; this.name = attributes.name || \"\"; this.uri = null; } } class XsdConnection extends _xfa_object.XFAObject { constructor(attributes) { super(CONNECTION_SET_NS_ID, \"xsdConnection\", true); this.dataDescription = attributes.dataDescription || \"\"; this.name = attributes.name || \"\"; this.rootElement = null; this.uri = null; } } class ConnectionSetNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (ConnectionSetNamespace.hasOwnProperty(name)) { return ConnectionSetNamespace[name](attributes); } return undefined; } static connectionSet(attrs) { return new ConnectionSet(attrs); } static effectiveInputPolicy(attrs) { return new EffectiveInputPolicy(attrs); } static effectiveOutputPolicy(attrs) { return new EffectiveOutputPolicy(attrs); } static operation(attrs) { return new Operation(attrs); } static rootElement(attrs) { return new RootElement(attrs); } static soapAction(attrs) { return new SoapAction(attrs); } static soapAddress(attrs) { return new SoapAddress(attrs); } static uri(attrs) { return new Uri(attrs); } static wsdlAddress(attrs) { return new WsdlAddress(attrs); } static wsdlConnection(attrs) { return new WsdlConnection(attrs); } static xmlConnection(attrs) { return new XmlConnection(attrs); } static xsdConnection(attrs) { return new XsdConnection(attrs); } } exports.ConnectionSetNamespace = ConnectionSetNamespace; /***/ }), /* 91 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.DatasetsNamespace = void 0; var _xfa_object = __w_pdfjs_require__(75); var _namespaces = __w_pdfjs_require__(77); const DATASETS_NS_ID = _namespaces.NamespaceIds.datasets.id; class Data extends _xfa_object.XmlObject { constructor(attributes) { super(DATASETS_NS_ID, \"data\", attributes); } [_xfa_object.$isNsAgnostic]() { return true; } } class Datasets extends _xfa_object.XFAObject { constructor(attributes) { super(DATASETS_NS_ID, \"datasets\", true); this.data = null; this.Signature = null; } [_xfa_object.$onChild](child) { const name = child[_xfa_object.$nodeName]; if (name === \"data\" && child[_xfa_object.$namespaceId] === DATASETS_NS_ID || name === \"Signature\" && child[_xfa_object.$namespaceId] === _namespaces.NamespaceIds.signature.id) { this[name] = child; } this[_xfa_object.$appendChild](child); } } class DatasetsNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (DatasetsNamespace.hasOwnProperty(name)) { return DatasetsNamespace[name](attributes); } return undefined; } static datasets(attributes) { return new Datasets(attributes); } static data(attributes) { return new Data(attributes); } } exports.DatasetsNamespace = DatasetsNamespace; /***/ }), /* 92 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.LocaleSetNamespace = void 0; var _namespaces = __w_pdfjs_require__(77); var _xfa_object = __w_pdfjs_require__(75); var _utils = __w_pdfjs_require__(76); const LOCALE_SET_NS_ID = _namespaces.NamespaceIds.localeSet.id; class CalendarSymbols extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"calendarSymbols\", true); this.name = \"gregorian\"; this.dayNames = new _xfa_object.XFAObjectArray(2); this.eraNames = null; this.meridiemNames = null; this.monthNames = new _xfa_object.XFAObjectArray(2); } } class CurrencySymbol extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"currencySymbol\"); this.name = (0, _utils.getStringOption)(attributes.name, [\"symbol\", \"isoname\", \"decimal\"]); } } class CurrencySymbols extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"currencySymbols\", true); this.currencySymbol = new _xfa_object.XFAObjectArray(3); } } class DatePattern extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"datePattern\"); this.name = (0, _utils.getStringOption)(attributes.name, [\"full\", \"long\", \"med\", \"short\"]); } } class DatePatterns extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"datePatterns\", true); this.datePattern = new _xfa_object.XFAObjectArray(4); } } class DateTimeSymbols extends _xfa_object.ContentObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"dateTimeSymbols\"); } } class Day extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"day\"); } } class DayNames extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"dayNames\", true); this.abbr = (0, _utils.getInteger)({ data: attributes.abbr, defaultValue: 0, validate: x => x === 1 }); this.day = new _xfa_object.XFAObjectArray(7); } } class Era extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"era\"); } } class EraNames extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"eraNames\", true); this.era = new _xfa_object.XFAObjectArray(2); } } class Locale extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"locale\", true); this.desc = attributes.desc || \"\"; this.name = \"isoname\"; this.calendarSymbols = null; this.currencySymbols = null; this.datePatterns = null; this.dateTimeSymbols = null; this.numberPatterns = null; this.numberSymbols = null; this.timePatterns = null; this.typeFaces = null; } } class LocaleSet extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"localeSet\", true); this.locale = new _xfa_object.XFAObjectArray(); } } class Meridiem extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"meridiem\"); } } class MeridiemNames extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"meridiemNames\", true); this.meridiem = new _xfa_object.XFAObjectArray(2); } } class Month extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"month\"); } } class MonthNames extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"monthNames\", true); this.abbr = (0, _utils.getInteger)({ data: attributes.abbr, defaultValue: 0, validate: x => x === 1 }); this.month = new _xfa_object.XFAObjectArray(12); } } class NumberPattern extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"numberPattern\"); this.name = (0, _utils.getStringOption)(attributes.name, [\"full\", \"long\", \"med\", \"short\"]); } } class NumberPatterns extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"numberPatterns\", true); this.numberPattern = new _xfa_object.XFAObjectArray(4); } } class NumberSymbol extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"numberSymbol\"); this.name = (0, _utils.getStringOption)(attributes.name, [\"decimal\", \"grouping\", \"percent\", \"minus\", \"zero\"]); } } class NumberSymbols extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"numberSymbols\", true); this.numberSymbol = new _xfa_object.XFAObjectArray(5); } } class TimePattern extends _xfa_object.StringObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"timePattern\"); this.name = (0, _utils.getStringOption)(attributes.name, [\"full\", \"long\", \"med\", \"short\"]); } } class TimePatterns extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"timePatterns\", true); this.timePattern = new _xfa_object.XFAObjectArray(4); } } class TypeFace extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"typeFace\", true); this.name = attributes.name | \"\"; } } class TypeFaces extends _xfa_object.XFAObject { constructor(attributes) { super(LOCALE_SET_NS_ID, \"typeFaces\", true); this.typeFace = new _xfa_object.XFAObjectArray(); } } class LocaleSetNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (LocaleSetNamespace.hasOwnProperty(name)) { return LocaleSetNamespace[name](attributes); } return undefined; } static calendarSymbols(attrs) { return new CalendarSymbols(attrs); } static currencySymbol(attrs) { return new CurrencySymbol(attrs); } static currencySymbols(attrs) { return new CurrencySymbols(attrs); } static datePattern(attrs) { return new DatePattern(attrs); } static datePatterns(attrs) { return new DatePatterns(attrs); } static dateTimeSymbols(attrs) { return new DateTimeSymbols(attrs); } static day(attrs) { return new Day(attrs); } static dayNames(attrs) { return new DayNames(attrs); } static era(attrs) { return new Era(attrs); } static eraNames(attrs) { return new EraNames(attrs); } static locale(attrs) { return new Locale(attrs); } static localeSet(attrs) { return new LocaleSet(attrs); } static meridiem(attrs) { return new Meridiem(attrs); } static meridiemNames(attrs) { return new MeridiemNames(attrs); } static month(attrs) { return new Month(attrs); } static monthNames(attrs) { return new MonthNames(attrs); } static numberPattern(attrs) { return new NumberPattern(attrs); } static numberPatterns(attrs) { return new NumberPatterns(attrs); } static numberSymbol(attrs) { return new NumberSymbol(attrs); } static numberSymbols(attrs) { return new NumberSymbols(attrs); } static timePattern(attrs) { return new TimePattern(attrs); } static timePatterns(attrs) { return new TimePatterns(attrs); } static typeFace(attrs) { return new TypeFace(attrs); } static typeFaces(attrs) { return new TypeFaces(attrs); } } exports.LocaleSetNamespace = LocaleSetNamespace; /***/ }), /* 93 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.SignatureNamespace = void 0; var _namespaces = __w_pdfjs_require__(77); var _xfa_object = __w_pdfjs_require__(75); const SIGNATURE_NS_ID = _namespaces.NamespaceIds.signature.id; class Signature extends _xfa_object.XFAObject { constructor(attributes) { super(SIGNATURE_NS_ID, \"signature\", true); } } class SignatureNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (SignatureNamespace.hasOwnProperty(name)) { return SignatureNamespace[name](attributes); } return undefined; } static signature(attributes) { return new Signature(attributes); } } exports.SignatureNamespace = SignatureNamespace; /***/ }), /* 94 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.StylesheetNamespace = void 0; var _namespaces = __w_pdfjs_require__(77); var _xfa_object = __w_pdfjs_require__(75); const STYLESHEET_NS_ID = _namespaces.NamespaceIds.stylesheet.id; class Stylesheet extends _xfa_object.XFAObject { constructor(attributes) { super(STYLESHEET_NS_ID, \"stylesheet\", true); } } class StylesheetNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (StylesheetNamespace.hasOwnProperty(name)) { return StylesheetNamespace[name](attributes); } return undefined; } static stylesheet(attributes) { return new Stylesheet(attributes); } } exports.StylesheetNamespace = StylesheetNamespace; /***/ }), /* 95 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.XdpNamespace = void 0; var _namespaces = __w_pdfjs_require__(77); var _xfa_object = __w_pdfjs_require__(75); const XDP_NS_ID = _namespaces.NamespaceIds.xdp.id; class Xdp extends _xfa_object.XFAObject { constructor(attributes) { super(XDP_NS_ID, \"xdp\", true); this.uuid = attributes.uuid || \"\"; this.timeStamp = attributes.timeStamp || \"\"; this.config = null; this.connectionSet = null; this.datasets = null; this.localeSet = null; this.stylesheet = new _xfa_object.XFAObjectArray(); this.template = null; } [_xfa_object.$onChildCheck](child) { const ns = _namespaces.NamespaceIds[child[_xfa_object.$nodeName]]; return ns && child[_xfa_object.$namespaceId] === ns.id; } } class XdpNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (XdpNamespace.hasOwnProperty(name)) { return XdpNamespace[name](attributes); } return undefined; } static xdp(attributes) { return new Xdp(attributes); } } exports.XdpNamespace = XdpNamespace; /***/ }), /* 96 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.XhtmlNamespace = void 0; var _xfa_object = __w_pdfjs_require__(75); var _namespaces = __w_pdfjs_require__(77); var _html_utils = __w_pdfjs_require__(82); var _utils = __w_pdfjs_require__(76); const XHTML_NS_ID = _namespaces.NamespaceIds.xhtml.id; const $richText = Symbol(); const VALID_STYLES = new Set([\"color\", \"font\", \"font-family\", \"font-size\", \"font-stretch\", \"font-style\", \"font-weight\", \"margin\", \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\", \"letter-spacing\", \"line-height\", \"orphans\", \"page-break-after\", \"page-break-before\", \"page-break-inside\", \"tab-interval\", \"tab-stop\", \"text-align\", \"text-decoration\", \"text-indent\", \"vertical-align\", \"widows\", \"kerning-mode\", \"xfa-font-horizontal-scale\", \"xfa-font-vertical-scale\", \"xfa-spacerun\", \"xfa-tab-stops\"]); const StyleMapping = new Map([[\"page-break-after\", \"breakAfter\"], [\"page-break-before\", \"breakBefore\"], [\"page-break-inside\", \"breakInside\"], [\"kerning-mode\", value => value === \"none\" ? \"none\" : \"normal\"], [\"xfa-font-horizontal-scale\", value => `scaleX(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], [\"xfa-font-vertical-scale\", value => `scaleY(${Math.max(0, Math.min(parseInt(value) / 100)).toFixed(2)})`], [\"xfa-spacerun\", \"\"], [\"xfa-tab-stops\", \"\"], [\"font-size\", (value, original) => { value = original.fontSize = (0, _utils.getMeasurement)(value); return (0, _html_utils.measureToString)(0.99 * value); }], [\"letter-spacing\", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [\"line-height\", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [\"margin\", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [\"margin-bottom\", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [\"margin-left\", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [\"margin-right\", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [\"margin-top\", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [\"text-indent\", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))], [\"font-family\", value => value], [\"vertical-align\", value => (0, _html_utils.measureToString)((0, _utils.getMeasurement)(value))]]); const spacesRegExp = /\\s+/g; const crlfRegExp = /[\\r\\n]+/g; const crlfForRichTextRegExp = /\\r\\n?/g; function mapStyle(styleStr, node, richText) { const style = Object.create(null); if (!styleStr) { return style; } const original = Object.create(null); for (const [key, value] of styleStr.split(\";\").map(s => s.split(\":\", 2))) { const mapping = StyleMapping.get(key); if (mapping === \"\") { continue; } let newValue = value; if (mapping) { if (typeof mapping === \"string\") { newValue = mapping; } else { newValue = mapping(value, original); } } if (key.endsWith(\"scale\")) { if (style.transform) { style.transform = `${style[key]} ${newValue}`; } else { style.transform = newValue; } } else { style[key.replaceAll(/-([a-zA-Z])/g, (_, x) => x.toUpperCase())] = newValue; } } if (style.fontFamily) { (0, _html_utils.setFontFamily)({ typeface: style.fontFamily, weight: style.fontWeight || \"normal\", posture: style.fontStyle || \"normal\", size: original.fontSize || 0 }, node, node[_xfa_object.$globalData].fontFinder, style); } if (richText && style.verticalAlign && style.verticalAlign !== \"0px\" && style.fontSize) { const SUB_SUPER_SCRIPT_FACTOR = 0.583; const VERTICAL_FACTOR = 0.333; const fontSize = (0, _utils.getMeasurement)(style.fontSize); style.fontSize = (0, _html_utils.measureToString)(fontSize * SUB_SUPER_SCRIPT_FACTOR); style.verticalAlign = (0, _html_utils.measureToString)(Math.sign((0, _utils.getMeasurement)(style.verticalAlign)) * fontSize * VERTICAL_FACTOR); } if (richText && style.fontSize) { style.fontSize = `calc(${style.fontSize} * var(--scale-factor))`; } (0, _html_utils.fixTextIndent)(style); return style; } function checkStyle(node) { if (!node.style) { return \"\"; } return node.style.trim().split(/\\s*;\\s*/).filter(s => !!s).map(s => s.split(/\\s*:\\s*/, 2)).filter(([key, value]) => { if (key === \"font-family\") { node[_xfa_object.$globalData].usedTypefaces.add(value); } return VALID_STYLES.has(key); }).map(kv => kv.join(\":\")).join(\";\"); } const NoWhites = new Set([\"body\", \"html\"]); class XhtmlObject extends _xfa_object.XmlObject { constructor(attributes, name) { super(XHTML_NS_ID, name); this[$richText] = false; this.style = attributes.style || \"\"; } [_xfa_object.$clean](builder) { super[_xfa_object.$clean](builder); this.style = checkStyle(this); } [_xfa_object.$acceptWhitespace]() { return !NoWhites.has(this[_xfa_object.$nodeName]); } [_xfa_object.$onText](str, richText = false) { if (!richText) { str = str.replace(crlfRegExp, \"\"); if (!this.style.includes(\"xfa-spacerun:yes\")) { str = str.replace(spacesRegExp, \" \"); } } else { this[$richText] = true; } if (str) { this[_xfa_object.$content] += str; } } [_xfa_object.$pushGlyphs](measure, mustPop = true) { const xfaFont = Object.create(null); const margin = { top: NaN, bottom: NaN, left: NaN, right: NaN }; let lineHeight = null; for (const [key, value] of this.style.split(\";\").map(s => s.split(\":\", 2))) { switch (key) { case \"font-family\": xfaFont.typeface = (0, _utils.stripQuotes)(value); break; case \"font-size\": xfaFont.size = (0, _utils.getMeasurement)(value); break; case \"font-weight\": xfaFont.weight = value; break; case \"font-style\": xfaFont.posture = value; break; case \"letter-spacing\": xfaFont.letterSpacing = (0, _utils.getMeasurement)(value); break; case \"margin\": const values = value.split(/ \\t/).map(x => (0, _utils.getMeasurement)(x)); switch (values.length) { case 1: margin.top = margin.bottom = margin.left = margin.right = values[0]; break; case 2: margin.top = margin.bottom = values[0]; margin.left = margin.right = values[1]; break; case 3: margin.top = values[0]; margin.bottom = values[2]; margin.left = margin.right = values[1]; break; case 4: margin.top = values[0]; margin.left = values[1]; margin.bottom = values[2]; margin.right = values[3]; break; } break; case \"margin-top\": margin.top = (0, _utils.getMeasurement)(value); break; case \"margin-bottom\": margin.bottom = (0, _utils.getMeasurement)(value); break; case \"margin-left\": margin.left = (0, _utils.getMeasurement)(value); break; case \"margin-right\": margin.right = (0, _utils.getMeasurement)(value); break; case \"line-height\": lineHeight = (0, _utils.getMeasurement)(value); break; } } measure.pushData(xfaFont, margin, lineHeight); if (this[_xfa_object.$content]) { measure.addString(this[_xfa_object.$content]); } else { for (const child of this[_xfa_object.$getChildren]()) { if (child[_xfa_object.$nodeName] === \"#text\") { measure.addString(child[_xfa_object.$content]); continue; } child[_xfa_object.$pushGlyphs](measure); } } if (mustPop) { measure.popFont(); } } [_xfa_object.$toHTML](availableSpace) { const children = []; this[_xfa_object.$extra] = { children }; this[_xfa_object.$childrenToHTML]({}); if (children.length === 0 && !this[_xfa_object.$content]) { return _utils.HTMLResult.EMPTY; } let value; if (this[$richText]) { value = this[_xfa_object.$content] ? this[_xfa_object.$content].replace(crlfForRichTextRegExp, \"\\n\") : undefined; } else { value = this[_xfa_object.$content] || undefined; } return _utils.HTMLResult.success({ name: this[_xfa_object.$nodeName], attributes: { href: this.href, style: mapStyle(this.style, this, this[$richText]) }, children, value }); } } class A extends XhtmlObject { constructor(attributes) { super(attributes, \"a\"); this.href = (0, _html_utils.fixURL)(attributes.href) || \"\"; } } class B extends XhtmlObject { constructor(attributes) { super(attributes, \"b\"); } [_xfa_object.$pushGlyphs](measure) { measure.pushFont({ weight: \"bold\" }); super[_xfa_object.$pushGlyphs](measure); measure.popFont(); } } class Body extends XhtmlObject { constructor(attributes) { super(attributes, \"body\"); } [_xfa_object.$toHTML](availableSpace) { const res = super[_xfa_object.$toHTML](availableSpace); const { html } = res; if (!html) { return _utils.HTMLResult.EMPTY; } html.name = \"div\"; html.attributes.class = [\"xfaRich\"]; return res; } } class Br extends XhtmlObject { constructor(attributes) { super(attributes, \"br\"); } [_xfa_object.$text]() { return \"\\n\"; } [_xfa_object.$pushGlyphs](measure) { measure.addString(\"\\n\"); } [_xfa_object.$toHTML](availableSpace) { return _utils.HTMLResult.success({ name: \"br\" }); } } class Html extends XhtmlObject { constructor(attributes) { super(attributes, \"html\"); } [_xfa_object.$toHTML](availableSpace) { const children = []; this[_xfa_object.$extra] = { children }; this[_xfa_object.$childrenToHTML]({}); if (children.length === 0) { return _utils.HTMLResult.success({ name: \"div\", attributes: { class: [\"xfaRich\"], style: {} }, value: this[_xfa_object.$content] || \"\" }); } if (children.length === 1) { const child = children[0]; if (child.attributes && child.attributes.class.includes(\"xfaRich\")) { return _utils.HTMLResult.success(child); } } return _utils.HTMLResult.success({ name: \"div\", attributes: { class: [\"xfaRich\"], style: {} }, children }); } } class I extends XhtmlObject { constructor(attributes) { super(attributes, \"i\"); } [_xfa_object.$pushGlyphs](measure) { measure.pushFont({ posture: \"italic\" }); super[_xfa_object.$pushGlyphs](measure); measure.popFont(); } } class Li extends XhtmlObject { constructor(attributes) { super(attributes, \"li\"); } } class Ol extends XhtmlObject { constructor(attributes) { super(attributes, \"ol\"); } } class P extends XhtmlObject { constructor(attributes) { super(attributes, \"p\"); } [_xfa_object.$pushGlyphs](measure) { super[_xfa_object.$pushGlyphs](measure, false); measure.addString(\"\\n\"); measure.addPara(); measure.popFont(); } [_xfa_object.$text]() { const siblings = this[_xfa_object.$getParent]()[_xfa_object.$getChildren](); if (siblings.at(-1) === this) { return super[_xfa_object.$text](); } return super[_xfa_object.$text]() + \"\\n\"; } } class Span extends XhtmlObject { constructor(attributes) { super(attributes, \"span\"); } } class Sub extends XhtmlObject { constructor(attributes) { super(attributes, \"sub\"); } } class Sup extends XhtmlObject { constructor(attributes) { super(attributes, \"sup\"); } } class Ul extends XhtmlObject { constructor(attributes) { super(attributes, \"ul\"); } } class XhtmlNamespace { static [_namespaces.$buildXFAObject](name, attributes) { if (XhtmlNamespace.hasOwnProperty(name)) { return XhtmlNamespace[name](attributes); } return undefined; } static a(attributes) { return new A(attributes); } static b(attributes) { return new B(attributes); } static body(attributes) { return new Body(attributes); } static br(attributes) { return new Br(attributes); } static html(attributes) { return new Html(attributes); } static i(attributes) { return new I(attributes); } static li(attributes) { return new Li(attributes); } static ol(attributes) { return new Ol(attributes); } static p(attributes) { return new P(attributes); } static span(attributes) { return new Span(attributes); } static sub(attributes) { return new Sub(attributes); } static sup(attributes) { return new Sup(attributes); } static ul(attributes) { return new Ul(attributes); } } exports.XhtmlNamespace = XhtmlNamespace; /***/ }), /* 97 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.UnknownNamespace = void 0; var _namespaces = __w_pdfjs_require__(77); var _xfa_object = __w_pdfjs_require__(75); class UnknownNamespace { constructor(nsId) { this.namespaceId = nsId; } [_namespaces.$buildXFAObject](name, attributes) { return new _xfa_object.XmlObject(this.namespaceId, name, attributes); } } exports.UnknownNamespace = UnknownNamespace; /***/ }), /* 98 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.DatasetReader = void 0; var _util = __w_pdfjs_require__(2); var _core_utils = __w_pdfjs_require__(4); var _xml_parser = __w_pdfjs_require__(64); function decodeString(str) { try { return (0, _util.stringToUTF8String)(str); } catch (ex) { (0, _util.warn)(`UTF-8 decoding failed: \"${ex}\".`); return str; } } class DatasetXMLParser extends _xml_parser.SimpleXMLParser { constructor(options) { super(options); this.node = null; } onEndElement(name) { const node = super.onEndElement(name); if (node && name === \"xfa:datasets\") { this.node = node; throw new Error(\"Aborting DatasetXMLParser.\"); } } } class DatasetReader { constructor(data) { if (data.datasets) { this.node = new _xml_parser.SimpleXMLParser({ hasAttributes: true }).parseFromString(data.datasets).documentElement; } else { const parser = new DatasetXMLParser({ hasAttributes: true }); try { parser.parseFromString(data[\"xdp:xdp\"]); } catch (_) {} this.node = parser.node; } } getValue(path) { if (!this.node || !path) { return \"\"; } const node = this.node.searchNode((0, _core_utils.parseXFAPath)(path), 0); if (!node) { return \"\"; } const first = node.firstChild; if (first && first.nodeName === \"value\") { return node.children.map(child => decodeString(child.textContent)); } return decodeString(node.textContent); } } exports.DatasetReader = DatasetReader; /***/ }), /* 99 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.XRef = void 0; var _util = __w_pdfjs_require__(2); var _primitives = __w_pdfjs_require__(3); var _core_utils = __w_pdfjs_require__(4); var _parser = __w_pdfjs_require__(15); var _base_stream = __w_pdfjs_require__(5); var _crypto = __w_pdfjs_require__(65); class XRef { constructor(stream, pdfManager) { this.stream = stream; this.pdfManager = pdfManager; this.entries = []; this.xrefstms = Object.create(null); this._cacheMap = new Map(); this._pendingRefs = new _primitives.RefSet(); this.stats = new _core_utils.DocStats(pdfManager.msgHandler); this._newPersistentRefNum = null; this._newTemporaryRefNum = null; } getNewPersistentRef(obj) { if (this._newPersistentRefNum === null) { this._newPersistentRefNum = this.entries.length || 1; } const num = this._newPersistentRefNum++; this._cacheMap.set(num, obj); return _primitives.Ref.get(num, 0); } getNewTemporaryRef() { if (this._newTemporaryRefNum === null) { this._newTemporaryRefNum = this.entries.length || 1; } return _primitives.Ref.get(this._newTemporaryRefNum++, 0); } resetNewTemporaryRef() { this._newTemporaryRefNum = null; } setStartXRef(startXRef) { this.startXRefQueue = [startXRef]; } parse(recoveryMode = false) { let trailerDict; if (!recoveryMode) { trailerDict = this.readXRef(); } else { (0, _util.warn)(\"Indexing all PDF objects\"); trailerDict = this.indexObjects(); } trailerDict.assignXref(this); this.trailer = trailerDict; let encrypt; try { encrypt = trailerDict.get(\"Encrypt\"); } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(`XRef.parse - Invalid \"Encrypt\" reference: \"${ex}\".`); } if (encrypt instanceof _primitives.Dict) { const ids = trailerDict.get(\"ID\"); const fileId = ids && ids.length ? ids[0] : \"\"; encrypt.suppressEncryption = true; this.encrypt = new _crypto.CipherTransformFactory(encrypt, fileId, this.pdfManager.password); } let root; try { root = trailerDict.get(\"Root\"); } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(`XRef.parse - Invalid \"Root\" reference: \"${ex}\".`); } if (root instanceof _primitives.Dict) { try { const pages = root.get(\"Pages\"); if (pages instanceof _primitives.Dict) { this.root = root; return; } } catch (ex) { if (ex instanceof _core_utils.MissingDataException) { throw ex; } (0, _util.warn)(`XRef.parse - Invalid \"Pages\" reference: \"${ex}\".`); } } if (!recoveryMode) { throw new _core_utils.XRefParseException(); } throw new _util.InvalidPDFException(\"Invalid Root reference.\"); } processXRefTable(parser) { if (!(\"tableState\" in this)) { this.tableState = { entryNum: 0, streamPos: parser.lexer.stream.pos, parserBuf1: parser.buf1, parserBuf2: parser.buf2 }; } const obj = this.readXRefTable(parser); if (!(0, _primitives.isCmd)(obj, \"trailer\")) { throw new _util.FormatError(\"Invalid XRef table: could not find trailer dictionary\"); } let dict = parser.getObj(); if (!(dict instanceof _primitives.Dict) && dict.dict) { dict = dict.dict; } if (!(dict instanceof _primitives.Dict)) { throw new _util.FormatError(\"Invalid XRef table: could not parse trailer dictionary\"); } delete this.tableState; return dict; } readXRefTable(parser) { const stream = parser.lexer.stream; const tableState = this.tableState; stream.pos = tableState.streamPos; parser.buf1 = tableState.parserBuf1; parser.buf2 = tableState.parserBuf2; let obj; while (true) { if (!(\"firstEntryNum\" in tableState) || !(\"entryCount\" in tableState)) { if ((0, _primitives.isCmd)(obj = parser.getObj(), \"trailer\")) { break; } tableState.firstEntryNum = obj; tableState.entryCount = parser.getObj(); } let first = tableState.firstEntryNum; const count = tableState.entryCount; if (!Number.isInteger(first) || !Number.isInteger(count)) { throw new _util.FormatError(\"Invalid XRef table: wrong types in subsection header\"); } for (let i = tableState.entryNum; i < count; i++) { tableState.streamPos = stream.pos; tableState.entryNum = i; tableState.parserBuf1 = parser.buf1; tableState.parserBuf2 = parser.buf2; const entry = {}; entry.offset = parser.getObj(); entry.gen = parser.getObj(); const type = parser.getObj(); if (type instanceof _primitives.Cmd) { switch (type.cmd) { case \"f\": entry.free = true; break; case \"n\": entry.uncompressed = true; break; } } if (!Number.isInteger(entry.offset) || !Number.isInteger(entry.gen) || !(entry.free || entry.uncompressed)) { throw new _util.FormatError(`Invalid entry in XRef subsection: ${first}, ${count}`); } if (i === 0 && entry.free && first === 1) { first = 0; } if (!this.entries[i + first]) { this.entries[i + first] = entry; } } tableState.entryNum = 0; tableState.streamPos = stream.pos; tableState.parserBuf1 = parser.buf1; tableState.parserBuf2 = parser.buf2; delete tableState.firstEntryNum; delete tableState.entryCount; } if (this.entries[0] && !this.entries[0].free) { throw new _util.FormatError(\"Invalid XRef table: unexpected first object\"); } return obj; } processXRefStream(stream) { if (!(\"streamState\" in this)) { const streamParameters = stream.dict; const byteWidths = streamParameters.get(\"W\"); let range = streamParameters.get(\"Index\"); if (!range) { range = [0, streamParameters.get(\"Size\")]; } this.streamState = { entryRanges: range, byteWidths, entryNum: 0, streamPos: stream.pos }; } this.readXRefStream(stream); delete this.streamState; return stream.dict; } readXRefStream(stream) { const streamState = this.streamState; stream.pos = streamState.streamPos; const [typeFieldWidth, offsetFieldWidth, generationFieldWidth] = streamState.byteWidths; const entryRanges = streamState.entryRanges; while (entryRanges.length > 0) { const [first, n] = entryRanges; if (!Number.isInteger(first) || !Number.isInteger(n)) { throw new _util.FormatError(`Invalid XRef range fields: ${first}, ${n}`); } if (!Number.isInteger(typeFieldWidth) || !Number.isInteger(offsetFieldWidth) || !Number.isInteger(generationFieldWidth)) { throw new _util.FormatError(`Invalid XRef entry fields length: ${first}, ${n}`); } for (let i = streamState.entryNum; i < n; ++i) { streamState.entryNum = i; streamState.streamPos = stream.pos; let type = 0, offset = 0, generation = 0; for (let j = 0; j < typeFieldWidth; ++j) { const typeByte = stream.getByte(); if (typeByte === -1) { throw new _util.FormatError(\"Invalid XRef byteWidths 'type'.\"); } type = type < 8 | typeByte; } if (typeFieldWidth === 0) { type = 1; } for (let j = 0; j < offsetFieldWidth; ++j) { const offsetByte = stream.getByte(); if (offsetByte === -1) { throw new _util.FormatError(\"Invalid XRef byteWidths 'offset'.\"); } offset = offset < 8 | offsetByte; } for (let j = 0; j < generationFieldWidth; ++j) { const generationByte = stream.getByte(); if (generationByte === -1) { throw new _util.FormatError(\"Invalid XRef byteWidths 'generation'.\"); } generation = generation < 8 | generationByte; } const entry = {}; entry.offset = offset; entry.gen = generation; switch (type) { case 0: entry.free = true; break; case 1: entry.uncompressed = true; break; case 2: break; default: throw new _util.FormatError(`Invalid XRef entry type: ${type}`); } if (!this.entries[first + i]) { this.entries[first + i] = entry; } } streamState.entryNum = 0; streamState.streamPos = stream.pos; entryRanges.splice(0, 2); } } indexObjects() { const TAB = 0x9, LF = 0xa, CR = 0xd, SPACE = 0x20; const PERCENT = 0x25, LT = 0x3c; function readToken(data, offset) { let token = \"\", ch = data[offset]; while (ch !== LF && ch !== CR && ch !== LT) { if (++offset >= data.length) { break; } token += String.fromCharCode(ch); ch = data[offset]; } return token; } function skipUntil(data, offset, what) { const length = what.length, dataLength = data.length; let skipped = 0; while (offset < dataLength) { let i = 0; while (i < length && data[offset + i] === what[i]) { ++i; } if (i >= length) { break; } offset++; skipped++; } return skipped; } const gEndobjRegExp = /\\b(endobj|\\d+\\s+\\d+\\s+obj|xref|trailer)\\b/g; const gStartxrefRegExp = /\\b(startxref|\\d+\\s+\\d+\\s+obj)\\b/g; const objRegExp = /^(\\d+)\\s+(\\d+)\\s+obj\\b/; const trailerBytes = new Uint8Array([116, 114, 97, 105, 108, 101, 114]); const startxrefBytes = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]); const xrefBytes = new Uint8Array([47, 88, 82, 101, 102]); this.entries.length = 0; this._cacheMap.clear(); const stream = this.stream; stream.pos = 0; const buffer = stream.getBytes(), bufferStr = (0, _util.bytesToString)(buffer), length = buffer.length; let position = stream.start; const trailers = [], xrefStms = []; while (position < length) { let ch = buffer[position]; if (ch === TAB || ch === LF || ch === CR || ch === SPACE) { ++position; continue; } if (ch === PERCENT) { do { ++position; if (position >= length) { break; } ch = buffer[position]; } while (ch !== LF && ch !== CR); continue; } const token = readToken(buffer, position); let m; if (token.startsWith(\"xref\") && (token.length === 4 || /\\s/.test(token[4]))) { position += skipUntil(buffer, position, trailerBytes); trailers.push(position); position += skipUntil(buffer, position, startxrefBytes); } else if (m = objRegExp.exec(token)) { const num = m[1] | 0, gen = m[2] | 0; const startPos = position + token.length; let contentLength, updateEntries = false; if (!this.entries[num]) { updateEntries = true; } else if (this.entries[num].gen === gen) { try { const parser = new _parser.Parser({ lexer: new _parser.Lexer(stream.makeSubStream(startPos)) }); parser.getObj(); updateEntries = true; } catch (ex) { if (ex instanceof _core_utils.ParserEOFException) { (0, _util.warn)(`indexObjects -- checking object (${token}): \"${ex}\".`); } else { updateEntries = true; } } } if (updateEntries) { this.entries[num] = { offset: position - stream.start, gen, uncompressed: true }; } gEndobjRegExp.lastIndex = startPos; const match = gEndobjRegExp.exec(bufferStr); if (match) { const endPos = gEndobjRegExp.lastIndex + 1; contentLength = endPos - position; if (match[1] !== \"endobj\") { (0, _util.warn)(`indexObjects: Found \"${match[1]}\" inside of another \"obj\", ` + 'caused by missing \"endobj\" -- trying to recover.'); contentLength -= match[1].length + 1; } } else { contentLength = length - position; } const content = buffer.subarray(position, position + contentLength); const xrefTagOffset = skipUntil(content, 0, xrefBytes); if (xrefTagOffset < contentLength && content[xrefTagOffset + 5] < 64) { xrefStms.push(position - stream.start); this.xrefstms[position - stream.start] = 1; } position += contentLength; } else if (token.startsWith(\"trailer\") && (token.length === 7 || /\\s/.test(token[7]))) { trailers.push(position); const startPos = position + token.length; let contentLength; gStartxrefRegExp.lastIndex = startPos; const match = gStartxrefRegExp.exec(bufferStr); if (match) { const endPos = gStartxrefRegExp.lastIndex + 1; contentLength = endPos - position; if (match[1] !== \"startxref\") { (0, _util.warn)(`indexObjects: Found \"${match[1]}\" after \"trailer\", ` + 'caused by missing \"startxref\" -- trying to recover.'); contentLength -= match[1].length + 1; } } else { contentLength = length - position; } position += contentLength; } else { position += token.length + 1; } } for (const xrefStm of xrefStms) { this.startXRefQueue.push(xrefStm); this.readXRef(true); } let trailerDict, trailerError; for (const trailer of [...trailers, \"generationFallback\", ...trailers]) { if (trailer === \"generationFallback\") { if (!trailerError) { break; } this._generationFallback = true; continue; } stream.pos = trailer; const parser = new _parser.Parser({ lexer: new _parser.Lexer(stream), xref: this, allowStreams: true, recoveryMode: true }); const obj = parser.getObj(); if (!(0, _primitives.isCmd)(obj, \"trailer\")) { continue; } const dict = parser.getObj(); if (!(dict instanceof _primitives.Dict)) { continue; } let validPagesDict = false; try { const rootDict = dict.get(\"Root\"); if (!(rootDict instanceof _primitives.Dict)) { continue; } const pagesDict = rootDict.get(\"Pages\"); if (!(pagesDict instanceof _primitives.Dict)) { continue; } const pagesCount = pagesDict.get(\"Count\"); if (Number.isInteger(pagesCount)) { validPagesDict = true; } } catch (ex) { trailerError = ex; continue; } if (validPagesDict && dict.has(\"ID\")) { return dict; } trailerDict = dict; } if (trailerDict) { return trailerDict; } if (this.topDict) { return this.topDict; } throw new _util.InvalidPDFException(\"Invalid PDF structure.\"); } readXRef(recoveryMode = false) { const stream = this.stream; const startXRefParsedCache = new Set(); while (this.startXRefQueue.length) { try { const startXRef = this.startXRefQueue[0]; if (startXRefParsedCache.has(startXRef)) { (0, _util.warn)(\"readXRef - skipping XRef table since it was already parsed.\"); this.startXRefQueue.shift(); continue; } startXRefParsedCache.add(startXRef); stream.pos = startXRef + stream.start; const parser = new _parser.Parser({ lexer: new _parser.Lexer(stream), xref: this, allowStreams: true }); let obj = parser.getObj(); let dict; if ((0, _primitives.isCmd)(obj, \"xref\")) { dict = this.processXRefTable(parser); if (!this.topDict) { this.topDict = dict; } obj = dict.get(\"XRefStm\"); if (Number.isInteger(obj)) { const pos = obj; if (!(pos in this.xrefstms)) { this.xrefstms[pos] = 1; this.startXRefQueue.push(pos); } } } else if (Number.isInteger(obj)) { if (!Number.isInteger(parser.getObj()) || !(0, _primitives.isCmd)(parser.getObj(), \"obj\") || !((obj = parser.getObj()) instanceof _base_stream.BaseStream)) { throw new _util.FormatError(\"Invalid XRef stream\"); } dict = this.processXRefStream(obj); if (!this.topDict) { this.topDict = dict; } if (!dict) { throw new _util.FormatError(\"Failed to read XRef stream\"); } } else { throw new _util.FormatError(\"Invalid XRef stream header\"); } obj = dict.get(\"Prev\"); if (Number.isInteger(obj)) { this.startXRefQueue.push(obj); } else if (obj instanceof _primitives.Ref) { this.startXRefQueue.push(obj.num); } } catch (e) { if (e instanceof _core_utils.MissingDataException) { throw e; } (0, _util.info)(\"(while reading XRef): \" + e); } this.startXRefQueue.shift(); } if (this.topDict) { return this.topDict; } if (recoveryMode) { return undefined; } throw new _core_utils.XRefParseException(); } getEntry(i) { const xrefEntry = this.entries[i]; if (xrefEntry && !xrefEntry.free && xrefEntry.offset) { return xrefEntry; } return null; } fetchIfRef(obj, suppressEncryption = false) { if (obj instanceof _primitives.Ref) { return this.fetch(obj, suppressEncryption); } return obj; } fetch(ref, suppressEncryption = false) { if (!(ref instanceof _primitives.Ref)) { throw new Error(\"ref object is not a reference\"); } const num = ref.num; const cacheEntry = this._cacheMap.get(num); if (cacheEntry !== undefined) { if (cacheEntry instanceof _primitives.Dict && !cacheEntry.objId) { cacheEntry.objId = ref.toString(); } return cacheEntry; } let xrefEntry = this.getEntry(num); if (xrefEntry === null) { this._cacheMap.set(num, xrefEntry); return xrefEntry; } if (this._pendingRefs.has(ref)) { this._pendingRefs.remove(ref); (0, _util.warn)(`Ignoring circular reference: ${ref}.`); return _primitives.CIRCULAR_REF; } this._pendingRefs.put(ref); try { if (xrefEntry.uncompressed) { xrefEntry = this.fetchUncompressed(ref, xrefEntry, suppressEncryption); } else { xrefEntry = this.fetchCompressed(ref, xrefEntry, suppressEncryption); } this._pendingRefs.remove(ref); } catch (ex) { this._pendingRefs.remove(ref); throw ex; } if (xrefEntry instanceof _primitives.Dict) { xrefEntry.objId = ref.toString(); } else if (xrefEntry instanceof _base_stream.BaseStream) { xrefEntry.dict.objId = ref.toString(); } return xrefEntry; } fetchUncompressed(ref, xrefEntry, suppressEncryption = false) { const gen = ref.gen; let num = ref.num; if (xrefEntry.gen !== gen) { const msg = `Inconsistent generation in XRef: ${ref}`; if (this._generationFallback && xrefEntry.gen < gen) { (0, _util.warn)(msg); return this.fetchUncompressed(_primitives.Ref.get(num, xrefEntry.gen), xrefEntry, suppressEncryption); } throw new _core_utils.XRefEntryException(msg); } const stream = this.stream.makeSubStream(xrefEntry.offset + this.stream.start); const parser = new _parser.Parser({ lexer: new _parser.Lexer(stream), xref: this, allowStreams: true }); const obj1 = parser.getObj(); const obj2 = parser.getObj(); const obj3 = parser.getObj(); if (obj1 !== num || obj2 !== gen || !(obj3 instanceof _primitives.Cmd)) { throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`); } if (obj3.cmd !== \"obj\") { if (obj3.cmd.startsWith(\"obj\")) { num = parseInt(obj3.cmd.substring(3), 10); if (!Number.isNaN(num)) { return num; } } throw new _core_utils.XRefEntryException(`Bad (uncompressed) XRef entry: ${ref}`); } if (this.encrypt && !suppressEncryption) { xrefEntry = parser.getObj(this.encrypt.createCipherTransform(num, gen)); } else { xrefEntry = parser.getObj(); } if (!(xrefEntry instanceof _base_stream.BaseStream)) { this._cacheMap.set(num, xrefEntry); } return xrefEntry; } fetchCompressed(ref, xrefEntry, suppressEncryption = false) { const tableOffset = xrefEntry.offset; const stream = this.fetch(_primitives.Ref.get(tableOffset, 0)); if (!(stream instanceof _base_stream.BaseStream)) { throw new _util.FormatError(\"bad ObjStm stream\"); } const first = stream.dict.get(\"First\"); const n = stream.dict.get(\"N\"); if (!Number.isInteger(first) || !Number.isInteger(n)) { throw new _util.FormatError(\"invalid first and n parameters for ObjStm stream\"); } let parser = new _parser.Parser({ lexer: new _parser.Lexer(stream), xref: this, allowStreams: true }); const nums = new Array(n); const offsets = new Array(n); for (let i = 0; i < n; ++i) { const num = parser.getObj(); if (!Number.isInteger(num)) { throw new _util.FormatError(`invalid object number in the ObjStm stream: ${num}`); } const offset = parser.getObj(); if (!Number.isInteger(offset)) { throw new _util.FormatError(`invalid object offset in the ObjStm stream: ${offset}`); } nums[i] = num; offsets[i] = offset; } const start = (stream.start || 0) + first; const entries = new Array(n); for (let i = 0; i < n; ++i) { const length = i < n - 1 ? offsets[i + 1] - offsets[i] : undefined; if (length < 0) { throw new _util.FormatError(\"Invalid offset in the ObjStm stream.\"); } parser = new _parser.Parser({ lexer: new _parser.Lexer(stream.makeSubStream(start + offsets[i], length, stream.dict)), xref: this, allowStreams: true }); const obj = parser.getObj(); entries[i] = obj; if (obj instanceof _base_stream.BaseStream) { continue; } const num = nums[i], entry = this.entries[num]; if (entry && entry.offset === tableOffset && entry.gen === i) { this._cacheMap.set(num, obj); } } xrefEntry = entries[xrefEntry.gen]; if (xrefEntry === undefined) { throw new _core_utils.XRefEntryException(`Bad (compressed) XRef entry: ${ref}`); } return xrefEntry; } async fetchIfRefAsync(obj, suppressEncryption) { if (obj instanceof _primitives.Ref) { return this.fetchAsync(obj, suppressEncryption); } return obj; } async fetchAsync(ref, suppressEncryption) { try { return this.fetch(ref, suppressEncryption); } catch (ex) { if (!(ex instanceof _core_utils.MissingDataException)) { throw ex; } await this.pdfManager.requestRange(ex.begin, ex.end); return this.fetchAsync(ref, suppressEncryption); } } getCatalogObj() { return this.root; } } exports.XRef = XRef; /***/ }), /* 100 */ /***/ ((__unused_webpack_module, exports) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.isNodeJS = void 0; const isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\"); exports.isNodeJS = isNodeJS; /***/ }), /* 101 */ /***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, \"__esModule\", ({ value: true })); exports.MessageHandler = void 0; var _util = __w_pdfjs_require__(2); const CallbackKind = { UNKNOWN: 0, DATA: 1, ERROR: 2 }; const StreamKind = { UNKNOWN: 0, CANCEL: 1, CANCEL_COMPLETE: 2, CLOSE: 3, ENQUEUE: 4, ERROR: 5, PULL: 6, PULL_COMPLETE: 7, START_COMPLETE: 8 }; function wrapReason(reason) { if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) { (0, _util.unreachable)('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.'); } switch (reason.name) { case \"AbortException\": return new _util.AbortException(reason.message); case \"MissingPDFException\": return new _util.MissingPDFException(reason.message); case \"PasswordException\": return new _util.PasswordException(reason.message, reason.code); case \"UnexpectedResponseException\": return new _util.UnexpectedResponseException(reason.message, reason.status); case \"UnknownErrorException\": return new _util.UnknownErrorException(reason.message, reason.details); default: return new _util.UnknownErrorException(reason.message, reason.toString()); } } class MessageHandler { constructor(sourceName, targetName, comObj) { this.sourceName = sourceName; this.targetName = targetName; this.comObj = comObj; this.callbackId = 1; this.streamId = 1; this.streamSinks = Object.create(null); this.streamControllers = Object.create(null); this.callbackCapabilities = Object.create(null); this.actionHandler = Object.create(null); this._onComObjOnMessage = event => { const data = event.data; if (data.targetName !== this.sourceName) { return; } if (data.stream) { this._processStreamMessage(data); return; } if (data.callback) { const callbackId = data.callbackId; const capability = this.callbackCapabilities[callbackId]; if (!capability) { throw new Error(`Cannot resolve callback ${callbackId}`); } delete this.callbackCapabilities[callbackId]; if (data.callback === CallbackKind.DATA) { capability.resolve(data.data); } else if (data.callback === CallbackKind.ERROR) { capability.reject(wrapReason(data.reason)); } else { throw new Error(\"Unexpected callback case\"); } return; } const action = this.actionHandler[data.action]; if (!action) { throw new Error(`Unknown action from worker: ${data.action}`); } if (data.callbackId) { const cbSourceName = this.sourceName; const cbTargetName = data.sourceName; new Promise(function (resolve) { resolve(action(data.data)); }).then(function (result) { comObj.postMessage({ sourceName: cbSourceName, targetName: cbTargetName, callback: CallbackKind.DATA, callbackId: data.callbackId, data: result }); }, function (reason) { comObj.postMessage({ sourceName: cbSourceName, targetName: cbTargetName, callback: CallbackKind.ERROR, callbackId: data.callbackId, reason: wrapReason(reason) }); }); return; } if (data.streamId) { this._createStreamSink(data); return; } action(data.data); }; comObj.addEventListener(\"message\", this._onComObjOnMessage); } on(actionName, handler) { const ah = this.actionHandler; if (ah[actionName]) { throw new Error(`There is already an actionName called \"${actionName}\"`); } ah[actionName] = handler; } send(actionName, data, transfers) { this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: actionName, data }, transfers); } sendWithPromise(actionName, data, transfers) { const callbackId = this.callbackId++; const capability = (0, _util.createPromiseCapability)(); this.callbackCapabilities[callbackId] = capability; try { this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: actionName, callbackId, data }, transfers); } catch (ex) { capability.reject(ex); } return capability.promise; } sendWithStream(actionName, data, queueingStrategy, transfers) { const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj; return new ReadableStream({ start: controller => { const startCapability = (0, _util.createPromiseCapability)(); this.streamControllers[streamId] = { controller, startCall: startCapability, pullCall: null, cancelCall: null, isClosed: false }; comObj.postMessage({ sourceName, targetName, action: actionName, streamId, data, desiredSize: controller.desiredSize }, transfers); return startCapability.promise; }, pull: controller => { const pullCapability = (0, _util.createPromiseCapability)(); this.streamControllers[streamId].pullCall = pullCapability; comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL, streamId, desiredSize: controller.desiredSize }); return pullCapability.promise; }, cancel: reason => { (0, _util.assert)(reason instanceof Error, \"cancel must have a valid reason\"); const cancelCapability = (0, _util.createPromiseCapability)(); this.streamControllers[streamId].cancelCall = cancelCapability; this.streamControllers[streamId].isClosed = true; comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL, streamId, reason: wrapReason(reason) }); return cancelCapability.promise; } }, queueingStrategy); } _createStreamSink(data) { const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj; const self = this, action = this.actionHandler[data.action]; const streamSink = { enqueue(chunk, size = 1, transfers) { if (this.isCancelled) { return; } const lastDesiredSize = this.desiredSize; this.desiredSize -= size; if (lastDesiredSize > 0 && this.desiredSize { /******/ for(var key in definition) { /******/ if(__w_pdfjs_require__.o(definition, key) && !__w_pdfjs_require__.o(exports, key)) { /******/ Object.defineProperty(exports, key, { enumerable: true, get: definition[key] }); /******/ } /******/ } /******/ }; /******/ })(); /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (() => { /******/ __w_pdfjs_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop)) /******/ })(); /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (() => { /******/ // define __esModule on exports /******/ __w_pdfjs_require__.r = (exports) => { /******/ if(typeof Symbol !== 'undefined' && Symbol.toStringTag) { /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }); /******/ } /******/ Object.defineProperty(exports, '__esModule', { value: true }); /******/ }; /******/ })(); /******/ /************************************************************************/ var __webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk. (() => { var exports = __webpack_exports__; Object.defineProperty(exports, \"__esModule\", ({ value: true })); Object.defineProperty(exports, \"WorkerMessageHandler\", ({ enumerable: true, get: function () { return _worker.WorkerMessageHandler; } })); var _worker = __w_pdfjs_require__(1); const pdfjsVersion = '3.2.146'; const pdfjsBuild = '3fd2a3548'; })(); /******/ return __webpack_exports__; /******/ })() ; }); //# sourceMappingURL=pdf.worker.js.map","link":"/js/pdfjs/build/pdf.worker.js"}]}