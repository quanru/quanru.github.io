title: Javascript 函数式编程の书摘
date: 2015-10-6 20:34:23
categories: 读书笔记
tags: JavaScript
---

### 章一
1，确定抽象，并为其构建函数；
2，利用已有的函数来构建更为复杂的抽象；
3，通过将现有的函数传给其他的函数来构建更加复杂的抽象。

<!-- more -->

# 章一

1，确定抽象，并为其构建函数；
2，利用已有的函数来构建更为复杂的抽象；
3，通过将现有的函数传给其他的函数来构建更加复杂的抽象。

# 章二

1，函数时一等公民：
>函数式编程语言应该是促进创造和使用函数的；

2，applicative 编程：
>函数A作为参数提供给函数B；

3，JavaScript对象的键只能是字符串；

# 章三

词法作用域：
>指一个变量的可见性，及其文本表述的模拟值；变量查找从最内层范围向外扩展。

动态作用域：
>1，维护一张”值“的全局表（维护一个命名绑定栈的全局映射）；
>2，并使用一个函数来查询绑定的值；
>3，缺点：任何给定的绑定值，在确定调用其函数前，都是不可知的。

闭包：
>闭包就是一个函数，捕获作用域内的外部绑定（例如，不是自己的参数）。这些绑定是为了之后使用（即使在该作用域已经结束）而被定义的。
>如果一个变量的引用同时存在于闭包的内外部，则它的变化可以跨越看似私有的界限，因此JavaScript经常使用如下模式，把捕获的变量作为私有数据：
```javascript
          var pingpong = (function() {
               var private = 0;
               return {     
                   inc: function(n) {
                              return private += n;
                    }
                    dec: function(n) {
                              return private -= n;
                    }
               };
           })();
           pingpong.inc(10);
           pingpong.dec(7);
```

# 章四

高阶函数：
>1，它是一等公民；
>2，以一个函数作为参数；
>3，以一个函数作为返回结果； 

闭包：
>1，闭包会捕获一个值（或引用），并多次返回相同的值；
>2，每一个新的闭包都会捕获不一样的值； 

# 章五

柯里化函数：
>逐渐返回消耗参数的函数，直到所有参数耗尽；

部分应用函数：
>是一个部分执行，等待接收剩余的参数立即执行的函数；

组合函数：
>_.compose: 从右往左执行，最右边的函数的结果会被送入其左侧的函数，一个接着一个。

# 章六

尾递归：
>函数（除了停止条件返回值）的最后一个动作是递归调用；

递归和组合函数：
>andify与orify；

相互关联函数：
>两个或多个函数相互调用会被称为相互递归，通过相互递归调用来回反弹彼此之间递减某个绝对值，直到一方或另一方达到零；

蹦床原理：
> 通过打包调用，而不是直接调用；trampoline函数：不断调用函数的返回值，直到它不再是一个函数。

# 章七

纯函数：
>1，其结果只能从它的参数的值来计算；
>2，不能依赖于能被外部操作改变的数据；
>3，不能改变外部状态。

幂等性：
>对同一的参数运行一次函数应该与连续两次运行是一个结果。

不变性：
>例如字符串；

对象的不变性：
>1，不可变对象应该在构造时固定它们的值之后不能再修改；
>2，不可变对象操作并返回新对象。

# 章八

惰性链：
>在调用value之前，_.chain是惰性的，什么都不会发生；

thunk：
>封装了一些行为的函数；

管道； 